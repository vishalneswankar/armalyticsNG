import {
  LabelComponent,
  LabelModule
} from "./chunk-3XH5B7OX.js";
import {
  DatePickerComponent,
  DatePickerCustomMessagesComponent,
  DatePickerModule
} from "./chunk-X7YVUIJD.js";
import {
  AutoCompleteComponent,
  AutoCompleteModule,
  DropDownListComponent,
  DropDownListModule,
  DropDownsModule
} from "./chunk-QNRKXUM7.js";
import {
  InputsModule,
  NumericTextBoxComponent,
  NumericTextBoxCustomMessagesComponent,
  NumericTextBoxModule,
  RadioButtonDirective,
  TextBoxComponent,
  TextBoxDirective
} from "./chunk-VFACOUDV.js";
import {
  TabContentDirective,
  TabStripComponent,
  TabStripModule,
  TabStripTabComponent,
  TabTitleDirective
} from "./chunk-6LUMNBLC.js";
import {
  ButtonComponent,
  ButtonModule,
  ChipComponent,
  ChipListComponent,
  ChipModule
} from "./chunk-VVCKWOYR.js";
import {
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  FormControl,
  FormControlDirective,
  FormGroup,
  FormsModule,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  ReactiveFormsModule,
  ɵNgNoValidate
} from "./chunk-UU3EZO4R.js";
import "./chunk-QNY7N3M5.js";
import {
  Deflate,
  Inflate,
  drawDOM,
  exportPDF
} from "./chunk-Y5H4MYDM.js";
import {
  IntlService,
  toString
} from "./chunk-ELXDII2W.js";
import {
  PopupModule,
  PopupService,
  arrowLeftIcon,
  arrowRightIcon,
  cancelIcon,
  caretAltDownIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltToLeftIcon,
  caretAltToRightIcon,
  columnsIcon,
  displayInlineFlexIcon,
  filterClearIcon,
  filterIcon,
  insertMiddleIcon,
  lockIcon,
  maxWidthIcon,
  minusIcon,
  moreVerticalIcon,
  plusIcon,
  reorderIcon,
  setColumnPositionIcon,
  slidersIcon,
  sortAscSmallIcon,
  sortDescSmallIcon,
  stickIcon,
  unlockIcon,
  unstickIcon
} from "./chunk-2G6IB7TQ.js";
import {
  ComponentMessages,
  L10N_PREFIX,
  LocalizationService
} from "./chunk-NQ5KEYNG.js";
import {
  animate,
  state,
  style,
  transition,
  trigger
} from "./chunk-DJ5S5XYK.js";
import {
  IconWrapperComponent,
  IconsModule,
  IconsService
} from "./chunk-QGYHBHMT.js";
import {
  DraggableDirective,
  DraggableModule,
  EventsModule,
  EventsOutsideAngularDirective,
  KendoInput,
  Keys,
  PreventableEvent,
  ResizeSensorComponent,
  ResizeSensorModule,
  WatermarkModule,
  WatermarkOverlayComponent,
  anyChanged,
  closest,
  contains,
  getter,
  guid,
  hasObservers,
  isChanged,
  isDocumentAvailable,
  isFocusable,
  isPresent,
  parseCSSClassNames,
  shouldShowValidationUI
} from "./chunk-NEHKRBA2.js";
import {
  validatePackage
} from "./chunk-RRG7PLXH.js";
import {
  DomSanitizer
} from "./chunk-TOWKR44Q.js";
import {
  CommonModule,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-YYSCT43L.js";
import {
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Input,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  Pipe,
  QueryList,
  Renderer2,
  SecurityContext,
  Self,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  __spreadValues,
  auditTime,
  bufferCount,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  forwardRef,
  from,
  fromEvent,
  interval,
  isDevMode,
  map,
  merge,
  of,
  setClassMetadata,
  switchMap,
  switchMapTo,
  take,
  takeUntil,
  tap,
  throttleTime,
  zip,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction6,
  ɵɵpureFunction8,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate5,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-DJXTNQ22.js";

// node_modules/@progress/kendo-data-query/dist/es/utils.js
var isPresent2 = function(value2) {
  return value2 !== null && value2 !== void 0;
};
var isBlank = function(value2) {
  return value2 === null || value2 === void 0;
};
var isArray = function(value2) {
  return Array.isArray(value2);
};
var isFunction = function(value2) {
  return typeof value2 === "function";
};
var isString = function(value2) {
  return typeof value2 === "string";
};
var isNullOrEmptyString = function(value2) {
  return isBlank(value2) || value2.trim().length === 0;
};
var isNotNullOrEmptyString = function(value2) {
  return !isNullOrEmptyString(value2);
};
var isNumeric = function(value2) {
  return !isNaN(value2 - parseFloat(value2));
};
var isDate = function(value2) {
  return value2 && value2.getTime;
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-descriptor.interface.js
var isCompositeFilterDescriptor = function(source) {
  return isPresent2(source.filters);
};

// node_modules/@progress/kendo-data-query/node_modules/tslib/tslib.es6.js
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}

// node_modules/@progress/kendo-data-query/dist/es/funcs.js
var ifElse = function(predicate, right, left) {
  return function(value2) {
    return predicate(value2) ? right(value2) : left(value2);
  };
};
var compose = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(data) {
    return args.reduceRight(function(acc, curr) {
      return curr(acc);
    }, data);
  };
};
var constant = function(x) {
  return function() {
    return x;
  };
};

// node_modules/@progress/kendo-data-query/dist/es/filter-serialization.common.js
var toUTC = function(date2) {
  return new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
};
var isDateValue = function(x) {
  return isDate(x.value);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter.operators.js
var operatorMap = function(key) {
  return {
    "!=": "neq",
    "<": "lt",
    "<=": "lte",
    "==": "eq",
    ">": "gt",
    ">=": "gte",
    equal: "eq",
    equals: "eq",
    equalto: "eq",
    ge: "gte",
    greater: "gt",
    greaterthan: "gt",
    greaterthanequal: "gte",
    isempty: "isempty",
    isequalto: "eq",
    isgreaterthan: "gt",
    isgreaterthanorequalto: "gte",
    islessthan: "lt",
    islessthanorequalto: "lte",
    isnotempty: "isnotempty",
    isnotequalto: "neq",
    isnull: "isnull",
    le: "lte",
    less: "lt",
    lessthan: "lt",
    lessthanequal: "lte",
    ne: "neq",
    notequal: "neq",
    notequals: "neq",
    notequalto: "neq",
    notsubstringof: "doesnotcontain"
  }[key.toLowerCase()] || key;
};
var normalizeOperator = function(descriptor) {
  if (descriptor.filters) {
    descriptor.filters = descriptor.filters.map(function(filter4) {
      var result = Object.assign({}, filter4);
      if (!isCompositeFilterDescriptor(filter4) && isString(filter4.operator)) {
        result.operator = operatorMap(filter4.operator);
      }
      if (isCompositeFilterDescriptor(filter4)) {
        normalizeOperator(result);
      }
      return result;
    });
  }
};
var normalizeDescriptor = function(descriptor) {
  if (!isCompositeFilterDescriptor(descriptor)) {
    return {
      filters: isArray(descriptor) ? descriptor : [descriptor],
      logic: "and"
    };
  }
  return Object.assign({}, descriptor);
};
var normalizeFilters = function(descriptor) {
  if (isPresent2(descriptor)) {
    descriptor = normalizeDescriptor(descriptor);
    normalizeOperator(descriptor);
  }
  return descriptor;
};

// node_modules/@progress/kendo-data-query/dist/es/odata.operators.js
var emptyString = constant("");

// node_modules/@progress/kendo-data-query/dist/es/accessor.js
var getterCache = {};
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
getterCache["undefined"] = function(obj) {
  return obj;
};
var getter2 = function(field, safe) {
  var key = field + safe;
  if (getterCache[key]) {
    return getterCache[key];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(_, index, indexAccessor, field2) {
    fields.push(isPresent2(index) ? index : indexAccessor || field2);
    return void 0;
  });
  getterCache[key] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length; idx++) {
      result = result[fields[idx]];
      if (!isPresent2(result) && safe) {
        return result;
      }
    }
    return result;
  };
  return getterCache[key];
};

// node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js
var pairwise = function(key) {
  return function(value2) {
    return [key, value2];
  };
};
var empty = function() {
  return null;
};
var isNotEmptyArray = function(value2) {
  return isPresent2(value2) && isArray(value2) && value2.length > 0;
};
var has = function(accessor) {
  return function(value2) {
    return isPresent2(accessor(value2));
  };
};
var isNotEmpty = function(accessor) {
  return function(value2) {
    return isNotEmptyArray(accessor(value2));
  };
};
var runOrEmpty = function(predicate, fn) {
  return ifElse(predicate, fn, empty);
};
var calcPage = function(_a) {
  var skip4 = _a.skip, take4 = _a.take;
  return Math.floor((skip4 || 0) / take4) + 1;
};
var formatDescriptors = function(accessor, formatter) {
  return function(state2) {
    return accessor(state2).map(formatter).join("~");
  };
};
var removeAfter = function(what) {
  return function(str) {
    return str.slice(0, str.indexOf(what));
  };
};
var replace = function(patterns) {
  return compose.apply(void 0, patterns.map(function(_a) {
    var left = _a[0], right = _a[1];
    return function(s) {
      return s.replace(new RegExp(left, "g"), right);
    };
  }));
};
var sanitizeDateLiterals = replace([['"', ""], [":", "-"]]);
var removeAfterDot = removeAfter(".");
var directionFormatter = function(_a) {
  var field = _a.field, _b = _a.dir, dir2 = _b === void 0 ? "asc" : _b;
  return field + "-" + dir2;
};
var aggregateFormatter = function(_a) {
  var field = _a.field, aggregate = _a.aggregate;
  return field + "-" + aggregate;
};
var take2 = getter2("take");
var aggregates = getter2("aggregates");
var skip = getter2("skip");
var group = getter2("group");
var sort = getter2("sort", true);
var formatSort = formatDescriptors(sort, directionFormatter);
var formatGroup = formatDescriptors(group, directionFormatter);
var formatAggregates = formatDescriptors(aggregates, aggregateFormatter);
var prefixDateValue = function(value2) {
  return "datetime'" + value2 + "'";
};
var formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);
var formatDate = function(_a) {
  var field = _a.field, value2 = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;
  return {
    value: formatDateValue(value2),
    field,
    ignoreCase,
    operator
  };
};
var normalizeSort = function(state2) {
  return Object.assign({}, state2, {
    sort: (sort(state2) || []).filter(function(_a) {
      var dir2 = _a.dir;
      return isNotNullOrEmptyString(dir2);
    })
  });
};
var transformSkip = compose(pairwise("page"), calcPage);
var transformTake = compose(pairwise("pageSize"), take2);
var transformGroup = compose(pairwise("group"), formatGroup);
var transformSort = compose(pairwise("sort"), formatSort);
var transformAggregates = compose(pairwise("aggregate"), formatAggregates);
var serializePage = runOrEmpty(has(skip), transformSkip);
var serializePageSize = runOrEmpty(has(take2), transformTake);
var serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);
var serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);
var serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);
var filterFormatter = function(_a) {
  var field = _a.field, operator = _a.operator, value2 = _a.value;
  return field + "~" + operator + "~" + value2;
};
var dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);

// node_modules/@progress/kendo-data-query/dist/es/mvc/deserialization.js
var set = function(field, target, value2) {
  target[field] = value2;
  return target;
};
var toCamelCase = function(str) {
  return str.replace(/(^[A-Z])/g, function(_, g1) {
    return g1.toLowerCase();
  });
};
var prop = function(fieldName) {
  return function(obj) {
    var value2 = obj[fieldName];
    if (isPresent2(value2)) {
      return value2;
    }
    return obj[toCamelCase(fieldName)];
  };
};
var member = prop("Member");
var aggregateMethodName = prop("AggregateMethodName");
var value = prop("Value");
var convert = function(mapper) {
  return function(values) {
    return Object.keys(values).reduce(mapper.bind(null, values), {});
  };
};
var translateAggregate = convert(function(source, acc, field) {
  return set(field.toLowerCase(), acc, source[field]);
});
var translateAggregates = convert(function(source, acc, field) {
  return set(field, acc, translateAggregate(source[field]));
});
var valueOrDefault = function(value2, defaultValue) {
  return isPresent2(value2) ? value2 : defaultValue;
};
var normalizeGroup = function(group2) {
  return {
    aggregates: group2.Aggregates || group2.aggregates,
    field: group2.Member || group2.member || group2.field,
    hasSubgroups: group2.HasSubgroups || group2.hasSubgroups || false,
    items: group2.Items || group2.items,
    value: valueOrDefault(group2.Key, valueOrDefault(group2.key, group2.value))
  };
};
var translateGroup = compose(function(_a) {
  var field = _a.field, hasSubgroups = _a.hasSubgroups, value2 = _a.value, aggregates2 = _a.aggregates, items = _a.items;
  return {
    aggregates: translateAggregates(aggregates2),
    field,
    items: hasSubgroups ? items.map(translateGroup) : items,
    value: value2
  };
}, normalizeGroup);

// node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js
var compare = function(a, b) {
  if (isBlank(a)) {
    return a === b ? 0 : -1;
  }
  if (isBlank(b)) {
    return 1;
  }
  if (a.localeCompare) {
    return a.localeCompare(b);
  }
  return a > b ? 1 : a < b ? -1 : 0;
};
var compareDesc = function(a, b) {
  return compare(b, a);
};
var descriptorAsFunc = function(descriptor) {
  if (typeof descriptor.compare === "function") {
    return descriptor.compare;
  }
  var prop2 = getter2(descriptor.field, true);
  return function(a, b) {
    return (descriptor.dir === "asc" ? compare : compareDesc)(prop2(a), prop2(b));
  };
};
var initial = function(_a, _b) {
  return 0;
};
var composeSortDescriptors = function(descriptors) {
  return descriptors.filter(function(x) {
    return isPresent2(x.dir) || isPresent2(x.compare);
  }).map(function(descriptor) {
    return descriptorAsFunc(descriptor);
  }).reduce(function(acc, curr) {
    return function(a, b) {
      return acc(a, b) || curr(a, b);
    };
  }, initial);
};

// node_modules/@progress/kendo-data-query/dist/es/transducers.js
var valueToString = function(value2) {
  value2 = isPresent2(value2) && value2.getTime ? value2.getTime() : value2;
  return value2 + "";
};
var groupCombinator = function(field) {
  var prop2 = getter2(field, true);
  var position2 = 0;
  return function(agg, value2) {
    agg[field] = agg[field] || {};
    var groupValue = prop2(value2);
    var key = valueToString(groupValue);
    var values = agg[field][key] || {
      __position: position2++,
      aggregates: {},
      items: [],
      value: groupValue
    };
    values.items.push(value2);
    agg[field][key] = values;
    return agg;
  };
};
var expandAggregates = function(result) {
  if (result === void 0) {
    result = {};
  }
  Object.keys(result).forEach(function(field) {
    var aggregates2 = result[field];
    Object.keys(aggregates2).forEach(function(aggregate) {
      aggregates2[aggregate] = aggregates2[aggregate].result();
    });
  });
  return result;
};
var aggregatesFuncs = function(name) {
  return {
    average: function() {
      var value2 = 0;
      var count3 = 0;
      return {
        calc: function(curr) {
          if (isNumeric(curr)) {
            value2 += curr;
            count3++;
          } else {
            value2 = curr;
          }
        },
        result: function() {
          return isNumeric(value2) ? value2 / count3 : value2;
        }
      };
    },
    count: function() {
      var state2 = 0;
      return {
        calc: function() {
          return state2++;
        },
        result: function() {
          return state2;
        }
      };
    },
    max: function() {
      var state2 = Number.NEGATIVE_INFINITY;
      return {
        calc: function(value2) {
          state2 = isNumeric(state2) || isDate(state2) ? state2 : value2;
          if (state2 < value2 && (isNumeric(value2) || isDate(value2))) {
            state2 = value2;
          }
        },
        result: function() {
          return state2;
        }
      };
    },
    min: function() {
      var state2 = Number.POSITIVE_INFINITY;
      return {
        calc: function(value2) {
          state2 = isNumeric(state2) || isDate(state2) ? state2 : value2;
          if (state2 > value2 && (isNumeric(value2) || isDate(value2))) {
            state2 = value2;
          }
        },
        result: function() {
          return state2;
        }
      };
    },
    sum: function() {
      var state2 = 0;
      return {
        calc: function(value2) {
          value2 = isPresent2(value2) ? value2 : 0;
          state2 += value2;
        },
        result: function() {
          return state2;
        }
      };
    }
  }[name]();
};
var aggregatesCombinator = function(descriptors) {
  var functions = descriptors.map(function(descriptor) {
    var fieldAccessor = getter2(descriptor.field, true);
    var aggregateName = (descriptor.aggregate || "").toLowerCase();
    var aggregateAccessor = getter2(aggregateName, true);
    return function(state2, value2) {
      var fieldAggregates = state2[descriptor.field] || {};
      var aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);
      aggregateFunction.calc(fieldAccessor(value2));
      fieldAggregates[descriptor.aggregate] = aggregateFunction;
      state2[descriptor.field] = fieldAggregates;
      return state2;
    };
  });
  return function(state2, value2) {
    return functions.reduce(function(agg, calc) {
      return calc(agg, value2);
    }, state2);
  };
};
var concat = function(arr, value2) {
  arr.push(value2);
  return arr;
};
var map2 = function(transform2) {
  return function(reduce) {
    return function(acc, curr, index) {
      return reduce(acc, transform2(curr, index));
    };
  };
};
var filter2 = function(predicate) {
  return function(reduce) {
    return function(acc, curr) {
      return predicate(curr) ? reduce(acc, curr) : acc;
    };
  };
};
var isTransformerResult = function(source) {
  return isPresent2(source.__value);
};
var reduced = function(x) {
  if (isTransformerResult(x)) {
    return x;
  }
  return {
    __value: x,
    reduced: true
  };
};
var take3 = function(count3) {
  return function(reduce) {
    return function(acc, curr) {
      return count3-- > 0 ? reduce(acc, curr) : reduced(acc);
    };
  };
};
var skip2 = function(count3) {
  return function(reduce) {
    return function(acc, curr) {
      return count3-- <= 0 ? reduce(acc, curr) : acc;
    };
  };
};
var exec = function(transform2, initialValue, data) {
  var result = initialValue;
  for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {
    result = transform2(result, data[idx], idx);
    if (isTransformerResult(result)) {
      result = result.__value;
      break;
    }
  }
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/aggregate.operators.js
var identity2 = map2(function(x) {
  return x;
});
var aggregateBy = function(data, descriptors, transformers) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity2;
  }
  var initialValue = {};
  if (!descriptors.length) {
    return initialValue;
  }
  var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);
  return expandAggregates(result);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-no-eval.js
var logic = {
  "or": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) || fn(a);
      };
    },
    identity: function() {
      return false;
    }
  },
  "and": {
    concat: function(acc, fn) {
      return function(a) {
        return acc(a) && fn(a);
      };
    },
    identity: function() {
      return true;
    }
  }
};
var operatorsMap = {
  contains: function(a, b) {
    return (a || "").indexOf(b) >= 0;
  },
  doesnotcontain: function(a, b) {
    return (a || "").indexOf(b) === -1;
  },
  doesnotendwith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) < 0;
  },
  doesnotstartwith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === -1;
  },
  endswith: function(a, b) {
    return (a || "").indexOf(b, (a || "").length - (b || "").length) >= 0;
  },
  eq: function(a, b) {
    return a === b;
  },
  gt: function(a, b) {
    return a > b;
  },
  gte: function(a, b) {
    return a >= b;
  },
  isempty: function(a) {
    return a === "";
  },
  isnotempty: function(a) {
    return a !== "";
  },
  isnotnull: function(a) {
    return isPresent2(a);
  },
  isnull: function(a) {
    return isBlank(a);
  },
  lt: function(a, b) {
    return a < b;
  },
  lte: function(a, b) {
    return a <= b;
  },
  neq: function(a, b) {
    return a != b;
  },
  startswith: function(a, b) {
    return (a || "").lastIndexOf(b, 0) === 0;
  }
};
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var convertValue = function(value2, ignoreCase) {
  if (value2 != null && isString(value2)) {
    var date2 = dateRegExp.exec(value2);
    if (date2) {
      return (/* @__PURE__ */ new Date(+date2[1])).getTime();
    } else if (ignoreCase) {
      return value2.toLowerCase();
    }
  } else if (value2 != null && isDate(value2)) {
    return value2.getTime();
  }
  return value2;
};
var typedGetter = function(prop2, value2, ignoreCase) {
  if (!isPresent2(value2)) {
    return prop2;
  }
  var acc = prop2;
  if (isString(value2)) {
    var date2 = dateRegExp.exec(value2);
    if (date2) {
      value2 = /* @__PURE__ */ new Date(+date2[1]);
    } else {
      acc = function(a) {
        var x = prop2(a);
        if (typeof x === "string" && ignoreCase) {
          return x.toLowerCase();
        } else {
          return isNumeric(x) ? x + "" : x;
        }
      };
    }
  }
  if (isDate(value2)) {
    return function(a) {
      var x = acc(a);
      return isDate(x) ? x.getTime() : x;
    };
  }
  return acc;
};
var transformFilter = function(_a) {
  var field = _a.field, ignoreCase = _a.ignoreCase, value2 = _a.value, operator = _a.operator;
  field = !isPresent2(field) ? function(a) {
    return a;
  } : field;
  ignoreCase = isPresent2(ignoreCase) ? ignoreCase : true;
  var itemProp = typedGetter(isFunction(field) ? field : getter2(field, true), value2, ignoreCase);
  value2 = convertValue(value2, ignoreCase);
  var op = isFunction(operator) ? operator : operatorsMap[operator];
  return function(a) {
    return op(itemProp(a), value2, ignoreCase);
  };
};
var transformCompositeFilter = function(filter4) {
  var combiner = logic[filter4.logic];
  return filter4.filters.filter(isPresent2).map(function(x) {
    return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x);
  }).reduce(combiner.concat, combiner.identity);
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/filter-expression.factory.js
var compileFilter = function(descriptor) {
  if (!descriptor || descriptor.filters.length === 0) {
    return function() {
      return true;
    };
  }
  return transformCompositeFilter(descriptor);
};
var filterBy = function(data, descriptor) {
  if (!isPresent2(descriptor) || isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0) {
    return data;
  }
  return data.filter(compileFilter(normalizeFilters(descriptor)));
};

// node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js
var normalizeGroups = function(descriptors) {
  descriptors = isArray(descriptors) ? descriptors : [descriptors];
  return descriptors.map(function(x) {
    return Object.assign({
      dir: "asc"
    }, x);
  });
};
var identity3 = map2(function(x) {
  return x;
});
var groupBy = function(data, descriptors, transformers, originalData) {
  if (descriptors === void 0) {
    descriptors = [];
  }
  if (transformers === void 0) {
    transformers = identity3;
  }
  if (originalData === void 0) {
    originalData = data;
  }
  descriptors = normalizeGroups(descriptors);
  if (!descriptors.length) {
    return data;
  }
  var descriptor = descriptors[0];
  var initialValue = {};
  var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);
  var result = [];
  Object.keys(view).forEach(function(field) {
    Object.keys(view[field]).forEach(function(value2) {
      var group2 = view[field][value2];
      var aggregateResult = {};
      var filteredData = originalData;
      if (isPresent2(descriptor.aggregates)) {
        filteredData = filterBy(originalData, {
          field: descriptor.field,
          ignoreCase: false,
          operator: "eq",
          value: group2.value
        });
        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);
      }
      result[group2.__position] = {
        aggregates: aggregateResult,
        field,
        items: descriptors.length > 1 ? groupBy(group2.items, descriptors.slice(1), identity3, filteredData) : group2.items,
        value: group2.value
      };
    });
  });
  return result;
};

// node_modules/@progress/kendo-data-query/dist/es/array.operators.js
var orderBy = function(data, descriptors) {
  if (descriptors.some(function(x) {
    return isPresent2(x.dir) || isPresent2(x.compare);
  })) {
    data = data.slice(0);
    var comparer = composeSortDescriptors(descriptors);
    data.sort(comparer);
  }
  return data;
};
var count = function(data, predicate) {
  var counter = 0;
  for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {
    if (predicate(data[idx])) {
      counter++;
    }
  }
  return counter;
};
var limit = function(data, predicate) {
  if (predicate) {
    return data.filter(predicate);
  }
  return data;
};
var process = function(data, state2) {
  var skipCount = state2.skip, takeCount = state2.take, filterDescriptor = state2.filter, sort2 = state2.sort, group2 = state2.group;
  var sortDescriptors = __spreadArrays(normalizeGroups(group2 || []), sort2 || []);
  if (sortDescriptors.length) {
    data = orderBy(data, sortDescriptors);
  }
  var hasFilters = isPresent2(filterDescriptor) && filter2.length;
  var hasGroups2 = isPresent2(group2) && group2.length;
  if (!hasFilters && !hasGroups2) {
    return {
      data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,
      total: data.length
    };
  }
  var total;
  var transformers = [];
  var predicate;
  if (hasFilters) {
    predicate = compileFilter(normalizeFilters(filterDescriptor));
    total = count(data, predicate);
    transformers.push(filter2(predicate));
  } else {
    total = data.length;
  }
  if (isPresent2(skipCount) && isPresent2(takeCount)) {
    transformers.push(skip2(skipCount));
    transformers.push(take3(takeCount));
  }
  if (transformers.length) {
    var transform2 = compose.apply(void 0, transformers);
    var result = hasGroups2 ? groupBy(data, group2, transform2, limit(data, predicate)) : exec(transform2(concat), [], data);
    return {
      data: result,
      total
    };
  }
  return {
    data: hasGroups2 ? groupBy(data, group2) : data,
    total
  };
};

// node_modules/@progress/kendo-data-query/dist/es/filtering/operators.enum.js
var FilterOperator;
(function(FilterOperator2) {
  FilterOperator2["Contains"] = "contains";
  FilterOperator2["DoesNotContain"] = "doesnotcontain";
  FilterOperator2["DoesNotEndWith"] = "doesnotendwith";
  FilterOperator2["DoesNotStartWith"] = "doesnotstartwith";
  FilterOperator2["EndsWith"] = "endswith";
  FilterOperator2["EqualTo"] = "eq";
  FilterOperator2["GreaterThan"] = "gt";
  FilterOperator2["GreaterThanOrEqual"] = "gte";
  FilterOperator2["IsEmpty"] = "isempty";
  FilterOperator2["IsNotEmpty"] = "isnotempty";
  FilterOperator2["IsNotNull"] = "isnotnull";
  FilterOperator2["IsNull"] = "isnull";
  FilterOperator2["LessThan"] = "lt";
  FilterOperator2["LessThanOrEqual"] = "lte";
  FilterOperator2["NotEqualTo"] = "neq";
  FilterOperator2["StartsWith"] = "startswith";
})(FilterOperator || (FilterOperator = {}));

// node_modules/@progress/kendo-draggable-common/dist/es/algorithms/intersect.js
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect = function(element, candidates) {
  var max = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};

// node_modules/@progress/kendo-draggable-common/dist/es/utils/index.js
var detectBrowser = function() {
  var ua = window && window.navigator.userAgent;
  if (!ua) {
    return false;
  }
  var browser = false;
  var match = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match = ua.match(browserRxs[agent]);
      if (match) {
        browser = {};
        browser[agent] = true;
        browser[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser.version = parseInt(document.DOCUMENT_NODE || match[2], 10);
        break;
      }
    }
  }
  return browser;
};
var getDocument = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow = function(element) {
  var document2 = getDocument(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support2 = {
    browser: detectBrowser()
  };
  var document2 = getDocument(element);
  return support2.browser.edge || support2.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el) {
  if (el && el.className && typeof el.className === "string" && el.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el) {
  var root = scrollableRoot(el);
  if (!el || el === document.body || el === document.documentElement) {
    return root;
  }
  var parent = el;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = {
    x: 0,
    y: 0
  };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el, window2) {
  var root = scrollableRoot(el);
  if (el === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x, y, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y && rect.left <= x && y <= rect.bottom && x <= rect.right;
};

// node_modules/@progress/kendo-draggable-common/dist/es/drag-n-drop.js
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event2) {
  return /^touch/.test(event2.type);
};
var isScrollEvent = function(event2) {
  return /^(scroll)/.test(event2.type);
};
var normalizeEvent = function(event2, state2) {
  return isTouchEvent(event2) ? {
    pageX: event2.changedTouches[0].pageX,
    pageY: event2.changedTouches[0].pageY,
    clientX: event2.changedTouches[0].clientX,
    clientY: event2.changedTouches[0].clientY,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    offsetX: state2.offset.x,
    offsetY: state2.offset.y,
    type: event2.type,
    originalEvent: event2,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event2) ? {
    pageX: state2.pageOffset.x,
    pageY: state2.pageOffset.y,
    clientX: state2.clientOffset.x,
    clientY: state2.clientOffset.y,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    offsetX: state2.offset.x,
    offsetY: state2.offset.y,
    type: event2.type,
    originalEvent: event2,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event2.pageX,
    pageY: event2.pageY,
    clientX: event2.clientX,
    clientY: event2.clientY,
    offsetX: event2.offsetX,
    offsetY: event2.offsetY,
    scrollX: state2.scrollOffset.x,
    scrollY: state2.scrollOffset.y,
    type: event2.type,
    ctrlKey: event2.ctrlKey,
    shiftKey: event2.shiftKey,
    altKey: event2.altKey,
    metaKey: event2.metaKey,
    originalEvent: event2
  };
};
var noop = function() {
};
var dispatchDragAndDrop = function(state2, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a = callbacks.onIsPressedChange, onIsPressedChange = _a === void 0 ? noop : _a, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop : _d, _e = callbacks.onPageOffsetChange, onPageOffsetChange = _e === void 0 ? noop : _e, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state2.autoScrollDirection;
  var overrideScrollableParent = state2.scrollableParent;
  var event2 = normalizeEvent(action.event, state2);
  switch (event2.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event2.originalEvent.isPrimary || event2.originalEvent.button !== 0)) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event2.originalEvent.which && event2.originalEvent.which > 1 || state2.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event2.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? {
        x: scrollableParent_1.scrollX,
        y: scrollableParent_1.scrollY
      } : {
        x: scrollableParent_1.scrollLeft,
        y: scrollableParent_1.scrollTop
      });
      onClientOffsetChange({
        x: event2.clientX,
        y: event2.clientY
      });
      onPageOffsetChange({
        x: event2.pageX,
        y: event2.pageY
      });
      onOffsetChange({
        x: event2.offsetX,
        y: event2.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event2);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state2.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? {
        x: scrollableParent.scrollX,
        y: scrollableParent.scrollY
      } : {
        x: scrollableParent.scrollLeft,
        y: scrollableParent.scrollTop
      };
      event2.scrollX = scrollOffset.x - state2.initialScrollOffset.x;
      event2.scrollY = scrollOffset.y - state2.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event2.scrollX,
        y: event2.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event2.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event2.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state2.pressed) {
        if (state2.autoScroll && event2.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event2.clientX, event2.clientY));
            var newVelocity = autoScrollVelocity(event2.clientX, event2.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state2.drag && drag.onDragStart) {
          drag.onDragStart(event2);
        }
        if (drag.onDrag) {
          drag.onDrag(event2);
        }
        var dropElement_1 = intersect(hint || element, state2.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d) {
          return d !== (hint || element);
        }));
        var drop = state2.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event2.clientX, event2.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state2.drop && state2.drop.element) !== dropElement_1) {
            if (state2.drop && state2.drop.onDragLeave) {
              state2.drop.onDragLeave(event2);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event2);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event2);
            }
          }
        } else if (state2.drop && state2.drop.onDragLeave) {
          state2.drop.onDragLeave(event2);
        }
      }
      onClientOffsetChange({
        x: event2.clientX,
        y: event2.clientY
      });
      onPageOffsetChange({
        x: event2.pageX,
        y: event2.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event2.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event2.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event2.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onRelease) {
        drag.onRelease(event2);
      }
      if (state2.drop && state2.drop.onDrop) {
        state2.drop.onDrop(event2);
      }
      if (state2.drag && drag.onDragEnd) {
        drag.onDragEnd(event2);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onDragEnd) {
        drag.onDragEnd(event2);
      }
      if (state2.drop && state2.drop.onDragLeave) {
        state2.drop.onDragLeave(event2);
      }
      break;
    }
    default:
      break;
  }
};

// node_modules/@progress/kendo-draggable-common/dist/es/auto-scroll.js
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};

// node_modules/@progress/kendo-angular-utils/fesm2020/progress-kendo-angular-utils.mjs
var _c0 = (a0, a1, a2) => ({
  $implicit: a0,
  index: a1,
  data: a2
});
function HintComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var packageMetadata = {
  name: "@progress/kendo-angular-utils",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1720607853,
  version: "16.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DragHandleDirective = class {
  constructor(element) {
    this.element = element;
    this.cursorStyle = "move";
  }
};
DragHandleDirective.ɵfac = function DragHandleDirective_Factory(t) {
  return new (t || DragHandleDirective)(ɵɵdirectiveInject(ElementRef));
};
DragHandleDirective.ɵdir = ɵɵdefineDirective({
  type: DragHandleDirective,
  selectors: [["", "kendoDragHandle", ""]],
  hostVars: 2,
  hostBindings: function DragHandleDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("cursor", ctx.cursorStyle);
    }
  },
  exportAs: ["kendoDragHandle"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragHandle]",
      exportAs: "kendoDragHandle"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    cursorStyle: [{
      type: HostBinding,
      args: ["style.cursor"]
    }]
  });
})();
function isDocumentNode(container) {
  return container.nodeType === 9;
}
var getAction = (event2, draggable) => {
  return {
    event: event2,
    payload: draggable
  };
};
var dragTargetTransition = "transform .3s ease-in-out";
var isPresent3 = (value2) => value2 !== null && value2 !== void 0;
function closestBySelector(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  const matches = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);
  let node = element;
  while (node && !isDocumentNode(node)) {
    if (matches(node, selector)) {
      return node;
    }
    node = node.parentNode;
  }
}
var intersect2 = (element, candidates) => {
  let max = 0;
  let result = null;
  candidates.forEach((candidate) => {
    if (candidate && element) {
      const ration = getRatio2(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};
var getRatio2 = (element, target) => {
  const elementRect = element.getBoundingClientRect();
  const targetRect = target.getBoundingClientRect();
  const top = Math.max(targetRect.top, elementRect.top);
  const left = Math.max(targetRect.left, elementRect.left);
  const right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  const bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = targetRect.width * targetRect.height;
    const entryArea = elementRect.width * elementRect.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var setElementStyles = (renderer, elem, styles) => {
  const props = Object.keys(styles);
  props.forEach((p) => {
    renderer.setStyle(elem, p, styles[p]);
  });
};
var allPointerDownEvents = ["pointerdown", "mousedown", "touchstart"];
var allPointerMoveEvents = ["pointermove", "mousemove", "touchmove"];
var allPointerUpEvents = ["pointerup", "pointercancel", "mouseup", "contextmenu", "touchend", "touchcancel"];
var DragStateService = class {
  constructor() {
    this.dragTarget = null;
    this.dropTarget = null;
    this.dragTargets = [];
    this.dropTargets = [];
    this.pressed = false;
    this.ignoreMouse = false;
    this.autoScroll = true;
    this.isScrolling = false;
    this.scrollableParent = null;
    this.autoScrollDirection = {
      horizontal: true,
      vertical: true
    };
    this.initialClientOffset = {
      x: 0,
      y: 0
    };
    this.clientOffset = {
      x: 0,
      y: 0
    };
    this.initialScrollOffset = {
      x: 0,
      y: 0
    };
    this.scrollOffset = {
      x: 0,
      y: 0
    };
    this.offset = {
      x: 0,
      y: 0
    };
    this.pageOffset = {
      x: 0,
      y: 0
    };
    this.velocity = {
      x: 0,
      y: 0
    };
    this.dragIndex = null;
    this.dropIndex = null;
    this.callbacks = {};
    this.scrollInterval = null;
    this.setCallbacks();
  }
  handleDragAndDrop(action) {
    this.updateState();
    dispatchDragAndDrop(this.state, action, this.callbacks);
  }
  setPressed(pressed) {
    this.pressed = pressed;
  }
  setScrolling(isScrolling) {
    this.isScrolling = isScrolling;
    if (isScrolling) {
      const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = window.setInterval(() => {
        autoScroll(scrollableParent, {
          x: this.velocity.x,
          y: this.velocity.y
        });
      }, 50);
    } else {
      if (this.scrollInterval) {
        window.clearInterval(this.scrollInterval);
        this.scrollInterval = null;
      }
    }
  }
  setVelocity(velocity) {
    this.velocity = velocity;
  }
  setOffset(offset2) {
    this.offset = offset2;
  }
  setClientOffset(clientOffset) {
    this.clientOffset = clientOffset;
  }
  setPageOffset(pageOffset) {
    this.pageOffset = pageOffset;
  }
  setInitialClientOffset(initialClientOffset) {
    this.initialClientOffset = initialClientOffset;
  }
  setScrollOffset(scrollOffset) {
    this.scrollOffset = scrollOffset;
  }
  setInitialScrollOffset(initialScrollOffset) {
    this.initialScrollOffset = initialScrollOffset;
  }
  get dragTargetPresent() {
    return isPresent3(this.dragTarget?.element);
  }
  get dropTargetPresent() {
    return isPresent3(this.dropTarget?.element);
  }
  updateState() {
    this.state = {
      drag: this.dragTarget,
      drop: this.dropTarget,
      drags: this.dragTargets,
      drops: this.dropTargets,
      pressed: this.pressed,
      ignoreMouse: this.ignoreMouse,
      autoScroll: this.autoScroll,
      isScrolling: this.isScrolling,
      scrollableParent: this.scrollableParent,
      autoScrollDirection: this.autoScrollDirection,
      initialClientOffset: this.initialClientOffset,
      clientOffset: this.clientOffset,
      initialScrollOffset: this.initialScrollOffset,
      scrollOffset: this.scrollOffset,
      offset: this.offset,
      pageOffset: this.pageOffset,
      velocity: this.velocity
    };
  }
  setCallbacks() {
    this.callbacks = {
      onVelocityChange: this.setVelocity.bind(this),
      onOffsetChange: this.setOffset.bind(this),
      onClientOffsetChange: this.setClientOffset.bind(this),
      onPageOffsetChange: this.setPageOffset.bind(this),
      onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),
      onScrollOffsetChange: this.setScrollOffset.bind(this),
      onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),
      onIsPressedChange: this.setPressed.bind(this),
      onIsScrollingChange: this.setScrolling.bind(this)
    };
  }
  ngOnDestroy() {
    if (this.scrollInterval) {
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = null;
    }
  }
};
DragStateService.ɵfac = function DragStateService_Factory(t) {
  return new (t || DragStateService)();
};
DragStateService.ɵprov = ɵɵdefineInjectable({
  token: DragStateService,
  factory: DragStateService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragStateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var HintComponent = class {
  constructor(element) {
    this.element = element;
    this.pointerEvents = "none";
  }
};
HintComponent.ɵfac = function HintComponent_Factory(t) {
  return new (t || HintComponent)(ɵɵdirectiveInject(ElementRef));
};
HintComponent.ɵcmp = ɵɵdefineComponent({
  type: HintComponent,
  selectors: [["kendo-draghint"]],
  hostVars: 2,
  hostBindings: function HintComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("pointer-events", ctx.pointerEvents);
    }
  },
  inputs: {
    template: "template",
    directive: "directive",
    targetIndex: "targetIndex",
    contextData: "contextData"
  },
  decls: 1,
  vars: 6,
  consts: [[4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function HintComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, HintComponent_ng_container_0_Template, 1, 0, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c0, ctx.directive, ctx.targetIndex, ctx.contextData));
    }
  },
  dependencies: [NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintComponent, [{
    type: Component,
    args: [{
      selector: "kendo-draghint",
      template: `
        <ng-container *ngTemplateOutlet="template; context: { $implicit: directive, index: targetIndex, data: contextData }">
        </ng-container>
    `
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    template: [{
      type: Input
    }],
    directive: [{
      type: Input
    }],
    targetIndex: [{
      type: Input
    }],
    contextData: [{
      type: Input
    }],
    pointerEvents: [{
      type: HostBinding,
      args: ["style.pointer-events"]
    }]
  });
})();
var DragTargetPressEvent = class {
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
};
var DragTargetDragReadyEvent = class {
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragStartEvent = class extends PreventableEvent {
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
};
var DragTargetDragEndEvent = class {
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
};
var DragTargetDragEvent = class extends PreventableEvent {
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
};
var DragTargetReleaseEvent = class {
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
};
var isDragStartPrevented$1 = false;
var isDragPrevented$1 = false;
var DragTargetDirective = class {
  constructor(element, renderer, ngZone, service, viewContainer) {
    this.element = element;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.service = service;
    this.viewContainer = viewContainer;
    this.hint = false;
    this.threshold = 0;
    this.autoScroll = true;
    this.dragDelay = 0;
    this.mode = "auto";
    this.onPress = new EventEmitter();
    this.onDragStart = new EventEmitter();
    this.onDrag = new EventEmitter();
    this.onDragReady = new EventEmitter();
    this.onRelease = new EventEmitter();
    this.onDragEnd = new EventEmitter();
    this.dragTarget = null;
    this.domSubscriptions = [];
    this.hintComponent = null;
    this.dragStarted = false;
    this.pressed = false;
    this.dragTimeout = null;
    this.initialPosition = {
      x: 0,
      y: 0
    };
    this.position = {
      x: 0,
      y: 0
    };
    this.scrollableParent = null;
    this.defaultHint = null;
    this._dragData = () => null;
    validatePackage(packageMetadata);
  }
  /**
   * Defines a callback function used for attaching custom data to the dragTarget.
   * The data will be available in the events of the respective [`DropTarget`]({% slug api_utils_droptargetdirective %}) or [`DropTargetContainer`]({% slug api_utils_droptargetcontainerdirective %}) directives.
   * The current DragTarget HTML element and its `dragTargetId` will be available as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  get hintTemplate() {
    return isPresent3(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent3(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  onPointerDown(event2) {
    if (this.dragHandles.length && !this.isDragHandle(event2.target)) {
      return;
    }
    event2.preventDefault();
    const action = getAction(event2, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.service.autoScroll = typeof this.autoScroll === "object" ? this.autoScroll.enabled !== false : this.autoScroll;
    this.service.scrollableParent = this.getAutoScrollContainer();
    this.service.autoScrollDirection = typeof this.autoScroll === "object" ? this.autoScroll.direction : {
      horizontal: true,
      vertical: true
    };
    this.attachDomHandlers();
  }
  onPointerMove(event2) {
    event2.preventDefault();
    const action = getAction(event2, this.dragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event2) {
    event2.preventDefault();
    const action = getAction(event2, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.attachDomHandlers();
  }
  ngOnInit() {
    this.initializeDragTarget();
  }
  ngAfterContentInit() {
    if (isPresent3(this.element) || isPresent3(this.dragTarget)) {
      this.attachDomHandlers();
      if (!this.dragHandles.length) {
        this.renderer.setStyle(this.nativeElement, "cursor", "move");
      }
    }
    this.service.dragTargets.push(this.dragTarget);
  }
  ngOnDestroy() {
    this.domSubscriptions.forEach((subscription) => subscription());
  }
  handlePress(event2) {
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.pressed = true;
        this.emitZoneAwareEvent("onDragReady", event2);
      }, this.dragDelay);
    } else {
      this.pressed = true;
    }
    this.scrollableParent = this.dragTarget.element ? getScrollableParent(this.dragTarget.element) : null;
    this.emitZoneAwareEvent("onPress", event2);
  }
  handleDragStart(event2) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    isDragStartPrevented$1 = this.emitZoneAwareEvent("onDragStart", event2).isDefaultPrevented();
    if (isDragStartPrevented$1) {
      return;
    }
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.nativeElement, "opacity", "0.7");
      }
      this.initialPosition = {
        x: event2.offsetX,
        y: event2.offsetY
      };
    } else {
      this.initialPosition = {
        x: event2.clientX - this.position.x,
        y: event2.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.dragTarget;
    this.service.dragTargetDirective = this;
    this.service.dragData = this.dragData({
      dragTarget: this.dragTarget.element,
      dragTargetId: this.dragTargetIdResult,
      dragTargetIndex: null
    });
  }
  handleDrag(event2) {
    if (!this.pressed || isDragStartPrevented$1) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.nativeElement;
    this.position = this.calculatePosition(elem, event2);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented$1 = this.emitZoneAwareEvent("onDrag", event2).isDefaultPrevented();
    if (isDragPrevented$1) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event2) {
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
      this.pressed = false;
    }
    this.emitZoneAwareEvent("onRelease", event2);
  }
  handleDragEnd(event2) {
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent3(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.nativeElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent3(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.position = {
          x: 0,
          y: 0
        };
      }
    }
    if (this.hint && isPresent3(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.nativeElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragTargetDirective = null;
    if (!this.dragStarted || isDragStartPrevented$1 || isDragPrevented$1) {
      return;
    }
    this.emitZoneAwareEvent("onDragEnd", event2);
    this.dragStarted = false;
  }
  initializeDragTarget() {
    this.dragTarget = {
      element: this.nativeElement,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
  }
  attachDomHandlers() {
    this.ngZone.runOutsideAngular(() => {
      if (this.domSubscriptions.length > 0) {
        this.domSubscriptions.forEach((subscription) => subscription());
      }
      if (!(isDocumentAvailable() && isPresent3(this.element))) {
        return;
      }
      if (this.service.pressed) {
        this.onPointerMove = this.onPointerMove.bind(this);
        this.onPointerUp = this.onPointerUp.bind(this);
        this.domSubscriptions = [this.renderer.listen(document, "pointermove", this.onPointerMove), this.renderer.listen(document, "mousemove", this.onPointerMove), this.renderer.listen(document, "touchmove", this.onPointerMove), this.renderer.listen(document, "pointerup", this.onPointerUp), this.renderer.listen(document, "pointercancel", this.onPointerUp), this.renderer.listen(document, "mouseup", this.onPointerUp), this.renderer.listen(document, "contextmenu", this.onPointerUp), this.renderer.listen(document, "touchend", this.onPointerUp), this.renderer.listen(document, "touchcancel", this.onPointerUp)];
        if (isPresent3(this.scrollableParent)) {
          if (this.scrollableParent === document.getElementsByTagName("html")[0]) {
            this.scrollableParent = window;
          }
          this.domSubscriptions.push(this.renderer.listen(this.scrollableParent, "scroll", this.onPointerMove));
        }
      } else {
        this.onPointerDown = this.onPointerDown.bind(this);
        const element = this.nativeElement;
        this.domSubscriptions = [this.renderer.listen(element, "pointerdown", this.onPointerDown), this.renderer.listen(element, "mousedown", this.onPointerDown), this.renderer.listen(element, "touchstart", this.onPointerDown)];
      }
    });
  }
  isDragHandle(el) {
    return this.dragHandles.toArray().some((dh) => contains(dh.element.nativeElement, el, true));
  }
  getAutoScrollContainer() {
    return typeof this.autoScroll === "object" && this.autoScroll.boundaryElementRef && this.autoScroll.boundaryElementRef.nativeElement ? this.autoScroll.boundaryElementRef.nativeElement : null;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent3(this.element))) {
      return;
    }
    if (isPresent3(this.hint) && typeof this.hint === "object") {
      if (isPresent3(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.dragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent3(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.nativeElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent3(this.hint.hintClass)) {
        const hintClasses2 = parseCSSClassNames(this.hint.hintClass);
        hintClasses2.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent3(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent3(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      if (typeof this.hint === "object" && isPresent3(this.hint.appendTo)) {
        this.hint.appendTo.element.nativeElement.removeChild(this.defaultHint);
      } else {
        document.body.removeChild(this.defaultHint);
      }
      this.defaultHint = null;
    }
    this.dragTarget.hint = null;
  }
  emitZoneAwareEvent(event2, normalizedEvent) {
    const eventProps = {
      dragTarget: this.nativeElement,
      dragEvent: normalizedEvent
    };
    if (this.hint && isPresent3(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    if (this.dragTargetId && this.dragTargetId !== "") {
      eventProps.dragTargetId = this.dragTargetIdResult;
    }
    let eventArgs;
    switch (event2) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event2].emit(eventArgs);
    });
    return eventArgs;
  }
  get dragTargetIdResult() {
    if (this.dragTargetId && this.dragTargetId !== "") {
      return typeof this.dragTargetId === "string" ? this.dragTargetId : this.dragTargetId({
        dragTarget: this.dragTarget.element,
        dragTargetIndex: null
      });
    }
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.nativeElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event2) {
    let position2 = null;
    if (element === this.hintElem) {
      position2 = {
        x: event2.clientX,
        y: event2.clientY
      };
    } else {
      position2 = {
        x: event2.clientX - this.initialPosition.x + event2.scrollX,
        y: event2.clientY - this.initialPosition.y + event2.scrollY
      };
    }
    if (this.restrictByAxis === "horizontal") {
      position2.y = 0;
    } else if (this.restrictByAxis === "vertical") {
      position2.x = 0;
    }
    return position2;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      const hintCoordinates = {
        x: this.position.x - this.initialPosition.x,
        y: this.position.y - this.initialPosition.y
      };
      return {
        top: `${hintCoordinates.y}px`,
        left: `${hintCoordinates.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform2 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform2,
        transition: "none"
      };
    }
  }
};
DragTargetDirective.ɵfac = function DragTargetDirective_Factory(t) {
  return new (t || DragTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef));
};
DragTargetDirective.ɵdir = ɵɵdefineDirective({
  type: DragTargetDirective,
  selectors: [["", "kendoDragTarget", ""]],
  contentQueries: function DragTargetDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DragHandleDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHandles = _t);
    }
  },
  inputs: {
    hint: "hint",
    threshold: "threshold",
    autoScroll: "autoScroll",
    dragTargetId: "dragTargetId",
    dragDelay: "dragDelay",
    restrictByAxis: "restrictByAxis",
    mode: "mode",
    dragData: "dragData"
  },
  outputs: {
    onPress: "onPress",
    onDragStart: "onDragStart",
    onDrag: "onDrag",
    onDragReady: "onDragReady",
    onRelease: "onRelease",
    onDragEnd: "onDragEnd"
  },
  exportAs: ["kendoDragTarget"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTarget]",
      exportAs: "kendoDragTarget"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }];
  }, {
    hint: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    restrictByAxis: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onDragReady: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    dragHandles: [{
      type: ContentChildren,
      args: [DragHandleDirective]
    }]
  });
})();
var DropTargetEvent = class {
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dropTarget;
  }
};
var DropTargetDirective = class {
  constructor(service, element, ngZone) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    this.onDragEnter = new EventEmitter();
    this.onDragOver = new EventEmitter();
    this.onDragLeave = new EventEmitter();
    this.onDrop = new EventEmitter();
    validatePackage(packageMetadata);
  }
  ngOnInit() {
    this.initializeDropTarget();
    this.service.dropTargets.push(this.dropTarget);
  }
  /**
   * @hidden
   */
  handleDragEnter(event2) {
    if (!this.service.dragTarget) {
      return;
    }
    this.service.dropTarget = this.dropTarget;
    this.emitZoneAwareEvent("onDragEnter", event2);
  }
  /**
   * @hidden
   */
  handleDragLeave(event2) {
    this.service.dropTarget = null;
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event2);
  }
  /**
   * @hidden
   */
  handleDragOver(event2) {
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event2);
  }
  /**
   * @hidden
   */
  handleDrop(event2) {
    this.emitZoneAwareEvent("onDrop", event2);
    this.service.dropTarget = null;
  }
  initializeDropTarget() {
    this.dropTarget = {
      element: this.element.nativeElement,
      onDragEnter: this.handleDragEnter.bind(this),
      onDragLeave: this.handleDragLeave.bind(this),
      onDragOver: this.handleDragOver.bind(this),
      onDrop: this.handleDrop.bind(this)
    };
  }
  emitZoneAwareEvent(event2, normalizedEvent) {
    const eventProps = {
      dropTarget: this.element.nativeElement,
      dragTarget: this.service.dragTarget?.element,
      dragEvent: normalizedEvent,
      dragData: this.service.dragData
    };
    if (isPresent3(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.element;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event2].emit(eventArgs);
    });
  }
};
DropTargetDirective.ɵfac = function DropTargetDirective_Factory(t) {
  return new (t || DropTargetDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
DropTargetDirective.ɵdir = ɵɵdefineDirective({
  type: DropTargetDirective,
  selectors: [["", "kendoDropTarget", ""]],
  outputs: {
    onDragEnter: "onDragEnter",
    onDragOver: "onDragOver",
    onDragLeave: "onDragLeave",
    onDrop: "onDrop"
  },
  exportAs: ["kendoDropTarget"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]",
      exportAs: "kendoDropTarget"
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var isDragStartPrevented = false;
var isDragPrevented = false;
var DragTargetContainerDirective = class {
  constructor(wrapper, ngZone, renderer, service, viewContainer, cdr) {
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.service = service;
    this.viewContainer = viewContainer;
    this.cdr = cdr;
    this.hint = false;
    this.dragDelay = 0;
    this.threshold = 0;
    this.mode = "auto";
    this.onDragReady = new EventEmitter();
    this.onPress = new EventEmitter();
    this.onDragStart = new EventEmitter();
    this.onDrag = new EventEmitter();
    this.onRelease = new EventEmitter();
    this.onDragEnd = new EventEmitter();
    this.currentDragTarget = null;
    this.dragTimeout = null;
    this.pressed = false;
    this.dragStarted = false;
    this.hintComponent = null;
    this.defaultHint = null;
    this.currentDragTargetElement = null;
    this.scrollableParent = null;
    this.previousDragTargets = [];
    this.initialPosition = {
      x: 0,
      y: 0
    };
    this.position = {
      x: 0,
      y: 0
    };
    this.positionsMap = /* @__PURE__ */ new Map();
    this._dragTargetFilter = null;
    this._dragDisabled = false;
    this._dragData = () => null;
    this._dragTargetId = () => null;
    validatePackage(packageMetadata);
  }
  /**
   * Specifies a selector for elements within a container which will be configured as draggable
   * ([see example]({% slug drag_target_container %})). The possible values include any
   * DOM `selector`.
   */
  set dragTargetFilter(value2) {
    this._dragTargetFilter = value2;
    if (!this.dragDisabled) {
      this.initializeDragTargets();
    }
  }
  get dragTargetFilter() {
    return this._dragTargetFilter;
  }
  /**
   * Defines a unique identifier for each drag target.
   * It exposes the current DragTarget HTML element and its index in the collection of drag targets as arguments.
   */
  set dragTargetId(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragTargetId must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragTargetId = fn;
  }
  get dragTargetId() {
    return this._dragTargetId;
  }
  /**
   * Defines a callback function which returns custom data passed to the DropTarget events.
   * It exposes the current DragTarget HTML element, its `dragTargetId` and its index in the collection of drag targets as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  /**
   * If set to true, the dragging of DragTargets within the container will be disabled.
   *
   * @default false
   */
  set dragDisabled(value2) {
    this._dragDisabled = value2;
    if (value2) {
      this.clearPreviousTargets();
      this.unsubscribe();
      if (isPresent3(this.hintElem)) {
        this.destroyHint();
      }
    } else {
      if (isPresent3(this.wrapper) || isPresent3(this.currentDragTarget)) {
        this.subscribe();
      }
      this.initializeDragTargets();
    }
  }
  get dragDisabled() {
    return this._dragDisabled;
  }
  /**
   * Used for notifying the DragTargetContainer that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDragTargets();
  }
  get allDragTargets() {
    return this.queryHost(this.dragTargetFilter);
  }
  get dragHandles() {
    return this.isHandleSelectorValid ? this.queryHost(this.dragHandle) : null;
  }
  get hintTemplate() {
    return isPresent3(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  ngAfterViewInit() {
    const isTargetPresent = isPresent3(this.wrapper) || isPresent3(this.currentDragTarget);
    if (!this.dragDisabled && isTargetPresent) {
      this.subscribe();
    }
    !this.dragDisabled && this.initializeDragTargets();
  }
  onPointerDown(event2) {
    if (isPresent3(this.dragHandles) && !this.isDragHandle(event2.target)) {
      return;
    }
    const action = getAction(event2, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onPointerMove(event2) {
    event2.preventDefault();
    const action = getAction(event2, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event2) {
    event2.preventDefault();
    const action = getAction(event2, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.ngZone.runOutsideAngular(() => {
      this.subscribe();
    });
  }
  handlePress(event2) {
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.pressed = true;
        this.emitZoneAwareEvent("onDragReady", event2);
      }, this.dragDelay);
    } else {
      this.pressed = true;
    }
    event2.originalEvent.preventDefault();
    const eventTarget = event2.originalEvent.target;
    this.currentDragTargetElement = closestBySelector(eventTarget, this.dragTargetFilter);
    this.currentDragTarget.element = this.currentDragTargetElement;
    this.service.dragIndex = this.getDragIndex();
    this.scrollableParent = this.hintTemplate ? document.body : this.currentDragTargetElement ? getScrollableParent(this.currentDragTargetElement) : null;
    this.emitZoneAwareEvent("onPress", event2);
  }
  handleDragStart(event2) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    isDragStartPrevented = this.emitZoneAwareEvent("onDragStart", event2).isDefaultPrevented();
    if (isDragStartPrevented) {
      return;
    }
    this.position = this.positionsMap.has(this.currentDragTargetElement) ? this.positionsMap.get(this.currentDragTargetElement) : {
      x: 0,
      y: 0
    };
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.currentDragTargetElement, "opacity", "0.7");
      }
    } else {
      this.initialPosition = {
        x: event2.clientX - this.position.x,
        y: event2.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.currentDragTarget;
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    this.service.dragTargetId = this.dragTargetId(targetIdArgs);
    const targetDataArgs = Object.assign({
      dragTargetId: this.service.dragTargetId
    }, targetIdArgs);
    this.service.dragData = this.dragData(targetDataArgs);
  }
  handleDrag(event2) {
    if (!this.pressed || isDragStartPrevented) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    this.position = this.calculatePosition(elem, event2);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented = this.emitZoneAwareEvent("onDrag", event2).isDefaultPrevented();
    if (isDragPrevented) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event2) {
    if (this.dragStarted) {
      this.positionsMap.set(this.currentDragTargetElement, this.position);
    }
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
      this.pressed = false;
    }
    this.emitZoneAwareEvent("onRelease", event2);
  }
  handleDragEnd(event2) {
    if (!this.dragStarted) {
      return;
    }
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent3(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent3(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.positionsMap.delete(this.currentDragTargetElement);
      }
    }
    if (this.hint && isPresent3(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.currentDragTargetElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragIndex = null;
    this.currentDragTarget.element = null;
    this.emitZoneAwareEvent("onDragEnd", event2);
    if (isDragStartPrevented || isDragPrevented) {
      return;
    }
    this.dragStarted = false;
  }
  get nativeElement() {
    return this.wrapper.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent3(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  unsubscribe() {
    if (this.pointerDownSubscription) {
      this.pointerDownSubscription.unsubscribe();
    }
    if (this.pointerMoveSubscription) {
      this.pointerMoveSubscription.unsubscribe();
    }
    if (this.pointerUpSubscription) {
      this.pointerUpSubscription.unsubscribe();
    }
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
  }
  subscribe() {
    this.ngZone.runOutsideAngular(() => {
      this.unsubscribe();
      if (!(isDocumentAvailable() && isPresent3(this.wrapper))) {
        return;
      }
      const element = this.nativeElement;
      if (this.service.pressed) {
        const pointerMoveStreams = allPointerMoveEvents.map((ev) => fromEvent(document, ev));
        const pointerUpStreams = allPointerUpEvents.map((ev) => fromEvent(document, ev));
        this.pointerMoveSubscription = merge(...pointerMoveStreams).pipe(filter(() => this.dragTargetFilter !== "")).subscribe((e) => this.onPointerMove(e));
        this.pointerUpSubscription = merge(...pointerUpStreams).subscribe((e) => this.onPointerUp(e));
        if (isPresent3(this.scrollableParent)) {
          this.scrollSubscription = fromEvent(this.scrollableParent, "scroll").subscribe((e) => this.onPointerMove(e));
        }
      } else {
        const pointerDownStreams = allPointerDownEvents.map((ev) => fromEvent(element, ev));
        this.pointerDownSubscription = merge(...pointerDownStreams).pipe(filter(() => this.dragTargetFilter !== "")).subscribe((e) => {
          const filterElement = closestBySelector(e.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
          if (filterElement) {
            this.onPointerDown(e);
          }
        });
      }
    });
  }
  emitZoneAwareEvent(event2, normalizedEvent) {
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    const eventProps = {
      dragTarget: this.currentDragTargetElement,
      dragEvent: normalizedEvent,
      dragTargetIndex: this.service.dragIndex,
      dragTargetId: this.dragTargetId(targetIdArgs)
    };
    if (this.hint && isPresent3(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    let eventArgs;
    switch (event2) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event2].emit(eventArgs);
    });
    return eventArgs;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent3(this.wrapper))) {
      return;
    }
    if (isPresent3(this.hint) && typeof this.hint === "object") {
      if (isPresent3(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.currentDragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent3(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.currentDragTargetElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent3(this.hint.hintClass)) {
        const hintClasses2 = parseCSSClassNames(this.hint.hintClass);
        hintClasses2.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent3(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.instance.targetIndex = this.service.dragIndex;
    const targetDataArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetId: this.service.dragTargetId,
      dragTargetIndex: this.service.dragIndex
    };
    this.hintComponent.instance.contextData = this.dragData(targetDataArgs);
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent3(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      document.body.removeChild(this.defaultHint);
      this.defaultHint = null;
    }
    this.currentDragTarget.hint = null;
  }
  getDragIndex() {
    return this.allDragTargets.indexOf(this.currentDragTargetElement);
  }
  initializeDragTargets() {
    if (!isPresent3(this.allDragTargets)) {
      if (this.previousDragTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDragTargets.forEach((dragTargetEl) => {
      const isDragTargetInitialized = this.service.dragTargets.find((dt) => dt.element === dragTargetEl);
      if (!isDragTargetInitialized) {
        this.service.dragTargets.push({
          element: dragTargetEl,
          hint: null,
          onPress: this.handlePress.bind(this),
          onRelease: this.handleRelease.bind(this),
          onDragStart: this.handleDragStart.bind(this),
          onDrag: this.handleDrag.bind(this),
          onDragEnd: this.handleDragEnd.bind(this)
        });
      }
    });
    if (this.previousDragTargets.length > 0) {
      const dragTargetsToRemove = this.previousDragTargets.filter((dt) => !this.allDragTargets.includes(dt));
      dragTargetsToRemove.forEach((dragTarget) => {
        const idx = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
        if (idx > -1) {
          this.service.dragTargets.splice(idx, 1);
        }
      });
    }
    this.previousDragTargets = this.allDragTargets;
    this.currentDragTarget = {
      element: null,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
    this.setCursorStyle();
  }
  isDragHandle(el) {
    return this.dragHandles.some((dh) => contains(dh, el, true));
  }
  get isHandleSelectorValid() {
    return isPresent3(this.dragHandle) && this.dragHandle !== "";
  }
  setCursorStyle() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent3(this.dragHandle) && this.dragHandle !== "") {
      if (isPresent3(this.dragHandles) && this.dragHandles.length > 0) {
        this.dragHandles.forEach((handle) => {
          this.renderer.setStyle(handle, "cursor", "move");
        });
      }
    } else {
      this.allDragTargets.forEach((target) => {
        this.renderer.setStyle(target, "cursor", "move");
      });
    }
  }
  queryHost(selector) {
    if (isPresent3(selector) && selector !== "") {
      return Array.from(this.nativeElement.querySelectorAll(selector));
    }
  }
  clearPreviousTargets() {
    this.previousDragTargets.forEach((dragTarget) => {
      const idx = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
      if (idx > -1) {
        this.service.dragTargets.splice(idx, 1);
      }
    });
    this.previousDragTargets = [];
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event2) {
    let position2 = null;
    if (element === this.hintElem) {
      position2 = {
        x: event2.clientX,
        y: event2.clientY
      };
    } else {
      position2 = {
        x: event2.clientX - this.initialPosition.x + event2.scrollX,
        y: event2.clientY - this.initialPosition.y + event2.scrollY
      };
    }
    return position2;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      const hintCoordinates = {
        x: this.position.x - this.initialPosition.x,
        y: this.position.y - this.initialPosition.y
      };
      return {
        top: `${hintCoordinates.y}px`,
        left: `${hintCoordinates.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform2 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform2,
        transition: "none"
      };
    }
  }
};
DragTargetContainerDirective.ɵfac = function DragTargetContainerDirective_Factory(t) {
  return new (t || DragTargetContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef));
};
DragTargetContainerDirective.ɵdir = ɵɵdefineDirective({
  type: DragTargetContainerDirective,
  selectors: [["", "kendoDragTargetContainer", ""]],
  inputs: {
    hint: "hint",
    dragTargetFilter: "dragTargetFilter",
    dragHandle: "dragHandle",
    dragDelay: "dragDelay",
    threshold: "threshold",
    dragTargetId: "dragTargetId",
    dragData: "dragData",
    dragDisabled: "dragDisabled",
    mode: "mode"
  },
  outputs: {
    onDragReady: "onDragReady",
    onPress: "onPress",
    onDragStart: "onDragStart",
    onDrag: "onDrag",
    onRelease: "onRelease",
    onDragEnd: "onDragEnd"
  },
  exportAs: ["kendoDragTargetContainer"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTargetContainer]",
      exportAs: "kendoDragTargetContainer"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hint: [{
      type: Input
    }],
    dragTargetFilter: [{
      type: Input
    }],
    dragHandle: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    dragDisabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    onDragReady: [{
      type: Output
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }]
  });
})();
var DropTargetContainerDirective = class {
  constructor(service, element, ngZone, cdr) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    this.cdr = cdr;
    this.onDragEnter = new EventEmitter();
    this.onDragOver = new EventEmitter();
    this.onDragLeave = new EventEmitter();
    this.onDrop = new EventEmitter();
    this.currentDropTargetElement = null;
    this.previousDropTargets = [];
    this._dropTargetFilter = null;
    this._dropDisabled = false;
    validatePackage(packageMetadata);
  }
  /**
   * Specifies a selector for elements within a container which will be configured as drop targets
   * ([see example]({% slug drop_target_container %})). The possible values include any
   * DOM `selector`.
   */
  set dropTargetFilter(value2) {
    this._dropTargetFilter = value2;
    if (!this.dropDisabled) {
      this.initializeDropTargets();
    }
  }
  get dropTargetFilter() {
    return this._dropTargetFilter;
  }
  /**
   * Specifies whether the Drop Targets within the container will emit the corresponding events upon interaction with a Drag Target.
   */
  set dropDisabled(value2) {
    this._dropDisabled = value2;
    if (value2) {
      this.clearPreviousTargets();
    } else {
      this.initializeDropTargets();
    }
  }
  get dropDisabled() {
    return this._dropDisabled;
  }
  /**
   * Used for notifying the DropTargetContainer that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDropTargets();
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  ngAfterViewInit() {
    !this.dropDisabled && this.initializeDropTargets();
  }
  get allDropTargets() {
    if (isPresent3(this.dropTargetFilter) && this.dropTargetFilter !== "") {
      return Array.from(this.nativeElement.querySelectorAll(this.dropTargetFilter));
    }
  }
  /**
   * @hidden
   */
  handleDragEnter(event2) {
    if (!this.service.dragTargetPresent || this.service.dropTargetPresent) {
      return;
    }
    const eventTarget = event2.originalEvent.target;
    const currDropTargetElem = intersect2(eventTarget, this.allDropTargets);
    const currDropTarget = this.service.dropTargets.find((dt) => dt.element === currDropTargetElem);
    if (!isPresent3(currDropTargetElem) || !isPresent3(currDropTarget)) {
      return;
    }
    this.currentDropTargetElement = currDropTargetElem;
    this.service.dropTarget = currDropTarget;
    this.service.dropIndex = this.getDropIndex();
    this.emitZoneAwareEvent("onDragEnter", event2);
  }
  /**
   * @hidden
   */
  handleDragLeave(event2) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event2);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  /**
   * @hidden
   */
  handleDragOver(event2) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event2);
  }
  /**
   * @hidden
   */
  handleDrop(event2) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDrop", event2);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  initializeDropTargets() {
    if (!isPresent3(this.allDropTargets)) {
      if (this.previousDropTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDropTargets.forEach((dropTargetEl) => {
      const isDropTargetInitialized = this.service.dropTargets.find((dt) => dt.element === dropTargetEl);
      if (!isDropTargetInitialized) {
        this.service.dropTargets.push({
          element: dropTargetEl,
          onDragEnter: this.handleDragEnter.bind(this),
          onDragLeave: this.handleDragLeave.bind(this),
          onDragOver: this.handleDragOver.bind(this),
          onDrop: this.handleDrop.bind(this)
        });
      }
    });
    if (this.previousDropTargets.length > 0) {
      const dropTargetsToRemove = this.previousDropTargets.filter((dt) => !this.allDropTargets.includes(dt));
      dropTargetsToRemove.forEach((dropTarget) => {
        const idx = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
        if (idx > -1) {
          this.service.dropTargets.splice(idx, 1);
        }
      });
    }
    this.previousDropTargets = this.allDropTargets;
  }
  emitZoneAwareEvent(event2, normalizedEvent) {
    const eventProps = {
      dragTarget: this.service.dragTarget?.element,
      dropTarget: this.currentDropTargetElement,
      dragData: this.service.dragData,
      dragEvent: normalizedEvent,
      dropTargetIndex: this.service.dropIndex
    };
    if (isPresent3(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.hint;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event2].emit(eventArgs);
    });
  }
  getDropIndex() {
    return this.allDropTargets.indexOf(this.currentDropTargetElement);
  }
  clearPreviousTargets() {
    this.previousDropTargets.forEach((dropTarget) => {
      const idx = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
      if (idx > -1) {
        this.service.dropTargets.splice(idx, 1);
      }
    });
    this.previousDropTargets = [];
  }
};
DropTargetContainerDirective.ɵfac = function DropTargetContainerDirective_Factory(t) {
  return new (t || DropTargetContainerDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
};
DropTargetContainerDirective.ɵdir = ɵɵdefineDirective({
  type: DropTargetContainerDirective,
  selectors: [["", "kendoDropTargetContainer", ""]],
  inputs: {
    dropTargetFilter: "dropTargetFilter",
    dropDisabled: "dropDisabled"
  },
  outputs: {
    onDragEnter: "onDragEnter",
    onDragOver: "onDragOver",
    onDragLeave: "onDragLeave",
    onDrop: "onDrop"
  },
  exportAs: ["kendoDropTargetContainer"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTargetContainer]",
      exportAs: "kendoDropTargetContainer"
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    dropTargetFilter: [{
      type: Input
    }],
    dropDisabled: [{
      type: Input
    }],
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var EXPORTS = [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent];
var DragAndDropModule = class {
};
DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {
  return new (t || DragAndDropModule)();
};
DragAndDropModule.ɵmod = ɵɵdefineNgModule({
  type: DragAndDropModule,
  declarations: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent],
  imports: [CommonModule],
  exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent]
});
DragAndDropModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropModule, [{
    type: NgModule,
    args: [{
      declarations: [...EXPORTS],
      exports: [...EXPORTS],
      imports: [CommonModule],
      entryComponents: [HintComponent]
    }]
  }], null, null);
})();
var UtilsModule = class {
};
UtilsModule.ɵfac = function UtilsModule_Factory(t) {
  return new (t || UtilsModule)();
};
UtilsModule.ɵmod = ɵɵdefineNgModule({
  type: UtilsModule,
  exports: [DragAndDropModule]
});
UtilsModule.ɵinj = ɵɵdefineInjector({
  imports: [DragAndDropModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UtilsModule, [{
    type: NgModule,
    args: [{
      exports: [DragAndDropModule]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-file-saver/dist/es/save-as.js
function saveAs(data, fileName, options) {
  if (options === void 0) options = {};
  var save = postToProxy;
  if (options.forceProxy && !options.proxyURL) {
    throw new Error("No proxyURL is set, but forceProxy is true");
  }
  if (!options.forceProxy) {
    if (canDownload()) {
      save = saveAsDataURI;
    }
    if (navigator.msSaveBlob) {
      save = saveAsBlob;
    }
  }
  save(data, fileName, options);
}
var anchor = function() {
  return document.createElement("a");
};
var canDownload = function() {
  return "download" in anchor();
};
function saveAsBlob(data, fileName) {
  var blob2 = data;
  if (typeof data === "string") {
    var parts = data.split(";base64,");
    var contentType = parts[0];
    var base642 = atob(parts[1]);
    var array = new Uint8Array(base642.length);
    for (var idx = 0; idx < base642.length; idx++) {
      array[idx] = base642.charCodeAt(idx);
    }
    blob2 = new Blob([array.buffer], {
      type: contentType
    });
  }
  navigator.msSaveBlob(blob2, fileName);
}
function saveAsDataURI(data, fileName) {
  var dataURI = data;
  if (window.Blob && data instanceof Blob) {
    dataURI = URL.createObjectURL(data);
  }
  var fileSaver = anchor();
  fileSaver.download = fileName;
  fileSaver.href = dataURI;
  var e = document.createEvent("MouseEvents");
  e.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
  fileSaver.dispatchEvent(e);
  setTimeout(function() {
    return URL.revokeObjectURL(dataURI);
  });
}
function postToProxy(dataURI, fileName, options) {
  if (!options.proxyURL) {
    return;
  }
  var form = document.createElement("form");
  form.setAttribute("action", options.proxyURL);
  form.setAttribute("method", "POST");
  form.setAttribute("target", options.proxyTarget || "_self");
  var formData = options.proxyData || {};
  formData.fileName = fileName;
  var parts = dataURI.split(";base64,");
  formData.contentType = parts[0].replace("data:", "");
  formData.base64 = parts[1];
  for (var name in formData) {
    if (formData.hasOwnProperty(name)) {
      var input = document.createElement("input");
      input.setAttribute("type", "hidden");
      input.setAttribute("name", name);
      input.setAttribute("value", formData[name]);
      form.appendChild(input);
    }
  }
  document.body.appendChild(form);
  form.submit();
  document.body.removeChild(form);
}

// node_modules/@progress/kendo-file-saver/dist/es/base64.js
var fromCharCode = String.fromCharCode;

// node_modules/@progress/kendo-angular-pdf-export/fesm2020/progress-kendo-angular-pdf-export.mjs
var _c02 = ["*"];
var packageMetadata2 = {
  name: "@progress/kendo-angular-pdf-export",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1720607840,
  version: "16.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var PDFExportTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
PDFExportTemplateDirective.ɵfac = function PDFExportTemplateDirective_Factory(t) {
  return new (t || PDFExportTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
PDFExportTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: PDFExportTemplateDirective,
  selectors: [["", "kendoPDFTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPDFTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FIELDS = ["bottom", "left", "right", "top"];
var PDFExportMarginComponent = class {
  /**
   * @hidden
   */
  get options() {
    const options = {};
    for (let idx = 0; idx < FIELDS.length; idx++) {
      const field = FIELDS[idx];
      const value2 = this[field];
      if (typeof value2 !== "undefined") {
        options[field] = value2;
      }
    }
    return options;
  }
};
PDFExportMarginComponent.ɵfac = function PDFExportMarginComponent_Factory(t) {
  return new (t || PDFExportMarginComponent)();
};
PDFExportMarginComponent.ɵcmp = ɵɵdefineComponent({
  type: PDFExportMarginComponent,
  selectors: [["kendo-pdf-export-margin"]],
  inputs: {
    left: "left",
    top: "top",
    right: "right",
    bottom: "bottom"
  },
  decls: 0,
  vars: 0,
  template: function PDFExportMarginComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export-margin",
      template: ``
    }]
  }], null, {
    left: [{
      type: Input
    }],
    top: [{
      type: Input
    }],
    right: [{
      type: Input
    }],
    bottom: [{
      type: Input
    }]
  });
})();
var compileTemplate = (templateRef) => {
  const context = {};
  let embeddedView = templateRef.createEmbeddedView(context);
  const result = (data) => {
    Object.assign(context, data);
    embeddedView.detectChanges();
    const templateWrap = document.createElement("span");
    embeddedView.rootNodes.forEach((rootNode) => {
      templateWrap.appendChild(rootNode.cloneNode(true));
    });
    return templateWrap;
  };
  result.destroy = () => {
    embeddedView.destroy();
    embeddedView = null;
  };
  return result;
};
var PDFExportComponent = class {
  constructor(element) {
    this.element = element;
    this.creator = "Kendo UI PDF Generator";
    this.fileName = "export.pdf";
    validatePackage(packageMetadata2);
  }
  get drawMargin() {
    const marginComponent = this.marginComponent;
    let margin = this.margin;
    if (marginComponent) {
      margin = Object.assign(margin || {}, marginComponent.options);
    }
    return margin;
  }
  /**
   * Saves the content as a PDF file with the specified name.
   * @param fileName - The name of the exported file.
   */
  saveAs(fileName = this.fileName) {
    this.save(this.element.nativeElement, fileName);
  }
  /**
   * Exports the content as a `Group` for further processing.
   *
   * @return The root group of the exported scene.
   */
  export() {
    return this.exportElement(this.element.nativeElement);
  }
  save(element, fileName) {
    this.exportElement(element).then((group2) => this.exportGroup(group2, this.pdfOptions())).then((dataUri) => this.saveDataUri(dataUri, fileName, this.saveOptions()));
  }
  exportElement(element) {
    const promise = this.drawElement(element, this.drawOptions());
    const cleanup = this.cleanup.bind(this);
    promise.then(cleanup, cleanup);
    return promise;
  }
  cleanup() {
    if (this.pageTemplate) {
      this.pageTemplate.destroy();
      delete this.pageTemplate;
    }
  }
  drawOptions() {
    if (this.pageTemplateDirective) {
      this.pageTemplate = compileTemplate(this.pageTemplateDirective.templateRef);
    }
    return {
      avoidLinks: this.avoidLinks,
      forcePageBreak: this.forcePageBreak,
      keepTogether: this.keepTogether,
      margin: this.drawMargin,
      paperSize: this.paperSize,
      landscape: this.landscape,
      repeatHeaders: this.repeatHeaders,
      scale: this.scale,
      template: this.pageTemplate
    };
  }
  pdfOptions() {
    return {
      autoPrint: this.autoPrint,
      author: this.author,
      creator: this.creator,
      date: this.date,
      imgDPI: this.imageResolution,
      keywords: this.keywords,
      landscape: this.landscape,
      margin: this.drawMargin,
      multiPage: true,
      paperSize: this.paperSize,
      producer: this.producer,
      subject: this.subject,
      title: this.title
    };
  }
  saveOptions() {
    return {
      forceProxy: this.forceProxy,
      proxyData: this.proxyData,
      proxyTarget: this.proxyTarget,
      proxyURL: this.proxyURL
    };
  }
  drawElement(element, options) {
    return drawDOM(element, options);
  }
  exportGroup(group2, options) {
    return exportPDF(group2, options);
  }
  saveDataUri(dataUri, fileName, options) {
    saveAs(dataUri, fileName, options);
  }
};
PDFExportComponent.ɵfac = function PDFExportComponent_Factory(t) {
  return new (t || PDFExportComponent)(ɵɵdirectiveInject(ElementRef));
};
PDFExportComponent.ɵcmp = ɵɵdefineComponent({
  type: PDFExportComponent,
  selectors: [["kendo-pdf-export"]],
  contentQueries: function PDFExportComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PDFExportTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, PDFExportMarginComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
    }
  },
  inputs: {
    autoPrint: "autoPrint",
    author: "author",
    avoidLinks: "avoidLinks",
    forcePageBreak: "forcePageBreak",
    keepTogether: "keepTogether",
    creator: "creator",
    date: "date",
    imageResolution: "imageResolution",
    fileName: "fileName",
    forceProxy: "forceProxy",
    keywords: "keywords",
    landscape: "landscape",
    margin: "margin",
    paperSize: "paperSize",
    repeatHeaders: "repeatHeaders",
    scale: "scale",
    proxyData: "proxyData",
    proxyURL: "proxyURL",
    proxyTarget: "proxyTarget",
    producer: "producer",
    subject: "subject",
    title: "title"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  template: function PDFExportComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pdf-export",
      template: `<div><ng-content></ng-content></div>`
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    autoPrint: [{
      type: Input
    }],
    author: [{
      type: Input
    }],
    avoidLinks: [{
      type: Input
    }],
    forcePageBreak: [{
      type: Input
    }],
    keepTogether: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    imageResolution: [{
      type: Input
    }],
    fileName: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    keywords: [{
      type: Input
    }],
    landscape: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    paperSize: [{
      type: Input
    }],
    repeatHeaders: [{
      type: Input
    }],
    scale: [{
      type: Input
    }],
    proxyData: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    proxyTarget: [{
      type: Input
    }],
    producer: [{
      type: Input
    }],
    subject: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFExportTemplateDirective, {
        static: false
      }]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFExportMarginComponent, {
        static: false
      }]
    }]
  });
})();
var COMPONENT_DIRECTIVES = [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective];
var PDFExportModule = class {
};
PDFExportModule.ɵfac = function PDFExportModule_Factory(t) {
  return new (t || PDFExportModule)();
};
PDFExportModule.ɵmod = ɵɵdefineNgModule({
  type: PDFExportModule,
  declarations: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective],
  exports: [PDFExportComponent, PDFExportMarginComponent, PDFExportTemplateDirective]
});
PDFExportModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFExportModule, [{
    type: NgModule,
    args: [{
      declarations: [COMPONENT_DIRECTIVES],
      exports: [COMPONENT_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-ooxml/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template) {
  return current.compile(template);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-ooxml/dist/es/utils/getter.js
var FIELD_REGEX2 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache2 = {};
var UNDEFINED = "undefined";
getterCache2[UNDEFINED] = function(obj) {
  return obj;
};
function getter3(field) {
  if (getterCache2[field]) {
    return getterCache2[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX2, function(match, index, indexAccessor, field2) {
    fields.push(typeof index !== UNDEFINED ? index : indexAccessor || field2);
  });
  getterCache2[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache2[field];
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/map.js
function map3(array, func) {
  return array.reduce(function(result, el, i) {
    var val = func(el, i);
    if (val != null) {
      result.push(val);
    }
    return result;
  }, []);
}

// node_modules/@progress/kendo-ooxml/dist/es/excel-exporter.js
function defaultGroupHeaderTemplate(data) {
  return data.title + ": " + data.value;
}
function createArray(length, callback) {
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    result.push(callback(idx));
  }
  return result;
}
function defaultItemId(item) {
  return item.id;
}
var ExcelExporter = function ExcelExporter2(options) {
  options.columns = this._trimColumns(options.columns || []);
  this.allColumns = map3(this._leafColumns(options.columns || []), this._prepareColumn);
  this.columns = this._visibleColumns(this.allColumns);
  this.options = options;
  this.data = options.data || [];
  this.aggregates = options.aggregates || {};
  this.groups = [].concat(options.groups || []);
  this.hasGroups = this.groups.length > 0;
  this.hierarchy = options.hierarchy;
  this.hasGroupHeaderColumn = this.columns.some(function(column) {
    return column.groupHeaderColumnTemplate;
  });
  this.collapsible = this.options.collapsible;
};
ExcelExporter.prototype.workbook = function workbook() {
  var workbook2 = {
    sheets: [{
      columns: this._columns(),
      rows: this.hierarchy ? this._hierarchyRows() : this._rows(),
      freezePane: this._freezePane(),
      filter: this._filter()
    }]
  };
  return workbook2;
};
ExcelExporter.prototype._trimColumns = function _trimColumns(columns) {
  var this$1 = this;
  return columns.filter(function(column) {
    var result = Boolean(column.field);
    if (!result && column.columns) {
      result = this$1._trimColumns(column.columns).length > 0;
    }
    return result;
  });
};
ExcelExporter.prototype._leafColumns = function _leafColumns(columns) {
  var this$1 = this;
  var result = [];
  for (var idx = 0; idx < columns.length; idx++) {
    if (!columns[idx].columns) {
      result.push(columns[idx]);
    } else {
      result = result.concat(this$1._leafColumns(columns[idx].columns));
    }
  }
  return result;
};
ExcelExporter.prototype._prepareColumn = function _prepareColumn(column) {
  if (!column.field) {
    return null;
  }
  var value2 = function(dataItem) {
    return getter3(column.field, true)(dataItem);
  };
  var values = null;
  if (column.values) {
    values = {};
    column.values.forEach(function(item) {
      values[item.value] = item.text;
    });
    value2 = function(dataItem) {
      return values[getter3(column.field, true)(dataItem)];
    };
  }
  return Object.assign({}, column, {
    value: value2,
    values,
    groupHeaderTemplate: column.groupHeaderTemplate ? template_service_default.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,
    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? template_service_default.compile(column.groupHeaderColumnTemplate) : null,
    groupFooterTemplate: column.groupFooterTemplate ? template_service_default.compile(column.groupFooterTemplate) : null,
    footerTemplate: column.footerTemplate ? template_service_default.compile(column.footerTemplate) : null
  });
};
ExcelExporter.prototype._filter = function _filter() {
  if (!this.options.filterable) {
    return null;
  }
  var depth = this._depth();
  return {
    from: depth,
    to: depth + this.columns.length - 1
  };
};
ExcelExporter.prototype._createPaddingCells = function _createPaddingCells(length) {
  var this$1 = this;
  return createArray(length, function() {
    return Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, this$1.options.paddingCellOptions);
  });
};
ExcelExporter.prototype._dataRow = function _dataRow(dataItem, level, depth) {
  var this$1 = this;
  var cells = this._createPaddingCells(level);
  if (this.hasGroups && depth && dataItem.items) {
    cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));
    var rows = this._dataRows(dataItem.items, level + 1);
    rows.unshift({
      type: "group-header",
      cells,
      level: this.collapsible ? level : null
    });
    return rows.concat(this._footer(dataItem, level));
  }
  var dataCells = [];
  for (var cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {
    dataCells[cellIdx] = this$1._cell(dataItem, this$1.columns[cellIdx]);
  }
  if (this.hierarchy) {
    dataCells[0].colSpan = depth - level + 1;
  }
  return [{
    type: "data",
    cells: cells.concat(dataCells),
    level: this.collapsible ? level : null
  }];
};
ExcelExporter.prototype._groupHeaderCells = function _groupHeaderCells(dataItem, level, depth) {
  var cells = [];
  var column = this.allColumns.filter(function(column2) {
    return column2.field === dataItem.field;
  })[0] || {};
  var title = column && column.title ? column.title : dataItem.field;
  var template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;
  var group2 = Object.assign({
    title,
    field: dataItem.field,
    value: column && column.values ? column.values[dataItem.value] : dataItem.value,
    aggregates: dataItem.aggregates,
    items: dataItem.items
  }, dataItem.aggregates[dataItem.field]);
  var value2 = template ? template(group2) : title + ": " + dataItem.value;
  cells.push(Object.assign({
    value: value2,
    background: "#dfdfdf",
    color: "#333",
    colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level
  }, column.groupHeaderCellOptions));
  if (this.hasGroupHeaderColumn) {
    this.columns.forEach(function(column2, index) {
      if (index > 0) {
        cells.push(Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column2.groupHeaderColumnTemplate ? column2.groupHeaderColumnTemplate(Object.assign({
            group: group2
          }, group2, dataItem.aggregates[column2.field])) : void 0
        }, column2.groupHeaderCellOptions));
      }
    });
  }
  return cells;
};
ExcelExporter.prototype._dataRows = function _dataRows(dataItems, level) {
  var this$1 = this;
  var depth = this._depth();
  var rows = [];
  for (var idx = 0; idx < dataItems.length; idx++) {
    rows.push.apply(rows, this$1._dataRow(dataItems[idx], level, depth));
  }
  return rows;
};
ExcelExporter.prototype._hierarchyRows = function _hierarchyRows() {
  var this$1 = this;
  var depth = this._depth();
  var data = this.data;
  var itemLevel = this.hierarchy.itemLevel;
  var itemId = this.hierarchy.itemId || defaultItemId;
  var hasFooter = this._hasFooterTemplate();
  var rows = [];
  var parents = [];
  var previousLevel = 0;
  var previousItemId;
  if (!hasFooter) {
    this.collapsible = false;
  }
  for (var idx = 0; idx < data.length; idx++) {
    var item = data[idx];
    var level = itemLevel(item, idx);
    if (hasFooter) {
      if (level > previousLevel) {
        parents.push({
          id: previousItemId,
          level: previousLevel
        });
      } else if (level < previousLevel) {
        rows.push.apply(rows, this$1._hierarchyFooterRows(parents, level, depth));
      }
      previousLevel = level;
      previousItemId = itemId(item, idx);
    }
    rows.push.apply(rows, this$1._dataRow(item, level + 1, depth));
  }
  if (hasFooter) {
    rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));
    var rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};
    rows.push(this._hierarchyFooter(rootAggregate, 0, depth));
  }
  this._prependHeaderRows(rows);
  return rows;
};
ExcelExporter.prototype._hierarchyFooterRows = function _hierarchyFooterRows(parents, currentLevel, depth) {
  var this$1 = this;
  var rows = [];
  while (parents.length && parents[parents.length - 1].level >= currentLevel) {
    var parent = parents.pop();
    rows.push(this$1._hierarchyFooter(this$1.aggregates[parent.id], parent.level + 1, depth));
  }
  return rows;
};
ExcelExporter.prototype._hasFooterTemplate = function _hasFooterTemplate() {
  var columns = this.columns;
  for (var idx = 0; idx < columns.length; idx++) {
    if (columns[idx].footerTemplate) {
      return true;
    }
  }
};
ExcelExporter.prototype._hierarchyFooter = function _hierarchyFooter(aggregates2, level, depth) {
  var cells = this.columns.map(function(column, index) {
    var colSpan = index ? 1 : depth - level + 1;
    if (column.footerTemplate) {
      var fieldAggregates = (aggregates2 || {})[column.field];
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        colSpan,
        value: column.footerTemplate(Object.assign({
          aggregates: aggregates2
        }, fieldAggregates))
      }, column.footerCellOptions);
    }
    return Object.assign({
      background: "#dfdfdf",
      color: "#333",
      colSpan
    }, column.footerCellOptions);
  });
  return {
    type: "footer",
    cells: this._createPaddingCells(level).concat(cells),
    level: this.collapsible ? level : null
  };
};
ExcelExporter.prototype._footer = function _footer(dataItem, level) {
  var rows = [];
  var footer = this.columns.some(function(column) {
    return column.groupFooterTemplate;
  });
  var templateData, group2;
  if (footer) {
    group2 = {
      group: {
        items: dataItem.items,
        field: dataItem.field,
        value: dataItem.value
      }
    };
    templateData = {};
    Object.keys(dataItem.aggregates).forEach(function(key) {
      templateData[key] = Object.assign({}, dataItem.aggregates[key], group2);
    });
  }
  var cells = this.columns.map(function(column) {
    if (column.groupFooterTemplate) {
      var data = Object.assign({}, templateData, dataItem.aggregates[column.field], group2);
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        value: column.groupFooterTemplate(data)
      }, column.groupFooterCellOptions);
    }
    return Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, column.groupFooterCellOptions);
  });
  if (footer) {
    rows.push({
      type: "group-footer",
      cells: this._createPaddingCells(this.groups.length).concat(cells),
      level: this.collapsible ? level : null
    });
  }
  return rows;
};
ExcelExporter.prototype._isColumnVisible = function _isColumnVisible(column) {
  return this._visibleColumns([column]).length > 0 && (column.field || column.columns);
};
ExcelExporter.prototype._visibleColumns = function _visibleColumns(columns) {
  var this$1 = this;
  return columns.filter(function(column) {
    var exportable = column.exportable;
    if (typeof exportable === "object") {
      exportable = column.exportable.excel;
    }
    var visibleInExport = !column.hidden && exportable !== false;
    var visibleInExportOnly = column.hidden && exportable === true;
    var visible = visibleInExport || visibleInExportOnly;
    if (visible && column.columns) {
      visible = this$1._visibleColumns(column.columns).length > 0;
    }
    return visible;
  });
};
ExcelExporter.prototype._headerRow = function _headerRow(row2, groups) {
  var this$1 = this;
  var headers = row2.cells.map(function(cell2) {
    return Object.assign(cell2, {
      colSpan: cell2.colSpan > 1 ? cell2.colSpan : 1,
      rowSpan: row2.rowSpan > 1 && !cell2.colSpan ? row2.rowSpan : 1
    });
  });
  if (this.hierarchy && headers[0].firstCell) {
    headers[0].colSpan += this._depth();
  }
  return {
    type: "header",
    cells: createArray(groups.length, function() {
      return Object.assign({
        background: "#7a7a7a",
        color: "#fff"
      }, this$1.options.headerPaddingCellOptions);
    }).concat(headers)
  };
};
ExcelExporter.prototype._prependHeaderRows = function _prependHeaderRows(rows) {
  var this$1 = this;
  var groups = this.groups;
  var headerRows = [{
    rowSpan: 1,
    cells: [],
    index: 0
  }];
  this._prepareHeaderRows(headerRows, this.options.columns);
  for (var idx = headerRows.length - 1; idx >= 0; idx--) {
    rows.unshift(this$1._headerRow(headerRows[idx], groups));
  }
};
ExcelExporter.prototype._prepareHeaderRows = function _prepareHeaderRows(rows, columns, parentCell, parentRow) {
  var this$1 = this;
  var row2 = parentRow || rows[rows.length - 1];
  var childRow = rows[row2.index + 1];
  var totalColSpan = 0;
  for (var idx = 0; idx < columns.length; idx++) {
    var column = columns[idx];
    if (this$1._isColumnVisible(column)) {
      var cell2 = Object.assign({
        background: "#7a7a7a",
        color: "#fff",
        value: column.title || column.field,
        colSpan: 0,
        firstCell: idx === 0 && (!parentCell || parentCell.firstCell)
      }, column.headerCellOptions);
      row2.cells.push(cell2);
      if (column.columns && column.columns.length) {
        if (!childRow) {
          childRow = {
            rowSpan: 0,
            cells: [],
            index: rows.length
          };
          rows.push(childRow);
        }
        cell2.colSpan = this$1._trimColumns(this$1._visibleColumns(column.columns)).length;
        this$1._prepareHeaderRows(rows, column.columns, cell2, childRow);
        totalColSpan += cell2.colSpan - 1;
        row2.rowSpan = rows.length - row2.index;
      }
    }
  }
  if (parentCell) {
    parentCell.colSpan += totalColSpan;
  }
};
ExcelExporter.prototype._rows = function _rows() {
  var this$1 = this;
  var rows = this._dataRows(this.data, 0);
  if (this.columns.length) {
    this._prependHeaderRows(rows);
    var footer = false;
    var cells = this.columns.map(function(column) {
      if (column.footerTemplate) {
        footer = true;
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column.footerTemplate(Object.assign({}, this$1.aggregates, this$1.aggregates[column.field]))
        }, column.footerCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333"
      }, column.footerCellOptions);
    });
    if (footer) {
      rows.push({
        type: "footer",
        cells: this._createPaddingCells(this.groups.length).concat(cells)
      });
    }
  }
  return rows;
};
ExcelExporter.prototype._headerDepth = function _headerDepth(columns) {
  var this$1 = this;
  var result = 1;
  var max = 0;
  for (var idx = 0; idx < columns.length; idx++) {
    if (columns[idx].columns) {
      var temp = this$1._headerDepth(columns[idx].columns);
      if (temp > max) {
        max = temp;
      }
    }
  }
  return result + max;
};
ExcelExporter.prototype._freezePane = function _freezePane() {
  var columns = this._visibleColumns(this.options.columns || []);
  var colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function(column) {
    return column.locked;
  })))).length;
  return {
    rowSplit: this._headerDepth(columns),
    colSplit: colSplit ? colSplit + this.groups.length : 0
  };
};
ExcelExporter.prototype._cell = function _cell(dataItem, column) {
  return Object.assign({
    value: column.value(dataItem)
  }, column.cellOptions);
};
ExcelExporter.prototype._depth = function _depth() {
  var depth = 0;
  if (this.hierarchy) {
    depth = this.hierarchy.depth;
  } else {
    depth = this.groups.length;
  }
  return depth;
};
ExcelExporter.prototype._columns = function _columns() {
  var depth = this._depth();
  var columns = createArray(depth, function() {
    return {
      width: 20
    };
  });
  return columns.concat(this.columns.map(function(column) {
    return {
      width: parseInt(column.width, 10),
      autoWidth: column.width ? false : true
    };
  }));
};
var excel_exporter_default = ExcelExporter;

// node_modules/@progress/kendo-ooxml/dist/es/services/intl-service.js
var current2 = {
  toString: function(value2) {
    return value2;
  }
};
var IntlService2 = function IntlService3() {
};
IntlService2.register = function register2(userImplementation) {
  current2 = userImplementation;
};
IntlService2.toString = function toString2(value2, format) {
  return current2.toString(value2, format);
};
var intl_service_default = IntlService2;

// node_modules/@progress/jszip-esm/dist/jszip-esm5.js
var external = {
  Promise
};
var support = {
  base64: true,
  array: true,
  string: true,
  nodebuffer: false,
  nodestream: false,
  get arraybuffer() {
    return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  },
  // Returns true if JSZip can read/generate Uint8Array, false otherwise.
  get uint8array() {
    return typeof Uint8Array !== "undefined";
  },
  get blob() {
    return blob();
  }
};
var blob = function() {
  var supported;
  if (typeof ArrayBuffer === "undefined") {
    supported = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      supported = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      supported = false;
    }
  }
  blob = function() {
    return supported;
  };
  return supported;
};
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var encode = function(input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0, len = input.length, remainingBytes = len;
  var isArray3 = typeof input !== "string";
  while (i < input.length) {
    remainingBytes = len - i;
    if (!isArray3) {
      chr1 = input.charCodeAt(i++);
      chr2 = i < len ? input.charCodeAt(i++) : 0;
      chr3 = i < len ? input.charCodeAt(i++) : 0;
    } else {
      chr1 = input[i++];
      chr2 = i < len ? input[i++] : 0;
      chr3 = i < len ? input[i++] : 0;
    }
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }
  return output.join("");
};
var decode = function(input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0, resultIndex = 0;
  var dataUrlPrefix = "data:";
  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    throw new Error("Invalid base64 input, it looks like a data url.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;
  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (totalLength % 1 !== 0) {
    throw new Error("Invalid base64 input, bad content length.");
  }
  var output;
  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }
  while (i < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i++));
    enc2 = _keyStr.indexOf(input.charAt(i++));
    enc3 = _keyStr.indexOf(input.charAt(i++));
    enc4 = _keyStr.indexOf(input.charAt(i++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;
    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }
    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }
  return output;
};
function string2binary(str) {
  var result = null;
  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }
  return stringToArrayLike(str, result);
}
var newBlob = function(part, type) {
  checkSupport("blob");
  return new Blob([part], {
    type
  });
};
function identity4(input) {
  return input;
}
function stringToArrayLike(str, array) {
  for (var i = 0; i < str.length; ++i) {
    array[i] = str.charCodeAt(i) & 255;
  }
  return array;
}
function stringifyByChunk(array, type, chunk) {
  var result = [], k = 0, len = array.length;
  if (len <= chunk) {
    return String.fromCharCode.apply(null, array);
  }
  while (k < len) {
    if (type === "array") {
      result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
    } else {
      result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
    }
    k += chunk;
  }
  return result.join("");
}
function stringifyByChar(array) {
  var resultStr = "";
  for (var i = 0; i < array.length; i++) {
    resultStr += String.fromCharCode(array[i]);
  }
  return resultStr;
}
var fromCharCodeSupportsTypedArrays = function() {
  var supported;
  try {
    supported = support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
  } catch (e) {
    supported = false;
  }
  fromCharCodeSupportsTypedArrays = function() {
    return supported;
  };
  return supported;
};
function arrayLikeToString(array) {
  var chunk = 65536, type = getTypeOf(array), canUseApply = true;
  if (type === "uint8array") {
    canUseApply = fromCharCodeSupportsTypedArrays();
  }
  if (canUseApply) {
    while (chunk > 1) {
      try {
        return stringifyByChunk(array, type, chunk);
      } catch (e) {
        chunk = Math.floor(chunk / 2);
      }
    }
  }
  return stringifyByChar(array);
}
var applyFromCharCode = arrayLikeToString;
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i = 0; i < arrayFrom.length; i++) {
    arrayTo[i] = arrayFrom[i];
  }
  return arrayTo;
}
var transform = {
  // string to ?
  "string": {
    "string": identity4,
    "array": function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    }
  },
  // array to ?
  "array": {
    "string": arrayLikeToString,
    "array": identity4,
    "arraybuffer": function(input) {
      return new Uint8Array(input).buffer;
    },
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // arraybuffer to ?
  "arraybuffer": {
    "string": function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity4,
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // uint8array to ?
  "uint8array": {
    "string": arrayLikeToString,
    "array": function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return input.buffer;
    },
    "uint8array": identity4
  }
};
var transformTo = function(outputType, input) {
  if (!input) {
    input = "";
  }
  if (!outputType) {
    return input;
  }
  checkSupport(outputType);
  var inputType = getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
var getTypeOf = function(input) {
  if (typeof input === "string") {
    return "string";
  }
  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }
  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }
  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
var checkSupport = function(type) {
  var supported = support[type.toLowerCase()];
  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};
var MAX_VALUE_16BITS = 65535;
var MAX_VALUE_32BITS = -1;
var pretty = function(str) {
  var res = "", code, i;
  for (i = 0; i < (str || "").length; i++) {
    code = str.charCodeAt(i);
    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }
  return res;
};
var delay2 = function(callback, args, self) {
  setTimeout(function() {
    callback.apply(self || null, args || []);
  }, 0);
};
var extend = function() {
  var arguments$1 = arguments;
  var result = {}, i, attr;
  for (i = 0; i < arguments.length; i++) {
    for (attr in arguments[i]) {
      if (Object.hasOwnProperty.call(arguments$1[i], attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments$1[i][attr];
      }
    }
  }
  return result;
};
var prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  var promise = external.Promise.resolve(inputData).then(function(data) {
    var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.onerror = function(e) {
          reject(e.target.error);
        };
        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function(data) {
    var dataType = getTypeOf(data);
    if (!dataType) {
      return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
    }
    if (dataType === "arraybuffer") {
      data = transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = decode(data);
      } else if (isBinary) {
        if (isOptimizedBinaryString !== true) {
          data = string2binary(data);
        }
      }
    }
    return data;
  });
};
var GenericWorker = function GenericWorker2(name) {
  this.name = name || "default";
  this.streamInfo = {};
  this.generatedError = null;
  this.extraStreamInfo = {};
  this.isPaused = true;
  this.isFinished = false;
  this.isLocked = false;
  this._listeners = {
    "data": [],
    "end": [],
    "error": []
  };
  this.previous = null;
};
GenericWorker.prototype.push = function push(chunk) {
  this.emit("data", chunk);
};
GenericWorker.prototype.end = function end() {
  if (this.isFinished) {
    return false;
  }
  this.flush();
  try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
  } catch (e) {
    this.emit("error", e);
  }
  return true;
};
GenericWorker.prototype.error = function error(e) {
  if (this.isFinished) {
    return false;
  }
  if (this.isPaused) {
    this.generatedError = e;
  } else {
    this.isFinished = true;
    this.emit("error", e);
    if (this.previous) {
      this.previous.error(e);
    }
    this.cleanUp();
  }
  return true;
};
GenericWorker.prototype.on = function on(name, listener) {
  this._listeners[name].push(listener);
  return this;
};
GenericWorker.prototype.cleanUp = function cleanUp() {
  this.streamInfo = this.generatedError = this.extraStreamInfo = null;
  this._listeners = [];
};
GenericWorker.prototype.emit = function emit(name, arg) {
  if (this._listeners[name]) {
    for (var i = 0; i < this._listeners[name].length; i++) {
      this._listeners[name][i].call(this, arg);
    }
  }
};
GenericWorker.prototype.pipe = function pipe(next) {
  return next.registerPrevious(this);
};
GenericWorker.prototype.registerPrevious = function registerPrevious(previous) {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.streamInfo = previous.streamInfo;
  this.mergeStreamInfo();
  this.previous = previous;
  var self = this;
  previous.on("data", function(chunk) {
    self.processChunk(chunk);
  });
  previous.on("end", function() {
    self.end();
  });
  previous.on("error", function(e) {
    self.error(e);
  });
  return this;
};
GenericWorker.prototype.pause = function pause() {
  if (this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = true;
  if (this.previous) {
    this.previous.pause();
  }
  return true;
};
GenericWorker.prototype.resume = function resume() {
  if (!this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = false;
  var withError = false;
  if (this.generatedError) {
    this.error(this.generatedError);
    withError = true;
  }
  if (this.previous) {
    this.previous.resume();
  }
  return !withError;
};
GenericWorker.prototype.flush = function flush() {
};
GenericWorker.prototype.processChunk = function processChunk(chunk) {
  this.push(chunk);
};
GenericWorker.prototype.withStreamInfo = function withStreamInfo(key, value2) {
  this.extraStreamInfo[key] = value2;
  this.mergeStreamInfo();
  return this;
};
GenericWorker.prototype.mergeStreamInfo = function mergeStreamInfo() {
  for (var key in this.extraStreamInfo) {
    if (!this.extraStreamInfo.hasOwnProperty(key)) {
      continue;
    }
    this.streamInfo[key] = this.extraStreamInfo[key];
  }
};
GenericWorker.prototype.lock = function lock() {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.isLocked = true;
  if (this.previous) {
    this.previous.lock();
  }
};
GenericWorker.prototype.toString = function toString3() {
  var me = "Worker " + this.name;
  if (this.previous) {
    return this.previous + " -> " + me;
  } else {
    return me;
  }
};
var utf8len = function(c) {
  var _utf8len = new Array(256);
  for (var i = 0; i < 256; i++) {
    _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  utf8len = function(c2) {
    return _utf8len[c2];
  };
  return _utf8len[c];
};
var string2buf = function(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  }
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
};
var buf2string = function(buf) {
  var i, out, c, c_len;
  var len = buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  }
  return applyFromCharCode(utf16buf);
};
var utf8encode = function utf8encode2(str) {
  return string2buf(str);
};
var utf8decode = function utf8decode2(buf) {
  buf = transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
var Utf8DecodeWorker = function(GenericWorker3) {
  function Utf8DecodeWorker2() {
    GenericWorker3.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  if (GenericWorker3) Utf8DecodeWorker2.__proto__ = GenericWorker3;
  Utf8DecodeWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Utf8DecodeWorker2.prototype.constructor = Utf8DecodeWorker2;
  Utf8DecodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    var data = transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker2.prototype.flush = function flush2() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  return Utf8DecodeWorker2;
}(GenericWorker);
var Utf8EncodeWorker = function(GenericWorker3) {
  function Utf8EncodeWorker2() {
    GenericWorker3.call(this, "utf-8 encode");
  }
  if (GenericWorker3) Utf8EncodeWorker2.__proto__ = GenericWorker3;
  Utf8EncodeWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Utf8EncodeWorker2.prototype.constructor = Utf8EncodeWorker2;
  Utf8EncodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  return Utf8EncodeWorker2;
}(GenericWorker);
var ConvertWorker = function(GenericWorker3) {
  function ConvertWorker2(destType) {
    GenericWorker3.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  if (GenericWorker3) ConvertWorker2.__proto__ = GenericWorker3;
  ConvertWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  ConvertWorker2.prototype.constructor = ConvertWorker2;
  ConvertWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  return ConvertWorker2;
}(GenericWorker);
function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return newBlob(transformTo("arraybuffer", content), mimeType);
    case "base64":
      return encode(content);
    default:
      return transformTo(type, content);
  }
}
function concat2(type, dataArray) {
  var i, index = 0, res = null, totalLength = 0;
  for (i = 0; i < dataArray.length; i++) {
    totalLength += dataArray[i].length;
  }
  switch (type) {
    case "string":
      return dataArray.join("");
    case "array":
      return Array.prototype.concat.apply([], dataArray);
    case "uint8array":
      res = new Uint8Array(totalLength);
      for (i = 0; i < dataArray.length; i++) {
        res.set(dataArray[i], index);
        index += dataArray[i].length;
      }
      return res;
    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
function accumulate(helper, updateCallback) {
  return new external.Promise(function(resolve, reject) {
    var dataArray = [];
    var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
    helper.on("data", function(data, meta) {
      dataArray.push(data);
      if (updateCallback) {
        updateCallback(meta);
      }
    }).on("error", function(err) {
      dataArray = [];
      reject(err);
    }).on("end", function() {
      try {
        var result = transformZipOutput(resultType, concat2(chunkType, dataArray), mimeType);
        resolve(result);
      } catch (e) {
        reject(e);
      }
      dataArray = [];
    }).resume();
  });
}
var StreamHelper = function StreamHelper2(worker, outputType, mimeType) {
  var internalType = outputType;
  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;
    case "base64":
      internalType = "string";
      break;
  }
  try {
    this._internalType = internalType;
    this._outputType = outputType;
    this._mimeType = mimeType;
    checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType));
    worker.lock();
  } catch (e) {
    this._worker = new GenericWorker("error");
    this._worker.error(e);
  }
};
StreamHelper.prototype.accumulate = function accumulate$1(updateCb) {
  return accumulate(this, updateCb);
};
StreamHelper.prototype.on = function on2(evt, fn) {
  var self = this;
  if (evt === "data") {
    this._worker.on(evt, function(chunk) {
      fn.call(self, chunk.data, chunk.meta);
    });
  } else {
    this._worker.on(evt, function() {
      delay2(fn, arguments, self);
    });
  }
  return this;
};
StreamHelper.prototype.resume = function resume2() {
  delay2(this._worker.resume, [], this._worker);
  return this;
};
StreamHelper.prototype.pause = function pause2() {
  this._worker.pause();
  return this;
};
var base64 = false;
var binary = false;
var dir = false;
var createFolders = true;
var date = null;
var compression = null;
var compressionOptions = null;
var comment = null;
var unixPermissions = null;
var dosPermissions = null;
var defaults = Object.freeze({
  __proto__: null,
  base64,
  binary,
  dir,
  createFolders,
  date,
  compression,
  compressionOptions,
  comment,
  unixPermissions,
  dosPermissions
});
var DEFAULT_BLOCK_SIZE = 16 * 1024;
var DataWorker = function(GenericWorker3) {
  function DataWorker2(dataP) {
    GenericWorker3.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self.dataIsReady = true;
      self.data = data;
      self.max = data && data.length || 0;
      self.type = getTypeOf(data);
      if (!self.isPaused) {
        self._tickAndRepeat();
      }
    }, function(e) {
      self.error(e);
    });
  }
  if (GenericWorker3) DataWorker2.__proto__ = GenericWorker3;
  DataWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  DataWorker2.prototype.constructor = DataWorker2;
  DataWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      delay2(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker2.prototype._tickAndRepeat = function _tickAndRepeat() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      delay2(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker2.prototype._tick = function _tick() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  return DataWorker2;
}(GenericWorker);
var DataLengthProbe = function(GenericWorker3) {
  function DataLengthProbe2(propName) {
    GenericWorker3.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  if (GenericWorker3) DataLengthProbe2.__proto__ = GenericWorker3;
  DataLengthProbe2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  DataLengthProbe2.prototype.constructor = DataLengthProbe2;
  DataLengthProbe2.prototype.processChunk = function processChunk2(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker3.prototype.processChunk.call(this, chunk);
  };
  return DataLengthProbe2;
}(GenericWorker);
var makeTable = function() {
  var table = [];
  for (var n = 0; n < 256; n++) {
    var c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  makeTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
function crc32str(crc, str, len, pos) {
  var t = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i = pos; i < end2; i++) {
    crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
  }
  return crc ^ -1;
}
function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray3 = getTypeOf(input) !== "string";
  if (isArray3) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
}
var Crc32Probe = function(GenericWorker3) {
  function Crc32Probe2() {
    GenericWorker3.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  if (GenericWorker3) Crc32Probe2.__proto__ = GenericWorker3;
  Crc32Probe2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  Crc32Probe2.prototype.constructor = Crc32Probe2;
  Crc32Probe2.prototype.processChunk = function processChunk2(chunk) {
    this.streamInfo.crc32 = crc32wrapper(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  return Crc32Probe2;
}(GenericWorker);
var CompressedObject = function CompressedObject2(compressedSize, uncompressedSize, crc322, compression2, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc322;
  this.compression = compression2;
  this.compressedContent = data;
};
CompressedObject.prototype.getContentWorker = function getContentWorker() {
  var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
  var that = this;
  worker.on("end", function() {
    if (this.streamInfo["data_length"] !== that.uncompressedSize) {
      throw new Error("Bug : uncompressed data size mismatch");
    }
  });
  return worker;
};
CompressedObject.prototype.getCompressedWorker = function getCompressedWorker() {
  return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
};
CompressedObject.createWorkerFrom = function createWorkerFrom(uncompressedWorker, compression2, compressionOptions2) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression2.compressWorker(compressionOptions2)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression2);
};
var ZipObject = function ZipObject2(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary;
  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};
ZipObject.prototype.internalStream = function internalStream(type) {
  var result = null, outputType = "string";
  try {
    if (!type) {
      throw new Error("No output type specified.");
    }
    outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
      outputType = "string";
    }
    result = this._decompressWorker();
    var isUnicodeString = !this._dataBinary;
    if (isUnicodeString && !askUnicodeString) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    if (!isUnicodeString && askUnicodeString) {
      result = result.pipe(new Utf8DecodeWorker());
    }
  } catch (e) {
    result = new GenericWorker("error");
    result.error(e);
  }
  return new StreamHelper(result, outputType, "");
};
ZipObject.prototype.async = function async(type, onUpdate) {
  return this.internalStream(type).accumulate(onUpdate);
};
ZipObject.prototype._compressWorker = function _compressWorker(compression2, compressionOptions2) {
  if (this._data instanceof CompressedObject && this._data.compression.magic === compression2.magic) {
    return this._data.getCompressedWorker();
  } else {
    var result = this._decompressWorker();
    if (!this._dataBinary) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    return CompressedObject.createWorkerFrom(result, compression2, compressionOptions2);
  }
};
ZipObject.prototype._decompressWorker = function _decompressWorker() {
  if (this._data instanceof CompressedObject) {
    return this._data.getContentWorker();
  } else if (this._data instanceof GenericWorker) {
    return this._data;
  } else {
    return new DataWorker(this._data);
  }
};
var arrayType = function() {
  var useTypedArray = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var resolved = useTypedArray ? "uint8array" : "array";
  arrayType = function() {
    return resolved;
  };
};
var FlateWorker = function(GenericWorker3) {
  function FlateWorker2(action, options) {
    GenericWorker3.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  if (GenericWorker3) FlateWorker2.__proto__ = GenericWorker3;
  FlateWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  FlateWorker2.prototype.constructor = FlateWorker2;
  FlateWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(transformTo(arrayType(), chunk.data), false);
  };
  FlateWorker2.prototype.flush = function flush2() {
    GenericWorker3.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker2.prototype._createPako = function _createPako() {
    var this$1$1 = this;
    var params = {
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    };
    this._pako = this._pakoAction === "Deflate" ? new Deflate(params) : new Inflate(params);
    this._pako.onData = function(data) {
      this$1$1.push({
        data,
        meta: this$1$1.meta
      });
    };
  };
  return FlateWorker2;
}(GenericWorker);
var DEFLATE = {
  magic: "\b\0",
  compressWorker: function(compressionOptions2) {
    return new FlateWorker("Deflate", compressionOptions2);
  },
  uncompressWorker: function() {
    return new FlateWorker("Inflate", {});
  }
};
var STORE = {
  magic: "\0\0",
  compressWorker: function() {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function() {
    return new GenericWorker("STORE decompression");
  }
};
var compressions = {
  STORE,
  DEFLATE
};
var LOCAL_FILE_HEADER = "PK";
var CENTRAL_FILE_HEADER = "PK";
var CENTRAL_DIRECTORY_END = "PK";
var ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
var ZIP64_CENTRAL_DIRECTORY_END = "PK";
var DATA_DESCRIPTOR = "PK\x07\b";
var decToHex = function(dec, bytes) {
  var hex = "", i;
  for (i = 0; i < bytes; i++) {
    hex += String.fromCharCode(dec & 255);
    dec = dec >>> 8;
  }
  return hex;
};
var generateUnixExternalFileAttr = function(unixPermissions2, isDir) {
  var result = unixPermissions2;
  if (!unixPermissions2) {
    result = isDir ? 16893 : 33204;
  }
  return (result & 65535) << 16;
};
var generateDosExternalFileAttr = function(dosPermissions2, isDir) {
  return (dosPermissions2 || 0) & 63;
};
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset2, platform, encodeFileName) {
  var file2 = streamInfo["file"], compression2 = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8encode, encodedFileName = transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = transformTo("string", utf8encode(file2.name)), comment2 = file2.comment, encodedComment = transformTo("string", encodeFileName(comment2)), utfEncodedComment = transformTo("string", utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date2 = file2.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  };
  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo["crc32"];
    dataInfo.compressedSize = streamInfo["compressedSize"];
    dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
  }
  var bitflag = 0;
  if (streamedContent) {
    bitflag |= 8;
  }
  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    bitflag |= 2048;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir2) {
    extFileAttr |= 16;
  }
  if (platform === "UNIX") {
    versionMadeBy = 798;
    extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
  } else {
    versionMadeBy = 20;
    extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
  }
  dosTime = date2.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date2.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date2.getUTCSeconds() / 2;
  dosDate = date2.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date2.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date2.getUTCDate();
  if (useUTF8ForFileName) {
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32wrapper(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "up" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32wrapper(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "uc" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }
  var header = "";
  header += "\n\0";
  header += decToHex(bitflag, 2);
  header += compression2.magic;
  header += decToHex(dosTime, 2);
  header += decToHex(dosDate, 2);
  header += decToHex(dataInfo.crc32, 4);
  header += decToHex(dataInfo.compressedSize, 4);
  header += decToHex(dataInfo.uncompressedSize, 4);
  header += decToHex(encodedFileName.length, 2);
  header += decToHex(extraFields.length, 2);
  var fileRecord = LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\0\0\0\0" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset2, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord,
    dirRecord
  };
};
var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment2, encodeFileName) {
  var dirEnd = "";
  var encodedComment = transformTo("string", encodeFileName(comment2));
  dirEnd = CENTRAL_DIRECTORY_END + // number of this disk
  "\0\0\0\0" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
var generateDataDescriptors = function(streamInfo) {
  var descriptor = "";
  descriptor = DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
  decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo["uncompressedSize"], 4);
  return descriptor;
};
var ZipFileWorker = function(GenericWorker3) {
  function ZipFileWorker2(streamFiles, comment2, platform, encodeFileName) {
    GenericWorker3.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment2;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  if (GenericWorker3) ZipFileWorker2.__proto__ = GenericWorker3;
  ZipFileWorker2.prototype = Object.create(GenericWorker3 && GenericWorker3.prototype);
  ZipFileWorker2.prototype.constructor = ZipFileWorker2;
  ZipFileWorker2.prototype.push = function push2(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker3.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker2.prototype.openedSource = function openedSource(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: {
          percent: 0
        }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker2.prototype.closedSource = function closedSource(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: {
          percent: 100
        }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: {
          percent: 0
        }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker2.prototype.flush = function flush2() {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: {
          percent: 100
        }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: {
        percent: 100
      }
    });
  };
  ZipFileWorker2.prototype.prepareNextSource = function prepareNextSource() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker2.prototype.registerPrevious = function registerPrevious2(previous) {
    this._sources.push(previous);
    var self = this;
    previous.on("data", function(chunk) {
      self.processChunk(chunk);
    });
    previous.on("end", function() {
      self.closedSource(self.previous.streamInfo);
      if (self._sources.length) {
        self.prepareNextSource();
      } else {
        self.end();
      }
    });
    previous.on("error", function(e) {
      self.error(e);
    });
    return this;
  };
  ZipFileWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker2.prototype.error = function error2(e) {
    var sources = this._sources;
    if (!GenericWorker3.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e$1) {
      }
    }
    return true;
  };
  ZipFileWorker2.prototype.lock = function lock2() {
    GenericWorker3.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  return ZipFileWorker2;
}(GenericWorker);
var getCompression = function(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression2 = compressions[compressionName];
  if (!compression2) {
    throw new Error(compressionName + " is not a valid compression method !");
  }
  return compression2;
};
var generateWorker = function(zip3, options, comment2) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment2, options.platform, options.encodeFileName);
  var entriesCount = 0;
  try {
    zip3.forEach(function(relativePath, file2) {
      entriesCount++;
      var compression2 = getCompression(file2.options.compression, options.compression);
      var compressionOptions2 = file2.options.compressionOptions || options.compressionOptions || {};
      var dir2 = file2.dir, date2 = file2.date;
      file2._compressWorker(compression2, compressionOptions2).withStreamInfo("file", {
        name: relativePath,
        dir: dir2,
        date: date2,
        comment: file2.comment || "",
        unixPermissions: file2.unixPermissions,
        dosPermissions: file2.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e) {
    zipFileWorker.error(e);
  }
  return zipFileWorker;
};
var DataReader = function DataReader2(data) {
  this.data = data;
  this.length = data.length;
  this.index = 0;
  this.zero = 0;
};
DataReader.prototype.checkOffset = function checkOffset(offset2) {
  this.checkIndex(this.index + offset2);
};
DataReader.prototype.checkIndex = function checkIndex(newIndex) {
  if (this.length < this.zero + newIndex || newIndex < 0) {
    throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
  }
};
DataReader.prototype.setIndex = function setIndex(newIndex) {
  this.checkIndex(newIndex);
  this.index = newIndex;
};
DataReader.prototype.skip = function skip3(n) {
  this.setIndex(this.index + n);
};
DataReader.prototype.byteAt = function byteAt(i) {
};
DataReader.prototype.readInt = function readInt(size) {
  var result = 0, i;
  this.checkOffset(size);
  for (i = this.index + size - 1; i >= this.index; i--) {
    result = (result << 8) + this.byteAt(i);
  }
  this.index += size;
  return result;
};
DataReader.prototype.readString = function readString(size) {
  return transformTo("string", this.readData(size));
};
DataReader.prototype.readData = function readData(size) {
};
DataReader.prototype.lastIndexOfSignature = function lastIndexOfSignature(sig) {
};
DataReader.prototype.readAndCheckSignature = function readAndCheckSignature(sig) {
};
DataReader.prototype.readDate = function readDate() {
  var dostime = this.readInt(4);
  return new Date(Date.UTC(
    (dostime >> 25 & 127) + 1980,
    // year
    (dostime >> 21 & 15) - 1,
    // month
    dostime >> 16 & 31,
    // day
    dostime >> 11 & 31,
    // hour
    dostime >> 5 & 63,
    // minute
    (dostime & 31) << 1
  ));
};
var ArrayReader = function(DataReader3) {
  function ArrayReader2(data) {
    DataReader3.call(this, data);
    for (var i = 0; i < this.data.length; i++) {
      data[i] = data[i] & 255;
    }
  }
  if (DataReader3) ArrayReader2.__proto__ = DataReader3;
  ArrayReader2.prototype = Object.create(DataReader3 && DataReader3.prototype);
  ArrayReader2.prototype.constructor = ArrayReader2;
  ArrayReader2.prototype.byteAt = function byteAt2(i) {
    return this.data[this.zero + i];
  };
  ArrayReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return ArrayReader2;
}(DataReader);
var StringReader = function(DataReader3) {
  function StringReader2(data) {
    DataReader3.call(this, data);
  }
  if (DataReader3) StringReader2.__proto__ = DataReader3;
  StringReader2.prototype = Object.create(DataReader3 && DataReader3.prototype);
  StringReader2.prototype.constructor = StringReader2;
  StringReader2.prototype.byteAt = function byteAt2(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return StringReader2;
}(DataReader);
var Uint8ArrayReader = function(ArrayReader2) {
  function Uint8ArrayReader2(data) {
    ArrayReader2.call(this, data);
  }
  if (ArrayReader2) Uint8ArrayReader2.__proto__ = ArrayReader2;
  Uint8ArrayReader2.prototype = Object.create(ArrayReader2 && ArrayReader2.prototype);
  Uint8ArrayReader2.prototype.constructor = Uint8ArrayReader2;
  Uint8ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return Uint8ArrayReader2;
}(ArrayReader);
function readerFor(data) {
  var type = getTypeOf(data);
  checkSupport(type);
  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }
  if (support.uint8array) {
    return new Uint8ArrayReader(transformTo("uint8array", data));
  }
  return new ArrayReader(transformTo("array", data));
}
var MADE_BY_DOS = 0;
var MADE_BY_UNIX = 3;
var findCompression = function(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }
    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }
  return null;
};
var ZipEntry = function ZipEntry2(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
};
ZipEntry.prototype.isEncrypted = function isEncrypted() {
  return (this.bitFlag & 1) === 1;
};
ZipEntry.prototype.useUTF8 = function useUTF8() {
  return (this.bitFlag & 2048) === 2048;
};
ZipEntry.prototype.readLocalPart = function readLocalPart(reader) {
  var compression2, localExtraFieldsLength;
  reader.skip(22);
  this.fileNameLength = reader.readInt(2);
  localExtraFieldsLength = reader.readInt(2);
  this.fileName = reader.readData(this.fileNameLength);
  reader.skip(localExtraFieldsLength);
  if (this.compressedSize === -1 || this.uncompressedSize === -1) {
    throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
  }
  compression2 = findCompression(this.compressionMethod);
  if (compression2 === null) {
    throw new Error("Corrupted zip : compression " + pretty(this.compressionMethod) + " unknown (inner file : " + transformTo("string", this.fileName) + ")");
  }
  this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression2, reader.readData(this.compressedSize));
};
ZipEntry.prototype.readCentralPart = function readCentralPart(reader) {
  this.versionMadeBy = reader.readInt(2);
  reader.skip(2);
  this.bitFlag = reader.readInt(2);
  this.compressionMethod = reader.readString(2);
  this.date = reader.readDate();
  this.crc32 = reader.readInt(4);
  this.compressedSize = reader.readInt(4);
  this.uncompressedSize = reader.readInt(4);
  var fileNameLength = reader.readInt(2);
  this.extraFieldsLength = reader.readInt(2);
  this.fileCommentLength = reader.readInt(2);
  this.diskNumberStart = reader.readInt(2);
  this.internalFileAttributes = reader.readInt(2);
  this.externalFileAttributes = reader.readInt(4);
  this.localHeaderOffset = reader.readInt(4);
  if (this.isEncrypted()) {
    throw new Error("Encrypted zip are not supported");
  }
  reader.skip(fileNameLength);
  this.readExtraFields(reader);
  this.parseZIP64ExtraField(reader);
  this.fileComment = reader.readData(this.fileCommentLength);
};
ZipEntry.prototype.processAttributes = function processAttributes() {
  this.unixPermissions = null;
  this.dosPermissions = null;
  var madeBy = this.versionMadeBy >> 8;
  this.dir = this.externalFileAttributes & 16 ? true : false;
  if (madeBy === MADE_BY_DOS) {
    this.dosPermissions = this.externalFileAttributes & 63;
  }
  if (madeBy === MADE_BY_UNIX) {
    this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
  }
  if (!this.dir && this.fileNameStr.slice(-1) === "/") {
    this.dir = true;
  }
};
ZipEntry.prototype.parseZIP64ExtraField = function parseZIP64ExtraField(reader) {
  if (!this.extraFields[1]) {
    return;
  }
  var extraReader = readerFor(this.extraFields[1].value);
  if (this.uncompressedSize === MAX_VALUE_32BITS) {
    this.uncompressedSize = extraReader.readInt(8);
  }
  if (this.compressedSize === MAX_VALUE_32BITS) {
    this.compressedSize = extraReader.readInt(8);
  }
  if (this.localHeaderOffset === MAX_VALUE_32BITS) {
    this.localHeaderOffset = extraReader.readInt(8);
  }
  if (this.diskNumberStart === MAX_VALUE_32BITS) {
    this.diskNumberStart = extraReader.readInt(4);
  }
};
ZipEntry.prototype.readExtraFields = function readExtraFields(reader) {
  var end2 = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
  if (!this.extraFields) {
    this.extraFields = {};
  }
  while (reader.index < end2) {
    extraFieldId = reader.readInt(2);
    extraFieldLength = reader.readInt(2);
    extraFieldValue = reader.readData(extraFieldLength);
    this.extraFields[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntry.prototype.handleUTF8 = function handleUTF8() {
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  if (this.useUTF8()) {
    this.fileNameStr = utf8decode(this.fileName);
    this.fileCommentStr = utf8decode(this.fileComment);
  } else {
    var upath = this.findExtraFieldUnicodePath();
    if (upath !== null) {
      this.fileNameStr = upath;
    } else {
      var fileNameByteArray = transformTo(decodeParamType, this.fileName);
      this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
    }
    var ucomment = this.findExtraFieldUnicodeComment();
    if (ucomment !== null) {
      this.fileCommentStr = ucomment;
    } else {
      var commentByteArray = transformTo(decodeParamType, this.fileComment);
      this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
    }
  }
};
ZipEntry.prototype.findExtraFieldUnicodePath = function findExtraFieldUnicodePath() {
  var upathField = this.extraFields[28789];
  if (upathField) {
    var extraReader = readerFor(upathField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileName) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(upathField.length - 5));
  }
  return null;
};
ZipEntry.prototype.findExtraFieldUnicodeComment = function findExtraFieldUnicodeComment() {
  var ucommentField = this.extraFields[25461];
  if (ucommentField) {
    var extraReader = readerFor(ucommentField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileComment) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(ucommentField.length - 5));
  }
  return null;
};
var ZipEntries = function ZipEntries2(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
};
ZipEntries.prototype.checkSignature = function checkSignature(expectedSignature) {
  if (!this.reader.readAndCheckSignature(expectedSignature)) {
    this.reader.index -= 4;
    var signature = this.reader.readString(4);
    throw new Error("Corrupted zip or bug: unexpected signature (" + pretty(signature) + ", expected " + pretty(expectedSignature) + ")");
  }
};
ZipEntries.prototype.isSignature = function isSignature(askedIndex, expectedSignature) {
  var currentIndex = this.reader.index;
  this.reader.setIndex(askedIndex);
  var signature = this.reader.readString(4);
  var result = signature === expectedSignature;
  this.reader.setIndex(currentIndex);
  return result;
};
ZipEntries.prototype.readBlockEndOfCentral = function readBlockEndOfCentral() {
  this.diskNumber = this.reader.readInt(2);
  this.diskWithCentralDirStart = this.reader.readInt(2);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
  this.centralDirRecords = this.reader.readInt(2);
  this.centralDirSize = this.reader.readInt(4);
  this.centralDirOffset = this.reader.readInt(4);
  this.zipCommentLength = this.reader.readInt(2);
  var zipComment = this.reader.readData(this.zipCommentLength);
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  var decodeContent = transformTo(decodeParamType, zipComment);
  this.zipComment = this.loadOptions.decodeFileName(decodeContent);
};
ZipEntries.prototype.readBlockZip64EndOfCentral = function readBlockZip64EndOfCentral() {
  this.zip64EndOfCentralSize = this.reader.readInt(8);
  this.reader.skip(4);
  this.diskNumber = this.reader.readInt(4);
  this.diskWithCentralDirStart = this.reader.readInt(4);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
  this.centralDirRecords = this.reader.readInt(8);
  this.centralDirSize = this.reader.readInt(8);
  this.centralDirOffset = this.reader.readInt(8);
  this.zip64ExtensibleData = {};
  var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
  while (index < extraDataSize) {
    extraFieldId = this.reader.readInt(2);
    extraFieldLength = this.reader.readInt(4);
    extraFieldValue = this.reader.readData(extraFieldLength);
    this.zip64ExtensibleData[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntries.prototype.readBlockZip64EndOfCentralLocator = function readBlockZip64EndOfCentralLocator() {
  this.diskWithZip64CentralDirStart = this.reader.readInt(4);
  this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
  this.disksCount = this.reader.readInt(4);
  if (this.disksCount > 1) {
    throw new Error("Multi-volumes zip are not supported");
  }
};
ZipEntries.prototype.readLocalFiles = function readLocalFiles() {
  var i, file2;
  for (i = 0; i < this.files.length; i++) {
    file2 = this.files[i];
    this.reader.setIndex(file2.localHeaderOffset);
    this.checkSignature(LOCAL_FILE_HEADER);
    file2.readLocalPart(this.reader);
    file2.handleUTF8();
    file2.processAttributes();
  }
};
ZipEntries.prototype.readCentralDir = function readCentralDir() {
  var file2;
  this.reader.setIndex(this.centralDirOffset);
  while (this.reader.readAndCheckSignature(CENTRAL_FILE_HEADER)) {
    file2 = new ZipEntry({
      zip64: this.zip64
    }, this.loadOptions);
    file2.readCentralPart(this.reader);
    this.files.push(file2);
  }
  if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 && this.files.length === 0) {
      throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
    }
  }
};
ZipEntries.prototype.readEndOfCentral = function readEndOfCentral() {
  var offset2 = this.reader.lastIndexOfSignature(CENTRAL_DIRECTORY_END);
  if (offset2 < 0) {
    var isGarbage = !this.isSignature(0, LOCAL_FILE_HEADER);
    if (isGarbage) {
      throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
    } else {
      throw new Error("Corrupted zip: can't find end of central directory");
    }
  }
  this.reader.setIndex(offset2);
  var endOfCentralDirOffset = offset2;
  this.checkSignature(CENTRAL_DIRECTORY_END);
  this.readBlockEndOfCentral();
  if (this.diskNumber === MAX_VALUE_16BITS || this.diskWithCentralDirStart === MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS || this.centralDirRecords === MAX_VALUE_16BITS || this.centralDirSize === MAX_VALUE_32BITS || this.centralDirOffset === MAX_VALUE_32BITS) {
    this.zip64 = true;
    offset2 = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    if (offset2 < 0) {
      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
    }
    this.reader.setIndex(offset2);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    this.readBlockZip64EndOfCentralLocator();
    if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, ZIP64_CENTRAL_DIRECTORY_END)) {
      this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_END);
      if (this.relativeOffsetEndOfZip64CentralDir < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
      }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_END);
    this.readBlockZip64EndOfCentral();
  }
  var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
  if (this.zip64) {
    expectedEndOfCentralDirOffset += 20;
    expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
  }
  var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
  if (extraBytes > 0) {
    if (this.isSignature(endOfCentralDirOffset, CENTRAL_FILE_HEADER)) ;
    else {
      this.reader.zero = extraBytes;
    }
  } else if (extraBytes < 0) {
    throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
  }
};
ZipEntries.prototype.prepareReader = function prepareReader(data) {
  this.reader = readerFor(data);
};
ZipEntries.prototype.load = function load(data) {
  this.prepareReader(data);
  this.readEndOfCentral();
  this.readCentralDir();
  this.readLocalFiles();
};
function checkEntryCRC32(zipEntry) {
  return new external.Promise(function(resolve, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function(e) {
      reject(e);
    }).on("end", function() {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve();
      }
    }).resume();
  });
}
function load2(data, options) {
  var zip3 = this;
  options = extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8decode
  });
  return prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data2);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
      for (var i = 0; i < files.length; i++) {
        promises.push(checkEntryCRC32(files[i]));
      }
    }
    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;
    for (var i = 0; i < files.length; i++) {
      var input = files[i];
      zip3.file(input.fileNameStr, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
    }
    if (zipEntries.zipComment.length) {
      zip3.comment = zipEntries.zipComment;
    }
    return zip3;
  });
}
var fileAdd = function(name, data, originalOptions) {
  var dataType = getTypeOf(data), parent;
  var o = extend(originalOptions || {}, defaults);
  o.date = o.date || /* @__PURE__ */ new Date();
  if (o.compression !== null) {
    o.compression = o.compression.toUpperCase();
  }
  if (typeof o.unixPermissions === "string") {
    o.unixPermissions = parseInt(o.unixPermissions, 8);
  }
  if (o.unixPermissions && o.unixPermissions & 16384) {
    o.dir = true;
  }
  if (o.dosPermissions && o.dosPermissions & 16) {
    o.dir = true;
  }
  if (o.dir) {
    name = forceTrailingSlash(name);
  }
  if (o.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }
  var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o.binary = !isUnicodeString;
  }
  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
  if (isCompressedEmpty || o.dir || !data || data.length === 0) {
    o.base64 = false;
    o.binary = true;
    data = "";
    o.compression = "STORE";
    dataType = "string";
  }
  var zipObjectContent = null;
  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else {
    zipObjectContent = prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
  }
  var object = new ZipObject(name, zipObjectContent, o);
  this.files[name] = object;
};
var parentFolder = function(path) {
  if (path.slice(-1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  var lastSlash = path.lastIndexOf("/");
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
var forceTrailingSlash = function(path) {
  if (path.slice(-1) !== "/") {
    path += "/";
  }
  return path;
};
var folderAdd = function(name, createFolders$1) {
  createFolders$1 = typeof createFolders$1 !== "undefined" ? createFolders$1 : createFolders;
  name = forceTrailingSlash(name);
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders$1
    });
  }
  return this.files[name];
};
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var JSZip = function JSZip2() {
  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  }
  this.files = /* @__PURE__ */ Object.create(null);
  this.comment = null;
  this.root = "";
  this.clone = function() {
    var newObj = new JSZip2();
    for (var i in this) {
      if (typeof this[i] !== "function") {
        newObj[i] = this[i];
      }
    }
    return newObj;
  };
};
var staticAccessors = {
  support: {
    configurable: true
  },
  defaults: {
    configurable: true
  },
  version: {
    configurable: true
  },
  external: {
    configurable: true
  }
};
JSZip.prototype.load = function load3() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.forEach = function forEach(cb) {
  var filename, relativePath, file2;
  for (filename in this.files) {
    file2 = this.files[filename];
    relativePath = filename.slice(this.root.length, filename.length);
    if (relativePath && filename.slice(0, this.root.length) === this.root) {
      cb(relativePath, file2);
    }
  }
};
JSZip.prototype.filter = function filter3(search) {
  var result = [];
  this.forEach(function(relativePath, entry) {
    if (search(relativePath, entry)) {
      result.push(entry);
    }
  });
  return result;
};
JSZip.prototype.file = function file(name, data, o) {
  if (arguments.length === 1) {
    if (isRegExp(name)) {
      var regexp = name;
      return this.filter(function(relativePath, file2) {
        return !file2.dir && regexp.test(relativePath);
      });
    } else {
      var obj = this.files[this.root + name];
      if (obj && !obj.dir) {
        return obj;
      } else {
        return null;
      }
    }
  } else {
    name = this.root + name;
    fileAdd.call(this, name, data, o);
  }
  return this;
};
JSZip.prototype.folder = function folder(arg) {
  if (!arg) {
    return this;
  }
  if (isRegExp(arg)) {
    return this.filter(function(relativePath, file2) {
      return file2.dir && arg.test(relativePath);
    });
  }
  var name = this.root + arg;
  var newFolder = folderAdd.call(this, name);
  var ret = this.clone();
  ret.root = newFolder.name;
  return ret;
};
JSZip.prototype.remove = function remove(name) {
  name = this.root + name;
  var file2 = this.files[name];
  if (!file2) {
    if (name.slice(-1) !== "/") {
      name += "/";
    }
    file2 = this.files[name];
  }
  if (file2 && !file2.dir) {
    delete this.files[name];
  } else {
    var kids = this.filter(function(relativePath, file3) {
      return file3.name.slice(0, name.length) === name;
    });
    for (var i = 0; i < kids.length; i++) {
      delete this.files[kids[i].name];
    }
  }
  return this;
};
JSZip.prototype.generate = function generate(options) {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.generateInternalStream = function generateInternalStream(options) {
  var worker, opts = {};
  try {
    opts = extend(options || {}, {
      streamFiles: false,
      compression: "STORE",
      compressionOptions: null,
      type: "",
      platform: "DOS",
      comment: null,
      mimeType: "application/zip",
      encodeFileName: utf8encode
    });
    opts.type = opts.type.toLowerCase();
    opts.compression = opts.compression.toUpperCase();
    if (opts.type === "binarystring") {
      opts.type = "string";
    }
    if (!opts.type) {
      throw new Error("No output type specified.");
    }
    checkSupport(opts.type);
    if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
      opts.platform = "UNIX";
    }
    if (opts.platform === "win32") {
      opts.platform = "DOS";
    }
    var comment2 = opts.comment || this.comment || "";
    worker = generateWorker(this, opts, comment2);
  } catch (e) {
    worker = new GenericWorker("error");
    worker.error(e);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
};
JSZip.prototype.generateAsync = function generateAsync(options, onUpdate) {
  return this.generateInternalStream(options).accumulate(onUpdate);
};
JSZip.prototype.loadAsync = function loadAsync(data, options) {
  return load2.apply(this, [data, options]);
};
JSZip.loadAsync = function loadAsync2(content, options) {
  return new JSZip().loadAsync(content, options);
};
staticAccessors.support.get = function() {
  return support;
};
staticAccessors.defaults.get = function() {
  return defaults;
};
staticAccessors.version.get = function() {
  return "3.2.2-esm";
};
staticAccessors.external.get = function() {
  return external;
};
Object.defineProperties(JSZip, staticAccessors);

// node_modules/@progress/kendo-ooxml/dist/es/utils/create-zip.js
function createZip() {
  return new JSZip();
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/time.js
function dateToJulianDays(y, m, d) {
  return (1461 * (y + 4800 + ((m - 13) / 12 | 0)) / 4 | 0) + (367 * (m - 1 - 12 * ((m - 13) / 12 | 0)) / 12 | 0) - (3 * ((y + 4900 + ((m - 13) / 12 | 0)) / 100 | 0) / 4 | 0) + d - 32075;
}
var BASE_DATE = dateToJulianDays(1900, 0, -1);
function packDate(year, month, date2) {
  return dateToJulianDays(year, month, date2) - BASE_DATE;
}
function packTime(hh, mm, ss, ms) {
  return (hh + (mm + (ss + ms / 1e3) / 60) / 60) / 24;
}
function dateToSerial(date2) {
  var time = packTime(date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds());
  var serial = packDate(date2.getFullYear(), date2.getMonth(), date2.getDate());
  return serial < 0 ? serial - 1 + time : serial + time;
}

// node_modules/@progress/kendo-ooxml/dist/es/ooxml.js
var MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
var DATA_URL_PREFIX = "data:" + MIME_TYPE + ";base64,";
var DATA_URL_OPTIONS = {
  compression: "DEFLATE",
  type: "base64"
};
var BLOB_OPTIONS = {
  compression: "DEFLATE",
  type: "blob"
};
var ARRAYBUFFER_OPTIONS = {
  compression: "DEFLATE",
  type: "arraybuffer"
};
function toDataURI(content) {
  return DATA_URL_PREFIX + content;
}
function indexOf(thing, array) {
  return array.indexOf(thing);
}
var parseJSON = JSON.parse.bind(JSON);
function ESC(val) {
  return String(val).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;");
}
function repeat(count3, func) {
  var str = "";
  for (var i = 0; i < count3; ++i) {
    str += func(i);
  }
  return str;
}
function foreach(arr, func) {
  var str = "";
  if (arr != null) {
    if (Array.isArray(arr)) {
      for (var i = 0; i < arr.length; ++i) {
        str += func(arr[i], i);
      }
    } else if (typeof arr == "object") {
      Object.keys(arr).forEach(function(key, i2) {
        str += func(arr[key], key, i2);
      });
    }
  }
  return str;
}
var XMLHEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r';
var RELS = XMLHEAD + '\n            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n               <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>\n               <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>\n               <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>\n            </Relationships>';
var CORE = function(ref2) {
  var creator = ref2.creator;
  var lastModifiedBy = ref2.lastModifiedBy;
  var created = ref2.created;
  var modified = ref2.modified;
  return XMLHEAD + '\n <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"\n   xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"\n   xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n   <dc:creator>' + ESC(creator) + "</dc:creator>\n   <cp:lastModifiedBy>" + ESC(lastModifiedBy) + '</cp:lastModifiedBy>\n   <dcterms:created xsi:type="dcterms:W3CDTF">' + ESC(created) + '</dcterms:created>\n   <dcterms:modified xsi:type="dcterms:W3CDTF">' + ESC(modified) + "</dcterms:modified>\n</cp:coreProperties>";
};
var APP = function(ref2) {
  var sheets = ref2.sheets;
  return XMLHEAD + '\n<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">\n  <Application>Microsoft Excel</Application>\n  <DocSecurity>0</DocSecurity>\n  <ScaleCrop>false</ScaleCrop>\n  <HeadingPairs>\n    <vt:vector size="2" baseType="variant">\n      <vt:variant>\n        <vt:lpstr>Worksheets</vt:lpstr>\n      </vt:variant>\n      <vt:variant>\n        <vt:i4>' + sheets.length + '</vt:i4>\n      </vt:variant>\n    </vt:vector>\n  </HeadingPairs>\n  <TitlesOfParts>\n    <vt:vector size="' + sheets.length + '" baseType="lpstr">' + foreach(sheets, function(sheet, i) {
    return sheet.options.title ? "<vt:lpstr>" + ESC(sheet.options.title) + "</vt:lpstr>" : "<vt:lpstr>Sheet" + (i + 1) + "</vt:lpstr>";
  }) + "</vt:vector>\n  </TitlesOfParts>\n  <LinksUpToDate>false</LinksUpToDate>\n  <SharedDoc>false</SharedDoc>\n  <HyperlinksChanged>false</HyperlinksChanged>\n  <AppVersion>14.0300</AppVersion>\n</Properties>";
};
var CONTENT_TYPES = function(ref2) {
  var sheetCount = ref2.sheetCount;
  var commentFiles = ref2.commentFiles;
  var drawingFiles = ref2.drawingFiles;
  return XMLHEAD + '\n<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">\n  <Default Extension="png" ContentType="image/png"/>\n  <Default Extension="gif" ContentType="image/gif"/>\n  <Default Extension="jpg" ContentType="image/jpeg"/>\n  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />\n  <Default Extension="xml" ContentType="application/xml" />\n  <Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>\n  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />\n  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>\n  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>\n  ' + repeat(sheetCount, function(idx) {
    return '<Override PartName="/xl/worksheets/sheet' + (idx + 1) + '.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />';
  }) + "\n  " + foreach(commentFiles, function(filename) {
    return '<Override PartName="/xl/' + filename + '" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"/>';
  }) + "\n  " + foreach(drawingFiles, function(filename) {
    return '<Override PartName="/xl/drawings/' + filename + '" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>';
  }) + '\n  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />\n  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />\n</Types>';
};
var WORKBOOK = function(ref2) {
  var sheets = ref2.sheets;
  var filterNames = ref2.filterNames;
  var userNames = ref2.userNames;
  return XMLHEAD + '\n<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">\n  <fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="9303" />\n  <workbookPr defaultThemeVersion="124226" />\n  <bookViews>\n    <workbookView xWindow="240" yWindow="45" windowWidth="18195" windowHeight="7995" />\n  </bookViews>\n  <sheets>\n  ' + foreach(sheets, function(ref3, i) {
    var options = ref3.options;
    var name = options.name || options.title || "Sheet" + (i + 1);
    var state2 = options.state || "visible";
    return '<sheet name="' + ESC(name) + '" state="' + state2 + '" sheetId="' + (i + 1) + '" r:id="rId' + (i + 1) + '" />';
  }) + "\n  </sheets>\n  " + (filterNames.length || userNames.length ? "\n    <definedNames>\n      " + foreach(filterNames, function(f) {
    return '\n         <definedName name="_xlnm._FilterDatabase" hidden="1" localSheetId="' + f.localSheetId + '">' + ESC(quoteSheet(f.name)) + "!" + ESC(f.from) + ":" + ESC(f.to) + "</definedName>";
  }) + "\n      " + foreach(userNames, function(f) {
    return '\n         <definedName name="' + f.name + '" hidden="' + (f.hidden ? 1 : 0) + '" ' + (f.localSheetId != null ? 'localSheetId="' + f.localSheetId + '"' : "") + ">" + ESC(f.value) + "</definedName>";
  }) + "\n    </definedNames>" : "") + '\n  <calcPr fullCalcOnLoad="1" calcId="145621" />\n</workbook>';
};
var WORKSHEET = function(ref$1) {
  var frozenColumns = ref$1.frozenColumns;
  var frozenRows = ref$1.frozenRows;
  var columns = ref$1.columns;
  var defaults2 = ref$1.defaults;
  var data = ref$1.data;
  var index = ref$1.index;
  var mergeCells = ref$1.mergeCells;
  var autoFilter = ref$1.autoFilter;
  var filter4 = ref$1.filter;
  var showGridLines = ref$1.showGridLines;
  var hyperlinks = ref$1.hyperlinks;
  var validations = ref$1.validations;
  var defaultCellStyleId = ref$1.defaultCellStyleId;
  var rtl = ref$1.rtl;
  var legacyDrawing2 = ref$1.legacyDrawing;
  var drawing = ref$1.drawing;
  var lastRow = ref$1.lastRow;
  var lastCol = ref$1.lastCol;
  var hasDisabledCells = ref$1.hasDisabledCells;
  return XMLHEAD + '\n<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" mc:Ignorable="x14ac">\n   ' + (lastRow && lastCol ? '<dimension ref="A1:' + ref(lastRow - 1, lastCol - 1) + '" />' : "") + "\n\n   <sheetViews>\n     <sheetView " + (rtl ? 'rightToLeft="1"' : "") + " " + (index === 0 ? 'tabSelected="1"' : "") + ' workbookViewId="0" ' + (showGridLines === false ? 'showGridLines="0"' : "") + ">\n     " + (frozenRows || frozenColumns ? '\n       <pane state="frozen"\n         ' + (frozenColumns ? 'xSplit="' + frozenColumns + '"' : "") + "\n         " + (frozenRows ? 'ySplit="' + frozenRows + '"' : "") + '\n         topLeftCell="' + (String.fromCharCode(65 + (frozenColumns || 0)) + ((frozenRows || 0) + 1)) + '"\n       />' : "") + '\n     </sheetView>\n   </sheetViews>\n\n   <sheetFormatPr x14ac:dyDescent="0.25" ' + (!defaults2.skipCustomHeight ? 'customHeight="1"' : "") + ' defaultRowHeight="' + (defaults2.rowHeight ? defaults2.rowHeight * 0.75 : 15) + '"\n     ' + (defaults2.columnWidth ? 'defaultColWidth="' + toWidth(defaults2.columnWidth) + '"' : "") + " />\n\n   " + (defaultCellStyleId != null || columns && columns.length > 0 ? "\n     <cols>\n       " + (!columns || !columns.length ? '\n         <col min="1" max="16384" style="' + defaultCellStyleId + '"\n              ' + (defaults2.columnWidth ? 'width="' + toWidth(defaults2.columnWidth) + '"' : "") + " /> " : "") + "\n       " + foreach(columns, function(column, ci) {
    var columnIndex = typeof column.index === "number" ? column.index + 1 : ci + 1;
    if (column.width === 0) {
      return "<col " + (defaultCellStyleId != null ? 'style="' + defaultCellStyleId + '"' : "") + '\n                        min="' + columnIndex + '" max="' + columnIndex + '" hidden="1" customWidth="1" />';
    }
    return "<col " + (defaultCellStyleId != null ? 'style="' + defaultCellStyleId + '"' : "") + '\n                      min="' + columnIndex + '" max="' + columnIndex + '" customWidth="1"\n                      ' + (column.autoWidth ? 'width="' + (column.width * 7 + 5) / 7 * 256 / 256 + '" bestFit="1"' : 'width="' + toWidth(column.width) + '"') + " />";
  }) + "\n     </cols>" : "") + "\n\n   <sheetData>\n     " + foreach(data, function(row2, ri) {
    var rowIndex = typeof row2.index === "number" ? row2.index + 1 : ri + 1;
    return '\n         <row r="' + rowIndex + '" x14ac:dyDescent="0.25"\n              ' + (row2.level ? 'outlineLevel="' + row2.level + '"' : "") + "\n              " + (row2.height === 0 ? 'hidden="1"' : row2.height ? 'ht="' + toHeight(row2.height) + '" customHeight="1"' : "") + ">\n           " + foreach(row2.data, function(cell2) {
      return '\n             <c r="' + cell2.ref + '" ' + (cell2.style ? 's="' + cell2.style + '"' : "") + " " + (cell2.type ? 't="' + cell2.type + '"' : "") + ">\n               " + (cell2.formula != null ? writeFormula(cell2.formula) : "") + "\n               " + (cell2.value != null ? "<v>" + ESC(cell2.value) + "</v>" : "") + "\n             </c>";
    }) + "\n         </row>\n       ";
  }) + "\n   </sheetData>\n\n   " + (hasDisabledCells ? '<sheetProtection sheet="1" objects="1" scenarios="1"/>' : "") + "\n\n   " + (autoFilter ? '<autoFilter ref="' + autoFilter.from + ":" + autoFilter.to + '"/>' : filter4 ? spreadsheetFilters(filter4) : "") + "\n\n   " + (mergeCells.length ? '\n     <mergeCells count="' + mergeCells.length + '">\n       ' + foreach(mergeCells, function(ref2) {
    return '<mergeCell ref="' + ref2 + '"/>';
  }) + "\n     </mergeCells>" : "") + "\n\n   " + (validations.length ? "\n     <dataValidations>\n       " + foreach(validations, function(val) {
    return '\n         <dataValidation sqref="' + val.sqref.join(" ") + '"\n                         showErrorMessage="' + val.showErrorMessage + '"\n                         type="' + ESC(val.type) + '"\n                         ' + (val.type !== "list" ? 'operator="' + ESC(val.operator) + '"' : "") + '\n                         allowBlank="' + val.allowBlank + '"\n                         showDropDown="' + val.showDropDown + '"\n                         ' + (val.error ? 'error="' + ESC(val.error) + '"' : "") + "\n                         " + (val.errorTitle ? 'errorTitle="' + ESC(val.errorTitle) + '"' : "") + ">\n           " + (val.formula1 ? "<formula1>" + ESC(val.formula1) + "</formula1>" : "") + "\n           " + (val.formula2 ? "<formula2>" + ESC(val.formula2) + "</formula2>" : "") + "\n         </dataValidation>";
  }) + "\n     </dataValidations>" : "") + "\n\n   " + (hyperlinks.length ? "\n     <hyperlinks>\n       " + foreach(hyperlinks, function(link) {
    return '\n         <hyperlink ref="' + link.ref + '" r:id="' + link.rId + '"/>';
  }) + "\n     </hyperlinks>" : "") + '\n\n   <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />\n   ' + (drawing ? '<drawing r:id="' + drawing + '"/>' : "") + "\n   " + (legacyDrawing2 ? '<legacyDrawing r:id="' + legacyDrawing2 + '"/>' : "") + "\n</worksheet>";
};
var WORKBOOK_RELS = function(ref2) {
  var count3 = ref2.count;
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + repeat(count3, function(idx) {
    return '\n    <Relationship Id="rId' + (idx + 1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet' + (idx + 1) + '.xml" />';
  }) + '\n  <Relationship Id="rId' + (count3 + 1) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml" />\n  <Relationship Id="rId' + (count3 + 2) + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />\n</Relationships>';
};
var WORKSHEET_RELS = function(ref2) {
  var hyperlinks = ref2.hyperlinks;
  var comments = ref2.comments;
  var sheetIndex = ref2.sheetIndex;
  var drawings = ref2.drawings;
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + foreach(hyperlinks, function(link) {
    return '\n    <Relationship Id="' + link.rId + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="' + ESC(link.target) + '" TargetMode="External" />';
  }) + "\n  " + (!comments.length ? "" : '\n    <Relationship Id="comment' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments" Target="../comments' + sheetIndex + '.xml"/>\n    <Relationship Id="vml' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing" Target="../drawings/vmlDrawing' + sheetIndex + '.vml"/>') + "\n  " + (!drawings.length ? "" : '\n    <Relationship Id="drw' + sheetIndex + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing' + sheetIndex + '.xml"/>') + "\n</Relationships>";
};
var COMMENTS_XML = function(ref2) {
  var comments = ref2.comments;
  return XMLHEAD + '\n<comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">\n  <authors>\n    <author></author>\n  </authors>\n  <commentList>\n    ' + foreach(comments, function(comment2) {
    return '\n      <comment ref="' + comment2.ref + '" authorId="0">\n        <text>\n          <r>\n            <rPr>\n              <sz val="8"/>\n              <color indexed="81"/>\n              <rFont val="Tahoma"/>\n              <charset val="1"/>\n            </rPr>\n            <t>' + ESC(comment2.text) + "</t>\n          </r>\n        </text>\n      </comment>";
  }) + "\n  </commentList>\n</comments>";
};
var LEGACY_DRAWING = function(ref2) {
  var comments = ref2.comments;
  return '<xml xmlns:v="urn:schemas-microsoft-com:vml"\n     xmlns:o="urn:schemas-microsoft-com:office:office"\n     xmlns:x="urn:schemas-microsoft-com:office:excel">\n  <v:shapetype coordsize="21600,21600" id="_x0000_t202" path="m,l,21600r21600,l21600,xe">\n    <v:stroke joinstyle="miter"/>\n    <v:path gradientshapeok="t" o:connecttype="rect"/>\n  </v:shapetype>\n  ' + foreach(comments, function(comment2) {
    return '\n    <v:shape type="#_x0000_t202" style="visibility: hidden" fillcolor="#ffffe1" o:insetmode="auto">\n      <v:shadow on="t" color="black" obscured="t"/>\n      <x:ClientData ObjectType="Note">\n        <x:MoveWithCells/>\n        <x:SizeWithCells/>\n        <x:Anchor>' + comment2.anchor + "</x:Anchor>\n        <x:AutoFill>False</x:AutoFill>\n        <x:Row>" + comment2.row + "</x:Row>\n        <x:Column>" + comment2.col + "</x:Column>\n      </x:ClientData>\n    </v:shape>";
  }) + "\n</xml>";
};
var DRAWINGS_XML = function(drawings) {
  return XMLHEAD + '\n<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"\n          xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"\n          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">\n  ' + foreach(drawings, function(drawing, index) {
    return '\n    <xdr:oneCellAnchor editAs="oneCell">\n      <xdr:from>\n        <xdr:col>' + drawing.col + "</xdr:col>\n        <xdr:colOff>" + drawing.colOffset + "</xdr:colOff>\n        <xdr:row>" + drawing.row + "</xdr:row>\n        <xdr:rowOff>" + drawing.rowOffset + '</xdr:rowOff>\n      </xdr:from>\n      <xdr:ext cx="' + drawing.width + '" cy="' + drawing.height + '" />\n      <xdr:pic>\n        <xdr:nvPicPr>\n          <xdr:cNvPr id="' + (index + 1) + '" name="Picture ' + (index + 1) + '"/>\n          <xdr:cNvPicPr/>\n        </xdr:nvPicPr>\n        <xdr:blipFill>\n          <a:blip r:embed="' + drawing.imageId + '"/>\n          <a:stretch>\n            <a:fillRect/>\n          </a:stretch>\n        </xdr:blipFill>\n        <xdr:spPr>\n          <a:prstGeom prst="rect">\n            <a:avLst/>\n          </a:prstGeom>\n        </xdr:spPr>\n      </xdr:pic>\n      <xdr:clientData/>\n    </xdr:oneCellAnchor>';
  }) + "\n</xdr:wsDr>";
};
var DRAWINGS_RELS_XML = function(rels) {
  return XMLHEAD + '\n<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">\n  ' + foreach(rels, function(rel) {
    return '\n    <Relationship Id="' + rel.rId + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="' + rel.target + '"/>';
  }) + "\n</Relationships>";
};
var SHARED_STRINGS = function(ref2) {
  var count3 = ref2.count;
  var uniqueCount = ref2.uniqueCount;
  var indexes = ref2.indexes;
  return XMLHEAD + '\n<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count3 + '" uniqueCount="' + uniqueCount + '">\n  ' + foreach(Object.keys(indexes), function(index) {
    return '\n    <si><t xml:space="preserve">' + ESC(index.substring(1)) + "</t></si>";
  }) + "\n</sst>";
};
var STYLES = function(ref2) {
  var formats = ref2.formats;
  var fonts = ref2.fonts;
  var fills = ref2.fills;
  var borders = ref2.borders;
  var styles = ref2.styles;
  return XMLHEAD + '\n<styleSheet\n    xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"\n    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"\n    mc:Ignorable="x14ac"\n    xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">\n  <numFmts count="' + formats.length + '">\n  ' + foreach(formats, function(format, fi) {
    return '\n    <numFmt formatCode="' + ESC(format.format) + '" numFmtId="' + (165 + fi) + '" />';
  }) + '\n  </numFmts>\n  <fonts count="' + (fonts.length + 1) + '" x14ac:knownFonts="1">\n    <font>\n       <sz val="11" />\n       <color theme="1" />\n       <name val="Calibri" />\n       <family val="2" />\n       <scheme val="minor" />\n    </font>\n    ' + foreach(fonts, function(font) {
    return "\n    <font>\n      " + (font.bold ? "<b/>" : "") + "\n      " + (font.italic ? "<i/>" : "") + "\n      " + (font.underline ? "<u/>" : "") + '\n      <sz val="' + (font.fontSize || 11) + '" />\n      ' + (font.color ? '<color rgb="' + ESC(font.color) + '" />' : '<color theme="1" />') + "\n      " + (font.fontFamily ? '\n        <name val="' + ESC(font.fontFamily) + '" />\n        <family val="2" />\n      ' : '\n        <name val="Calibri" />\n        <family val="2" />\n        <scheme val="minor" />\n      ') + "\n    </font>";
  }) + '\n  </fonts>\n  <fills count="' + (fills.length + 2) + '">\n      <fill><patternFill patternType="none"/></fill>\n      <fill><patternFill patternType="gray125"/></fill>\n    ' + foreach(fills, function(fill) {
    return "\n      " + (fill.background ? '\n        <fill>\n          <patternFill patternType="solid">\n              <fgColor rgb="' + ESC(fill.background) + '"/>\n          </patternFill>\n        </fill>\n      ' : "");
  }) + '\n  </fills>\n  <borders count="' + (borders.length + 1) + '">\n    <border><left/><right/><top/><bottom/><diagonal/></border>\n    ' + foreach(borders, borderTemplate) + '\n  </borders>\n  <cellStyleXfs count="1">\n    <xf borderId="0" fillId="0" fontId="0" />\n  </cellStyleXfs>\n  <cellXfs count="' + (styles.length + 1) + '">\n    <xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" />\n    ' + foreach(styles, function(style2) {
    return '\n      <xf xfId="0"\n          ' + (style2.fontId ? 'fontId="' + style2.fontId + '" applyFont="1"' : "") + "\n          " + (style2.fillId ? 'fillId="' + style2.fillId + '" applyFill="1"' : "") + "\n          " + (style2.numFmtId ? 'numFmtId="' + style2.numFmtId + '" applyNumberFormat="1"' : "") + "\n          " + (style2.textAlign || style2.verticalAlign || style2.wrap ? 'applyAlignment="1"' : "") + "\n          " + (style2.borderId ? 'borderId="' + style2.borderId + '" applyBorder="1"' : "") + "\n          " + (style2.disabled != null ? 'applyProtection="1"' : "") + ">\n        " + (style2.textAlign || style2.verticalAlign || style2.wrap ? "\n        <alignment\n          " + (style2.textAlign ? 'horizontal="' + ESC(style2.textAlign) + '"' : "") + "\n          " + (style2.verticalAlign ? 'vertical="' + ESC(style2.verticalAlign) + '"' : "") + "\n          " + (style2.indent ? 'indent="' + ESC(style2.indent) + '"' : "") + "\n          " + (style2.wrap ? 'wrapText="1"' : "") + " />\n        " : "") + "\n        " + (style2.disabled != null ? '\n        <protection locked="' + (style2.disabled ? 1 : 0) + '" />\n        ' : "") + "\n      </xf>\n    ";
  }) + '\n  </cellXfs>\n  <cellStyles count="1">\n    <cellStyle name="Normal" xfId="0" builtinId="0"/>\n  </cellStyles>\n  <dxfs count="0" />\n  <tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleMedium9" />\n</styleSheet>';
};
function writeFormula(formula) {
  if (typeof formula == "string") {
    return "<f>" + ESC(formula) + "</f>";
  }
  return '<f t="array" ref="' + formula.ref + '">' + ESC(formula.src) + "</f>";
}
function numChar(colIndex) {
  var letter = Math.floor(colIndex / 26) - 1;
  return (letter >= 0 ? numChar(letter) : "") + String.fromCharCode(65 + colIndex % 26);
}
function ref(rowIndex, colIndex) {
  return numChar(colIndex) + (rowIndex + 1);
}
function $ref(rowIndex, colIndex) {
  return "$" + numChar(colIndex) + "$" + (rowIndex + 1);
}
function filterRowIndex(options) {
  var frozenRows = options.frozenRows || (options.freezePane || {}).rowSplit || 1;
  return frozenRows - 1;
}
function toWidth(px) {
  var maximumDigitWidth = 7;
  return px / maximumDigitWidth - Math.floor(128 / maximumDigitWidth) / 256;
}
function toHeight(px) {
  return px * 0.75;
}
function stripFunnyChars(value2) {
  return String(value2).replace(/[\x00-\x09\x0B\x0C\x0E-\x1F]/g, "").replace(/\r?\n/g, "\r\n");
}
var Worksheet = function Worksheet2(options, sharedStrings, styles, borders) {
  this.options = options;
  this._strings = sharedStrings;
  this._styles = styles;
  this._borders = borders;
  this._validations = {};
  this._comments = [];
  this._drawings = options.drawings || [];
  this._hyperlinks = (this.options.hyperlinks || []).map(function(link, i) {
    return Object.assign({}, link, {
      rId: "link" + i
    });
  });
};
Worksheet.prototype.relsToXML = function relsToXML() {
  var hyperlinks = this._hyperlinks;
  var comments = this._comments;
  var drawings = this._drawings;
  if (hyperlinks.length || comments.length || drawings.length) {
    return WORKSHEET_RELS({
      hyperlinks,
      comments,
      sheetIndex: this.options.sheetIndex,
      drawings
    });
  }
};
Worksheet.prototype.toXML = function toXML(index) {
  var this$1 = this;
  var mergeCells = this.options.mergedCells || [];
  var rows = this.options.rows || [];
  var data = inflate(rows, mergeCells);
  this._readCells(data);
  var autoFilter = this.options.filter;
  var filter4;
  if (autoFilter && typeof autoFilter.from === "number" && typeof autoFilter.to === "number") {
    autoFilter = {
      from: ref(filterRowIndex(this.options), autoFilter.from),
      to: ref(filterRowIndex(this.options), autoFilter.to)
    };
  } else if (autoFilter && autoFilter.ref && autoFilter.columns) {
    filter4 = autoFilter;
    autoFilter = null;
  }
  var validations = [];
  for (var i in this$1._validations) {
    if (Object.prototype.hasOwnProperty.call(this$1._validations, i)) {
      validations.push(this$1._validations[i]);
    }
  }
  var defaultCellStyleId = null;
  var defaultCellStyle = this.options.defaultCellStyle;
  if (this._hasDisabledCells) {
    if (!defaultCellStyle) {
      defaultCellStyle = {
        disabled: false
      };
    } else {
      defaultCellStyle = Object.assign({
        disabled: false
      }, defaultCellStyle);
    }
  }
  if (defaultCellStyle) {
    defaultCellStyleId = this._lookupStyle(defaultCellStyle);
  }
  var freezePane = this.options.freezePane || {};
  var defaults2 = this.options.defaults || {};
  var lastRow = this.options.rows ? this._getLastRow() : 1;
  var lastCol = this.options.rows ? this._getLastCol() : 1;
  return WORKSHEET({
    frozenColumns: this.options.frozenColumns || freezePane.colSplit,
    frozenRows: this.options.frozenRows || freezePane.rowSplit,
    columns: this.options.columns,
    defaults: defaults2,
    data,
    index,
    mergeCells,
    autoFilter,
    filter: filter4,
    showGridLines: this.options.showGridLines,
    hyperlinks: this._hyperlinks,
    validations,
    defaultCellStyleId,
    rtl: this.options.rtl !== void 0 ? this.options.rtl : defaults2.rtl,
    legacyDrawing: this._comments.length ? "vml" + this.options.sheetIndex : null,
    drawing: this._drawings.length ? "drw" + this.options.sheetIndex : null,
    lastRow,
    lastCol,
    hasDisabledCells: this._hasDisabledCells
  });
};
Worksheet.prototype.commentsXML = function commentsXML() {
  if (this._comments.length) {
    return COMMENTS_XML({
      comments: this._comments
    });
  }
};
Worksheet.prototype.drawingsXML = function drawingsXML(images) {
  if (this._drawings.length) {
    var rels = {};
    var main = this._drawings.map(function(drw) {
      var ref2 = parseRef(drw.topLeftCell);
      var img = rels[drw.image];
      if (!img) {
        img = rels[drw.image] = {
          rId: "img" + drw.image,
          target: images[drw.image].target
        };
      }
      return {
        col: ref2.col,
        colOffset: pixelsToExcel(drw.offsetX),
        row: ref2.row,
        rowOffset: pixelsToExcel(drw.offsetY),
        width: pixelsToExcel(drw.width),
        height: pixelsToExcel(drw.height),
        imageId: img.rId
      };
    });
    return {
      main: DRAWINGS_XML(main),
      rels: DRAWINGS_RELS_XML(rels)
    };
  }
};
Worksheet.prototype.legacyDrawing = function legacyDrawing() {
  if (this._comments.length) {
    return LEGACY_DRAWING({
      comments: this._comments
    });
  }
};
Worksheet.prototype._lookupString = function _lookupString(value2) {
  var key = "$" + value2;
  var index = this._strings.indexes[key];
  var result;
  if (index !== void 0) {
    result = index;
  } else {
    result = this._strings.indexes[key] = this._strings.uniqueCount;
    this._strings.uniqueCount++;
  }
  this._strings.count++;
  return result;
};
Worksheet.prototype._lookupStyle = function _lookupStyle(style2) {
  var json = JSON.stringify(style2);
  if (json === "{}") {
    return 0;
  }
  var index = indexOf(json, this._styles);
  if (index < 0) {
    index = this._styles.push(json) - 1;
  }
  return index + 1;
};
Worksheet.prototype._lookupBorder = function _lookupBorder(border) {
  var json = JSON.stringify(border);
  if (json === "{}") {
    return;
  }
  var index = indexOf(json, this._borders);
  if (index < 0) {
    index = this._borders.push(json) - 1;
  }
  return index + 1;
};
Worksheet.prototype._readCells = function _readCells(rowData) {
  var this$1 = this;
  for (var i = 0; i < rowData.length; i++) {
    var row2 = rowData[i];
    var cells = row2.cells;
    row2.data = [];
    for (var j = 0; j < cells.length; j++) {
      var cellData = this$1._cell(cells[j], row2.index, j);
      if (cellData) {
        row2.data.push(cellData);
      }
    }
  }
};
Worksheet.prototype._cell = function _cell2(data, rowIndex, cellIndex) {
  var this$1 = this;
  if (!data || data === EMPTY_CELL) {
    return null;
  }
  var value2 = data.value;
  var border = {};
  if (data.borderLeft) {
    border.left = data.borderLeft;
  }
  if (data.borderRight) {
    border.right = data.borderRight;
  }
  if (data.borderTop) {
    border.top = data.borderTop;
  }
  if (data.borderBottom) {
    border.bottom = data.borderBottom;
  }
  if (data.dBorders) {
    border.diagonal = data.dBorders;
  }
  border = this._lookupBorder(border);
  var defStyle = this.options.defaultCellStyle || {};
  var style2 = {
    borderId: border
  };
  (function(add) {
    add("color");
    add("background");
    add("bold");
    add("italic");
    add("underline");
    if (!add("fontFamily")) {
      add("fontName", "fontFamily");
    }
    add("fontSize");
    add("format");
    if (!add("textAlign")) {
      add("hAlign", "textAlign");
    }
    if (!add("verticalAlign")) {
      add("vAlign", "verticalAlign");
    }
    add("wrap");
    add("indent");
    if (!add("disabled")) {
      if (add("enable")) {
        style2.disabled = !style2.enable;
        delete style2.enable;
      }
    }
    if (style2.disabled) {
      this$1._hasDisabledCells = true;
    }
  })(function(prop2, target) {
    var val = data[prop2];
    if (val === void 0) {
      val = defStyle[prop2];
    }
    if (val !== void 0) {
      style2[target || prop2] = val;
      return true;
    }
  });
  var columns = this.options.columns || [];
  var column = columns[cellIndex];
  var type = typeof value2;
  if (column && column.autoWidth && (!data.colSpan || data.colSpan === 1)) {
    var displayValue = value2;
    if (type === "number") {
      displayValue = intl_service_default.toString(value2, data.format);
    }
    column.width = Math.max(column.width || 0, String(displayValue).length);
  }
  if (type === "string") {
    value2 = stripFunnyChars(value2);
    value2 = this._lookupString(value2);
    type = "s";
  } else if (type === "number") {
    type = "n";
  } else if (type === "boolean") {
    type = "b";
    value2 = Number(value2);
  } else if (value2 && value2.getTime) {
    type = null;
    value2 = dateToSerial(value2);
    if (!style2.format) {
      style2.format = "mm-dd-yy";
    }
  } else {
    type = null;
    value2 = null;
  }
  style2 = this._lookupStyle(style2);
  var cellName = ref(rowIndex, cellIndex);
  if (data.validation) {
    this._addValidation(data.validation, cellName);
  }
  if (data.comment) {
    var anchor2 = [
      cellIndex + 1,
      // start column
      15,
      // start column offset
      rowIndex,
      // start row
      10,
      // start row offset
      cellIndex + 3,
      // end column
      15,
      // end column offset
      rowIndex + 3,
      // end row
      4
      // end row offset
    ];
    this._comments.push({
      ref: cellName,
      text: data.comment,
      row: rowIndex,
      col: cellIndex,
      anchor: anchor2.join(", ")
    });
  }
  return {
    value: value2,
    formula: data.formula,
    type,
    style: style2,
    ref: cellName
  };
};
Worksheet.prototype._addValidation = function _addValidation(v, ref2) {
  var tmp = {
    showErrorMessage: v.type === "reject" ? 1 : 0,
    formula1: v.from,
    formula2: v.to,
    type: MAP_EXCEL_TYPE[v.dataType] || v.dataType,
    operator: MAP_EXCEL_OPERATOR[v.comparerType] || v.comparerType,
    allowBlank: v.allowNulls ? 1 : 0,
    showDropDown: v.showButton ? 0 : 1,
    // LOL, Excel!
    error: v.messageTemplate,
    errorTitle: v.titleTemplate
  };
  var json = JSON.stringify(tmp);
  if (!this._validations[json]) {
    this._validations[json] = tmp;
    tmp.sqref = [];
  }
  this._validations[json].sqref.push(ref2);
};
Worksheet.prototype._getLastRow = function _getLastRow() {
  return countData(this.options.rows);
};
Worksheet.prototype._getLastCol = function _getLastCol() {
  var last = 0;
  this.options.rows.forEach(function(row2) {
    if (row2.cells) {
      last = Math.max(last, countData(row2.cells));
    }
  });
  return last;
};
function countData(data) {
  var last = data.length;
  data.forEach(function(el) {
    if (el.index && el.index >= last) {
      last = el.index + 1;
    }
  });
  return last;
}
var MAP_EXCEL_OPERATOR = {
  // includes only what differs; key is our operator, value is Excel
  // operator.
  greaterThanOrEqualTo: "greaterThanOrEqual",
  lessThanOrEqualTo: "lessThanOrEqual"
};
var MAP_EXCEL_TYPE = {
  // eslint-disable-next-line id-denylist
  number: "decimal"
};
var defaultFormats = {
  "General": 0,
  "0": 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49,
  "[$-404]e/m/d": 27,
  "m/d/yy": 30,
  "t0": 59,
  "t0.00": 60,
  "t#,##0": 61,
  "t#,##0.00": 62,
  "t0%": 67,
  "t0.00%": 68,
  "t# ?/?": 69,
  "t# ??/??": 70
};
function maybeRGB(value2) {
  function hex(val) {
    var x = parseInt(val, 10).toString(16);
    return x.length < 2 ? "0" + x : x;
  }
  var m = /^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+)\s*)?\)/i.exec(value2.trim());
  if (m) {
    var opacity = (m[4] ? parseFloat(m[4]) : 1) * 255 | 0;
    return "#" + hex(opacity) + hex(m[1]) + hex(m[2]) + hex(m[3]);
  }
  return value2;
}
function convertColor(value2) {
  var color = maybeRGB(value2);
  if (color.length < 6) {
    color = color.replace(/(\w)/g, function($0, $1) {
      return $1 + $1;
    });
  }
  color = color.substring(1).toUpperCase();
  if (color.length < 8) {
    color = "FF" + color;
  }
  return color;
}
var Workbook = function Workbook2(options) {
  var this$1 = this;
  this.options = options || {};
  this._strings = {
    indexes: {},
    count: 0,
    uniqueCount: 0
  };
  this._styles = [];
  this._borders = [];
  this._images = this.options.images;
  this._imgId = 0;
  this._sheets = map3(this.options.sheets || [], function(options2, i) {
    options2.defaults = this$1.options;
    options2.sheetIndex = i + 1;
    return new Worksheet(options2, this$1._strings, this$1._styles, this$1._borders);
  });
};
Workbook.prototype.imageFilename = function imageFilename(mimeType) {
  var id2 = ++this._imgId;
  switch (mimeType) {
    case "image/jpg":
    case "image/jpeg":
      return "image" + id2 + ".jpg";
    case "image/png":
      return "image" + id2 + ".png";
    case "image/gif":
      return "image" + id2 + ".gif";
    default:
      return "image" + id2 + ".bin";
  }
};
Workbook.prototype.toZIP = function toZIP() {
  var this$1 = this;
  var zip3 = createZip();
  var docProps = zip3.folder("docProps");
  docProps.file("core.xml", CORE({
    creator: this.options.creator || "Kendo UI",
    lastModifiedBy: this.options.creator || "Kendo UI",
    created: this.options.date || (/* @__PURE__ */ new Date()).toJSON(),
    modified: this.options.date || (/* @__PURE__ */ new Date()).toJSON()
  }));
  var sheetCount = this._sheets.length;
  docProps.file("app.xml", APP({
    sheets: this._sheets
  }));
  var rels = zip3.folder("_rels");
  rels.file(".rels", RELS);
  var xl = zip3.folder("xl");
  var xlRels = xl.folder("_rels");
  xlRels.file("workbook.xml.rels", WORKBOOK_RELS({
    count: sheetCount
  }));
  if (this._images) {
    var media = xl.folder("media");
    Object.keys(this._images).forEach(function(id2) {
      var img = this$1._images[id2];
      var filename = this$1.imageFilename(img.type);
      media.file(filename, img.data);
      img.target = "../media/" + filename;
    });
  }
  var sheetIds = {};
  xl.file("workbook.xml", WORKBOOK({
    sheets: this._sheets,
    filterNames: map3(this._sheets, function(sheet2, index) {
      var options = sheet2.options;
      var sheetName2 = options.name || options.title || "Sheet" + (index + 1);
      sheetIds[sheetName2.toLowerCase()] = index;
      var filter4 = options.filter;
      if (filter4) {
        if (filter4.ref) {
          var a = filter4.ref.split(":");
          var from2 = parseRef(a[0]);
          var to = parseRef(a[1]);
          return {
            localSheetId: index,
            name: sheetName2,
            from: $ref(from2.row, from2.col),
            to: $ref(to.row, to.col)
          };
        } else if (typeof filter4.from !== "undefined" && typeof filter4.to !== "undefined") {
          return {
            localSheetId: index,
            name: sheetName2,
            from: $ref(filterRowIndex(options), filter4.from),
            to: $ref(filterRowIndex(options), filter4.to)
          };
        }
      }
    }),
    userNames: map3(this.options.names || [], function(def) {
      return {
        name: def.localName,
        localSheetId: def.sheet ? sheetIds[def.sheet.toLowerCase()] : null,
        value: def.value,
        hidden: def.hidden
      };
    })
  }));
  var worksheets = xl.folder("worksheets");
  var drawings = xl.folder("drawings");
  var drawingsRels = drawings.folder("_rels");
  var sheetRels = worksheets.folder("_rels");
  var commentFiles = [];
  var drawingFiles = [];
  for (var idx = 0; idx < sheetCount; idx++) {
    var sheet = this$1._sheets[idx];
    var sheetName = "sheet" + (idx + 1) + ".xml";
    var sheetXML = sheet.toXML(idx);
    var relsXML = sheet.relsToXML();
    var commentsXML2 = sheet.commentsXML();
    var legacyDrawing2 = sheet.legacyDrawing();
    var drawingsXML2 = sheet.drawingsXML(this$1._images);
    if (relsXML) {
      sheetRels.file(sheetName + ".rels", relsXML);
    }
    if (commentsXML2) {
      var name = "comments" + sheet.options.sheetIndex + ".xml";
      xl.file(name, commentsXML2);
      commentFiles.push(name);
    }
    if (legacyDrawing2) {
      drawings.file("vmlDrawing" + sheet.options.sheetIndex + ".vml", legacyDrawing2);
    }
    if (drawingsXML2) {
      var name$1 = "drawing" + sheet.options.sheetIndex + ".xml";
      drawings.file(name$1, drawingsXML2.main);
      drawingsRels.file(name$1 + ".rels", drawingsXML2.rels);
      drawingFiles.push(name$1);
    }
    worksheets.file(sheetName, sheetXML);
  }
  var borders = map3(this._borders, parseJSON);
  var styles = map3(this._styles, parseJSON);
  var hasFont = function(style2) {
    return style2.underline || style2.bold || style2.italic || style2.color || style2.fontFamily || style2.fontSize;
  };
  var convertFontSize = function(value2) {
    var fontInPx = Number(value2);
    var fontInPt;
    if (fontInPx) {
      fontInPt = fontInPx * 3 / 4;
    }
    return fontInPt;
  };
  var fonts = map3(styles, function(style2) {
    if (style2.fontSize) {
      style2.fontSize = convertFontSize(style2.fontSize);
    }
    if (style2.color) {
      style2.color = convertColor(style2.color);
    }
    if (hasFont(style2)) {
      return style2;
    }
  });
  var formats = map3(styles, function(style2) {
    if (style2.format && defaultFormats[style2.format] === void 0) {
      return style2;
    }
  });
  var fills = map3(styles, function(style2) {
    if (style2.background) {
      style2.background = convertColor(style2.background);
      return style2;
    }
  });
  xl.file("styles.xml", STYLES({
    fonts,
    fills,
    formats,
    borders,
    styles: map3(styles, function(style2) {
      var result = {};
      if (hasFont(style2)) {
        result.fontId = indexOf(style2, fonts) + 1;
      }
      if (style2.background) {
        result.fillId = indexOf(style2, fills) + 2;
      }
      result.textAlign = style2.textAlign;
      result.indent = style2.indent;
      result.verticalAlign = style2.verticalAlign;
      result.wrap = style2.wrap;
      result.borderId = style2.borderId;
      if (style2.format) {
        if (defaultFormats[style2.format] !== void 0) {
          result.numFmtId = defaultFormats[style2.format];
        } else {
          result.numFmtId = 165 + indexOf(style2, formats);
        }
      }
      if (style2.disabled != null) {
        result.disabled = style2.disabled;
      }
      return result;
    })
  }));
  xl.file("sharedStrings.xml", SHARED_STRINGS(this._strings));
  zip3.file("[Content_Types].xml", CONTENT_TYPES({
    sheetCount,
    commentFiles,
    drawingFiles
  }));
  return zip3;
};
Workbook.prototype.toDataURL = function toDataURL() {
  var zip3 = this.toZIP();
  return zip3.generateAsync ? zip3.generateAsync(DATA_URL_OPTIONS).then(toDataURI) : toDataURI(zip3.generate(DATA_URL_OPTIONS));
};
Workbook.prototype.toBlob = function toBlob() {
  var zip3 = this.toZIP();
  if (zip3.generateAsync) {
    return zip3.generateAsync(BLOB_OPTIONS);
  }
  return new Blob([zip3.generate(ARRAYBUFFER_OPTIONS)], {
    type: MIME_TYPE
  });
};
function borderStyle(width) {
  var alias = "thin";
  if (width === 2) {
    alias = "medium";
  } else if (width === 3) {
    alias = "thick";
  }
  return alias;
}
function borderSideTemplate(name, style2) {
  var result = "";
  if (style2) {
    result += "<" + name + ' style="' + borderStyle(style2.size) + '">';
    if (style2.color) {
      result += '<color rgb="' + convertColor(style2.color) + '"/>';
    }
    result += "</" + name + ">";
  }
  return result;
}
function borderTemplate(border) {
  var diag = border.diagonal ? border.diagonal.type : 0;
  return "<border " + (diag & 2 ? 'diagonalUp="true"' : "") + " " + (diag & 1 ? 'diagonalDown="true"' : "") + ">\n      " + borderSideTemplate("left", border.left) + "\n      " + borderSideTemplate("right", border.right) + "\n      " + borderSideTemplate("top", border.top) + "\n      " + borderSideTemplate("bottom", border.bottom) + "\n      " + borderSideTemplate("diagonal", border.diagonal) + "\n    </border>";
}
var EMPTY_CELL = {};
function inflate(rows, mergedCells) {
  var rowData = [];
  var rowsByIndex = [];
  indexRows(rows, function(row2, index) {
    var data = {
      _source: row2,
      index,
      height: row2.height,
      level: row2.level,
      cells: []
    };
    rowData.push(data);
    rowsByIndex[index] = data;
  });
  var sorted = sortByIndex(rowData).slice(0);
  var ctx = {
    rowData,
    rowsByIndex,
    mergedCells
  };
  for (var i = 0; i < sorted.length; i++) {
    fillCells(sorted[i], ctx);
    delete sorted[i]._source;
  }
  return sortByIndex(rowData);
}
function indexRows(rows, callback) {
  for (var i = 0; i < rows.length; i++) {
    var row2 = rows[i];
    if (!row2) {
      continue;
    }
    var index = row2.index;
    if (typeof index !== "number") {
      index = i;
    }
    callback(row2, index);
  }
}
function sortByIndex(items) {
  return items.sort(function(a, b) {
    return a.index - b.index;
  });
}
function pushUnique(array, el) {
  if (array.indexOf(el) < 0) {
    array.push(el);
  }
}
function getSpan(mergedCells, ref2) {
  for (var i = 0; i < mergedCells.length; ++i) {
    var range = mergedCells[i];
    var a = range.split(":");
    var topLeft = a[0];
    if (topLeft === ref2) {
      var bottomRight = a[1];
      topLeft = parseRef(topLeft);
      bottomRight = parseRef(bottomRight);
      return {
        rowSpan: bottomRight.row - topLeft.row + 1,
        colSpan: bottomRight.col - topLeft.col + 1
      };
    }
  }
}
function parseRef(ref2) {
  function getcol(str) {
    var upperStr = str.toUpperCase();
    var col = 0;
    for (var i = 0; i < upperStr.length; ++i) {
      col = col * 26 + upperStr.charCodeAt(i) - 64;
    }
    return col - 1;
  }
  function getrow(str) {
    return parseInt(str, 10) - 1;
  }
  var m = /^([a-z]+)(\d+)$/i.exec(ref2);
  return {
    row: getrow(m[2]),
    col: getcol(m[1])
  };
}
function pixelsToExcel(px) {
  return Math.round(px * 9525);
}
function fillCells(data, ctx) {
  var row2 = data._source;
  var rowIndex = data.index;
  var cells = row2.cells;
  var cellData = data.cells;
  if (!cells) {
    return;
  }
  for (var i = 0; i < cells.length; i++) {
    var cell2 = cells[i] || EMPTY_CELL;
    var rowSpan = cell2.rowSpan || 1;
    var colSpan = cell2.colSpan || 1;
    var cellIndex = insertCell(cellData, cell2);
    var topLeftRef = ref(rowIndex, cellIndex);
    if (rowSpan === 1 && colSpan === 1) {
      var tmp = getSpan(ctx.mergedCells, topLeftRef);
      if (tmp) {
        colSpan = tmp.colSpan;
        rowSpan = tmp.rowSpan;
      }
    }
    spanCell(cell2, cellData, cellIndex, colSpan);
    if (rowSpan > 1 || colSpan > 1) {
      pushUnique(ctx.mergedCells, topLeftRef + ":" + ref(rowIndex + rowSpan - 1, cellIndex + colSpan - 1));
    }
    if (rowSpan > 1) {
      for (var ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {
        var nextRow = ctx.rowsByIndex[ri];
        if (!nextRow) {
          nextRow = ctx.rowsByIndex[ri] = {
            index: ri,
            cells: []
          };
          ctx.rowData.push(nextRow);
        }
        spanCell(cell2, nextRow.cells, cellIndex - 1, colSpan + 1);
      }
    }
  }
}
function insertCell(data, cell2) {
  var index;
  if (typeof cell2.index === "number") {
    index = cell2.index;
    insertCellAt(data, cell2, cell2.index);
  } else {
    index = appendCell(data, cell2);
  }
  return index;
}
function insertCellAt(data, cell2, index) {
  data[index] = cell2;
}
function appendCell(data, cell2) {
  var index = data.length;
  for (var i = 0; i < data.length + 1; i++) {
    if (!data[i]) {
      data[i] = cell2;
      index = i;
      break;
    }
  }
  return index;
}
function spanCell(cell2, row2, startIndex, colSpan) {
  for (var i = 1; i < colSpan; i++) {
    var tmp = {
      borderTop: cell2.borderTop,
      borderRight: cell2.borderRight,
      borderBottom: cell2.borderBottom,
      borderLeft: cell2.borderLeft
    };
    insertCellAt(row2, tmp, startIndex + i);
  }
}
var SPREADSHEET_FILTERS = function(ref$1) {
  var ref2 = ref$1.ref;
  var columns = ref$1.columns;
  var generators = ref$1.generators;
  return '\n<autoFilter ref="' + ref2 + '">\n  ' + foreach(columns, function(col) {
    return '\n    <filterColumn colId="' + col.index + '">\n      ' + generators[col.filter](col) + "\n    </filterColumn>\n  ";
  }) + "\n</autoFilter>";
};
var SPREADSHEET_CUSTOM_FILTER = function(ref2) {
  var logic2 = ref2.logic;
  var criteria = ref2.criteria;
  return "\n<customFilters " + (logic2 === "and" ? 'and="1"' : "") + ">\n" + foreach(criteria, function(f) {
    var op = spreadsheetFilters.customOperator(f);
    var val = spreadsheetFilters.customValue(f);
    return "<customFilter " + (op ? 'operator="' + op + '"' : "") + ' val="' + val + '"/>';
  }) + "\n</customFilters>";
};
var SPREADSHEET_DYNAMIC_FILTER = function(ref2) {
  var type = ref2.type;
  return '<dynamicFilter type="' + spreadsheetFilters.dynamicFilterType(type) + '" />';
};
var SPREADSHEET_TOP_FILTER = function(ref2) {
  var type = ref2.type;
  var value2 = ref2.value;
  return '<top10 percent="' + (/percent$/i.test(type) ? 1 : 0) + '"\n       top="' + (/^top/i.test(type) ? 1 : 0) + '"\n       val="' + value2 + '" />';
};
var SPREADSHEET_VALUE_FILTER = function(ref2) {
  var blanks = ref2.blanks;
  var values = ref2.values;
  return "<filters " + (blanks ? 'blank="1"' : "") + ">\n    " + foreach(values, function(value2) {
    return '\n      <filter val="' + value2 + '" />';
  }) + "\n  </filters>";
};
function spreadsheetFilters(filter4) {
  return SPREADSHEET_FILTERS({
    ref: filter4.ref,
    columns: filter4.columns,
    generators: {
      custom: SPREADSHEET_CUSTOM_FILTER,
      dynamic: SPREADSHEET_DYNAMIC_FILTER,
      top: SPREADSHEET_TOP_FILTER,
      value: SPREADSHEET_VALUE_FILTER
    }
  });
}
spreadsheetFilters.customOperator = function(f) {
  return {
    eq: "equal",
    gt: "greaterThan",
    gte: "greaterThanOrEqual",
    lt: "lessThan",
    lte: "lessThanOrEqual",
    ne: "notEqual",
    // These are not in the spec, but seems to be how Excel does
    // it (see customValue below).  For the non-negated versions,
    // the operator attribute is missing completely.
    doesnotstartwith: "notEqual",
    doesnotendwith: "notEqual",
    doesnotcontain: "notEqual",
    doesnotmatch: "notEqual"
  }[f.operator.toLowerCase()];
};
function quoteSheet(name) {
  if (/^\'/.test(name)) {
    return name;
  }
  if (/^[a-z_][a-z0-9_]*$/i.test(name)) {
    return name;
  }
  return "'" + name.replace(/\x27/g, "\\'") + "'";
}
spreadsheetFilters.customValue = function(f) {
  function esc(str) {
    return str.replace(/([*?])/g, "~$1");
  }
  switch (f.operator.toLowerCase()) {
    case "startswith":
    case "doesnotstartwith":
      return esc(f.value) + "*";
    case "endswith":
    case "doesnotendwith":
      return "*" + esc(f.value);
    case "contains":
    case "doesnotcontain":
      return "*" + esc(f.value) + "*";
    default:
      return f.value;
  }
};
spreadsheetFilters.dynamicFilterType = function(type) {
  return {
    quarter1: "Q1",
    quarter2: "Q2",
    quarter3: "Q3",
    quarter4: "Q4",
    january: "M1",
    february: "M2",
    march: "M3",
    april: "M4",
    may: "M5",
    june: "M6",
    july: "M7",
    august: "M8",
    september: "M9",
    october: "M10",
    november: "M11",
    december: "M12"
  }[type.toLowerCase()] || type;
};

// node_modules/@progress/kendo-angular-excel-export/fesm2020/progress-kendo-angular-excel-export.mjs
var compileTemplate2 = (templateRef, context, updateContext) => {
  let embeddedView = templateRef.createEmbeddedView(context);
  const result = (data) => {
    updateContext(context, data);
    embeddedView.detectChanges();
    return embeddedView.rootNodes.reduce((content, rootNode) => {
      return content + rootNode.textContent;
    }, "").trim();
  };
  result.destroy = () => {
    embeddedView.destroy();
    embeddedView = null;
  };
  return result;
};
var updateGroupHeaderContext = (context, data) => {
  context.$implicit = context.group = data;
  context.field = data.field;
  context.value = data.value;
  context.aggregates = data.aggregates;
};
var updateGroupFooterContext = (context, data) => {
  context.group = data.group;
  context.$implicit = context.aggregates = data;
};
var updateFooterContext = (context, data) => {
  context.aggregates = data.aggregates;
};
var toExporterColumns = (sourceColumns) => {
  const exporterColumns = [];
  let columnIndex = 0;
  const addColumns = (columns, result, level) => {
    columns.forEach((column) => {
      if (column.level === level) {
        const exporterColumn = new ExporterColumn(column, columnIndex);
        result.push(exporterColumn);
        if (column.children && column.children.some((c) => c !== column)) {
          const children2 = exporterColumn.columns = [];
          addColumns(column.children, children2, level + 1);
        } else {
          columnIndex++;
        }
      }
    });
  };
  addColumns(sourceColumns, exporterColumns, 0);
  return exporterColumns;
};
var destroyColumns = (columns) => {
  if (columns) {
    columns.forEach((column) => {
      column.destroy();
    });
  }
};
var ExporterColumn = class {
  constructor(column, columnIndex) {
    this.title = column.title;
    this.field = column.field;
    this.hidden = column.hidden;
    this.locked = column.locked;
    this.width = column.width;
    this.headerCellOptions = column.headerCellOptions;
    this.cellOptions = column.cellOptions;
    this.groupHeaderCellOptions = column.groupHeaderCellOptions;
    this.groupFooterCellOptions = column.groupFooterCellOptions;
    this.footerCellOptions = column.footerCellOptions;
    if (column.footerTemplate) {
      this.footerTemplate = compileTemplate2(column.footerTemplate.templateRef, {
        $implicit: column,
        column,
        columnIndex
      }, updateFooterContext);
    }
    if (column.groupFooterTemplate) {
      this.groupFooterTemplate = compileTemplate2(column.groupFooterTemplate.templateRef, {
        column,
        field: column.field
      }, updateGroupFooterContext);
    }
    if (column.groupHeaderTemplate) {
      this.groupHeaderTemplate = compileTemplate2(column.groupHeaderTemplate.templateRef, {}, updateGroupHeaderContext);
    }
    if (column.groupHeaderColumnTemplate) {
      this.groupHeaderColumnTemplate = compileTemplate2(column.groupHeaderColumnTemplate.templateRef, {}, updateGroupHeaderContext);
    }
  }
  destroy() {
    if (this.footerTemplate) {
      this.footerTemplate.destroy();
    }
    if (this.groupFooterTemplate) {
      this.groupFooterTemplate.destroy();
    }
    if (this.groupHeaderTemplate) {
      this.groupHeaderTemplate.destroy();
    }
    if (this.groupHeaderColumnTemplate) {
      this.groupHeaderColumnTemplate.destroy();
    }
    destroyColumns(this.columns);
  }
};
intl_service_default.register({
  toString
});
var workbookOptions = (options) => {
  const columns = toExporterColumns(options.columns);
  const exporter = new excel_exporter_default({
    columns,
    data: options.data,
    filterable: options.filterable,
    groups: options.group,
    paddingCellOptions: options.paddingCellOptions,
    headerPaddingCellOptions: options.headerPaddingCellOptions,
    collapsible: options.collapsible,
    hierarchy: options.hierarchy,
    aggregates: options.aggregates
  });
  const result = exporter.workbook();
  result.creator = options.creator;
  result.date = options.date;
  result.rtl = options.rtl;
  destroyColumns(columns);
  return result;
};
var toDataURL2 = (options) => {
  const workbook2 = new Workbook(options);
  return workbook2.toDataURL();
};
var isWorkbookOptions = (value2) => {
  return value2 && value2.sheets;
};
var ColumnBase = class {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * @hidden
   */
  get level() {
    return this.parent ? this.parent.level + 1 : 0;
  }
};
ColumnBase.ɵfac = function ColumnBase_Factory(t) {
  return new (t || ColumnBase)(ɵɵdirectiveInject(ColumnBase));
};
ColumnBase.ɵcmp = ɵɵdefineComponent({
  type: ColumnBase,
  selectors: [["ng-component"]],
  contentQueries: function ColumnBase_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnBase, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  inputs: {
    title: "title",
    width: "width",
    locked: "locked",
    hidden: "hidden",
    headerCellOptions: "headerCellOptions"
  },
  decls: 0,
  vars: 0,
  template: function ColumnBase_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: ColumnBase
    }];
  }, {
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    locked: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    headerCellOptions: [{
      type: Input
    }],
    children: [{
      type: ContentChildren,
      args: [ColumnBase]
    }]
  });
})();
var packageMetadata3 = {
  name: "@progress/kendo-angular-excel-export",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1720607862,
  version: "16.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var ExcelExportComponent = class {
  constructor(localization, zone) {
    this.localization = localization;
    this.zone = zone;
    this.fileName = "Export.xlsx";
    this.columns = new QueryList();
    validatePackage(packageMetadata3);
    this.saveFile = this.saveFile.bind(this);
  }
  /**
   * Saves the data to Excel.
   *
   * @param exportData - An optional parameter. Can be the data that will be exported or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}).
   */
  save(exportData) {
    this.toDataURL(exportData).then(this.saveFile);
  }
  /**
   * Based on the specified columns and data, returns
   * [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %})
   * ([see example]({% slug customrowsandcells_excelexport %})).
   *
   * @param exportData - The optional data to be exported.
   * @returns {WorkbookOptions} - The workbook options.
   */
  workbookOptions(exportData) {
    const currentData = this.getExportData(exportData);
    const options = workbookOptions({
      columns: this.columns,
      data: currentData.data,
      group: currentData.group,
      filterable: this.filterable,
      creator: this.creator,
      date: this.date,
      rtl: this.localization.rtl,
      paddingCellOptions: this.paddingCellOptions,
      headerPaddingCellOptions: this.headerPaddingCellOptions,
      collapsible: this.collapsible
    });
    return options;
  }
  /**
   * Returns a promise which will be resolved with the file data URI
   * ([see example]({% slug filesaving_excelexport %})).
   *
   * @param exportData - The optional data or [`WorkbookOptions`]({% slug api_excel-export_workbookoptions %}) that will be used to generate the data URI.
   * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
   */
  toDataURL(exportData) {
    const options = isWorkbookOptions(exportData) ? exportData : this.workbookOptions(exportData);
    return this.zone.runOutsideAngular(() => toDataURL2(options));
  }
  getExportData(exportData) {
    let result;
    if (exportData) {
      if (Array.isArray(exportData)) {
        result = {
          data: exportData
        };
      } else {
        result = exportData;
      }
    } else {
      result = {
        data: this.data,
        group: this.group
      };
    }
    return result;
  }
  saveFile(dataURL) {
    saveAs(dataURL, this.fileName, {
      forceProxy: this.forceProxy,
      proxyURL: this.proxyURL
    });
  }
};
ExcelExportComponent.ɵfac = function ExcelExportComponent_Factory(t) {
  return new (t || ExcelExportComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
};
ExcelExportComponent.ɵcmp = ɵɵdefineComponent({
  type: ExcelExportComponent,
  selectors: [["kendo-excelexport"]],
  contentQueries: function ExcelExportComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnBase, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
    }
  },
  inputs: {
    fileName: "fileName",
    filterable: "filterable",
    collapsible: "collapsible",
    creator: "creator",
    date: "date",
    forceProxy: "forceProxy",
    proxyURL: "proxyURL",
    data: "data",
    group: "group",
    paddingCellOptions: "paddingCellOptions",
    headerPaddingCellOptions: "headerPaddingCellOptions"
  },
  exportAs: ["kendoExcelExport"],
  features: [ɵɵProvidersFeature([LocalizationService, {
    provide: L10N_PREFIX,
    useValue: "kendo.excelexport"
  }])],
  decls: 0,
  vars: 0,
  template: function ExcelExportComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelExportComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoExcelExport",
      selector: "kendo-excelexport",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.excelexport"
      }],
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    fileName: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    paddingCellOptions: [{
      type: Input
    }],
    headerPaddingCellOptions: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase, {
        descendants: true
      }]
    }]
  });
})();
var GroupHeaderTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupHeaderTemplateDirective.ɵfac = function GroupHeaderTemplateDirective_Factory(t) {
  return new (t || GroupHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupHeaderTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: GroupHeaderTemplateDirective,
  selectors: [["", "kendoExcelExportGroupHeaderTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupHeaderTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderColumnTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupHeaderColumnTemplateDirective.ɵfac = function GroupHeaderColumnTemplateDirective_Factory(t) {
  return new (t || GroupHeaderColumnTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupHeaderColumnTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: GroupHeaderColumnTemplateDirective,
  selectors: [["", "kendoExcelExportGroupHeaderColumnTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderColumnTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupHeaderColumnTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupFooterTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupFooterTemplateDirective.ɵfac = function GroupFooterTemplateDirective_Factory(t) {
  return new (t || GroupFooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupFooterTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: GroupFooterTemplateDirective,
  selectors: [["", "kendoExcelExportGroupFooterTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupFooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportGroupFooterTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FooterTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
FooterTemplateDirective.ɵfac = function FooterTemplateDirective_Factory(t) {
  return new (t || FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
FooterTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: FooterTemplateDirective,
  selectors: [["", "kendoExcelExportFooterTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoExcelExportFooterTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnComponent = class extends ColumnBase {
  constructor(parent) {
    super(parent);
  }
};
ColumnComponent.ɵfac = function ColumnComponent_Factory(t) {
  return new (t || ColumnComponent)(ɵɵdirectiveInject(ColumnBase, 13));
};
ColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnComponent,
  selectors: [["kendo-excelexport-column"]],
  contentQueries: function ColumnComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
    }
  },
  inputs: {
    field: "field",
    cellOptions: "cellOptions",
    groupHeaderCellOptions: "groupHeaderCellOptions",
    groupFooterCellOptions: "groupFooterCellOptions",
    footerCellOptions: "footerCellOptions"
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase,
    useExisting: forwardRef(() => ColumnComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ColumnComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase,
        useExisting: forwardRef(() => ColumnComponent)
      }],
      selector: "kendo-excelexport-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, {
    field: [{
      type: Input
    }],
    cellOptions: [{
      type: Input
    }],
    groupHeaderCellOptions: [{
      type: Input
    }],
    groupFooterCellOptions: [{
      type: Input
    }],
    footerCellOptions: [{
      type: Input
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective, {
        static: false
      }]
    }],
    groupHeaderColumnTemplate: [{
      type: ContentChild,
      args: [GroupHeaderColumnTemplateDirective, {
        static: false
      }]
    }],
    groupFooterTemplate: [{
      type: ContentChild,
      args: [GroupFooterTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var ColumnGroupComponent = class extends ColumnBase {
  constructor(parent) {
    super(parent);
    this.parent = parent;
  }
};
ColumnGroupComponent.ɵfac = function ColumnGroupComponent_Factory(t) {
  return new (t || ColumnGroupComponent)(ɵɵdirectiveInject(ColumnBase, 13));
};
ColumnGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnGroupComponent,
  selectors: [["kendo-excelexport-column-group"]],
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase,
    useExisting: forwardRef(() => ColumnGroupComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ColumnGroupComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnGroupComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase,
        useExisting: forwardRef(() => ColumnGroupComponent)
      }],
      selector: "kendo-excelexport-column-group",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
var declarations = [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective];
var ExcelExportModule = class {
};
ExcelExportModule.ɵfac = function ExcelExportModule_Factory(t) {
  return new (t || ExcelExportModule)();
};
ExcelExportModule.ɵmod = ɵɵdefineNgModule({
  type: ExcelExportModule,
  declarations: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective],
  exports: [ExcelExportComponent, ColumnComponent, ColumnGroupComponent, FooterTemplateDirective, GroupFooterTemplateDirective, GroupHeaderTemplateDirective, GroupHeaderColumnTemplateDirective]
});
ExcelExportModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelExportModule, [{
    type: NgModule,
    args: [{
      declarations: [declarations],
      exports: [declarations]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-grid/fesm2020/progress-kendo-angular-grid.mjs
var _c03 = ["defaultTemplate"];
var _c1 = () => ({
  lastTarget: true
});
var _c2 = (a0, a1, a2) => ({
  field: a0,
  type: "groupIndicator",
  hint: a1,
  target: a2
});
var _c3 = (a0, a1) => ({
  keydown: a0,
  click: a1
});
function GroupPanelComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("context", ɵɵpureFunction0(2, _c1));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.text, " ");
  }
}
function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-chip", 7, 1);
    ɵɵlistener("contentClick", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_contentClick_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.directionChange(group_r3));
    })("remove", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_remove_0_listener() {
      const group_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.remove(group_r3));
    })("menuToggle", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_menuToggle_0_listener() {
      const ctx_r3 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r3.$implicit;
      const first_r5 = ctx_r3.first;
      const last_r6 = ctx_r3.last;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, first_r5, last_r6, group_r3.field));
    })("keydown.alt.arrowdown", function GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template_kendo_chip_keydown_alt_arrowdown_0_listener($event) {
      const ctx_r7 = ɵɵrestoreView(_r2);
      const group_r3 = ctx_r7.$implicit;
      const first_r5 = ctx_r7.first;
      const last_r6 = ctx_r7.last;
      const chip_r7 = ɵɵreference(1);
      const ctx_r0 = ɵɵnextContext(2);
      $event.preventDefault();
      return ɵɵresetView(ctx_r0.toggleMenu(chip_r7, first_r5, last_r6, group_r3.field));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const group_r3 = ctx.$implicit;
    const index_r9 = ctx.index;
    const chip_r7 = ɵɵreference(1);
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("title", ctx_r0.getTitle(group_r3))("enableDrag", true)("context", ɵɵpureFunction3(11, _c2, group_r3.field, ctx_r0.groupTitles[index_r9], chip_r7))("label", ctx_r0.groupTitles[index_r9])("removable", true)("hasMenu", true)("icon", ctx_r0.getDirectionIcon(group_r3))("svgIcon", ctx_r0.getDirectionSvgIcon(group_r3));
    ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx_r0.isChipMenuOpen)("aria-controls", ctx_r0.gridId);
  }
}
function GroupPanelComponent_kendo_chiplist_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-chiplist", 5);
    ɵɵtemplate(1, GroupPanelComponent_kendo_chiplist_1_kendo_chip_1_Template, 2, 15, "kendo-chip", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r0.navigable);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function GroupPanelComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1, " ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("context", ɵɵpureFunction0(1, _c1));
  }
}
function GroupPanelComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 8)(1, "li", 9)(2, "span", 10);
    ɵɵelement(3, "kendo-icon-wrapper", 11);
    ɵɵelementStart(4, "span", 12);
    ɵɵtext(5);
    ɵɵelementEnd()()();
    ɵɵelementStart(6, "li", 9)(7, "span", 10);
    ɵɵelement(8, "kendo-icon-wrapper", 11);
    ɵɵelementStart(9, "span", 12);
    ɵɵtext(10);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(13, _c3, ctx_r0.handleKeyDown, ctx_r0.handleClick));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.first);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-right" : "arrow-left")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowRightIcon : ctx_r0.arrowLeftIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuPrevious"));
    ɵɵadvance();
    ɵɵattribute("aria-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵclassProp("k-disabled", ctx_r0.last);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.rtl ? "arrow-left" : "arrow-right")("svgIcon", ctx_r0.rtl ? ctx_r0.arrowLeftIcon : ctx_r0.arrowRightIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.messageFor("groupChipMenuNext"));
  }
}
var _c4 = ["kendoGridColGroup", ""];
function ColGroupComponent_col_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-group-col", true);
  }
}
function ColGroupComponent_col_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    ɵɵclassProp("k-hierarchy-col", true);
  }
}
function ColGroupComponent_col_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("width", column_r1.width, "px");
    ɵɵclassProp("k-sorted", ctx_r1.isSorted(ctx_r1.getColumnComponent(column_r1)));
  }
}
var _c5 = ["kendoGridLoading", ""];
function LoadingComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 1);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 2)(4, "div", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.loadingText);
  }
}
function LoadingComponent_1_ng_template_0_Template(rf, ctx) {
}
function LoadingComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, LoadingComponent_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.loadingTemplate == null ? null : ctx_r0.loadingTemplate.templateRef);
  }
}
var _c6 = ["kendoGridGroupHeader", ""];
var _c7 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  templateRef: a0,
  group: a1,
  aggregates: a2,
  value: a3,
  field: a4,
  index: a5,
  expanded: a6,
  $implicit: a7
});
var _c8 = (a0, a1, a2, a3, a4, a5) => ({
  group: a0,
  aggregates: a1,
  value: a2,
  field: a3,
  index: a4,
  $implicit: a5
});
function GroupHeaderComponent_ng_container_0_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
}
function GroupHeaderComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_0_td_1_Template, 1, 0, "td", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.prefixGroupCell(ctx_r0.item));
  }
}
function GroupHeaderComponent_td_1_ng_container_2_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate2(" ", ctx_r0.groupTitle(ctx_r0.item), ": ", ɵɵpipeBind3(2, 2, ctx_r0.item.data, "value", ctx_r0.formatForGroup(ctx_r0.item)), " ");
  }
}
function GroupHeaderComponent_td_1_ng_container_2_ng_template_4_Template(rf, ctx) {
}
function GroupHeaderComponent_td_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 6);
    ɵɵlistener("click", function GroupHeaderComponent_td_1_ng_container_2_Template_a_click_1_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.toggleGroup(ctx_r0.item));
    });
    ɵɵelement(2, "kendo-icon-wrapper", 7);
    ɵɵelementEnd();
    ɵɵtemplate(3, GroupHeaderComponent_td_1_ng_container_2_ng_container_3_Template, 3, 6, "ng-container", 0)(4, GroupHeaderComponent_td_1_ng_container_2_ng_template_4_Template, 0, 0, "ng-template", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.groupButtonTitle)("aria-label", ctx_r0.groupButtonTitle);
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.arrowIcon)("svgIcon", ctx_r0.arrowSVGIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.groupHeaderTemplate(ctx_r0.item));
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction8(6, _c7, ctx_r0.groupHeaderTemplate(ctx_r0.item), ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.isExpanded, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4)(1, "p", 5);
    ɵɵtemplate(2, GroupHeaderComponent_td_1_ng_container_2_Template, 5, 15, "ng-container", 0);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", 0)("logicalSlaveCell", ctx_r0.skipGroupDecoration)("groupItem", ctx_r0.item)("colSpan", ctx_r0.logicalColSpan());
    ɵɵattribute("colspan", ctx_r0.groupSpan(ctx_r0.item))("role", ctx_r0.ariaRole())("aria-expanded", ctx_r0.isExpanded);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
  }
}
function GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template(rf, ctx) {
}
function GroupHeaderComponent_ng_container_2_td_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, GroupHeaderComponent_ng_container_2_td_1_1_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    const column_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", column_r3.groupHeaderColumnTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction6(2, _c8, ctx_r0.item.data, ctx_r0.item.data == null ? null : ctx_r0.item.data.aggregates, ctx_r0.item.data == null ? null : ctx_r0.item.data.value, ctx_r0.item.data == null ? null : ctx_r0.item.data.field, ctx_r0.item.index, ctx_r0.item.data));
  }
}
function GroupHeaderComponent_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 10);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_1_Template, 1, 9, null, 0);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex)("logicalColIndex", index_r4 + 1)("logicalSlaveCell", false)("groupItem", ctx_r0.item)("colSpan", 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r3.groupHeaderColumnTemplateRef);
  }
}
function GroupHeaderComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GroupHeaderComponent_ng_container_2_td_1_Template, 2, 6, "td", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groupHeaderColumns);
  }
}
var _c9 = ["kendoGridCell", ""];
var _c10 = (a0) => ({
  $implicit: a0
});
function CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_1_ng_container_1_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.templateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const childColumn_r2 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind3(2, 1, ctx_r0.dataItem, childColumn_r2.field, childColumn_r2.format), " ");
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_ng_container_2_ng_container_1_Template, 3, 5, "ng-container", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.childColumns);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵpipe(2, "valueOf");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ɵɵpipeBind3(2, 1, ctx_r0.dataItem, ctx_r0.column.field, ctx_r0.column.format));
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 7);
    ɵɵelement(2, "input", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵproperty("kendoGridSelectionCheckbox", ctx_r0.rowIndex);
    ɵɵattribute("id", ctx_r0.selectionCheckboxId)("aria-label", ctx_r0.selectionCheckboxLabel);
  }
}
function CellComponent_ng_container_1_ng_container_1_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-icon-wrapper", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.reorderIcon);
  }
}
function CellComponent_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_1_Template, 1, 2, null, 4)(2, CellComponent_ng_container_1_ng_container_1_ng_container_2_Template, 2, 1, "ng-container", 4)(3, CellComponent_ng_container_1_ng_container_1_ng_container_3_Template, 3, 5, "ng-container", 4)(4, CellComponent_ng_container_1_ng_container_1_ng_container_4_Template, 3, 3, "ng-container", 4)(5, CellComponent_ng_container_1_ng_container_1_ng_container_5_Template, 2, 1, "ng-container", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isSpanColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isBoundColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isCheckboxColumn && !ctx_r0.isNew);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isRowReorderColumn && !ctx_r0.isNew);
  }
}
function CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_1_ng_template_2_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.loadingTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c10, ctx_r0.column));
  }
}
function CellComponent_ng_container_1_ng_template_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 11);
  }
}
function CellComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_1_ng_template_2_0_Template, 1, 4, null, 4)(1, CellComponent_ng_container_1_ng_template_2_div_1_Template, 1, 0, "div", 10);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngIf", ctx_r0.loadingTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.loadingTemplate);
  }
}
function CellComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_1_ng_container_1_Template, 6, 5, "ng-container", 3)(2, CellComponent_ng_container_1_ng_template_2_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const loading_r3 = ɵɵreference(3);
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.showLoading)("ngIfElse", loading_r3);
  }
}
function CellComponent_ng_container_2_1_ng_template_0_Template(rf, ctx) {
}
function CellComponent_ng_container_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, CellComponent_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.editTemplateRef)("ngTemplateOutletContext", ctx_r0.editTemplateContext);
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-numerictextbox", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("format", ctx_r0.format)("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-datepicker", 16);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("format", ctx_r0.format)("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_input_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "input", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_input_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "input", 18);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("formControl", ctx_r0.formGroup.get(ctx_r0.column.field));
  }
}
function CellComponent_ng_container_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 1);
    ɵɵtemplate(1, CellComponent_ng_container_2_ng_container_2_kendo_numerictextbox_1_Template, 1, 2, "kendo-numerictextbox", 13)(2, CellComponent_ng_container_2_ng_container_2_kendo_datepicker_2_Template, 1, 2, "kendo-datepicker", 13);
    ɵɵelementStart(3, "span", 7);
    ɵɵtemplate(4, CellComponent_ng_container_2_ng_container_2_input_4_Template, 1, 1, "input", 14);
    ɵɵelementEnd();
    ɵɵtemplate(5, CellComponent_ng_container_2_ng_container_2_input_5_Template, 1, 1, "input", 15);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngSwitch", ctx_r0.column.editor);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "numeric");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "date");
    ɵɵadvance(2);
    ɵɵproperty("ngSwitchCase", "boolean");
  }
}
function CellComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, CellComponent_ng_container_2_1_Template, 1, 2, null, 4)(2, CellComponent_ng_container_2_ng_container_2_Template, 6, 4, "ng-container", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.editTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.column.editTemplateRef);
  }
}
var _c11 = ["kendoGridTableBody", ""];
var _c12 = (a0) => ({
  templateRef: a0
});
var _c13 = (a0, a1) => ({
  dataItem: a0,
  index: a1
});
var _c14 = (a0, a1, a2) => ({
  dataItem: a0,
  rowIndex: a1,
  $implicit: a2
});
var _c15 = (a0, a1, a2, a3, a4, a5) => ({
  templateRef: a0,
  group: a1,
  field: a2,
  column: a3,
  aggregates: a4,
  $implicit: a5
});
function TableBodyComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 8);
  }
}
function TableBodyComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, "td", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_0_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", 0);
  }
}
function TableBodyComponent_ng_container_0_td_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 10);
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const columnIndex_r3 = ctx.index;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("left", column_r2.sticky ? "0" : void 0);
    ɵɵclassProp("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("rowIndex", -1)("columnIndex", ctx_r0.lockedColumnsCount + columnIndex_r3)("isNew", true)("column", column_r2)("dataItem", ctx_r0.newDataItem)("ngClass", column_r2.cssClass)("ngStyle", column_r2.sticky ? ctx_r0.addStickyColumnStyles(column_r2) : column_r2.style)("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalColIndex", ctx_r0.logicalColIndex(column_r2))("colSpan", column_r2.colspan);
    ɵɵattribute("colspan", column_r2.colspan)("role", column_r2.tableCellsRole);
  }
}
function TableBodyComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "tr", 4);
    ɵɵtemplate(2, TableBodyComponent_ng_container_0_ng_container_2_Template, 2, 1, "ng-container", 0)(3, TableBodyComponent_ng_container_0_td_3_Template, 1, 2, "td", 5)(4, TableBodyComponent_ng_container_0_td_4_Template, 1, 16, "td", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("logicalRowIndex", ctx_r0.addRowLogicalIndex())("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount())("totalColumns", ctx_r0.totalColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_tr_1_2_ng_template_0_Template(rf, ctx) {
}
function TableBodyComponent_tr_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TableBodyComponent_tr_1_2_ng_template_0_Template, 0, 0, "ng-template", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c12, ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
  }
}
function TableBodyComponent_tr_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.noRecordsText, " ");
  }
}
function TableBodyComponent_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 11)(1, "td", 12);
    ɵɵtemplate(2, TableBodyComponent_tr_1_2_Template, 1, 3, null, 0)(3, TableBodyComponent_tr_1_ng_container_3_Template, 2, 1, "ng-container", 0);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("colspan", ctx_r0.colSpan);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !(ctx_r0.noRecordsTemplate == null ? null : ctx_r0.noRecordsTemplate.templateRef));
  }
}
function TableBodyComponent_ng_container_2_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 18);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r0.columns)("groups", ctx_r0.groups)("item", item_r5)("hasDetails", !!(ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef))("skipGroupDecoration", ctx_r0.skipGroupDecoration)("hasGroupHeaderColumn", ctx_r0.hasGroupHeaderColumn)("groupHeaderColumns", ctx_r0.groupHeaderColumns)("rowIndex", rowIndex_r6 + 1)("totalColumnsCount", ctx_r0.totalColumnsCount)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.groupHeaderSlaveCellsCount);
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 8);
  }
}
function TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_td_1_Template, 1, 0, "td", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 24);
    ɵɵlistener("click", function TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r7);
      const item_r5 = ɵɵnextContext(3).$implicit;
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.toggleRow(item_r5.index, item_r5.data));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r5 = ɵɵnextContext(3).$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r0.detailButtonTitle(item_r5))("aria-label", ctx_r0.detailButtonTitle(item_r5));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.detailButtonIconName(item_r5))("svgIcon", ctx_r0.detailButtonSvgIcon(item_r5));
  }
}
function TableBodyComponent_ng_container_2_tr_2_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 22);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_td_2_a_1_Template, 2, 4, "a", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("detailExpandCell", true);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate.showIf(item_r5.data, item_r5.index));
  }
}
function TableBodyComponent_ng_container_2_tr_2_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 26);
  }
  if (rf & 2) {
    const column_r8 = ctx.$implicit;
    const columnIndex_r9 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-grid-content-sticky", column_r8.sticky)("k-touch-action-none", ctx_r0.isSelectable() && ctx_r0.selectable.drag)("k-touch-action-auto", !(ctx_r0.isSelectable() && ctx_r0.selectable.drag))("k-grid-edit-cell", ctx_r0.isEditingCell(item_r5.index, column_r8))("k-selected", ctx_r0.isSelectable && ctx_r0.cellSelectionService.isCellSelected(item_r5, column_r8));
    ɵɵproperty("rowIndex", item_r5.index)("columnIndex", ctx_r0.lockedColumnsCount + columnIndex_r9)("column", column_r8)("dataItem", item_r5.data)("isLoading", ctx_r0.isLoading)("isVirtual", ctx_r0.isVirtual)("loadingTemplate", ctx_r0.cellLoadingTemplate)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r8))("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", columnIndex_r9)("colSpan", column_r8.colspan)("ngClass", column_r8.cssClass)("ngStyle", column_r8.sticky ? ctx_r0.addStickyColumnStyles(column_r8) : column_r8.style);
    ɵɵattribute("data-kendo-grid-column-index", ctx_r0.lockedColumnsCount + columnIndex_r9)("role", column_r8.tableCellsRole)("aria-selected", ctx_r0.lockedColumnsCount < 1 && ctx_r0.isSelectable() ? ctx_r0.isAriaSelected(item_r5, column_r8) : void 0)("colspan", column_r8.colspan);
  }
}
function TableBodyComponent_ng_container_2_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 19);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_2_ng_container_1_Template, 2, 1, "ng-container", 0)(2, TableBodyComponent_ng_container_2_tr_2_td_2_Template, 2, 6, "td", 20)(3, TableBodyComponent_ng_container_2_tr_2_td_3_Template, 1, 29, "td", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0.isOdd(item_r5) ? "k-alt k-table-alt-row" : "");
    ɵɵclassProp("k-grid-row-sticky", ctx_r0.rowSticky ? ctx_r0.rowSticky(ɵɵpureFunction2(25, _c13, item_r5.data, item_r5.index)) : false)("k-master-row", true)("k-grid-edit-row", ctx_r0.isEditingRow(item_r5.index))("k-selected", ctx_r0.isSelectable() && ctx_r0.isRowSelected(item_r5));
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5))("ngClass", ctx_r0.rowClass(ɵɵpureFunction2(28, _c13, item_r5.data, item_r5.index)));
    ɵɵattribute("aria-selected", ctx_r0.lockedColumnsCount < 1 ? ctx_r0.isSelectable() && ctx_r0.isRowSelected(item_r5) : void 0)("data-kendo-grid-item-index", item_r5.index);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.columns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_ng_container_2_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 32);
  }
}
function TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template(rf, ctx) {
}
function TableBodyComponent_ng_container_2_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 27);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_3_td_1_Template, 1, 0, "td", 28);
    ɵɵelement(2, "td", 29);
    ɵɵelementStart(3, "td", 30);
    ɵɵtemplate(4, TableBodyComponent_ng_container_2_tr_3_ng_template_4_Template, 0, 0, "ng-template", 31);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("k-alt", ctx_r0.isOdd(item_r5));
    ɵɵproperty("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6) + 1)("logicalSlaveRow", false)("logicalCellsCount", 1);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
    ɵɵadvance(2);
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6) + 1)("logicalColIndex", 0)("dataRowIndex", item_r5.index)("dataItem", item_r5.data)("colIndex", 0)("colSpan", ctx_r0.allColumnsSpan + 1);
    ɵɵattribute("colspan", ctx_r0.columnsSpan);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.detailTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction3(17, _c14, item_r5.data, item_r5.index, item_r5.data));
  }
}
function TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 32);
  }
}
function TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_td_1_Template, 1, 0, "td", 28);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.groups);
  }
}
function TableBodyComponent_ng_container_2_tr_4_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 9);
  }
  if (rf & 2) {
    const rowIndex_r6 = ɵɵnextContext(2).index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", 0);
  }
}
function TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template(rf, ctx) {
}
function TableBodyComponent_ng_container_2_tr_4_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 35);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_td_3_ng_template_1_Template, 0, 0, "ng-template", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r10 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalColIndex", ctx_r0.logicalColIndex(column_r10));
    ɵɵattribute("data-skip", ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction6(4, _c15, column_r10.groupFooterTemplateRef, item_r5.data, column_r10.field, column_r10, item_r5.data == null ? null : item_r5.data.aggregates, item_r5.data == null ? null : item_r5.data.aggregates));
  }
}
function TableBodyComponent_ng_container_2_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 33);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_4_ng_container_1_Template, 2, 1, "ng-container", 0)(2, TableBodyComponent_ng_container_2_tr_4_td_2_Template, 1, 2, "td", 5)(3, TableBodyComponent_ng_container_2_tr_4_td_3_Template, 2, 11, "td", 34);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    const item_r5 = ctx_r3.$implicit;
    const rowIndex_r6 = ctx_r3.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", ctx_r0.logicalRowIndex(rowIndex_r6))("logicalSlaveRow", ctx_r0.lockedColumnsCount > 0)("totalColumns", ctx_r0.totalColumns)("logicalCellsCount", ctx_r0.columns.length)("logicalSlaveCellsCount", ctx_r0.unlockedColumnsCount(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.skipGroupDecoration);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.footerColumns)("ngForTrackBy", ctx_r0.trackByColumns);
  }
}
function TableBodyComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TableBodyComponent_ng_container_2_tr_1_Template, 1, 14, "tr", 14)(2, TableBodyComponent_ng_container_2_tr_2_Template, 4, 31, "tr", 15)(3, TableBodyComponent_ng_container_2_tr_3_Template, 5, 21, "tr", 16)(4, TableBodyComponent_ng_container_2_tr_4_Template, 4, 9, "tr", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isGroup(item_r5) && ctx_r0.isParentGroupExpanded(item_r5) && ctx_r0.showGroupHeader(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDataItem(item_r5) && (!item_r5.group || ctx_r0.isDataItemInExpandedGroup(item_r5)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDataItem(item_r5) && (!item_r5.group || ctx_r0.isDataItemInExpandedGroup(item_r5)) && (ctx_r0.detailTemplate == null ? null : ctx_r0.detailTemplate.templateRef) && ctx_r0.detailTemplate.showIf(item_r5.data, item_r5.index) && ctx_r0.isExpanded(item_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isFooter(item_r5) && item_r5.group && (ctx_r0.isFooterItemInExpandedGroup(item_r5) || ctx_r0.showGroupFooters && ctx_r0.isParentGroupExpanded(item_r5.group)) && !item_r5.data.hideFooter);
  }
}
function TableBodyComponent_kendo_resize_sensor_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 36);
    ɵɵlistener("resize", function TableBodyComponent_kendo_resize_sensor_3_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var _c16 = ["*"];
function StringFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function StringFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-string-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function NumericFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function NumericFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("format", ctx_r1.format)("decimals", ctx_r1.decimals)("spinners", ctx_r1.spinners)("min", ctx_r1.min)("max", ctx_r1.max)("step", ctx_r1.step)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function DateFilterMenuComponent_kendo_dropdownlist_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3);
    ɵɵlistener("valueChange", function DateFilterMenuComponent_kendo_dropdownlist_1_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.logicChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("filterMenuDropDownLabel", ctx_r1.filterMenuDropDownLabel)("data", ctx_r1.logicOperators)("valuePrimitive", true)("value", ctx_r1.filter == null ? null : ctx_r1.filter.logic);
  }
}
function DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-date-filter-menu-input", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("operators", ctx_r1.operators)("currentFilter", ctx_r1.secondFilter)("filterService", ctx_r1.filterService)("column", ctx_r1.column)("filter", ctx_r1.filter)("activeView", ctx_r1.activeView)("bottomView", ctx_r1.bottomView)("topView", ctx_r1.topView)("format", ctx_r1.format)("formatPlaceholder", ctx_r1.formatPlaceholder)("placeholder", ctx_r1.placeholder)("min", ctx_r1.min)("max", ctx_r1.max)("weekNumber", ctx_r1.weekNumber)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function BooleanFilterMenuComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "input", 3, 0);
    ɵɵlistener("change", function BooleanFilterMenuComponent_li_1_Template_input_change_1_listener() {
      const item_r2 = ɵɵrestoreView(_r1).$implicit;
      const input_r3 = ɵɵreference(2);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onChange(item_r2.value, input_r3));
    })("keydown.shift.tab", function BooleanFilterMenuComponent_li_1_Template_input_keydown_shift_tab_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.onShiftTab($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("columnLabel", ctx_r3.columnLabel)("name", ctx_r3.idPrefix)("checked", ctx_r3.isSelected(item_r2.value));
    ɵɵattribute("id", ctx_r3.radioId(item_r2.value));
    ɵɵadvance(2);
    ɵɵattribute("for", ctx_r3.radioId(item_r2.value));
    ɵɵadvance();
    ɵɵtextInterpolate(item_r2.text);
  }
}
var _c17 = ["resetButton"];
var _c18 = ["filterButton"];
function FilterMenuContainerComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("filterService", ctx_r1.childService)("column", ctx_r1.column)("filter", ctx_r1.childFilter)("menuTabbingService", ctx_r1.menuTabbingService);
  }
}
function FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template(rf, ctx) {
}
function FilterMenuContainerComponent_ng_container_4_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterMenuContainerComponent_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.column.filterMenuTemplateRef)("ngTemplateOutletContext", ctx_r1.templateContext);
  }
}
function FilterMenuContainerComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FilterMenuContainerComponent_ng_container_4_1_Template, 1, 2, null, 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.column.filterMenuTemplateRef);
  }
}
var _c19 = ["anchor"];
var _c20 = ["template"];
function FilterMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 4);
    ɵɵlistener("close", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.escape", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close());
    })("keydown.enter", function FilterMenuComponent_ng_template_3_Template_kendo_grid_filter_menu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r4.column)("filter", ctx_r4.filter);
  }
}
var _c21 = ["applyButton"];
function ColumnListComponent_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵelement(1, "input", 6);
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const index_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("kendoColumnMenuChooserItemChecked", !column_r1.hidden);
    ɵɵadvance();
    ɵɵproperty("checked", !column_r1.hidden)("disabled", ctx_r2.isDisabled(column_r1));
    ɵɵattribute("data-index", index_r2)("aria-hidden", true);
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r1.displayTitle);
  }
}
function ColumnListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 8)(1, "button", 9, 0);
    ɵɵlistener("click", function ColumnListComponent_div_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.applyChanges());
    })("keydown.enter", function ColumnListComponent_div_2_Template_button_keydown_enter_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation;
      return ɵɵresetView(ctx_r2.applyChanges());
    })("keydown.space", function ColumnListComponent_div_2_Template_button_keydown_space_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation;
      return ɵɵresetView(ctx_r2.applyChanges());
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 10, 1);
    ɵɵlistener("keydown.tab", function ColumnListComponent_div_2_Template_button_keydown_tab_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.onTab($event));
    })("click", function ColumnListComponent_div_2_Template_button_click_4_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.cancelChanges());
    })("keydown.enter", function ColumnListComponent_div_2_Template_button_keydown_enter_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation;
      return ɵɵresetView(ctx_r2.cancelChanges());
    })("keydown.space", function ColumnListComponent_div_2_Template_button_keydown_space_4_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      $event.preventDefault();
      $event.stopPropagation;
      return ɵɵresetView(ctx_r2.cancelChanges());
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.actionsClass);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r2.applyText);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r2.resetText);
  }
}
function ColumnMenuItemComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵelementContainer(1, 4);
    ɵɵelement(2, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("overflow", "hidden");
    ɵɵproperty("@state", ctx_r0.contentState);
    ɵɵattribute("id", ctx_r0.contentId);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.contentTemplate.templateRef);
  }
}
function ColumnMenuChooserComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnlist", 2);
    ɵɵlistener("apply", function ColumnMenuChooserComponent_ng_template_1_Template_kendo_grid_columnlist_apply_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onApply($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("applyText", ctx_r1.ctx.localization.get("columnsApply"))("resetText", ctx_r1.ctx.localization.get("columnsReset"))("ariaLabel", ctx_r1.ctx.localization.get("columns"))("columns", ctx_r1.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r1.actionsClass)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded)("service", ctx_r1.service);
  }
}
function ColumnMenuFilterComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 2);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuFilterComponent_ng_template_1_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("column", ctx_r1.service.column)("menuTabbingService", ctx_r1.service.menuTabbingService)("filter", ctx_r1.service.filter)("actionsClass", ctx_r1.actionsClass)("isLast", ctx_r1.isLast)("isExpanded", ctx_r1.expanded);
  }
}
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-lock", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template_kendo_grid_columnmenu_lock_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, !ctx_r1.showStick));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-stick", 3);
    ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template_kendo_grid_columnmenu_stick_keydown_tab_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onTab($event, true));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r1.service);
  }
}
function ColumnMenuPositionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_lock_0_Template, 1, 1, "kendo-grid-columnmenu-lock", 2)(1, ColumnMenuPositionComponent_ng_template_1_kendo_grid_columnmenu_stick_1_Template, 1, 1, "kendo-grid-columnmenu-stick", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.showLock);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showStick);
  }
}
function ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeColumn());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeThisColumn"))("svgIcon", ctx_r1.maxWidthIcon);
  }
}
function ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-item", 1);
    ɵɵlistener("itemClick", function ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.autoSizeAllColumns());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r1.ctx.localization.get("autosizeAllColumns"))("svgIcon", ctx_r1.displayInlineFlexIcon);
  }
}
var _c22 = ["tabbedInterfaceTemplate"];
var _c23 = (a0) => ({
  "k-active": a0
});
var _c24 = (a0, a1) => ({
  service: a0,
  column: a1
});
function ColumnMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_3_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const defaultTemplate_r6 = ɵɵreference(6);
    const tabbedInterfaceTemplate_r7 = ɵɵreference(8);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r4.column.columnMenuTemplateRef || ctx_r4.columnMenuTemplate || (ctx_r4.settings.view === "tabbed" ? tabbedInterfaceTemplate_r7 : defaultTemplate_r6))("ngTemplateOutletContext", ɵɵpureFunction2(2, _c24, ctx_r4.service, ctx_r4.column));
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 23, 4);
  }
  if (rf & 2) {
    const sortItem_r9 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r9)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 23, 5);
  }
  if (rf & 2) {
    const lockItem_r10 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r10)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 23, 6);
  }
  if (rf & 2) {
    const stickItem_r11 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r11)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 24, 7);
  }
  if (rf & 2) {
    const positionItem_r12 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r12)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_5_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-chooser", 26, 8);
  }
  if (rf & 2) {
    const chooserItem_r13 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", chooserItem_r13)("service", ctx_r4.service)("expanded", ctx_r4.expandedColumns);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 27, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r14 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r14)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 28, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r15 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r15);
  }
}
function ColumnMenuComponent_ng_template_5_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-filter", 26, 11);
  }
  if (rf & 2) {
    const filterItem_r16 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("kendoGridColumnMenuItem", filterItem_r16)("service", ctx_r4.service)("expanded", ctx_r4.expandedFilter);
  }
}
function ColumnMenuComponent_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnmenu-container", 15);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_escape_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    })("keydown.enter", function ColumnMenuComponent_ng_template_5_Template_kendo_grid_columnmenu_container_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_sort_1_Template, 2, 2, "kendo-grid-columnmenu-sort", 17)(2, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_lock_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17)(3, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_stick_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17)(4, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_position_4_Template, 2, 5, "kendo-grid-columnmenu-position", 18)(5, ColumnMenuComponent_ng_template_5_span_5_Template, 1, 2, "span", 19)(6, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_chooser_6_Template, 2, 3, "kendo-grid-columnmenu-chooser", 20)(7, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21)(8, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22)(9, ColumnMenuComponent_ng_template_5_span_9_Template, 1, 2, "span", 19)(10, ColumnMenuComponent_ng_template_5_kendo_grid_columnmenu_filter_10_Template, 2, 3, "kendo-grid-columnmenu-filter", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasFilter);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 33);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.filterIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuFilterTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-filter-menu-container", 34);
    ɵɵlistener("keydown.shift.tab", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_keydown_shift_tab_0_listener($event) {
      ɵɵrestoreView(_r18);
      return ɵɵresetView($event.stopImmediatePropagation());
    })("close", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template_kendo_grid_filter_menu_container_close_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("column", ctx_r4.service.column)("menuTabbingService", ctx_r4.service.menuTabbingService)("filter", ctx_r4.service.filter)("actionsClass", ctx_r4.actionsClass);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_ng_template_2_Template, 1, 4, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 35);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.slidersIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuGeneralTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-sort", 23, 4);
  }
  if (rf & 2) {
    const sortItem_r19 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", sortItem_r19)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-lock", 23, 5);
  }
  if (rf & 2) {
    const lockItem_r20 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", lockItem_r20)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-stick", 23, 6);
  }
  if (rf & 2) {
    const stickItem_r21 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("kendoGridColumnMenuItem", stickItem_r21)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-position", 24, 7);
  }
  if (rf & 2) {
    const positionItem_r22 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("showLock", ctx_r4.hasLock)("showStick", ctx_r4.hasStick)("kendoGridColumnMenuItem", positionItem_r22)("service", ctx_r4.service)("expanded", ctx_r4.expandedPosition);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 25);
  }
  if (rf & 2) {
    ɵɵstyleProp("border-color", "rgba(0, 0, 0, 0.08)");
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-column", 27, 9);
  }
  if (rf & 2) {
    const autoSizeColumnItem_r23 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeColumnItem_r23)("column", ctx_r4.column);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-columnmenu-autosize-all-columns", 28, 10);
  }
  if (rf & 2) {
    const autoSizeAllColumnsItem_r24 = ɵɵreference(1);
    const ctx_r4 = ɵɵnextContext(4);
    ɵɵproperty("service", ctx_r4.service)("kendoGridColumnMenuItem", autoSizeAllColumnsItem_r24);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_sort_0_Template, 2, 2, "kendo-grid-columnmenu-sort", 17)(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_1_Template, 1, 2, "span", 19)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_lock_2_Template, 2, 2, "kendo-grid-columnmenu-lock", 17)(3, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_stick_3_Template, 2, 2, "kendo-grid-columnmenu-stick", 17)(4, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_4_Template, 1, 2, "span", 19)(5, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_position_5_Template, 2, 5, "kendo-grid-columnmenu-position", 18)(6, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_span_6_Template, 1, 2, "span", 19)(7, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_column_7_Template, 2, 3, "kendo-grid-columnmenu-autosize-column", 21)(8, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_kendo_grid_columnmenu_autosize_all_columns_8_Template, 2, 2, "kendo-grid-columnmenu-autosize-all-columns", 22);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("ngIf", ctx_r4.hasSort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasSort && (ctx_r4.hasLock || ctx_r4.hasStick || ctx_r4.hasPosition || ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasLock && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasStick && !ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r4.hasLock || ctx_r4.hasStick) && !ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasPosition && (ctx_r4.hasAutoSizeColumn || ctx_r4.hasAutoSizeAllColumns));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeColumn);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasAutoSizeAllColumns);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_ng_template_2_Template, 9, 9, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 36);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r4.columnsIcon);
    ɵɵattribute("title", ctx_r4.ctx.localization.get("columnMenuColumnsTabTitle"));
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-columnlist", 37);
    ɵɵlistener("apply", function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template_kendo_grid_columnlist_apply_0_listener($event) {
      ɵɵrestoreView(_r25);
      const ctx_r4 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r4.onApply($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(3);
    ɵɵproperty("applyText", ctx_r4.ctx.localization.get("columnsApply"))("resetText", ctx_r4.ctx.localization.get("columnsReset"))("columns", ctx_r4.columns)("autoSync", false)("allowHideAll", false)("actionsClass", ctx_r4.actionsClass)("service", ctx_r4.service);
  }
}
function ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "kendo-tabstrip-tab");
    ɵɵtemplate(1, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_1_Template, 1, 2, "ng-template", 31)(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_ng_template_2_Template, 1, 7, "ng-template", 32);
    ɵɵelementEnd();
  }
}
function ColumnMenuComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-tabstrip", 29, 12);
    ɵɵlistener("keydown.escape", function ColumnMenuComponent_ng_template_7_Template_kendo_tabstrip_keydown_escape_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.close(true));
    });
    ɵɵtemplate(2, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_2_Template, 3, 0, "kendo-tabstrip-tab", 30)(3, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_3_Template, 3, 0, "kendo-tabstrip-tab", 30)(4, ColumnMenuComponent_ng_template_7_kendo_tabstrip_tab_4_Template, 3, 0, "kendo-tabstrip-tab", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.hasFilter);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.showGeneralTab);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.hasColumnChooser);
  }
}
var _c25 = ["dropdown"];
var _c26 = () => ({
  width: "auto"
});
function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dropdownlist", 3, 0);
    ɵɵlistener("valueChange", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_valueChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChange($event));
    })("keydown", function FilterCellOperatorsComponent_kendo_dropdownlist_0_Template_kendo_dropdownlist_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.dropdownKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("data", ctx_r1.operators)("value", ctx_r1.value)("svgIcon", ctx_r1.filterSVGIcon)("valuePrimitive", true)("popupSettings", ɵɵpureFunction0(7, _c26))("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.column && ctx_r1.columnLabel);
  }
}
function FilterCellOperatorsComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function FilterCellOperatorsComponent_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearClick());
    })("keydown", function FilterCellOperatorsComponent_button_1_Template_button_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.filterClearIcon)("title", ctx_r1.clearText)("size", ctx_r1.size);
  }
}
var _c27 = ["kendoGridFilterCell", ""];
function FilterCellComponent_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("column", ctx_r0.column)("filter", ctx_r0.filter);
  }
}
function FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template(rf, ctx) {
}
function FilterCellComponent_ng_container_0_ng_container_3_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, FilterCellComponent_ng_container_0_ng_container_3_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.column.filterCellTemplateRef)("ngTemplateOutletContext", ctx_r0.templateContext);
  }
}
function FilterCellComponent_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, FilterCellComponent_ng_container_0_ng_container_3_1_Template, 1, 2, null, 0);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.column.filterCellTemplateRef);
  }
}
function FilterCellComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0)(1, 1);
    ɵɵtemplate(2, FilterCellComponent_ng_container_0_ng_container_2_Template, 2, 2, "ng-container", 2)(3, FilterCellComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 2);
    ɵɵelementContainerEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngSwitch", ctx_r0.hasTemplate);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", false);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
  }
}
var _c28 = ["kendoGridFilterRow", ""];
function FilterRowComponent_td_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
  if (rf & 2) {
    ɵɵclassProp("k-group-cell", true);
  }
}
function FilterRowComponent_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 3);
  }
  if (rf & 2) {
    ɵɵclassProp("k-hierarchy-cell", true);
  }
}
function FilterRowComponent_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const columnIndex_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-grid-header-sticky", column_r1.sticky);
    ɵɵproperty("ngStyle", ctx_r2.addStickyStyles(column_r1))("ngClass", column_r1.filterClass)("column", column_r1)("filter", ctx_r2.filter)("logicalRowIndex", ctx_r2.logicalRowIndex)("logicalColIndex", ctx_r2.getLogicalColIndex(columnIndex_r2));
    ɵɵattribute("aria-label", ctx_r2.filterLabel(column_r1));
  }
}
var _c29 = ["kendoGridHeader", ""];
var _c30 = (a0, a1, a2, a3) => ({
  field: a0,
  type: "column",
  column: a1,
  hint: a2,
  lastColumn: a3
});
var _c31 = (a0, a1, a2, a3) => ({
  templateRef: a0,
  columnIndex: a1,
  column: a2,
  $implicit: a3
});
var _c32 = (a0, a1, a2) => ({
  type: "columnGroup",
  column: a0,
  hint: a1,
  lastColumn: a2
});
function HeaderComponent_tr_1_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 7);
  }
}
function HeaderComponent_tr_1_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "th", 8);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 20);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 21);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 14)(2, "span", 15);
    ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_template_3_Template, 0, 0, "ng-template", 16)(4, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_ng_container_4_Template, 3, 1, "ng-container", 12);
    ɵɵelementEnd();
    ɵɵtemplate(5, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_filter_menu_5_Template, 1, 3, "kendo-grid-filter-menu", 17)(6, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_kendo_grid_column_menu_6_Template, 1, 8, "kendo-grid-column-menu", 18);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("templateContext", ɵɵpureFunction4(4, _c31, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template(rf, ctx) {
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 26);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵpropertyInterpolate1("name", "sort-", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir, "-small");
    ɵɵproperty("svgIcon", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir === "asc" ? ctx_r2.sortAscSmallIcon : ctx_r2.sortDescSmallIcon);
    ɵɵattribute("aria-label", ctx_r2.sortableLabel);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 27);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.sortOrder(ctx_r2.getColumnComponent(column_r2).field));
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-filter-menu", 20);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", ctx_r2.getColumnComponent(column_r2))("filter", ctx_r2.filter)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 21);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(3).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate)("sort", ctx_r2.sort)("filter", ctx_r2.filter)("sortable", ctx_r2.sortable)("tabIndex", ctx_r2.tabIndex);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 14)(2, "span", 22, 0);
    ɵɵlistener("click", function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template_span_click_2_listener($event) {
      ɵɵrestoreView(_r4);
      const link_r5 = ɵɵreference(3);
      const column_r2 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onSortClick(ctx_r2.getColumnComponent(column_r2), $event, link_r5));
    });
    ɵɵtemplate(4, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_template_4_Template, 0, 0, "ng-template", 16)(5, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_ng_container_5_Template, 3, 1, "ng-container", 12);
    ɵɵelementStart(6, "span", 23);
    ɵɵtemplate(7, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_icon_wrapper_7_Template, 1, 4, "kendo-icon-wrapper", 24);
    ɵɵelementEnd();
    ɵɵtemplate(8, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_span_8_Template, 2, 1, "span", 25);
    ɵɵelementEnd();
    ɵɵtemplate(9, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_filter_menu_9_Template, 1, 3, "kendo-grid-filter-menu", 17)(10, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_kendo_grid_column_menu_10_Template, 1, 8, "kendo-grid-column-menu", 18);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance(4);
    ɵɵproperty("templateContext", ɵɵpureFunction4(6, _c31, column_r2.headerTemplateRef, column_r2.leafIndex, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.sortDescriptor(ctx_r2.getColumnComponent(column_r2).field).dir);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showSortNumbering(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 28);
    ɵɵelement(2, "input", 29);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵadvance(2);
    ɵɵattribute("id", ctx_r2.selectAllCheckboxId())("aria-label", ctx_r2.selectAllCheckboxLabel);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 30);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 11);
    ɵɵlistener("keydown", function HeaderComponent_tr_1_ng_container_3_th_1_Template_th_keydown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const column_r2 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onHeaderKeydown(ctx_r2.getColumnComponent(column_r2), $event));
    });
    ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_1_Template, 7, 9, "ng-container", 12)(2, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_2_Template, 11, 11, "ng-container", 12)(3, HeaderComponent_tr_1_ng_container_3_th_1_ng_container_3_Template, 3, 2, "ng-container", 12)(4, HeaderComponent_tr_1_ng_container_3_th_1_span_4_Template, 1, 2, "span", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const columnIndex_r7 = ctx_r5.index;
    const last_r8 = ctx_r5.last;
    const levelIndex_r9 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-sorted", !!ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("k-filterable", ctx_r2.showFilterMenu && ctx_r2.isFilterable(ctx_r2.getColumnComponent(column_r2)) || ctx_r2.showColumnMenu(column_r2))("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), columnIndex_r7))("k-grid-header-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("colSpan", column_r2.colspan)("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction4(27, _c30, ctx_r2.getColumnComponent(column_r2).field, column_r2, column_r2.title || ctx_r2.getColumnComponent(column_r2).field, last_r8 && columnIndex_r7 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.sticky ? ctx_r2.addStickyStyles(column_r2) : column_r2.headerStyle);
    ɵɵattribute("aria-sort", ctx_r2.sortState(ctx_r2.getColumnComponent(column_r2)))("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan)("aria-haspopup", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? "dialog" : void 0)("aria-expanded", ctx_r2.isNavigable && (ctx_r2.showFilterMenu || ctx_r2.showColumnMenu(column_r2)) ? false : void 0)("aria-keyshortcuts", ctx_r2.isNavigable ? "Alt + ArrowDown" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.isSortable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isSortable(ctx_r2.getColumnComponent(column_r2)));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isCheckboxColumn(column_r2) && !column_r2.headerTemplateRef && column_r2.showSelectAll);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resizable);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_2_ng_template_3_Template(rf, ctx) {
}
function HeaderComponent_tr_1_ng_container_3_th_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    ɵɵadvance(2);
    ɵɵtextInterpolate(column_r2.displayTitle);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_2_kendo_grid_column_menu_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-column-menu", 34);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("standalone", false)("settings", ctx_r2.columnMenuSettings)("column", column_r2)("columnMenuTemplate", ctx_r2.columnMenuTemplate);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 30);
  }
  if (rf & 2) {
    const column_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("column", column_r2)("columns", ctx_r2.columns);
  }
}
function HeaderComponent_tr_1_ng_container_3_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 31)(1, "span", 14)(2, "span", 32);
    ɵɵtemplate(3, HeaderComponent_tr_1_ng_container_3_th_2_ng_template_3_Template, 0, 0, "ng-template", 16)(4, HeaderComponent_tr_1_ng_container_3_th_2_ng_container_4_Template, 3, 1, "ng-container", 12);
    ɵɵelementEnd();
    ɵɵtemplate(5, HeaderComponent_tr_1_ng_container_3_th_2_kendo_grid_column_menu_5_Template, 1, 4, "kendo-grid-column-menu", 33);
    ɵɵelementEnd();
    ɵɵtemplate(6, HeaderComponent_tr_1_ng_container_3_th_2_span_6_Template, 1, 2, "span", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const column_r2 = ctx_r5.$implicit;
    const columnIndex_r7 = ctx_r5.index;
    const last_r8 = ctx_r5.last;
    const levelIndex_r9 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("k-first", ctx_r2.isFirstOnRow(ctx_r2.getColumnComponent(column_r2), columnIndex_r7))("k-filterable", ctx_r2.showColumnMenu(column_r2))("k-grid-content-sticky", column_r2.sticky);
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalColIndex", ctx_r2.logicalColumnIndex(column_r2))("rowSpan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colSpan", column_r2.colspan)("headerLabelText", column_r2.title || ctx_r2.getColumnComponent(column_r2).field)("enableDrag", ctx_r2.shouldActivate(column_r2))("context", ɵɵpureFunction3(21, _c32, column_r2, column_r2.title, last_r8 && columnIndex_r7 === 0))("ngClass", column_r2.headerClass)("ngStyle", column_r2.headerStyle);
    ɵɵattribute("rowspan", column_r2.rowspan(ctx_r2.totalColumnLevels))("colspan", column_r2.colspan);
    ɵɵadvance(3);
    ɵɵproperty("templateContext", ɵɵpureFunction4(25, _c31, column_r2.headerTemplateRef, ctx_r2.lockedColumnsCount + columnIndex_r7, column_r2, column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r2.headerTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showColumnMenu(column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resizable);
  }
}
function HeaderComponent_tr_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, HeaderComponent_tr_1_ng_container_3_th_1_Template, 5, 32, "th", 9)(2, HeaderComponent_tr_1_ng_container_3_th_2_Template, 7, 30, "th", 10);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.isColumnGroupComponent(column_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.isColumnGroupComponent(column_r2));
  }
}
function HeaderComponent_tr_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 3);
    ɵɵtemplate(1, HeaderComponent_tr_1_th_1_Template, 1, 0, "th", 4)(2, HeaderComponent_tr_1_th_2_Template, 1, 0, "th", 5)(3, HeaderComponent_tr_1_ng_container_3_Template, 3, 2, "ng-container", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const levelIndex_r9 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("logicalRowIndex", levelIndex_r9)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.groups);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.detailTemplate == null ? null : ctx_r2.detailTemplate.templateRef);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.columnsForLevel(levelIndex_r9))("ngForTrackBy", ctx_r2.trackByIndex);
  }
}
function HeaderComponent_tr_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 35);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("columns", ctx_r2.leafColumns)("filter", ctx_r2.filter)("groups", ctx_r2.groups)("detailTemplate", ctx_r2.detailTemplate)("lockedColumnsCount", ctx_r2.lockedColumnsCount)("logicalRowIndex", ctx_r2.totalColumnLevels + 1)("logicalSlaveRow", ctx_r2.lockedColumnsCount > 0)("logicalCellsCount", ctx_r2.columns.length)("logicalSlaveCellsCount", ctx_r2.unlockedColumnsCount)("totalColumns", ctx_r2.totalColumns);
  }
}
var _c33 = ["kendoGridFooter", ""];
function FooterComponent_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 4);
  }
}
function FooterComponent_td_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "td", 5);
  }
}
function FooterComponent_td_4_ng_template_1_Template(rf, ctx) {
}
function FooterComponent_td_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 6);
    ɵɵtemplate(1, FooterComponent_td_4_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("k-grid-footer-sticky", column_r1.sticky);
    ɵɵproperty("logicalRowIndex", ctx_r1.logicalRowIndex)("logicalColIndex", ctx_r1.logicalColumnIndex(column_r1))("ngClass", column_r1.footerClass)("ngStyle", column_r1.sticky ? ctx_r1.addStickyStyles(column_r1) : column_r1.footerStyle);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction4(7, _c31, column_r1.footerTemplateRef, column_r1.leafIndex, column_r1, column_r1));
  }
}
var _c34 = ["select"];
var _c35 = ["numbers"];
var _c36 = (a0, a1) => ({
  "k-picker-sm": a0,
  "k-picker-md": a1
});
var _c37 = (a0) => ({
  "k-selected": a0
});
function PagerNumericButtonsComponent_option_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 10);
    ɵɵtext(1, "... ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("selected", false);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.start - 1));
  }
}
function PagerNumericButtonsComponent_option_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const num_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("value", num_r3.toString())("selected", num_r3 === ctx_r1.currentPage)("ngClass", ɵɵpureFunction1(6, _c37, ctx_r1.currentPage === num_r3));
    ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r3))("aria-current", ctx_r1.currentPage === num_r3 ? "page" : void 0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", num_r3, " ");
  }
}
function PagerNumericButtonsComponent_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 12);
    ɵɵtext(1, "... ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("selected", false);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.end + 1));
  }
}
function PagerNumericButtonsComponent_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_7_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.start - 2));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.start - 1))("title", ctx_r1.pageLabel(ctx_r1.start - 1));
  }
}
function PagerNumericButtonsComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 14);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_8_Template_button_click_0_listener() {
      const num_r6 = ɵɵrestoreView(_r5).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(num_r6 - 1));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const num_r6 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size)("selected", ctx_r1.currentPage === num_r6);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(num_r6))("title", ctx_r1.pageLabel(num_r6))("aria-current", ctx_r1.currentPage === num_r6 ? "page" : void 0);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", num_r6, " ");
  }
}
function PagerNumericButtonsComponent_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function PagerNumericButtonsComponent_button_9_Template_button_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changePage(ctx_r1.end));
    });
    ɵɵtext(1, "...");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r1.size);
    ɵɵattribute("aria-label", ctx_r1.pageLabel(ctx_r1.end + 1))("title", ctx_r1.pageLabel(ctx_r1.end + 1));
  }
}
var _c38 = (a0, a1) => ({
  keydown: a0,
  focusout: a1
});
function PagerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("focusin", function PagerComponent_div_0_Template_div_focusin_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onInnerFocusIn($event, "start"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.focusTrapTabIndex);
    ɵɵattribute("aria-hidden", true);
  }
}
function PagerComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.template.templateRef)("ngTemplateOutletContext", ctx_r1.templateContext);
  }
}
function PagerComponent_ng_container_2_kendo_pager_prev_buttons_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-prev-buttons", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function PagerComponent_ng_container_2_kendo_pager_numeric_buttons_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-numeric-buttons", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("buttonCount", ctx_r1.settings.buttonCount);
  }
}
function PagerComponent_ng_container_2_kendo_pager_input_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-input", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function PagerComponent_ng_container_2_kendo_pager_next_buttons_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-next-buttons", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size);
  }
}
function PagerComponent_ng_container_2_kendo_pager_info_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-info");
  }
}
function PagerComponent_ng_container_2_kendo_pager_page_sizes_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-pager-page-sizes", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("size", ctx_r1.size)("pageSizes", ctx_r1.settings.pageSizes);
  }
}
function PagerComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 6);
    ɵɵtemplate(2, PagerComponent_ng_container_2_kendo_pager_prev_buttons_2_Template, 1, 1, "kendo-pager-prev-buttons", 7)(3, PagerComponent_ng_container_2_kendo_pager_numeric_buttons_3_Template, 1, 2, "kendo-pager-numeric-buttons", 8)(4, PagerComponent_ng_container_2_kendo_pager_input_4_Template, 1, 1, "kendo-pager-input", 7)(5, PagerComponent_ng_container_2_kendo_pager_next_buttons_5_Template, 1, 1, "kendo-pager-next-buttons", 7);
    ɵɵelementEnd();
    ɵɵtemplate(6, PagerComponent_ng_container_2_kendo_pager_info_6_Template, 1, 0, "kendo-pager-info", 2)(7, PagerComponent_ng_container_2_kendo_pager_page_sizes_7_Template, 1, 2, "kendo-pager-page-sizes", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.settings.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.settings.type === "numeric");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.settings.type === "input");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.settings.previousNext);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.settings.info);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.settings.pageSizes);
  }
}
function PagerComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("focusin", function PagerComponent_div_3_Template_div_focusin_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onInnerFocusIn($event, "end"));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.focusTrapTabIndex);
    ɵɵattribute("aria-hidden", true);
  }
}
function PagerComponent_kendo_resize_sensor_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 13);
    ɵɵlistener("resize", function PagerComponent_kendo_resize_sensor_4_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resizeHandler());
    });
    ɵɵelementEnd();
  }
}
var _c39 = ["container"];
var _c40 = ["lockedContainer"];
var _c41 = ["lockedTable"];
var _c42 = ["table"];
var _c43 = () => [];
var _c44 = (a0, a1, a2, a3) => ({
  keydown: a0,
  scroll: a1,
  mousewheel: a2,
  DOMMouseScroll: a3
});
function ListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13, 2)(2, "div", 6)(3, "table", 14, 3);
    ɵɵelement(5, "colgroup", 8)(6, "tbody", 15);
    ɵɵelementEnd();
    ɵɵelement(7, "kendo-resize-sensor");
    ɵɵelementEnd();
    ɵɵelementStart(8, "div", 11);
    ɵɵelement(9, "div");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction4(31, _c44, ctx_r0.lockedKeydown, ctx_r0.lockedScroll, ctx_r0.lockedMousewheel, ctx_r0.lockedMousewheel))("scope", ctx_r0);
    ɵɵadvance(3);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r0.size);
    ɵɵadvance(2);
    ɵɵproperty("groups", ctx_r0.groups)("columns", ctx_r0.lockedLeafColumns)("detailTemplate", ctx_r0.detailTemplate)("sort", ctx_r0.sort);
    ɵɵadvance();
    ɵɵproperty("groups", ctx_r0.groups)("isLocked", true)("data", ctx_r0.data)("noRecordsText", "")("columns", ctx_r0.lockedLeafColumns)("totalColumnsCount", ctx_r0.leafColumns.length)("totalColumns", ctx_r0.columns)("detailTemplate", ctx_r0.detailTemplate)("showGroupFooters", ctx_r0.showFooter)("skip", ctx_r0.skip)("selectable", ctx_r0.selectable)("trackBy", ctx_r0.trackBy)("filterable", ctx_r0.filterable)("rowClass", ctx_r0.rowClass)("isLoading", ctx_r0.loading)("isVirtual", ctx_r0.isVirtual)("cellLoadingTemplate", ctx_r0.cellLoadingTemplate);
    ɵɵadvance(3);
    ɵɵstyleProp("height", ctx_r0.totalHeight, "px");
  }
}
function ListComponent_kendo_resize_sensor_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_kendo_resize_sensor_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-resize-sensor");
  }
}
function ListComponent_div_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r0.totalWidth, "px");
  }
}
function ToolbarComponent_0_ng_template_0_Template(rf, ctx) {
}
function ToolbarComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ToolbarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.toolbarTemplateRef)("ngTemplateOutletContext", ctx_r0.context);
  }
}
var _c45 = (a0) => ({
  aggregates: a0
});
function StatusBarComponent_0_ng_template_0_Template(rf, ctx) {
}
function StatusBarComponent_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StatusBarComponent_0_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.statusBarTemplate == null ? null : ctx_r0.statusBarTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c45, ctx_r0.aggregates));
  }
}
var _c46 = ["lockedHeader"];
var _c47 = ["header"];
var _c48 = ["ariaRoot"];
var _c49 = ["footer"];
var _c50 = (a0) => ({
  hintTemplate: a0
});
function GridComponent_kendo_grid_toolbar_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r0.size)("navigable", ctx_r0.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r0.messageFor("topToolbarLabel"))("aria-controls", ctx_r0.ariaRootId);
  }
}
function GridComponent_kendo_pager_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 18);
    ɵɵlistener("pageChange", function GridComponent_kendo_pager_3_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.notifyPageChange("pager", $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r0.navigation.pagerEnabled ? "0" : "-1")("template", ctx_r0.pagerTemplate)("pageSize", ctx_r0.pageSize)("total", ctx_r0.view.total)("skip", ctx_r0.skip)("size", ctx_r0.size)("options", ctx_r0.pageable);
    ɵɵattribute("role", ctx_r0.navigation.pagerEnabled ? "application" : void 0);
  }
}
function GridComponent_kendo_grid_group_panel_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-grid-group-panel", 19);
    ɵɵlistener("change", function GridComponent_kendo_grid_group_panel_4_Template_kendo_grid_group_panel_change_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.groupChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("navigable", ctx_r0.navigation.toolbarEnabled)("text", ctx_r0.groupableEmptyText)("groups", ctx_r0.group);
    ɵɵattribute("aria-label", ctx_r0.messageFor("groupPanelLabel"))("aria-controls", ctx_r0.ariaRootId);
  }
}
function GridComponent_ng_container_7_div_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 30, 3)(2, "table", 31);
    ɵɵelement(3, "colgroup", 27)(4, "thead", 32);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r0.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r0.lockedLeafColumns)("groups", ctx_r0.group)("detailTemplate", ctx_r0.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r0.resizable)("scrollable", true)("columns", ctx_r0.lockedColumns)("totalColumnLevels", ctx_r0.totalColumnLevels)("sort", ctx_r0.sort)("groups", ctx_r0.group)("filter", ctx_r0.filter)("filterable", ctx_r0.filterable)("groupable", ctx_r0.showGroupPanel)("reorderable", ctx_r0.reorderable)("sortable", ctx_r0.sortable)("columnMenu", ctx_r0.columnMenuOptions)("columnMenuTemplate", ctx_r0.columnMenuTemplate)("totalColumnsCount", ctx_r0.leafColumns.length)("totalColumns", ctx_r0.columnsContainer)("detailTemplate", ctx_r0.detailTemplate)("tabIndex", ctx_r0.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_ng_container_7_div_1_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r0.columnsContainer.unlockedWidth, "px");
  }
}
function GridComponent_ng_container_7_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 23);
    ɵɵtemplate(1, GridComponent_ng_container_7_div_1_div_1_Template, 5, 26, "div", 24);
    ɵɵelementStart(2, "div", 25, 2)(4, "table", 26);
    ɵɵelement(5, "colgroup", 27)(6, "thead", 28);
    ɵɵelementEnd();
    ɵɵtemplate(7, GridComponent_ng_container_7_div_1_div_7_Template, 2, 2, "div", 29);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r0.headerPadding);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isLocked);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r0.lockedLeafColumns.length > 0)("lockedWidth", ctx_r0.lockedWidth + ctx_r0.scrollbarWidth + 2);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r0.nonLockedWidth, "px");
    ɵɵproperty("virtualColumns", ctx_r0.virtualColumns)("size", ctx_r0.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r0.headerLeafColumns)("groups", ctx_r0.isLocked ? ɵɵpureFunction0(31, _c43) : ctx_r0.group)("detailTemplate", ctx_r0.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("resizable", ctx_r0.resizable)("scrollable", true)("columns", ctx_r0.headerColumns)("totalColumnLevels", ctx_r0.totalColumnLevels)("sort", ctx_r0.sort)("filter", ctx_r0.filter)("filterable", ctx_r0.filterable)("groupable", ctx_r0.showGroupPanel)("reorderable", ctx_r0.reorderable)("groups", ctx_r0.isLocked ? ɵɵpureFunction0(32, _c43) : ctx_r0.group)("sortable", ctx_r0.sortable)("columnMenu", ctx_r0.columnMenuOptions)("columnMenuTemplate", ctx_r0.columnMenuTemplate)("lockedColumnsCount", ctx_r0.lockedLeafColumns.length)("totalColumnsCount", ctx_r0.leafColumns.length)("totalColumns", ctx_r0.columnsContainer)("detailTemplate", ctx_r0.detailTemplate)("tabIndex", ctx_r0.navigation.tableEnabled ? "-1" : "0");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.virtualColumns);
  }
}
function GridComponent_ng_container_7_div_3_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 39)(1, "table", 40);
    ɵɵelement(2, "colgroup", 27)(3, "tfoot", 41);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r0.lockedWidth, "px");
    ɵɵproperty("locked", true)("size", ctx_r0.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r0.lockedLeafColumns)("groups", ctx_r0.group)("detailTemplate", ctx_r0.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("scrollable", true)("groups", ctx_r0.group)("columns", ctx_r0.lockedLeafColumns)("detailTemplate", ctx_r0.detailTemplate)("logicalRowIndex", ctx_r0.ariaRowCount)("totalColumns", ctx_r0.columnsContainer);
  }
}
function GridComponent_ng_container_7_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵtemplate(1, GridComponent_ng_container_7_div_3_div_1_Template, 4, 15, "div", 35);
    ɵɵelementStart(2, "div", 36, 4)(4, "table", 37);
    ɵɵelement(5, "colgroup", 27)(6, "tfoot", 38);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵstyleProp("padding", ctx_r0.headerPadding);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.lockedLeafColumns.length);
    ɵɵadvance();
    ɵɵproperty("kendoGridResizableContainer", ctx_r0.lockedLeafColumns.length > 0)("lockedWidth", ctx_r0.lockedWidth + ctx_r0.scrollbarWidth + 3);
    ɵɵadvance(2);
    ɵɵstyleProp("width", ctx_r0.nonLockedWidth, "px");
    ɵɵproperty("size", ctx_r0.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r0.headerLeafColumns)("groups", ctx_r0.isLocked ? ɵɵpureFunction0(18, _c43) : ctx_r0.group)("detailTemplate", ctx_r0.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("logicalRowIndex", ctx_r0.ariaRowCount)("scrollable", true)("groups", ctx_r0.isLocked ? ɵɵpureFunction0(19, _c43) : ctx_r0.group)("columns", ctx_r0.headerColumns)("lockedColumnsCount", ctx_r0.lockedLeafColumns.length)("detailTemplate", ctx_r0.detailTemplate)("totalColumns", ctx_r0.columnsContainer);
  }
}
function GridComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, GridComponent_ng_container_7_div_1_Template, 8, 33, "div", 20);
    ɵɵelementStart(2, "kendo-grid-list", 21);
    ɵɵlistener("onPress", function GridComponent_ng_container_7_Template_kendo_grid_list_onPress_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "press"));
    })("onDragStart", function GridComponent_ng_container_7_Template_kendo_grid_list_onDragStart_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "dragStart"));
    })("onDrag", function GridComponent_ng_container_7_Template_kendo_grid_list_onDrag_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "drag"));
    })("onDragEnter", function GridComponent_ng_container_7_Template_kendo_grid_list_onDragEnter_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "dragEnter"));
    })("onDragLeave", function GridComponent_ng_container_7_Template_kendo_grid_list_onDragLeave_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "dragLeave"));
    })("onDragEnd", function GridComponent_ng_container_7_Template_kendo_grid_list_onDragEnd_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "dragEnd"));
    })("onDrop", function GridComponent_ng_container_7_Template_kendo_grid_list_onDrop_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.handleReorderEvents($event, "drop"));
    })("pageChange", function GridComponent_ng_container_7_Template_kendo_grid_list_pageChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.notifyPageChange("list", $event));
    })("scrollBottom", function GridComponent_ng_container_7_Template_kendo_grid_list_scrollBottom_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.notifyScrollBottom());
    })("contentScroll", function GridComponent_ng_container_7_Template_kendo_grid_list_contentScroll_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.contentScroll.emit($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, GridComponent_ng_container_7_div_3_Template, 7, 20, "div", 22);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const defaultHint_r5 = ɵɵreference(14);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.hideHeader);
    ɵɵadvance();
    ɵɵproperty("dragDisabled", !ctx_r0.rowReorderable)("dropDisabled", !ctx_r0.rowReorderable)("dragTargetFilter", ctx_r0.getDefaultSelectors("dragTarget"))("dropTargetFilter", ctx_r0.getDefaultSelectors("dropTarget"))("dragHandle", ctx_r0.getDefaultSelectors("handle"))("hint", ɵɵpureFunction1(33, _c50, defaultHint_r5))("dragData", ctx_r0.gridData)("data", ctx_r0.view)("rowHeight", ctx_r0.rowHeight)("detailRowHeight", ctx_r0.detailRowHeight)("total", ctx_r0.totalCount)("take", ctx_r0.pageSize)("groups", ctx_r0.group)("groupable", ctx_r0.groupable)("skip", ctx_r0.skip)("trackBy", ctx_r0.trackBy)("columns", ctx_r0.columnsContainer)("selectable", ctx_r0.selectable)("filterable", ctx_r0.filterable)("detailTemplate", ctx_r0.detailTemplate)("noRecordsTemplate", ctx_r0.noRecordsTemplate)("size", ctx_r0.size)("rowClass", ctx_r0.rowClass)("rowSticky", ctx_r0.rowSticky)("loading", ctx_r0.loading)("isVirtual", ctx_r0.isVirtual)("cellLoadingTemplate", ctx_r0.cellLoadingTemplate == null ? null : ctx_r0.cellLoadingTemplate.templateRef)("loadingTemplate", ctx_r0.loadingTemplate == null ? null : ctx_r0.loadingTemplate.templateRef)("virtualColumns", ctx_r0.virtualColumns)("enableDrag", ctx_r0.marqueeSelection)("sort", ctx_r0.sort);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showFooter);
  }
}
function GridComponent_ng_container_8_thead_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "thead", 46);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("resizable", ctx_r0.resizable)("scrollable", false)("columns", ctx_r0.visibleColumns)("totalColumnLevels", ctx_r0.totalColumnLevels)("totalColumns", ctx_r0.columnsContainer)("groups", ctx_r0.group)("groupable", ctx_r0.showGroupPanel)("reorderable", ctx_r0.reorderable)("sort", ctx_r0.sort)("sortable", ctx_r0.sortable)("filter", ctx_r0.filter)("filterable", ctx_r0.filterable)("columnMenu", ctx_r0.columnMenuOptions)("columnMenuTemplate", ctx_r0.columnMenuTemplate)("detailTemplate", ctx_r0.detailTemplate)("tabIndex", ctx_r0.navigation.tableEnabled ? "-1" : "0");
  }
}
function GridComponent_ng_container_8_tfoot_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tfoot", 47);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("scrollable", false)("logicalRowIndex", ctx_r0.ariaRowCount)("groups", ctx_r0.group)("columns", ctx_r0.leafColumns)("detailTemplate", ctx_r0.detailTemplate)("totalColumns", ctx_r0.columnsContainer);
  }
}
function GridComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "table", 42);
    ɵɵelement(2, "colgroup", 27);
    ɵɵtemplate(3, GridComponent_ng_container_8_thead_3_Template, 1, 16, "thead", 43);
    ɵɵelement(4, "tbody", 44);
    ɵɵtemplate(5, GridComponent_ng_container_8_tfoot_5_Template, 1, 6, "tfoot", 45);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("table-layout", ctx_r0.resizable ? "fixed" : null);
    ɵɵproperty("size", ctx_r0.size);
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r0.leafColumns)("groups", ctx_r0.group)("detailTemplate", ctx_r0.detailTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.hideHeader);
    ɵɵadvance();
    ɵɵproperty("isLoading", ctx_r0.loading)("groups", ctx_r0.group)("data", ctx_r0.view)("skip", ctx_r0.skip)("columns", ctx_r0.leafColumns)("selectable", ctx_r0.selectable)("filterable", ctx_r0.filterable)("noRecordsTemplate", ctx_r0.noRecordsTemplate)("detailTemplate", ctx_r0.detailTemplate)("showGroupFooters", ctx_r0.showGroupFooters)("trackBy", ctx_r0.trackBy)("rowClass", ctx_r0.rowClass)("enableDrag", ctx_r0.marqueeSelection);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.showFooter);
  }
}
function GridComponent_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 48);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("loadingTemplate", ctx_r0.loadingTemplate);
  }
}
function GridComponent_kendo_grid_status_bar_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-status-bar", 49);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("statusBarTemplate", ctx_r0.statusBarTemplate);
  }
}
function GridComponent_kendo_pager_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-pager", 50);
    ɵɵlistener("pageChange", function GridComponent_kendo_pager_11_Template_kendo_pager_pageChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0.notifyPageChange("pager", $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r0.navigation.pagerEnabled ? "0" : "-1")("template", ctx_r0.pagerTemplate)("pageSize", ctx_r0.pageSize)("total", ctx_r0.view.total)("skip", ctx_r0.skip)("size", ctx_r0.size)("options", ctx_r0.pageable);
    ɵɵattribute("role", ctx_r0.navigation.pagerEnabled ? "application" : void 0);
  }
}
function GridComponent_kendo_grid_toolbar_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-grid-toolbar", 51);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r0.size)("navigable", ctx_r0.navigation.toolbarEnabled);
    ɵɵattribute("aria-label", ctx_r0.messageFor("bottomToolbarLabel"))("aria-controls", ctx_r0.ariaRootId);
  }
}
function GridComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 52);
    ɵɵtext(1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.getHintSettings("hintIcon"))("svgIcon", ctx_r0.getHintSettings("hintSVGIcon"));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.hintText, " ");
  }
}
function GridComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 53);
  }
}
var _c51 = ["columnList"];
function ColumnChooserComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "kendo-grid-columnlist", 5, 2);
    ɵɵlistener("apply", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_columnlist_apply_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onApply($event));
    })("columnChange", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_columnlist_columnChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onChange($event));
    })("keydown.shift.tab", function ColumnChooserComponent_ng_template_2_Template_kendo_grid_columnlist_keydown_shift_tab_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onShiftTab($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r4.ctx.localization.get("columns"));
    ɵɵadvance();
    ɵɵproperty("columns", ctx_r4.columns)("ariaLabel", ctx_r4.ctx.localization.get("columns"))("isLast", true)("applyText", ctx_r4.ctx.localization.get("columnsApply"))("resetText", ctx_r4.ctx.localization.get("columnsReset"))("autoSync", ctx_r4.autoSync)("allowHideAll", ctx_r4.allowHideAll);
  }
}
var _c52 = ["kendoGridEditCommand", ""];
function EditCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function EditCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function EditCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c53 = ["kendoGridCancelCommand", ""];
function CancelCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function CancelCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function CancelCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c54 = ["kendoGridSaveCommand", ""];
function SaveCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function SaveCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function SaveCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c55 = ["kendoGridRemoveCommand", ""];
function RemoveCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function RemoveCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function RemoveCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c56 = ["kendoGridAddCommand", ""];
function AddCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function AddCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function AddCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c57 = ["kendoGridPDFCommand", ""];
function PDFCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function PDFCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function PDFCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var _c58 = ["kendoGridExcelCommand", ""];
function ExcelCommandDirective_kendo_icon_wrapper_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.icon)("svgIcon", ctx_r0.svgIcon);
  }
}
function ExcelCommandDirective_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵelement(1, "img", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("src", ctx_r0.imageUrl, ɵɵsanitizeUrl);
  }
}
function ExcelCommandDirective_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.iconClass);
  }
}
var EMPTY_REGEX = /^\s*$/;
var isPresent4 = (value2) => value2 !== null && value2 !== void 0;
var isBlank2 = (value2) => value2 === null || value2 === void 0;
var isArray2 = (value2) => Array.isArray(value2);
var isTruthy = (value2) => !!value2;
var isNullOrEmptyString2 = (value2) => isBlank2(value2) || EMPTY_REGEX.test(value2);
var observe = (list) => merge(of(list), list.changes);
var isUniversal = () => typeof document === "undefined";
var isString2 = (value2) => typeof value2 === "string";
var isNumber = (value2) => typeof value2 === "number" && !isNaN(value2);
var extractFormat = (format) => {
  if (isString2(format) && !isNullOrEmptyString2(format) && format.startsWith("{0:")) {
    return format.slice(3, format.length - 1);
  }
  return format;
};
var not = (fn) => (...args) => !fn(...args);
var or = (...conditions) => (value2) => conditions.reduce((acc, x) => acc || x(value2), false);
var and = (...conditions) => (value2) => conditions.reduce((acc, x) => acc && x(value2), true);
var Skip = new InjectionToken("Skip");
var createPromise = () => {
  let resolveFn, rejectFn;
  const promise = new Promise((resolve, reject) => {
    resolveFn = (data) => {
      resolve(data);
      return promise;
    };
    rejectFn = (data) => {
      reject(data);
      return promise;
    };
  });
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  return promise;
};
var iterator = getIterator$1();
function getIterator$1() {
  if (typeof Symbol === "function" && Symbol.iterator) {
    return Symbol.iterator;
  }
  const keys = Object.getOwnPropertyNames(Map.prototype);
  const proto = Map.prototype;
  for (let i = 0; i < keys.length; ++i) {
    const key = keys[i];
    if (key !== "entries" && key !== "size" && proto[key] === proto.entries) {
      return key;
    }
  }
}
var FRAME_DURATION = 1e3 / 60;
var wnd = typeof window !== "undefined" ? window : {};
var requestAnimationFrame = wnd.requestAnimationFrame || wnd.msRequestAnimationFrame || ((callback) => setTimeout(callback, FRAME_DURATION));
var cancelAnimationFrame = wnd.cancelAnimationFrame || wnd.msCancelRequestAnimationFrame || clearTimeout;
var detectIE = () => {
  if (!isDocumentAvailable()) {
    return;
  }
  const ua = window.navigator.userAgent;
  const msie = ua.indexOf("MSIE ");
  const trident = ua.indexOf("Trident/");
  return msie > 0 || trident > 0;
};
var nodesToArray = (nodes) => [].slice.call(nodes);
var replaceMessagePlaceholder = (message, name, value2) => message.replace(new RegExp(`{\\s*${name}\\s*}`, "g"), value2);
var recursiveFlatMap = (item) => isGroupResult(item) ? item.items.flatMap(recursiveFlatMap) : [__spreadValues({}, item)];
var isGroupResult = (obj) => {
  return "aggregates" in obj && "items" in obj && "field" in obj && "value" in obj;
};
var GridSpacerComponent = class {
  constructor() {
    this.hostClass = true;
  }
  get sizedClass() {
    return isPresent4(this.width);
  }
  get flexBasisStyle() {
    return this.width;
  }
};
GridSpacerComponent.ɵfac = function GridSpacerComponent_Factory(t) {
  return new (t || GridSpacerComponent)();
};
GridSpacerComponent.ɵcmp = ɵɵdefineComponent({
  type: GridSpacerComponent,
  selectors: [["kendo-grid-spacer"], ["kendo-pager-spacer"]],
  hostVars: 6,
  hostBindings: function GridSpacerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("flex-basis", ctx.flexBasisStyle);
      ɵɵclassProp("k-spacer", ctx.hostClass)("k-spacer-sized", ctx.sizedClass);
    }
  },
  inputs: {
    width: "width"
  },
  decls: 0,
  vars: 0,
  template: function GridSpacerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridSpacerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-spacer, kendo-pager-spacer",
      template: ``
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-spacer"]
    }],
    sizedClass: [{
      type: HostBinding,
      args: ["class.k-spacer-sized"]
    }],
    flexBasisStyle: [{
      type: HostBinding,
      args: ["style.flexBasis"]
    }],
    width: [{
      type: Input
    }]
  });
})();
var DomEventsService = class {
  constructor() {
    this.cellClick = new EventEmitter();
    this.cellMousedown = new EventEmitter();
    this.cellMouseup = new EventEmitter();
    this.click = new EventEmitter();
    this.keydown = new EventEmitter();
    this.focus = new EventEmitter();
    this.focusIn = new EventEmitter();
    this.focusOut = new EventEmitter();
    this.windowBlur = new EventEmitter();
    this.paste = new EventEmitter();
  }
};
DomEventsService.ɵfac = function DomEventsService_Factory(t) {
  return new (t || DomEventsService)();
};
DomEventsService.ɵprov = ɵɵdefineInjectable({
  token: DomEventsService,
  factory: DomEventsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsService, [{
    type: Injectable
  }], null, null);
})();
var LocalDataChangesService = class {
  constructor() {
    this.changes = new EventEmitter();
  }
};
LocalDataChangesService.ɵfac = function LocalDataChangesService_Factory(t) {
  return new (t || LocalDataChangesService)();
};
LocalDataChangesService.ɵprov = ɵɵdefineInjectable({
  token: LocalDataChangesService,
  factory: LocalDataChangesService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalDataChangesService, [{
    type: Injectable
  }], null, null);
})();
var FOCUS_ROOT_ACTIVE = new InjectionToken("focus-root-initial-active-state");
var FocusRoot = class {
  constructor(active = false) {
    this.active = active;
    this.groups = /* @__PURE__ */ new Set();
  }
  registerGroup(group2) {
    if (this.active) {
      this.groups.add(group2);
    }
  }
  unregisterGroup(group2) {
    if (this.active) {
      this.groups.delete(group2);
    }
  }
  activate() {
    if (this.active) {
      this.groups.forEach((f) => f.activate());
    }
  }
  deactivate() {
    if (this.active) {
      this.groups.forEach((f) => f.deactivate());
    }
  }
};
FocusRoot.ɵfac = function FocusRoot_Factory(t) {
  return new (t || FocusRoot)(ɵɵinject(FOCUS_ROOT_ACTIVE, 8));
};
FocusRoot.ɵprov = ɵɵdefineInjectable({
  token: FocusRoot,
  factory: FocusRoot.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusRoot, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FOCUS_ROOT_ACTIVE]
      }]
    }];
  }, null);
})();
var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
var NODE_NAME_PREDICATES = {};
var toClassList = (classNames) => String(classNames).trim().split(" ");
var hasClasses = (element, classNames) => {
  const namesList = toClassList(classNames);
  return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
var matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
var matchesNodeName = (nodeName) => {
  if (!NODE_NAME_PREDICATES[nodeName]) {
    NODE_NAME_PREDICATES[nodeName] = (element) => String(element.nodeName).toLowerCase() === nodeName.toLowerCase();
  }
  return NODE_NAME_PREDICATES[nodeName];
};
var closest2 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var closestInScope = (node, predicate, scope) => {
  while (node && node !== scope && !predicate(node)) {
    node = node.parentNode;
  }
  if (node !== scope) {
    return node;
  }
};
var contains$2 = (parent, node, matchSelf = false) => {
  const outside = !closest2(node, (child) => child === parent);
  if (outside) {
    return false;
  }
  const el = closest2(node, (child) => child === node);
  return el && (matchSelf || el !== parent);
};
var isVisible = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const rect = element.getBoundingClientRect();
  const hasSize = rect.width > 0 && rect.height > 0;
  const hasPosition2 = rect.x !== 0 && rect.y !== 0;
  return (hasSize || hasPosition2) && window.getComputedStyle(element).visibility !== "hidden";
};
var isFocusable2 = (element) => {
  if (!element.tagName) {
    return false;
  }
  const tagName = element.tagName.toLowerCase();
  const hasTabIndex = Boolean(element.getAttribute("tabIndex"));
  const focusable = !element.disabled && focusableRegex.test(tagName);
  return focusable || hasTabIndex;
};
var isFocusableWithTabKey = (element, checkVisibility = true) => {
  if (!isFocusable2(element)) {
    return false;
  }
  const visible = !checkVisibility || isVisible(element);
  const ariaHidden = element.getAttribute("aria-hidden") === "true";
  const tabIndex = element.getAttribute("tabIndex");
  return visible && !ariaHidden && tabIndex !== "-1";
};
var findElement = (node, predicate, matchSelf = true) => {
  if (!node) {
    return;
  }
  if (matchSelf && predicate(node)) {
    return node;
  }
  node = node.firstChild;
  while (node) {
    if (node.nodeType === 1) {
      const element = findElement(node, predicate);
      if (element) {
        return element;
      }
    }
    node = node.nextSibling;
  }
};
var findLastElement = (node, predicate, matchSelf = true) => {
  let last = null;
  findElement(node, (node2) => {
    if (predicate(node2)) {
      last = node2;
    }
    return false;
  }, matchSelf);
  return last;
};
var findFocusable = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility));
};
var findFocusableChild = (element, checkVisibility = true) => {
  return findElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
var findLastFocusableChild = (element, checkVisibility = true) => {
  return findLastElement(element, (node) => isFocusableWithTabKey(node, checkVisibility), false);
};
function rtlScrollPosition(position2, element, initial2) {
  let result = position2;
  if (initial2 < 0) {
    result = -position2;
  } else if (initial2 > 0) {
    result = element.scrollWidth - element.offsetWidth - position2;
  }
  return result;
}
var isButton = matchesNodeName("button");
var isInputTag = matchesNodeName("input");
var navigableRegex = /(button|checkbox|color|file|radio|reset|submit)/i;
var isNavigableInput = (element) => isInputTag(element) && navigableRegex.test(element.type);
var isNavigable = (element) => !element.disabled && (isButton(element) || isNavigableInput(element));
var DefaultFocusableElement = class {
  constructor(host, renderer) {
    this.renderer = renderer;
    this.element = host.nativeElement;
    this.focusable = findFocusable(this.element, false) || this.element;
  }
  get enabled() {
    return this.focusable && !this.focusable.disabled;
  }
  get visible() {
    return this.focusable && isVisible(this.focusable);
  }
  isNavigable() {
    return this.canFocus() && isNavigable(this.element);
  }
  toggle(active) {
    this.renderer.setAttribute(this.focusable, "tabIndex", active ? "0" : "-1");
  }
  focus() {
    if (this.focusable) {
      this.focusable.focus();
    }
  }
  canFocus() {
    return this.visible && this.enabled;
  }
  hasFocus() {
    return isDocumentAvailable() && document.activeElement !== this.element && closest2(document.activeElement, (e) => e === this.element);
  }
};
var CELL_CONTEXT = new InjectionToken("grid-cell-context");
var EMPTY_CELL_CONTEXT = {};
var GridToolbarNavigationService = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.navigableElements = [];
    this.currentActiveIndex = 0;
    this.defaultFocusableSelector = `
        [kendogridtoolbarfocusable],
        [kendogridaddcommand],
        [kendogridcancelcommand],
        [kendogrideditcommand],
        [kendogridremovecommand],
        [kendogridsavecommand],
        [kendogridexcelcommand],
        [kendogridpdfcommand]
    `;
  }
  notify() {
    this.navigableElements = this.navigableElements.length && Array.from(this.navigableElements[0].parentElement.querySelectorAll(this.defaultFocusableSelector)) || [];
    this.currentActiveIndex = 0;
    this.updateFocus();
  }
  focus() {
    this.navigableElements[this.currentActiveIndex]?.focus();
  }
  updateFocus() {
    if (!this.navigableElements.length) {
      return;
    }
    this.navigableElements.forEach((el) => {
      this.renderer.setAttribute(el, "tabindex", "-1");
    });
    this.renderer.setAttribute(this.navigableElements[this.currentActiveIndex], "tabindex", "0");
    if (isDocumentAvailable() && document.activeElement.closest(".k-toolbar")) {
      this.navigableElements[this.currentActiveIndex].focus();
    }
  }
};
GridToolbarNavigationService.ɵfac = function GridToolbarNavigationService_Factory(t) {
  return new (t || GridToolbarNavigationService)(ɵɵinject(Renderer2));
};
GridToolbarNavigationService.ɵprov = ɵɵdefineInjectable({
  token: GridToolbarNavigationService,
  factory: GridToolbarNavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarNavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
var ContextService = class {
  constructor(renderer, localization) {
    this.renderer = renderer;
    this.localization = localization;
    this.topToolbarNavigation = new GridToolbarNavigationService(this.renderer);
    this.bottomToolbarNavigation = new GridToolbarNavigationService(this.renderer);
  }
};
ContextService.ɵfac = function ContextService_Factory(t) {
  return new (t || ContextService)(ɵɵinject(Renderer2), ɵɵinject(LocalizationService));
};
ContextService.ɵprov = ɵɵdefineInjectable({
  token: ContextService,
  factory: ContextService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContextService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: LocalizationService
    }];
  }, null);
})();
var FocusableDirective = class {
  constructor(cellContext, hostElement, renderer, ctx) {
    this.cellContext = cellContext;
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ctx = ctx;
    this.active = true;
    this._enabled = true;
    if (this.cellContext) {
      this.group = this.cellContext.focusGroup;
    }
    if (this.group) {
      this.group.registerElement(this);
    }
  }
  /**
   * @hidden
   */
  set enabled(value2) {
    if (value2 === "") {
      value2 = true;
    } else {
      value2 = Boolean(value2);
    }
    if (value2 !== this.enabled) {
      this._enabled = value2;
      if (this.element) {
        this.element.toggle(this.active && value2);
      }
    }
  }
  get enabled() {
    return this._enabled;
  }
  ngAfterViewInit() {
    if (!this.element && this.ctx.navigable) {
      this.element = new DefaultFocusableElement(this.hostElement, this.renderer);
    }
    if (this.group && this.element) {
      this.toggle(this.group.isActive);
    }
  }
  ngOnDestroy() {
    if (this.group) {
      this.group.unregisterElement(this);
    }
  }
  /**
   * @hidden
   */
  toggle(active) {
    if (this.element && active !== this.active) {
      this.element.toggle(this.enabled && active);
      this.active = active;
    }
  }
  /**
   * @hidden
   */
  canFocus() {
    return this.enabled && this.element && this.element.canFocus();
  }
  /**
   * @hidden
   */
  isNavigable() {
    return this.enabled && this.element && this.element.isNavigable();
  }
  /**
   * @hidden
   */
  focus() {
    if (this.enabled && this.element) {
      this.element.focus();
    }
  }
  /**
   * @hidden
   */
  hasFocus() {
    return this.enabled && this.element && this.element.hasFocus();
  }
  /**
   * @hidden
   */
  registerElement(element) {
    this.element = element;
  }
};
FocusableDirective.ɵfac = function FocusableDirective_Factory(t) {
  return new (t || FocusableDirective)(ɵɵdirectiveInject(CELL_CONTEXT, 12), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService));
};
FocusableDirective.ɵdir = ɵɵdefineDirective({
  type: FocusableDirective,
  selectors: [["", "kendoGridFocusable", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridSelectionCheckbox", ""]],
  inputs: {
    enabled: [0, "kendoGridFocusable", "enabled"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusableDirective, [{
    type: Directive,
    args: [{
      selector: `[kendoGridFocusable],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridCancelCommand],
        [kendoGridSelectionCheckbox]
    `
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }, {
        type: SkipSelf
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }];
  }, {
    enabled: [{
      type: Input,
      args: ["kendoGridFocusable"]
    }]
  });
})();
var GridFocusableElement = class {
  constructor(navigationService) {
    this.navigationService = navigationService;
  }
  focus() {
    this.navigationService.focusCell();
  }
  toggle(active) {
    this.navigationService.toggle(active);
  }
  canFocus() {
    return true;
  }
  hasFocus() {
    return this.navigationService.hasFocus();
  }
  isNavigable() {
    return false;
  }
};
var NavigationCursor = class {
  constructor(model) {
    this.model = model;
    this.changes = new Subject();
    this.activeRow = 0;
    this.activeCol = 0;
    this.virtualCol = 0;
    this.virtualRow = 0;
  }
  set metadata(value2) {
    this._metadata = value2;
    if (isPresent4(value2)) {
      const newActiveCol = value2.hasDetailTemplate ? 1 : 0;
      const shouldChange = this.activeRow < value2.headerRows && this.activeCol === 0;
      if (shouldChange && newActiveCol !== this.activeCol) {
        this.activeCol = newActiveCol;
        this.reset();
      }
    }
  }
  get metadata() {
    return this._metadata;
  }
  get row() {
    return this.model.findRow(this.activeRow);
  }
  get cell() {
    const row2 = this.row;
    if (row2) {
      return this.model.findCell(this.activeCol, row2);
    }
  }
  get dataRowIndex() {
    const row2 = this.row;
    if (row2) {
      return row2.dataRowIndex;
    }
    return -1;
  }
  /**
   * Assumes and announces a new cursor position.
   */
  reset(rowIndex = this.activeRow, colIndex = this.activeCol, force = true) {
    if (this.activate(rowIndex, colIndex, force)) {
      this.virtualRow = rowIndex;
      this.virtualCol = colIndex;
    }
  }
  activate(rowIndex, colIndex, force) {
    if (!force && this.isActiveRange(rowIndex, colIndex)) {
      return false;
    }
    const prevColIndex = this.activeCol;
    const prevRowIndex = this.activeRow;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
    this.changes.next({
      colIndex,
      prevColIndex,
      prevRowIndex,
      rowIndex
    });
    return true;
  }
  isActiveRange(rowIndex, colIndex) {
    if (this.activeRow !== rowIndex) {
      return false;
    }
    const cell2 = this.cell;
    const {
      start,
      end: end2
    } = this.model.cellRange(cell2);
    return !cell2 || start <= colIndex && colIndex <= end2;
  }
  /**
   * Assumes a new cursor position without announcing it.
   */
  assume(rowIndex = this.activeRow, colIndex = this.activeCol) {
    this.virtualRow = rowIndex;
    this.virtualCol = colIndex;
    this.activeCol = colIndex;
    this.activeRow = rowIndex;
  }
  /**
   * Announces a current cursor position to subscribers.
   */
  announce() {
    this.changes.next({
      colIndex: this.activeCol,
      prevColIndex: this.activeCol,
      prevRowIndex: this.activeRow,
      rowIndex: this.activeRow
    });
  }
  activateVirtualCell(cell2) {
    const rowRange = this.model.rowRange(cell2);
    const cellRange = this.model.cellRange(cell2);
    const activeCol = this.activeCol;
    const activeRow = this.activeRow;
    if (rowRange.start <= activeRow && activeRow <= rowRange.end && cellRange.start <= activeCol && activeCol <= cellRange.end) {
      this.activeRow = cell2.rowIndex;
      this.activeCol = cell2.colIndex;
      return true;
    }
  }
  isActive(rowIndex, colIndex) {
    return this.activeCol === colIndex && this.activeRow === rowIndex;
  }
  moveUp(offset2 = 1) {
    return this.offsetRow(-offset2);
  }
  moveDown(offset2 = 1) {
    return this.offsetRow(offset2);
  }
  moveLeft(offset2 = 1) {
    return this.offsetCol(-offset2);
  }
  moveRight(offset2 = 1) {
    return this.offsetCol(offset2);
  }
  lastCellIndex(row2) {
    return this.metadata.columns.leafColumnsToRender.length - 1 + (this.metadata.hasDetailTemplate && (!row2 || !row2.groupItem) ? 1 : 0);
  }
  offsetCol(offset2) {
    const prevRow = this.model.findRow(this.virtualRow);
    const lastIndex = this.lastCellIndex(prevRow);
    const virtualCol = this.virtualCol;
    this.virtualCol = Math.max(0, Math.min(virtualCol + offset2, lastIndex));
    let nextColIndex = this.virtualCol;
    const nextRowIndex = this.virtualRow;
    let cell2 = this.model.findCell(this.virtualCol, prevRow);
    if (!cell2 && this.metadata.virtualColumns) {
      return this.activate(nextRowIndex, nextColIndex);
    }
    if (!cell2 && this.metadata.hasDetailTemplate) {
      this.virtualCol += 1;
      return false;
    }
    if (cell2.colSpan > 1 && cell2.colIndex <= virtualCol && virtualCol < cell2.colIndex + cell2.colSpan) {
      nextColIndex = offset2 > 0 ? Math.min(cell2.colIndex + cell2.colSpan, lastIndex) : Math.max(0, cell2.colIndex + offset2);
      const nextCell = this.model.findCell(nextColIndex, prevRow);
      if (cell2 !== nextCell) {
        cell2 = nextCell;
        this.virtualCol = cell2.colIndex;
      } else {
        this.virtualCol = virtualCol;
      }
    }
    return this.activate(cell2.rowIndex, cell2.colIndex);
  }
  offsetRow(offset2) {
    let nextColIndex = this.virtualCol;
    if (this.metadata && this.metadata.isVirtual) {
      const maxIndex = this.metadata.maxLogicalRowIndex;
      let nextIndex = Math.max(0, Math.min(this.activeRow + offset2, maxIndex));
      if (this.metadata.hasDetailTemplate && !this.model.findRow(nextIndex)) {
        nextIndex = offset2 > 0 ? nextIndex + 1 : nextIndex - 1;
        nextIndex = Math.max(0, Math.min(nextIndex, maxIndex));
      }
      if (this.metadata.hasDetailTemplate && nextIndex === maxIndex) {
        if (this.model.lastRow.index !== maxIndex) {
          nextIndex--;
        }
      }
      const nextRow2 = this.model.findRow(nextIndex);
      if (nextRow2) {
        let cell3 = this.model.findCell(this.virtualCol, nextRow2);
        if (!cell3) {
          return;
        }
        if (cell3.rowIndex <= this.virtualRow && offset2 > 0 && cell3.rowSpan > 1) {
          cell3 = this.model.findCell(this.virtualCol, this.model.findRow(cell3.rowIndex + cell3.rowSpan - 1 + offset2));
        }
        nextIndex = cell3.rowIndex;
        nextColIndex = cell3.colIndex;
      }
      this.virtualRow = nextIndex;
      return this.activate(nextIndex, nextColIndex);
    }
    const nextRow = this.model.findRow(this.virtualRow + offset2) || this.model.nextRow(this.virtualRow, offset2);
    if (!nextRow) {
      return false;
    }
    let cell2 = this.model.findCell(this.virtualCol, nextRow);
    if (cell2 && cell2.rowIndex <= this.virtualRow && offset2 > 0 && cell2.rowSpan > 1) {
      const nextPos = cell2.rowIndex + cell2.rowSpan - 1 + offset2;
      cell2 = this.model.findCell(this.virtualCol, this.model.findRow(nextPos));
    }
    if (!cell2 && (this.metadata.virtualColumns || this.metadata.hasDetailTemplate)) {
      return this.activate(this.virtualRow + offset2, this.virtualCol);
    }
    this.virtualRow = cell2.rowIndex;
    return this.activate(this.virtualRow, cell2.colIndex);
  }
};
var ItemMap = class {
  constructor() {
    this.count = 0;
    this.items = {};
  }
  get first() {
    if (this.count > 0) {
      let result;
      this.forEach((item) => {
        result = item;
        return true;
      });
      return result;
    }
  }
  get last() {
    if (this.count > 0) {
      const keys = Object.keys(this.items);
      return this.items[keys[keys.length - 1]];
    }
  }
  removeItem(key) {
    if (this.items[key]) {
      delete this.items[key];
      this.count--;
    }
  }
  setItem(key, item) {
    if (!this.items[key]) {
      this.count++;
    }
    this.items[key] = item;
  }
  getItem(key) {
    return this.items[key];
  }
  toArray() {
    const result = [];
    this.forEach((item) => {
      result.push(item);
    });
    return result;
  }
  forEach(callback) {
    for (const key in this.items) {
      if (this.items.hasOwnProperty(key) && callback(this.items[key])) {
        return this.items[key];
      }
    }
  }
  find(callback) {
    return this.forEach(callback);
  }
};
var NavigationModel = class {
  constructor() {
    this.rows = new ItemMap();
  }
  get firstRow() {
    return this.rows.first;
  }
  get lastRow() {
    return this.rows.last;
  }
  registerCell(cell2) {
    const row2 = this.rows.getItem(cell2.logicalRowIndex);
    if (!row2) {
      return;
    }
    const colIndex = cell2.logicalColIndex;
    const modelCell = {
      uid: cell2.uid,
      colIndex,
      rowIndex: row2.index,
      colSpan: cell2.colSpan,
      rowSpan: cell2.rowSpan,
      detailExpandCell: cell2.detailExpandCell,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      focusGroup: cell2.focusGroup
    };
    row2.cells.setItem(colIndex, modelCell);
    if (cell2.groupItem) {
      row2.groupItem = cell2.groupItem;
    }
    return modelCell;
  }
  unregisterCell(index, rowIndex, cell2) {
    const row2 = this.rows.getItem(rowIndex);
    if (row2) {
      const match = row2.cells.getItem(index);
      if (match && match.uid === cell2.uid) {
        row2.cells.removeItem(index);
      }
    }
  }
  registerRow(row2) {
    const modelRow = {
      uid: row2.uid,
      index: row2.logicalRowIndex,
      dataItem: row2.dataItem,
      dataRowIndex: row2.dataRowIndex,
      cells: new ItemMap()
    };
    this.rows.setItem(row2.logicalRowIndex, modelRow);
  }
  updateRow(row2) {
    const current3 = this.rows.getItem(row2.logicalRowIndex);
    if (current3) {
      Object.assign(current3, {
        dataItem: row2.dataItem,
        dataRowIndex: row2.dataRowIndex
      });
    }
  }
  unregisterRow(index, row2) {
    const match = this.rows.getItem(index);
    if (match && match.uid === row2.uid) {
      this.rows.removeItem(index);
    }
  }
  cellRange(cell2) {
    if (cell2) {
      const start = cell2.colIndex;
      const end2 = cell2.colIndex + (cell2.colSpan || 1) - 1;
      return {
        start,
        end: end2
      };
    }
    return {};
  }
  rowRange(cell2) {
    if (cell2) {
      const start = cell2.rowIndex;
      const end2 = cell2.rowIndex + (cell2.rowSpan || 1) - 1;
      return {
        start,
        end: end2
      };
    }
    return {};
  }
  nextRow(rowIndex, offset2) {
    const rows = this.rows.toArray();
    const row2 = this.rows.getItem(rowIndex);
    const position2 = rows.indexOf(row2);
    const next = rows[position2 + offset2];
    return next;
  }
  findRow(index) {
    return this.rows.getItem(index);
  }
  findCell(index, row2) {
    if (!row2) {
      return;
    }
    const rowIndex = row2.index;
    let cell2 = row2.cells.getItem(index);
    let currentIndex = rowIndex;
    while (!cell2 && row2) {
      row2 = this.rows.getItem(currentIndex);
      cell2 = this.rowCell(index, row2);
      currentIndex--;
    }
    if (cell2 && rowIndex <= row2.index + (cell2.rowSpan || 1) - 1) {
      return cell2;
    }
  }
  rowCell(index, row2) {
    if (!row2 || !row2.cells.count) {
      return;
    }
    const firstCell = row2.cells.first;
    let cell2, currentIndex = index;
    while (!cell2 && currentIndex >= firstCell.colIndex) {
      cell2 = row2.cells.getItem(currentIndex);
      currentIndex--;
    }
    if (cell2 && index <= cell2.colIndex + (cell2.colSpan || 1) - 1) {
      return cell2;
    }
  }
};
var PreventableEvent2 = class {
  constructor() {
    this.prevented = false;
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns a respective boolean if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var CellCloseEvent = class extends PreventableEvent2 {
  constructor(options) {
    super();
    this.action = "cellClose";
    Object.assign(this, options);
  }
};
var isEqual = (index) => (item) => item.index === index;
var isNotEqual = (index) => (item) => item.index !== index;
var isNewRow = (index) => index === -1 || index === void 0;
var EditService = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changes = new EventEmitter();
    this.editedIndices = [];
    this.keepEditCell = false;
    this.closingCell = false;
    this.changedSource = new Subject();
    this.changed = this.changedSource.asObservable().pipe(switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1))));
  }
  editRow(index, group2 = void 0) {
    this.editedIndices.push({
      index,
      group: group2
    });
    this.onChanged();
  }
  addRow(group2) {
    this.newItemGroup = {
      group: group2
    };
    this.onChanged();
  }
  editCell(rowIndex, column, group2) {
    if (isNewRow(rowIndex) || column.editable === false || !(column.editTemplate || column.field)) {
      return;
    }
    this.preventCellClose();
    if (!this.closeCell()) {
      this.editRow(rowIndex, group2);
      this.column = column;
      this.onChanged();
    }
  }
  isEditing() {
    return this.editedIndices.length > 0;
  }
  isEditingCell() {
    return this.isEditing() && this.column !== void 0;
  }
  get hasNewItem() {
    return isPresent4(this.newItemGroup);
  }
  get newDataItem() {
    if (this.hasNewItem) {
      return this.newItemGroup.group.value;
    }
    return {};
  }
  close(index) {
    if (isNewRow(index)) {
      this.newItemGroup = void 0;
      return;
    }
    this.editedIndices = this.editedIndices.filter(isNotEqual(index));
    delete this.column;
    this.onChanged();
  }
  closeCell(originalEvent) {
    if (this.column && !this.closingCell) {
      return this.ngZone.run(() => {
        const {
          index,
          group: group2
        } = this.editedIndices[0];
        const args = new CellCloseEvent({
          column: this.column,
          formGroup: group2,
          originalEvent,
          rowIndex: index
        });
        this.closingCell = true;
        this.changes.emit(args);
        this.closingCell = false;
        if (!args.isDefaultPrevented()) {
          this.cancelCell();
        }
        return args.isDefaultPrevented();
      });
    }
  }
  cancelCell() {
    if (this.column) {
      this.editedIndices = [];
      delete this.column;
      this.onChanged();
    }
  }
  shouldCloseCell() {
    return this.column && !this.keepEditCell;
  }
  preventCellClose() {
    this.ngZone.runOutsideAngular(() => {
      window.clearTimeout(this.keepCellTimeout);
      this.keepEditCell = true;
      this.keepCellTimeout = window.setTimeout(() => {
        this.keepEditCell = false;
      }, 0);
    });
  }
  context(index) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    return this.findByIndex(index);
  }
  columnContext(index, column) {
    if (isNewRow(index)) {
      return this.newItemGroup;
    }
    if (!this.column || column === this.column) {
      return this.findByIndex(index);
    }
  }
  isEdited(index) {
    if (isNewRow(index) && isPresent4(this.newItemGroup)) {
      return true;
    }
    return !this.column && isPresent4(this.findByIndex(index));
  }
  hasEdited(index) {
    return isPresent4(this.context(index));
  }
  isEditedColumn(index, column) {
    if (this.column && this.column === column) {
      return isPresent4(this.findByIndex(index));
    }
    return false;
  }
  beginEdit(rowIndex) {
    this.changes.emit({
      action: "edit",
      rowIndex
    });
  }
  beginAdd() {
    this.changes.emit({
      action: "add"
    });
  }
  endEdit(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "cancel",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  save(rowIndex) {
    const {
      group: formGroup
    } = this.context(rowIndex);
    this.changes.emit({
      action: "save",
      rowIndex,
      formGroup,
      isNew: isNewRow(rowIndex)
    });
  }
  remove(rowIndex) {
    this.changes.emit({
      action: "remove",
      rowIndex
    });
  }
  findByIndex(index) {
    return this.editedIndices.find(isEqual(index));
  }
  onChanged() {
    this.ngZone.runOutsideAngular(() => {
      this.changedSource.next();
    });
  }
};
EditService.ɵfac = function EditService_Factory(t) {
  return new (t || EditService)(ɵɵinject(NgZone));
};
EditService.ɵprov = ɵɵdefineInjectable({
  token: EditService,
  factory: EditService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var getGroupRowArgs = (groupItem) => {
  if (!isPresent4(groupItem)) {
    return null;
  }
  return {
    group: groupItem.data,
    groupIndex: groupItem.index,
    parentGroup: getGroupRowArgs(groupItem.parentGroup)
  };
};
var isChildIndex = (targetIndex, parentIndex) => {
  const sameIndex = parentIndex === targetIndex;
  const lastSeparatorIndex = targetIndex.lastIndexOf("_");
  const sameSubGroupIndex = targetIndex.substring(0, lastSeparatorIndex) === parentIndex;
  return !sameIndex && sameSubGroupIndex;
};
var GroupsService = class {
  constructor() {
    this.changes = new Subject();
    this.rowState = /* @__PURE__ */ new Set();
  }
  reset() {
    this.rowState.clear();
  }
  ngOnDestroy() {
    this.reset();
  }
  isExpanded(groupArgs) {
    if (this.userCallback) {
      return this.userCallback(groupArgs);
    }
    return !this.rowState.has(groupArgs.groupIndex);
  }
  isInExpandedGroup(groupItem) {
    let expanded = true;
    while (groupItem && expanded) {
      expanded = this.isExpanded({
        group: groupItem.data,
        groupIndex: groupItem.index,
        parentGroup: getGroupRowArgs(groupItem.parentGroup)
      });
      groupItem = groupItem.parentGroup;
    }
    return expanded;
  }
  toggleRow(groupItem, emit2 = true) {
    const parentGroup = getGroupRowArgs(groupItem.parentGroup);
    const expand = !this.isExpanded({
      group: groupItem.data,
      groupIndex: groupItem.index,
      parentGroup
    });
    this.changes.next({
      group: groupItem.data,
      expand,
      groupIndex: groupItem.index,
      parentGroup,
      emit: emit2
    });
    if (this.userCallback) {
      return;
    }
    if (expand) {
      this.rowState.delete(groupItem.index);
    } else {
      this.rowState.add(groupItem.index);
    }
  }
  expandChildren(parentIndex) {
    this.rowState.forEach((index) => isChildIndex(index, parentIndex) && this.rowState.delete(index));
  }
};
GroupsService.ɵfac = function GroupsService_Factory(t) {
  return new (t || GroupsService)();
};
GroupsService.ɵprov = ɵɵdefineInjectable({
  token: GroupsService,
  factory: GroupsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupsService, [{
    type: Injectable
  }], null, null);
})();
var PagerContextService = class {
  constructor() {
    this.changes = new Subject();
    this.pageChange = new Subject();
  }
  get currentPage() {
    return this.skip / this.pageSize;
  }
  notifyChanges(changes) {
    this.total = changes.total;
    this.pageSize = changes.pageSize;
    this.skip = changes.skip;
    this.changes.next(changes);
  }
  changePage(page) {
    this.pageChange.next({
      skip: page * this.pageSize,
      take: this.pageSize
    });
  }
  changePageSize(value2) {
    this.pageChange.next({
      skip: 0,
      take: value2
    });
  }
  nextPage() {
    const nextPage = this.currentPage + 1;
    if (nextPage * this.pageSize < this.total) {
      this.changePage(nextPage);
    }
  }
  prevPage() {
    const prevPage = this.currentPage - 1;
    if (prevPage * this.pageSize >= 0) {
      this.changePage(prevPage);
    }
  }
};
var DetailCollapseEvent = class extends PreventableEvent2 {
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailExpandEvent = class extends PreventableEvent2 {
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DetailsService = class {
  constructor() {
    this.changes = new Subject();
    this.rowState = /* @__PURE__ */ new Set();
  }
  ngOnDestroy() {
    this.rowState.clear();
  }
  isExpanded(index, dataItem) {
    if (this.userCallback) {
      return this.userCallback({
        index,
        dataItem
      });
    }
    return this.rowState.has(index);
  }
  toggleRow(index, dataItem) {
    if (this.isExpanded(index, dataItem)) {
      this.collapseRow(index, dataItem);
    } else {
      this.expandRow(index, dataItem);
    }
  }
  expandRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: true
    });
    if (!prevented && !this.userCallback) {
      this.rowState.add(index);
    }
  }
  collapseRow(index, dataItem) {
    const prevented = this.emitEvent({
      dataItem,
      index,
      expand: false
    });
    if (!prevented && !this.userCallback) {
      this.rowState.delete(index);
    }
  }
  emitEvent(args) {
    const eventArg = new (args.expand ? DetailExpandEvent : DetailCollapseEvent)(args);
    this.changes.next(eventArg);
    return eventArg.isDefaultPrevented();
  }
};
DetailsService.ɵfac = function DetailsService_Factory(t) {
  return new (t || DetailsService)();
};
DetailsService.ɵprov = ɵɵdefineInjectable({
  token: DetailsService,
  factory: DetailsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailsService, [{
    type: Injectable
  }], null, null);
})();
var ScrollRequestService = class {
  constructor() {
    this.requests = new Subject();
  }
  scrollTo(request, adjustIndex = true) {
    this.requests.next({
      request,
      adjustIndex
    });
  }
  scrollToItem(request) {
    this.requests.next({
      request
    });
  }
};
ScrollRequestService.ɵfac = function ScrollRequestService_Factory(t) {
  return new (t || ScrollRequestService)();
};
ScrollRequestService.ɵprov = ɵɵdefineInjectable({
  token: ScrollRequestService,
  factory: ScrollRequestService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollRequestService, [{
    type: Injectable
  }], null, null);
})();
var isInSameGrid = (element, gridElement) => closest2(element, matchesNodeName("kendo-grid")) === gridElement;
var matchHeaderCell = matchesNodeName("th");
var matchDataCell = matchesNodeName("td");
var matchFooterCell = matchesNodeName(".k-grid-footer td");
var matchCell = (element) => matchDataCell(element) || matchHeaderCell(element) || matchFooterCell(element);
var gridCell = (element, gridElement) => {
  let target = closest2(element, matchCell);
  while (target && !isInSameGrid(target, gridElement)) {
    target = closest2(target.parentElement, matchCell);
  }
  return target;
};
var targetCell = (target, gridElement) => {
  const cell2 = gridCell(target, gridElement);
  const row2 = closest2(cell2, matchesNodeName("tr"));
  if (cell2 && row2) {
    let rowIndex = row2.getAttribute("aria-rowindex") || row2.getAttribute("data-kendo-grid-row-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) - 1 : null;
    let colIndex = cell2.getAttribute("aria-colindex");
    colIndex = colIndex ? parseInt(colIndex, 10) - 1 : null;
    if (rowIndex !== null && colIndex !== null) {
      return {
        colIndex,
        rowIndex,
        element: cell2
      };
    }
  }
};
var isArrowKey = (keyCode) => keyCode === Keys.ArrowLeft || keyCode === Keys.ArrowRight || keyCode === Keys.ArrowUp || keyCode === Keys.ArrowDown;
var isNavigationKey = (keyCode) => isArrowKey(keyCode) || keyCode === Keys.PageUp || keyCode === Keys.PageDown || keyCode === Keys.Home || keyCode === Keys.End;
var isInput = matchesNodeName("input");
var isTextInput = (element) => element && isInput(element) && element.type.toLowerCase() === "text";
var isPrintableCharacter = (str) => str.length === 1 && str.match(/\S/);
var NavigationViewport = class {
  constructor(firstItemIndex, lastItemIndex) {
    this.firstItemIndex = firstItemIndex;
    this.lastItemIndex = lastItemIndex;
  }
  containsRow(dataRowIndex) {
    const headerRow2 = dataRowIndex < 0;
    return headerRow2 || dataRowIndex >= this.firstItemIndex && dataRowIndex <= this.lastItemIndex;
  }
  intersects(start, end2) {
    return start <= this.firstItemIndex && this.lastItemIndex <= end2 || this.firstItemIndex <= start && start <= this.lastItemIndex || this.firstItemIndex <= end2 && end2 <= this.lastItemIndex;
  }
};
var NavigationService = class {
  constructor(zone, domEvents, pagerContextService, scrollRequestService, groupsService, detailsService, focusRoot, editService, cd, ctx, focusableParent) {
    this.zone = zone;
    this.domEvents = domEvents;
    this.pagerContextService = pagerContextService;
    this.scrollRequestService = scrollRequestService;
    this.groupsService = groupsService;
    this.detailsService = detailsService;
    this.focusRoot = focusRoot;
    this.editService = editService;
    this.cd = cd;
    this.ctx = ctx;
    this.focusableParent = focusableParent;
    this.cellKeydown = new EventEmitter();
    this.activeRowIndex = 0;
    this.alive = false;
    this.active = true;
    this.mode = 0;
    this.model = new NavigationModel();
    this.cursor = new NavigationCursor(this.model);
    this.pagerIsNavigable = false;
    this.tableIsNavigable = false;
    this.toolbarIsNavigable = false;
    this.changes = this.cursor.changes;
  }
  set metadata(value2) {
    this.meta = value2;
    this.cursor.metadata = value2;
  }
  get metadata() {
    return this.meta;
  }
  get enabled() {
    return this.alive;
  }
  get pagerEnabled() {
    return this.alive && this.pagerIsNavigable;
  }
  get tableEnabled() {
    return this.alive && this.tableIsNavigable;
  }
  get toolbarEnabled() {
    return this.alive && this.toolbarIsNavigable;
  }
  get activeCell() {
    if (this.mode !== 0) {
      return this.cursor.cell;
    }
  }
  get activeRow() {
    if (this.mode !== 0) {
      return Object.assign({}, this.cursor.row, {
        cells: this.cursor.row.cells.toArray()
      });
    }
  }
  get activeDataRow() {
    return Math.max(0, this.activeRowIndex - this.meta.headerRows);
  }
  init(meta, navigableOptions) {
    this.setActiveSections(navigableOptions);
    this.alive = true;
    this.focusRoot.active = true;
    this.metadata = meta;
    const onStableSubscriber = (...operators) => (args) => this.zone.isStable ? from([true]).pipe(map(() => args)) : this.zone.onStable.pipe(take(1), map(() => args), ...operators);
    const onStable = onStableSubscriber();
    this.subs = new Subscription();
    this.subs.add(this.cursor.changes.subscribe((args) => this.onCursorChanges(args)));
    this.subs.add(this.domEvents.focus.pipe(switchMap(onStable)).subscribe((args) => this.navigateTo(args.target)));
    this.subs.add(this.domEvents.focusOut.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    ), switchMap(onStableSubscriber(takeUntil(this.domEvents.focus)))).subscribe((args) => this.onFocusOut(args)));
    this.subs.add(this.domEvents.windowBlur.pipe(filter(
      () => this.mode !== 0
      /* NavigationMode.Standby */
    )).subscribe(() => this.onWindowBlur()));
    this.subs.add(
      // Closing the editor will not always trigger focusout in Firefox.
      // To get around this, we ensure that the cell is closed after editing.
      this.editService.changes.pipe(filter(
        (e) => e.action !== "edit" && this.mode === 2
        /* NavigationMode.Content */
      ), filter((e) => e.action === "cellClose" && !e.prevented), switchMap(onStable)).subscribe(() => this.leaveCell())
    );
    this.subs.add(this.pagerContextService.pageChange.subscribe(() => this.cursor.reset(0, 0)));
    this.subs.add(this.domEvents.keydown.subscribe((args) => this.onKeydown(args)));
    this.subs.add(this.domEvents.keydown.pipe(filter(
      (args) => args.keyCode === Keys.Tab && this.mode === 2
      /* NavigationMode.Content */
    ), switchMapTo(this.domEvents.focusOut.pipe(takeUntil(
      // Timeout if focusOut doesn't fire very soon
      interval(0).pipe(take(1))
    )))).subscribe(() => this.onTabout()));
    if (this.focusableParent) {
      const element = new GridFocusableElement(this);
      this.focusableParent.registerElement(element);
    }
    this.deactivateElements();
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
    this.alive = false;
  }
  registerCell(cell2) {
    if (cell2.logicalRowIndex !== this.pendingRowIndex) {
      const modelCell = this.model.registerCell(cell2);
      if (this.virtualCell && this.cursor.activateVirtualCell(modelCell)) {
        this.virtualCell = false;
      }
    }
  }
  registerCellOnCurrentRow(cell2) {
    if (cell2.logicalRowIndex === this.pendingRowIndex) {
      this.model.registerCell(cell2);
    }
  }
  unregisterCell(index, rowIndex, cell2) {
    this.model.unregisterCell(index, rowIndex, cell2);
  }
  registerRow(row2) {
    this.model.registerRow(row2);
    this.pendingRowIndex = row2.logicalRowIndex;
  }
  updateRow(row2) {
    this.model.updateRow(row2);
  }
  unregisterRow(index, row2) {
    this.model.unregisterRow(index, row2);
    const lastRow = this.model.lastRow;
    if (lastRow && this.mode === 0) {
      const maxIndex = this.needsViewport() && this.viewport ? this.viewport.lastItemIndex : lastRow.index;
      if (this.activeRowIndex > maxIndex) {
        this.cursor.reset(0, 0);
      }
    }
  }
  isCellFocusable(cell2) {
    return this.alive && this.active && this.mode !== 2 && this.cursor.isActive(cell2.logicalRowIndex, cell2.logicalColIndex);
  }
  isCellFocused(cell2) {
    return this.mode === 1 && this.isCellFocusable(cell2);
  }
  navigateTo(el) {
    if (!this.alive || !isDocumentAvailable()) {
      return;
    }
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (!cell2) {
      return;
    }
    const oldMode = this.mode;
    const focusInCell = contains$2(cell2.element, document.activeElement);
    const focusInActiveRowContent = this.mode === 2 && this.activeRowIndex === cell2.rowIndex && el !== cell2.element;
    if (focusInCell) {
      this.mode = 2;
      this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      this.activateRow();
    } else if (!focusInActiveRowContent) {
      this.mode = 1;
      this.deactivateElements();
      const alreadyActive = this.cursor.isActive(cell2.rowIndex, cell2.colIndex);
      const isCursor = oldMode === 1 && alreadyActive;
      if (!isCursor) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
      }
    }
  }
  tryFocus(el) {
    this.activateElements();
    const focusable = findFocusableChild(el);
    if (focusable) {
      const cell2 = targetCell(focusable, this.meta.gridElement.nativeElement);
      if (cell2) {
        this.cursor.reset(cell2.rowIndex, cell2.colIndex);
        this.deactivateElements();
        this.enterCell();
      }
      focusable.focus();
    } else {
      this.deactivateElements();
    }
    return !!focusable;
  }
  needsViewport() {
    return this.meta && this.meta.isVirtual;
  }
  setViewport(firstItemIndex, lastItemIndex) {
    this.viewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const dataRowIndex = this.activeDataRow;
      const ahead = firstItemIndex - dataRowIndex;
      const behind = dataRowIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(firstItemIndex + this.meta.headerRows);
      } else if (behind > 0) {
        this.cursor.reset(lastItemIndex - this.meta.headerRows);
      }
    }
  }
  setColumnViewport(firstItemIndex, lastItemIndex) {
    this.columnViewport = new NavigationViewport(firstItemIndex, lastItemIndex);
    if (this.meta && this.meta.isVirtual && this.activeDataRow > -1) {
      const activeColumnIndex = this.cursor.cell ? this.cursor.cell.colIndex : 0;
      const ahead = firstItemIndex - activeColumnIndex;
      const behind = activeColumnIndex - lastItemIndex;
      if (ahead > 0) {
        this.cursor.reset(void 0, firstItemIndex, false);
      } else if (behind > 0) {
        this.cursor.reset(void 0, lastItemIndex, false);
      }
    }
  }
  focusCell(rowIndex = void 0, colIndex = void 0) {
    this.mode = 1;
    this.cursor.reset(rowIndex, colIndex);
    return this.activeCell;
  }
  focusCellByElement(el) {
    const cell2 = targetCell(el, this.meta.gridElement.nativeElement);
    if (cell2) {
      return this.focusCell(cell2.rowIndex, cell2.colIndex);
    }
  }
  focusNextCell(wrap = true) {
    return this.focusAdjacentCell(true, wrap);
  }
  focusPrevCell(wrap = true) {
    return this.focusAdjacentCell(false, wrap);
  }
  toggle(active) {
    this.active = active;
    this.cursor.announce();
  }
  hasFocus() {
    return this.mode === 1 || this.mode === 2;
  }
  autoFocusCell(start, end2) {
    return !this.meta.virtualColumns || end2 < this.meta.columns.lockedLeafColumns.length || this.columnViewport.intersects(start, end2);
  }
  setActiveSections(navigableOptions) {
    this.pagerIsNavigable = navigableOptions.includes("pager");
    this.tableIsNavigable = navigableOptions.includes("table");
    this.toolbarIsNavigable = navigableOptions.includes("toolbar");
  }
  focusAdjacentCell(fwd, wrap) {
    this.focusCell();
    let success = fwd ? this.moveCursorFwd() : this.moveCursorBwd();
    if (wrap && !success) {
      success = fwd ? this.cursor.moveDown(1) : this.cursor.moveUp(1);
      if (success) {
        const row2 = this.cursor.row;
        const colIdx = fwd ? 0 : this.cursor.lastCellIndex(row2);
        this.cursor.reset(row2.index, colIdx);
      }
    }
    if (success) {
      return this.activeCell;
    } else {
      this.mode = 0;
      this.cursor.announce();
    }
    return null;
  }
  enterCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    const group2 = cell2.focusGroup;
    const focusable = group2 && group2.canFocus();
    this.mode = focusable ? 2 : 1;
    this.cursor.announce();
    if (focusable) {
      this.activateRow();
      group2.focus();
    }
  }
  leaveCell() {
    const cell2 = this.cursor.cell;
    if (!cell2) {
      return;
    }
    const group2 = cell2.focusGroup;
    const focusable = group2 && group2.canFocus();
    if (!focusable) {
      this.deactivateElements();
    }
    this.mode = 1;
    this.cursor.announce();
  }
  activateElements() {
    this.focusRoot.activate();
  }
  deactivateElements() {
    this.focusRoot.deactivate();
  }
  activateRow() {
    this.cursor.row.cells.forEach((cell2) => cell2.focusGroup && cell2.focusGroup.activate());
  }
  moveCursorFwd() {
    return this.ctx.localization.rtl ? this.cursor.moveLeft() : this.cursor.moveRight();
  }
  moveCursorBwd() {
    return this.ctx.localization.rtl ? this.cursor.moveRight() : this.cursor.moveLeft();
  }
  onCursorKeydown(args) {
    let preventDefault = false;
    const modifier = args.ctrlKey || args.metaKey;
    const step = modifier ? 5 : 1;
    if (!this.onCellKeydown(args)) {
      return;
    }
    const row2 = this.cursor.row;
    switch (args.keyCode) {
      case Keys.ArrowDown:
        preventDefault = this.cursor.moveDown(step);
        break;
      case Keys.ArrowUp:
        preventDefault = this.cursor.moveUp(step);
        break;
      case Keys.ArrowRight:
        preventDefault = this.moveCursorFwd();
        break;
      case Keys.ArrowLeft:
        preventDefault = this.moveCursorBwd();
        break;
      case Keys.PageDown:
        if (this.metadata.isVirtual && this.viewport) {
          let nextItemIndex = this.meta.headerRows + this.viewport.lastItemIndex + 1;
          if (this.metadata.hasDetailTemplate) {
            nextItemIndex++;
          }
          nextItemIndex = Math.min(this.meta.maxLogicalRowIndex, nextItemIndex);
          this.cursor.reset(nextItemIndex);
          preventDefault = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.nextPage());
          preventDefault = true;
        }
        break;
      case Keys.PageUp:
        if (this.metadata.isVirtual && this.viewport) {
          const viewportSize = this.viewport.lastItemIndex - this.viewport.firstItemIndex;
          const firstItemIndex = this.viewport.firstItemIndex;
          const nextItemIndex = Math.max(this.meta.headerRows, firstItemIndex - viewportSize - 1);
          this.cursor.reset(nextItemIndex);
          preventDefault = true;
        } else if (this.metadata.hasPager) {
          this.zone.run(() => this.pagerContextService.prevPage());
          preventDefault = true;
        }
        break;
      case Keys.Home:
        if (modifier) {
          if (this.meta.isVirtual) {
            this.cursor.reset(this.meta.headerRows, 0, false);
          } else {
            this.cursor.reset(this.model.firstRow.index, 0, false);
          }
        } else {
          let firstColumnIndex = 0;
          if (this.meta.hasDetailTemplate && row2.index < this.meta.headerRows) {
            firstColumnIndex = 1;
          }
          this.cursor.reset(row2.index, firstColumnIndex, false);
        }
        preventDefault = true;
        break;
      case Keys.End:
        if (modifier) {
          if (this.meta.isVirtual) {
            let lastRowIndex = this.meta.maxLogicalRowIndex;
            if (this.meta.hasDetailTemplate) {
              lastRowIndex--;
            }
            this.cursor.reset(lastRowIndex, this.cursor.lastCellIndex(), false);
          } else {
            this.cursor.reset(this.model.lastRow.index, this.cursor.lastCellIndex(this.model.lastRow), false);
          }
        } else {
          const lastIndex = this.cursor.lastCellIndex(row2);
          const cell2 = this.model.findCell(lastIndex, row2);
          if (cell2) {
            this.cursor.reset(cell2.rowIndex, cell2.colIndex);
          } else {
            this.cursor.reset(row2.index, lastIndex);
          }
        }
        preventDefault = true;
        break;
      case Keys.Enter:
      case Keys.F2: {
        const groupItem = row2.groupItem;
        if (groupItem) {
          this.zone.run(() => this.groupsService.toggleRow(groupItem));
        } else if (this.cursor.cell.detailExpandCell) {
          this.zone.run(() => this.detailsService.toggleRow(row2.dataRowIndex, row2.dataItem));
        } else {
          this.enterCell();
          if (!this.cursor.cell.focusGroup.isNavigable()) {
            preventDefault = true;
          }
        }
        break;
      }
      default:
        if (!args.ctrlKey && !args.altKey && isPrintableCharacter(args.key)) {
          this.enterCell();
        }
    }
    if (preventDefault) {
      args.preventDefault();
    }
  }
  onContentKeydown(args) {
    if (!this.onCellKeydown(args)) {
      return;
    }
    const confirm = !args.defaultPrevented && args.keyCode === Keys.Enter && isTextInput(args.srcElement);
    if (args.keyCode === Keys.Escape || args.keyCode === Keys.F2 || confirm) {
      this.leaveCell();
      this.cursor.reset();
      args.stopPropagation();
    } else if (isNavigationKey(args.keyCode) && this.cursor.cell.focusGroup.isNavigable()) {
      this.onCursorKeydown(args);
      if (args.defaultPrevented) {
        this.leaveCell();
      }
    }
  }
  onCellKeydown(args) {
    if (this.editService.isEditingCell()) {
      const confirm = args.keyCode === Keys.Enter;
      const cancel = args.keyCode === Keys.Escape;
      const navigate = isNavigationKey(args.keyCode);
      if (confirm) {
        this.editService.closeCell(args);
      } else if (cancel) {
        this.editService.closeCell(args);
        this.cd.detectChanges();
      } else if (navigate) {
        return false;
      }
    }
    this.cellKeydown.emit(args);
    return true;
  }
  onCursorChanges(args) {
    this.activeRowIndex = args.rowIndex;
    const dataRowIndex = this.activeDataRow;
    if (this.meta && this.meta.isVirtual && args.rowIndex >= this.meta.headerRows && this.viewport && !this.viewport.containsRow(dataRowIndex) && dataRowIndex > -1) {
      this.scrollRequestService.scrollTo({
        row: dataRowIndex
      });
    }
    if (this.meta.virtualColumns && args.colIndex >= this.meta.columns.lockedLeafColumns.length) {
      const cell2 = this.activeCell;
      const {
        start,
        end: end2
      } = this.model.cellRange(cell2);
      if (!cell2) {
        this.virtualCell = true;
      }
      if (!cell2 && this.mode !== 0 || cell2 && !this.columnViewport.intersects(start, end2)) {
        this.scrollRequestService.scrollTo({
          column: args.colIndex - (this.metadata.hasDetailTemplate ? 1 : 0)
        });
      }
    }
  }
  onFocusOut(args) {
    if (isVisible(args.target)) {
      this.mode = 0;
    } else {
      this.mode = 1;
    }
    this.deactivateElements();
    this.cursor.announce();
  }
  onWindowBlur() {
    this.mode = 0;
    this.deactivateElements();
    this.cursor.announce();
  }
  onKeydown(args) {
    if (this.mode === 1) {
      this.onCursorKeydown(args);
    } else if (this.mode === 2) {
      this.onContentKeydown(args);
    }
  }
  onTabout() {
    if (this.cursor.cell.focusGroup.isNavigable()) {
      return;
    }
    this.leaveCell();
    this.cursor.reset();
  }
};
NavigationService.ɵfac = function NavigationService_Factory(t) {
  return new (t || NavigationService)(ɵɵinject(NgZone), ɵɵinject(DomEventsService), ɵɵinject(PagerContextService), ɵɵinject(ScrollRequestService), ɵɵinject(GroupsService), ɵɵinject(DetailsService), ɵɵinject(FocusRoot), ɵɵinject(EditService), ɵɵinject(ChangeDetectorRef), ɵɵinject(ContextService), ɵɵinject(FocusableDirective, 8));
};
NavigationService.ɵprov = ɵɵdefineInjectable({
  token: NavigationService,
  factory: NavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: DomEventsService
    }, {
      type: PagerContextService
    }, {
      type: ScrollRequestService
    }, {
      type: GroupsService
    }, {
      type: DetailsService
    }, {
      type: FocusRoot
    }, {
      type: EditService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: FocusableDirective,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var sequence = 0;
var IdService = class {
  constructor() {
    this.prefix = `k-grid${sequence++}`;
  }
  gridId() {
    return this.prefix;
  }
  cellId(rowIndex, colIndex) {
    return `${this.prefix}-r${rowIndex}c${colIndex}`;
  }
  selectionCheckboxId(itemIndex) {
    return `${this.prefix}-checkbox${itemIndex}`;
  }
  selectAllCheckboxId() {
    return `${this.prefix}-select-all`;
  }
};
IdService.ɵfac = function IdService_Factory(t) {
  return new (t || IdService)();
};
IdService.ɵprov = ɵɵdefineInjectable({
  token: IdService,
  factory: IdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IdService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var HeaderTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
HeaderTemplateDirective.ɵfac = function HeaderTemplateDirective_Factory(t) {
  return new (t || HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
HeaderTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: HeaderTemplateDirective,
  selectors: [["", "kendoGridHeaderTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridHeaderTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FooterTemplateDirective2 = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
FooterTemplateDirective2.ɵfac = function FooterTemplateDirective_Factory2(t) {
  return new (t || FooterTemplateDirective2)(ɵɵdirectiveInject(TemplateRef, 8));
};
FooterTemplateDirective2.ɵdir = ɵɵdefineDirective({
  type: FooterTemplateDirective2,
  selectors: [["", "kendoGridFooterTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFooterTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnMenuTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
ColumnMenuTemplateDirective.ɵfac = function ColumnMenuTemplateDirective_Factory(t) {
  return new (t || ColumnMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
ColumnMenuTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnMenuTemplateDirective,
  selectors: [["", "kendoGridColumnMenuTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnMenuErrorMessages = {
  autoSizeColumn: `The auto size column does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-column-item.`,
  autoSizeAllColumns: `The auto size all columns does not work with enabled virtual columns.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-autosize-all-columns-item.`,
  serviceInput: `The service input of the predefined column menu components is mandatory.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/column-menu/#toc-customizing-the-content.`
};
var ClipboardErrorMessages = {
  activeCellNavigable: `Grid must be navigable to use "activeCell" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-active-cell.`,
  selectionSelectable: `Grid must be selectable to use "selection" as clipboard target type.
    See https://www.telerik.com/kendo-angular-ui/components/grid/accessories/clipboard/#toc-current-selection.`
};
var ColumnConfigurationErrorMessages = {
  fieldName: (field) => `Grid column field name '${field}' does not look like a valid JavaScript identifier.
        Identifiers can contain only alphanumeric characters (including "$" or "_"), and may not start with a digit.
        Please use only valid identifier names to ensure error-free operation.`,
  width: (value2, parsedValue) => `Expected numeric value for column width, but got a string "${value2}". Treating as ${parsedValue}px.`,
  invalidColumn: (column) => `Invalid column ${column}.`,
  requiredWidth: (columnType) => `${columnType} columns feature requires all columns to have set width.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}.`,
  requiredScroll: (columnType) => `${columnType} columns are only supported when scrolling is enabled.
    See https://www.telerik.com/kendo-angular-ui/components/grid/columns/${columnType.toLowerCase()}/`,
  groupColumnContent: "ColumnGroupComponent should contain ColumnComponent or CommandColumnComponent.",
  lockedParent: "Locked child columns require their parent columns to be locked.",
  columnNested: "Columns can be nested only inside ColumnGroupComponent",
  nestedInside: (nestedColumnNameType, parentColumnType) => `${nestedColumnNameType} cannot be nested inside ${parentColumnType}.`
};
var GridConfigurationErrorMessages = {
  functionType: (propName, fn) => `${propName} must be a function, but received ${JSON.stringify(fn)}.`,
  incompatibleFeatures: (feat1Name, feat2Name) => `'Having both ${feat1Name} and ${feat2Name} is not supported.'`,
  nonLockedColumnPresent: "There should be at least one non-locked column. See https://www.telerik.com/kendo-angular-ui/components/grid/columns/locked/#toc-known-limitations",
  rowHeightVirtual: `The virtual scrolling functionality requires setting the rowHeight (and detailRowHeight when there are detail rows).
        Row height and detail row height settings should be set only when virtual scrolling mode is enabled.
        See https://www.telerik.com/kendo-angular-ui/components/grid/scroll-modes/virtual/#toc-getting-started.`,
  focusNavigable: "The Grid should be configured as navigable to control focus. See https://www.telerik.com/kendo-angular-ui/components/grid/keyboard-navigation/.",
  expandCollapseMethods: (expandMethodName, collapseMethodName, directiveName, callbackName) => `The ${expandMethodName} and ${collapseMethodName} methods should not be called
        when using the ${directiveName} directive or the ${callbackName} callback.
        These methods are provided only for backwards compatibility with legacy versions.`,
  requiredEditService: `The default edit service of the editing directives works only when binding to plain array.
        Please provide an editService. See https://www.telerik.com/kendo-angular-ui/components/grid/editing/editing-directives/#toc-custom-editing-service.`,
  requiredModule: (exportedType, moduleName, componentSelector) => `Creating ${exportedType} requires including the ${moduleName} and adding the ${componentSelector} component.`,
  groupBindingDirectives: `Using the "kendoGridGroupBinding" directive in combination with the "kendoGridExpandGroupBy" directive
        or the "isGroupExpanded" callback is not supported. To use grouping with the "kendoGridGroupBinding" directive,
        set the Grid "groupable" property to "true".`,
  unsupportedMethod: (methodName, suggestedMethodName) => `Using ${methodName} in this context is not supported. Use ${suggestedMethodName} instead.`
};
var isSpanColumn = (column) => column.isSpanColumn;
var isCheckboxColumn = (column) => column.isCheckboxColumn;
var isRowReorderColumn = (column) => column.isRowReorderColumn;
var isColumnContainer = (column) => column.isColumnGroup || isSpanColumn(column);
var ColumnBase2 = class {
  /**
   * @hidden
   */
  constructor(parent, idService) {
    this.parent = parent;
    this.matchesMedia = true;
    this.orderIndex = 0;
    this.isColumnGroup = false;
    this.isSpanColumn = false;
    this.resizable = true;
    this.reorderable = true;
    this.minResizableWidth = 10;
    this._locked = false;
    this.sticky = false;
    this.lockable = true;
    this.stickable = true;
    this.columnMenu = true;
    this.includeInChooser = true;
    this.tableCellsRole = "gridcell";
    this.headerTemplates = new QueryList();
    this.columnMenuTemplates = new QueryList();
    this.idService = idService;
    if (parent && idService && parent.idService.gridId() === idService.gridId() && !isColumnContainer(parent)) {
      throw new Error(ColumnConfigurationErrorMessages.columnNested);
    }
  }
  /**
   * @hidden
   */
  set leafIndex(value2) {
    this._leafIndex = value2;
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this._leafIndex;
  }
  /**
   * The width of the column (in pixels).
   */
  set width(value2) {
    if (typeof value2 === "string") {
      const parsedValue = this._width = parseInt(value2, 10);
      if (isDevMode()) {
        console.warn(ColumnConfigurationErrorMessages.width(value2, parsedValue));
      }
    } else {
      this._width = value2;
    }
  }
  get width() {
    return this._width;
  }
  /**
   * Toggles the locked (frozen) state of the columns ([more information and example]({% slug locked_columns_grid %})).
   *
   * @default false
   *
   */
  set locked(value2) {
    this._locked = value2;
  }
  get locked() {
    return this._locked;
  }
  /**
   * @hidden
   */
  get level() {
    if (this.parent && isSpanColumn(this.parent)) {
      return this.parent.level;
    }
    return this.parent ? this.parent.level + 1 : 0;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.parent ? this.parent.isLocked : this.locked;
  }
  /**
   * @hidden
   */
  get colspan() {
    return 1;
  }
  /**
   * @hidden
   */
  rowspan(totalColumnLevels) {
    return this.level < totalColumnLevels ? totalColumnLevels - this.level + 1 : 1;
  }
  /**
   * @hidden
   */
  get headerTemplateRef() {
    const template = this.headerTemplates.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get footerTemplateRef() {
    return this.footerTemplate ? this.footerTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get columnMenuTemplateRef() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  /**
   * @hidden
   */
  get displayTitle() {
    return this.title;
  }
  /**
   * @hidden
   */
  get isVisible() {
    return !this.hidden && this.matchesMedia;
  }
};
ColumnBase2.ɵfac = function ColumnBase_Factory2(t) {
  return new (t || ColumnBase2)(ɵɵdirectiveInject(ColumnBase2), ɵɵdirectiveInject(IdService));
};
ColumnBase2.ɵcmp = ɵɵdefineComponent({
  type: ColumnBase2,
  selectors: [["kendo-grid-column-base"]],
  contentQueries: function ColumnBase_ContentQueries2(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, FooterTemplateDirective2, 5);
      ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplates = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    }
  },
  inputs: {
    resizable: "resizable",
    reorderable: "reorderable",
    minResizableWidth: "minResizableWidth",
    maxResizableWidth: "maxResizableWidth",
    title: "title",
    width: "width",
    autoSize: "autoSize",
    locked: "locked",
    sticky: "sticky",
    hidden: "hidden",
    media: "media",
    lockable: "lockable",
    stickable: "stickable",
    columnMenu: "columnMenu",
    includeInChooser: "includeInChooser",
    tableCellsRole: "tableCellsRole",
    style: "style",
    headerStyle: "headerStyle",
    filterStyle: "filterStyle",
    footerStyle: "footerStyle",
    cssClass: [0, "class", "cssClass"],
    headerClass: "headerClass",
    filterClass: "filterClass",
    footerClass: "footerClass"
  },
  decls: 0,
  vars: 0,
  template: function ColumnBase_Template2(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnBase2, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-base",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2
    }, {
      type: IdService
    }];
  }, {
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    minResizableWidth: [{
      type: Input
    }],
    maxResizableWidth: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    locked: [{
      type: Input
    }],
    sticky: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    media: [{
      type: Input
    }],
    lockable: [{
      type: Input
    }],
    stickable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    includeInChooser: [{
      type: Input
    }],
    tableCellsRole: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    headerStyle: [{
      type: Input
    }],
    filterStyle: [{
      type: Input
    }],
    footerStyle: [{
      type: Input
    }],
    cssClass: [{
      type: Input,
      args: ["class"]
    }],
    headerClass: [{
      type: Input
    }],
    filterClass: [{
      type: Input
    }],
    footerClass: [{
      type: Input
    }],
    headerTemplates: [{
      type: ContentChildren,
      args: [HeaderTemplateDirective, {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective2, {
        static: false
      }]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }]
  });
})();
var CellTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
CellTemplateDirective.ɵfac = function CellTemplateDirective_Factory(t) {
  return new (t || CellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
CellTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: CellTemplateDirective,
  selectors: [["", "kendoGridCellTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var EditTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
EditTemplateDirective.ɵfac = function EditTemplateDirective_Factory(t) {
  return new (t || EditTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
EditTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: EditTemplateDirective,
  selectors: [["", "kendoGridEditTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderTemplateDirective2 = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupHeaderTemplateDirective2.ɵfac = function GroupHeaderTemplateDirective_Factory2(t) {
  return new (t || GroupHeaderTemplateDirective2)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupHeaderTemplateDirective2.ɵdir = ɵɵdefineDirective({
  type: GroupHeaderTemplateDirective2,
  selectors: [["", "kendoGridGroupHeaderTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupHeaderColumnTemplateDirective2 = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupHeaderColumnTemplateDirective2.ɵfac = function GroupHeaderColumnTemplateDirective_Factory2(t) {
  return new (t || GroupHeaderColumnTemplateDirective2)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupHeaderColumnTemplateDirective2.ɵdir = ɵɵdefineDirective({
  type: GroupHeaderColumnTemplateDirective2,
  selectors: [["", "kendoGridGroupHeaderColumnTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderColumnTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupHeaderColumnTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var GroupFooterTemplateDirective2 = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
GroupFooterTemplateDirective2.ɵfac = function GroupFooterTemplateDirective_Factory2(t) {
  return new (t || GroupFooterTemplateDirective2)(ɵɵdirectiveInject(TemplateRef, 8));
};
GroupFooterTemplateDirective2.ɵdir = ɵɵdefineDirective({
  type: GroupFooterTemplateDirective2,
  selectors: [["", "kendoGridGroupFooterTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupFooterTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupFooterTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FilterCellTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
FilterCellTemplateDirective.ɵfac = function FilterCellTemplateDirective_Factory(t) {
  return new (t || FilterCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
FilterCellTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: FilterCellTemplateDirective,
  selectors: [["", "kendoGridFilterCellTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterCellTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var FilterMenuTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
FilterMenuTemplateDirective.ɵfac = function FilterMenuTemplateDirective_Factory(t) {
  return new (t || FilterMenuTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
FilterMenuTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: FilterMenuTemplateDirective,
  selectors: [["", "kendoGridFilterMenuTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterMenuTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
function isColumnComponent(column) {
  return isPresent4(column.field);
}
var ColumnComponent2 = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.sortable = true;
    this.groupable = true;
    this.editor = "text";
    this.filter = "text";
    this.filterable = true;
    this.editable = true;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
  get groupHeaderTemplateRef() {
    return this.groupHeaderTemplate ? this.groupHeaderTemplate.templateRef : void 0;
  }
  get groupHeaderColumnTemplateRef() {
    return this.groupHeaderColumnTemplate ? this.groupHeaderColumnTemplate.templateRef : void 0;
  }
  get groupFooterTemplateRef() {
    return this.groupFooterTemplate ? this.groupFooterTemplate.templateRef : void 0;
  }
  get editTemplateRef() {
    return this.editTemplate ? this.editTemplate.templateRef : void 0;
  }
  get filterCellTemplateRef() {
    return this.filterCellTemplate ? this.filterCellTemplate.templateRef : void 0;
  }
  get filterMenuTemplateRef() {
    return this.filterMenuTemplate ? this.filterMenuTemplate.templateRef : void 0;
  }
  get displayTitle() {
    return this.title === void 0 ? this.field : this.title;
  }
};
ColumnComponent2.ɵfac = function ColumnComponent_Factory2(t) {
  return new (t || ColumnComponent2)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
ColumnComponent2.ɵcmp = ɵɵdefineComponent({
  type: ColumnComponent2,
  selectors: [["kendo-grid-column"]],
  contentQueries: function ColumnComponent_ContentQueries2(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, GroupHeaderTemplateDirective2, 5);
      ɵɵcontentQuery(dirIndex, GroupHeaderColumnTemplateDirective2, 5);
      ɵɵcontentQuery(dirIndex, GroupFooterTemplateDirective2, 5);
      ɵɵcontentQuery(dirIndex, EditTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, FilterCellTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, FilterMenuTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupHeaderColumnTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupFooterTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterCellTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenuTemplate = _t.first);
    }
  },
  inputs: {
    field: "field",
    format: "format",
    sortable: "sortable",
    groupable: "groupable",
    editor: "editor",
    filter: "filter",
    filterable: "filterable",
    editable: "editable"
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => ColumnComponent2)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ColumnComponent_Template2(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnComponent2)
      }],
      selector: "kendo-grid-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    field: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    editor: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }],
    groupHeaderTemplate: [{
      type: ContentChild,
      args: [GroupHeaderTemplateDirective2, {
        static: false
      }]
    }],
    groupHeaderColumnTemplate: [{
      type: ContentChild,
      args: [GroupHeaderColumnTemplateDirective2, {
        static: false
      }]
    }],
    groupFooterTemplate: [{
      type: ContentChild,
      args: [GroupFooterTemplateDirective2, {
        static: false
      }]
    }],
    editTemplate: [{
      type: ContentChild,
      args: [EditTemplateDirective, {
        static: false
      }]
    }],
    filterCellTemplate: [{
      type: ContentChild,
      args: [FilterCellTemplateDirective, {
        static: false
      }]
    }],
    filterMenuTemplate: [{
      type: ContentChild,
      args: [FilterMenuTemplateDirective, {
        static: false
      }]
    }]
  });
})();
function isSpanColumnComponent(column) {
  return column.isSpanColumn;
}
var SpanColumnComponent = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.isSpanColumn = true;
    this.template = new QueryList();
    this.editTemplate = new QueryList();
    this.childColumns = new QueryList();
    this.includeInChooser = false;
    this._editable = true;
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("SpanColumnComponent", "SpanColumnComponent"));
    }
  }
  /**
   * Defines whether the edit template of the column will be rendered.
   * To enable the editing functionality for a spanned column, set an edit template for it ([see example](slug:custom_reactive_editing_grid)).
   * @default false
   */
  set editable(value2) {
    this._editable = value2;
  }
  get editable() {
    return isPresent4(this.editTemplateRef) && this._editable;
  }
  /**
   * @hidden
   * added for backwards compitability
   */
  set width(_value) {
  }
  get width() {
    return this.childColumns.reduce((total, column) => total + column.width, 0);
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.childColumns.first.leafIndex;
  }
  /**
   * @hidden
   */
  get templateRef() {
    const template = this.template.first;
    return template ? template.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get editTemplateRef() {
    const editTemplate = this.editTemplate.first;
    return editTemplate ? editTemplate.templateRef : void 0;
  }
  /**
   * @hidden
   */
  get colspan() {
    return this.childColumns.filter((c) => c.isVisible).length;
  }
  /**
   * Toggles the locked (frozen) state of the columns ([see example](slug:locked_columns_grid)).
   * @default false
   */
  set locked(value2) {
    this._locked = value2;
  }
  get locked() {
    return this._locked || this.childColumns.some((c) => c.locked);
  }
  get childrenArray() {
    return this.childColumns.toArray();
  }
  get hasChildren() {
    return this.childColumns.length > 0;
  }
};
SpanColumnComponent.ɵfac = function SpanColumnComponent_Factory(t) {
  return new (t || SpanColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
SpanColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: SpanColumnComponent,
  selectors: [["kendo-grid-span-column"]],
  contentQueries: function SpanColumnComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CellTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, EditTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, ColumnComponent2, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.editTemplate = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.childColumns = _t);
    }
  },
  inputs: {
    editable: "editable",
    locked: "locked"
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => SpanColumnComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SpanColumnComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SpanColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => SpanColumnComponent)
      }],
      selector: "kendo-grid-span-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    template: [{
      type: ContentChildren,
      args: [CellTemplateDirective, {
        descendants: false
      }]
    }],
    editTemplate: [{
      type: ContentChildren,
      args: [EditTemplateDirective, {
        descendants: false
      }]
    }],
    childColumns: [{
      type: ContentChildren,
      args: [ColumnComponent2]
    }],
    editable: [{
      type: Input
    }],
    locked: [{
      type: Input
    }]
  });
})();
var expandColumns = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? column.childrenArray : [column]), []);
var expandColumnsWithSpan = (columns) => columns.reduce((acc, column) => acc.concat(isSpanColumnComponent(column) ? [column].concat(column.childrenArray) : [column]), []);
var columnsToRender = (columns) => expandColumns(columns).filter((x) => x.isVisible);
var sumProp = (prop2) => (array) => (array || []).reduce((prev, curr) => prev + (curr[prop2] || 0), 0);
var sumColumnWidths = sumProp("width");
var columnsSpan = sumProp("colspan");
var validField = new RegExp(`^[$A-Z_a-z][$A-Z_a-z0-9\\.]*$`);
var isValidFieldName = (fieldName) => !isNullOrEmptyString2(fieldName) && validField.test(fieldName) && fieldName[0] !== "." && fieldName[fieldName.length - 1] !== ".";
var children = (column) => column.children.filter((child) => child !== column);
var leafColumns = (columns) => {
  return columns.reduce((acc, column) => {
    if (column.isColumnGroup) {
      acc = acc.concat(leafColumns(children(column)));
    } else if (column.isSpanColumn) {
      acc = acc.concat(column.childrenArray);
    } else {
      acc.push(column);
    }
    return acc;
  }, []).filter((x) => x.isVisible);
};
var someLeafColumn = (callback, ...columns) => leafColumns(columns).some(callback);
var resizableColumns = (columns) => columns.filter((column) => isTruthy(column.resizable) && column.isVisible);
var sortColumns = (columns) => orderBy(columns, [{
  field: "orderIndex",
  dir: "asc"
}]);
var isInSpanColumn$1 = (column) => isTruthy(column.parent) && isSpanColumnComponent(column.parent);
function isColumnGroupComponent(column) {
  return column.isColumnGroup;
}
var ColumnGroupComponent2 = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
    this.includeInChooser = false;
    this.isColumnGroup = true;
    this.minResizableWidth = 10;
    if (parent && parent.isSpanColumn) {
      throw new Error(ColumnConfigurationErrorMessages.nestedInside("ColumnGroupComponent", "SpanColumnComponent"));
    }
  }
  /**
   * @hidden
   */
  rowspan() {
    return 1;
  }
  /**
   * @hidden
   */
  get colspan() {
    if (!this.children) {
      return 1;
    }
    return columnsSpan(this.children.filter((child) => child !== this && child.isVisible));
  }
  /**
   * @hidden
   */
  get leafIndex() {
    return this.children ? (this.firstChild || {}).leafIndex : -1;
  }
  get childrenArray() {
    return this.children.filter((c) => c !== this);
  }
  get hasChildren() {
    return Boolean(this.firstChild);
  }
  get firstChild() {
    return this.children.find((column) => column !== this);
  }
};
ColumnGroupComponent2.ɵfac = function ColumnGroupComponent_Factory2(t) {
  return new (t || ColumnGroupComponent2)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
ColumnGroupComponent2.ɵcmp = ɵɵdefineComponent({
  type: ColumnGroupComponent2,
  selectors: [["kendo-grid-column-group"]],
  contentQueries: function ColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => ColumnGroupComponent2)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ColumnGroupComponent_Template2(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnGroupComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => ColumnGroupComponent2)
      }],
      selector: "kendo-grid-column-group",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }]
  });
})();
var reset = (...lists) => {
  let diff = false;
  for (let idx = 0; idx < lists.length; idx++) {
    const [list, columns] = lists[idx];
    diff = diff || list.length !== columns.length;
    list.reset(columns);
  }
  return diff;
};
var ColumnsContainer = class {
  constructor(columns) {
    this.columns = columns;
    this.allColumns = new QueryList();
    this.leafColumns = new QueryList();
    this.lockedColumns = new QueryList();
    this.nonLockedColumns = new QueryList();
    this.lockedLeafColumns = new QueryList();
    this.nonLockedLeafColumns = new QueryList();
    this.totalLevels = 0;
    this.changes = new EventEmitter();
    this.leafColumnsToRender = [];
    this.lockedColumnsToRender = [];
    this.nonLockedColumnsToRender = [];
    this.hasGroupHeaderColumn = false;
    this.hasGroupFooter = false;
    this.hasFooter = false;
    this.unlockedWidth = 0;
  }
  refresh() {
    const currentLevels = this.totalLevels;
    const leafColumns2 = new Array();
    const lockedLeafColumns = new Array();
    const nonLockedLeafColumns = new Array();
    const lockedColumns = new Array();
    const nonLockedColumns = new Array();
    const allColumns = new Array();
    const leafColumnsToRender = new Array();
    const lockedColumnsToRender = new Array();
    const nonLockedColumnsToRender = new Array();
    let hasGroupHeaderColumn = false;
    let hasGroupFooter = false;
    let hasFooter = false;
    let unlockedWidth = 0;
    let leafIndex = 0;
    this.totalLevels = 0;
    this.columns().forEach((column) => {
      const containerLeafColumns = column.isLocked === true ? lockedLeafColumns : nonLockedLeafColumns;
      const containerColumns = column.isLocked === true ? lockedColumns : nonLockedColumns;
      const toRenderContainer = column.isLocked === true ? lockedColumnsToRender : nonLockedColumnsToRender;
      if (!isColumnGroupComponent(column)) {
        containerLeafColumns.push(column);
        leafColumns2.push(column);
        leafColumnsToRender.push(...columnsToRender([column]));
        toRenderContainer.push(...columnsToRender([column]));
        hasGroupHeaderColumn = hasGroupHeaderColumn || someLeafColumn((leaf) => Boolean(leaf.groupHeaderColumnTemplateRef), column);
        hasGroupFooter = hasGroupFooter || someLeafColumn((leaf) => Boolean(leaf.groupFooterTemplateRef), column);
        hasFooter = hasFooter || someLeafColumn((leaf) => Boolean(leaf.footerTemplateRef), column);
        if (!column.isLocked) {
          unlockedWidth += column.width || 0;
        }
        if (column.isSpanColumn) {
          column.childColumns.forEach((c) => {
            c.leafIndex = leafIndex++;
          });
        } else {
          column.leafIndex = leafIndex++;
        }
      }
      containerColumns.push(column);
      allColumns.push(column);
      this.totalLevels = column.level > this.totalLevels ? column.level : this.totalLevels;
    });
    this.hasGroupHeaderColumn = hasGroupHeaderColumn;
    this.hasGroupFooter = hasGroupFooter;
    this.hasFooter = hasFooter;
    this.leafColumnsToRender = leafColumnsToRender;
    this.lockedColumnsToRender = lockedColumnsToRender;
    this.nonLockedColumnsToRender = nonLockedColumnsToRender;
    this.unlockedWidth = unlockedWidth;
    const changes = reset([this.leafColumns, leafColumns2], [this.lockedLeafColumns, lockedLeafColumns], [this.nonLockedLeafColumns, nonLockedLeafColumns], [this.lockedColumns, lockedColumns], [this.allColumns, allColumns], [this.nonLockedColumns, nonLockedColumns]) || currentLevels !== this.totalLevels;
    if (changes) {
      this.changes.emit();
    }
    return changes;
  }
};
var NO_STICKY = {
  left: "0px",
  right: "0px"
};
var ColumnInfoService = class {
  constructor() {
    this.visibilityChange = new EventEmitter();
    this.lockedChange = new EventEmitter();
    this.stickyChange = new EventEmitter();
    this.columnRangeChange = new EventEmitter();
    this.columnsContainer = new ColumnsContainer(() => []);
  }
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  get totalLevels() {
    return this.columnsContainer.totalLevels;
  }
  get hiddenColumns() {
    if (!this.list) {
      return [];
    }
    return this.list().filter((column) => !column.isVisible);
  }
  get leafNamedColumns() {
    const columns = expandColumns(this.list().filterSort((column) => !column.isColumnGroup)).filter((column) => column.matchesMedia && column.displayTitle);
    return orderBy(columns, [{
      field: "locked",
      dir: "desc"
    }]);
  }
  get unlockedRootCount() {
    return this.list().rootColumns().filter((column) => !column.locked && column.isVisible).length;
  }
  stickyColumnsStyles(column) {
    this.stickyColumns = this.list().rootColumns().filter((column2) => column2.sticky && !column2.locked && column2.isVisible);
    if (this.stickyColumns.length === 0) {
      return NO_STICKY;
    }
    const result = this.stickyColumns.reduce((acc, curr) => {
      if (curr.leafIndex < column.leafIndex) {
        acc.left += curr.width;
      } else if (curr.leafIndex > column.leafIndex) {
        acc.right += curr.width;
      }
      return acc;
    }, {
      left: 0,
      right: 0
    });
    return {
      left: `${result.left}px`,
      right: `${result.right}px`
    };
  }
  init(columns, list) {
    this.columnsContainer = columns;
    this.list = list;
    this.stickyColumns = null;
  }
  changeVisibility(columns) {
    this.stickyColumns = null;
    this.visibilityChange.emit(columns);
  }
  changeLocked(columns) {
    this.stickyColumns = null;
    this.lockedChange.emit(columns);
  }
  changeStuck(columns) {
    this.stickyColumns = null;
    this.stickyChange.emit(columns);
  }
};
ColumnInfoService.ɵfac = function ColumnInfoService_Factory(t) {
  return new (t || ColumnInfoService)();
};
ColumnInfoService.ɵprov = ɵɵdefineInjectable({
  token: ColumnInfoService,
  factory: ColumnInfoService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnInfoService, [{
    type: Injectable
  }], null, null);
})();
var CellSelectionAggregateService = class {
  constructor(ctx, dataChanges, columnInfoService) {
    this.ctx = ctx;
    this.dataChanges = dataChanges;
    this.columnInfoService = columnInfoService;
    this.selectedItems = [];
    this.groupedAggregates = {
      dates: [],
      numbers: [],
      booleans: []
    };
    this.aggregates = {
      sum: null,
      average: null,
      min: null,
      max: null,
      count: null,
      isTrue: null,
      isFalse: null,
      earliest: null,
      latest: null
    };
  }
  isAggregateIncluded(aggregate) {
    const {
      cellAggregates
    } = this.ctx.grid.selectable;
    if (typeof cellAggregates !== "boolean") {
      return cellAggregates?.includes(aggregate);
    }
    return true;
  }
  init() {
    if (this.ctx.grid.selectable.cellAggregates) {
      this.data = this.dataChanges.data ? this.dataChanges.data : this.ctx.grid.data;
      if (this.isAggregateIncluded("count")) {
        this.aggregates["count"] = 0;
      }
      const selectionDirective = this.ctx.grid.selectionDirective;
      if (selectionDirective && !this.isRowSelection) {
        this.selectedItems = selectionDirective.selectedKeys;
      }
    }
  }
  onSelectionChange(selectionArgs) {
    this.handleSelectedItems(selectionArgs);
    this.nullifyAggregates();
    this.handleAggregateChanges();
    return this.aggregates;
  }
  get isRowSelection() {
    return typeof this.ctx.grid.selectable === "boolean" || !this.ctx.grid.selectable.cell;
  }
  handleAggregateChanges() {
    const lockedColumns = this.columnInfoService.lockedLeafColumns.toArray();
    const nonLockedColumns = this.columnInfoService.nonLockedLeafColumns.toArray();
    const selectedItemsLength = this.selectedItems.length;
    const columns = [...lockedColumns, ...nonLockedColumns];
    const fields = columns.map((col) => col.field);
    if (this.isAggregateIncluded("count")) {
      this.aggregates["count"] = this.isRowSelection ? selectedItemsLength * columns.length : selectedItemsLength;
    }
    this.selectedItems.forEach((item) => {
      if (this.isRowSelection) {
        fields.forEach((field) => {
          const cellValue = item.dataItem;
          if (cellValue && cellValue.hasOwnProperty(field)) {
            const cellValue2 = item.dataItem[field];
            this.groupAggregates(cellValue2);
          }
        });
      } else if (!this.isRowSelection) {
        const itemKey = this.data[item.itemKey];
        const field = fields[item.columnKey];
        if (itemKey && itemKey.hasOwnProperty(field)) {
          const cellValue = itemKey[fields[item.columnKey]];
          this.groupAggregates(cellValue);
        }
      }
    });
    this.calculateAggregates();
  }
  groupAggregates(aggregate) {
    if (typeof aggregate === "number") {
      this.groupedAggregates.numbers.push(aggregate);
    } else if (typeof aggregate === "boolean") {
      this.groupedAggregates.booleans.push(aggregate);
    } else if (aggregate instanceof Date) {
      this.groupedAggregates.dates.push(aggregate);
    }
  }
  calculateAggregates() {
    if (this.groupedAggregates.numbers.length > 0) {
      if (this.isAggregateIncluded("min")) {
        this.aggregates["min"] = Math.min(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("max")) {
        this.aggregates["max"] = Math.max(...this.groupedAggregates.numbers);
      }
      if (this.isAggregateIncluded("sum")) {
        this.aggregates["sum"] = this.groupedAggregates.numbers.reduce((acc, curr) => acc += curr, 0);
      }
      if (this.isAggregateIncluded("average")) {
        this.aggregates["average"] = this.aggregates["sum"] / this.groupedAggregates.numbers.length;
      }
    }
    if (this.groupedAggregates.booleans.length > 0) {
      if (this.isAggregateIncluded("isTrue")) {
        const isTrueCount = this.groupedAggregates.booleans.filter((bool) => bool).length;
        this.aggregates["isTrue"] = isTrueCount > 0 ? isTrueCount : null;
      }
      if (this.isAggregateIncluded("isFalse")) {
        const isFalseCount = this.groupedAggregates.booleans.length - this.aggregates["isTrue"];
        this.aggregates["isFalse"] = isFalseCount > 0 ? isFalseCount : null;
      }
    }
    if (this.groupedAggregates.dates.length > 0) {
      if (this.isAggregateIncluded("earliest")) {
        this.aggregates["earliest"] = new Date(Math.min(...this.groupedAggregates.dates));
      }
      if (this.isAggregateIncluded("latest")) {
        this.aggregates["latest"] = new Date(Math.max(...this.groupedAggregates.dates));
      }
    }
  }
  handleSelectedItems(selectionArgs) {
    const rowOrCellSelect = `${this.isRowSelection ? "selectedRows" : "selectedCells"}`;
    const rowOrCellDeselect = `${this.isRowSelection ? "deselectedRows" : "deselectedCells"}`;
    const selectedItems = selectionArgs[rowOrCellSelect];
    const deselectedItems = selectionArgs[rowOrCellDeselect];
    if (!this.isRowSelection) {
      deselectedItems.forEach((item, index) => {
        if (index + 1 < deselectedItems.length) {
          if (item.itemKey === deselectedItems[index + 1].itemKey && item.columnKey === deselectedItems[index + 1].columnKey) {
            deselectedItems.splice(index, 1);
          }
        }
      });
    }
    if (selectedItems.length > 0) {
      selectedItems.forEach((item) => {
        this.selectedItems = [...this.selectedItems, item];
      });
    }
    if (deselectedItems.length > 0) {
      if (this.isRowSelection) {
        deselectedItems.forEach((row2) => {
          this.selectedItems = this.selectedItems.filter((elem) => elem.dataItem !== row2.dataItem);
        });
      } else {
        deselectedItems.forEach((cell2) => {
          const index = this.selectedItems.findIndex((elem) => elem.itemKey === cell2.itemKey && elem.columnKey === cell2.columnKey);
          this.selectedItems.splice(index, 1);
        });
      }
    }
  }
  nullifyAggregates() {
    this.groupedAggregates = {
      dates: [],
      numbers: [],
      booleans: []
    };
    this.aggregates["count"] = null;
    this.aggregates["sum"] = this.aggregates["average"] = null;
    this.aggregates["max"] = this.aggregates["min"] = null;
    this.aggregates["isFalse"] = this.aggregates["isTrue"] = null;
    this.aggregates["earliest"] = this.aggregates["latest"] = null;
  }
};
CellSelectionAggregateService.ɵfac = function CellSelectionAggregateService_Factory(t) {
  return new (t || CellSelectionAggregateService)(ɵɵinject(ContextService), ɵɵinject(LocalDataChangesService), ɵɵinject(ColumnInfoService));
};
CellSelectionAggregateService.ɵprov = ɵɵdefineInjectable({
  token: CellSelectionAggregateService,
  factory: CellSelectionAggregateService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionAggregateService, [{
    type: Injectable
  }], function() {
    return [{
      type: ContextService
    }, {
      type: LocalDataChangesService
    }, {
      type: ColumnInfoService
    }];
  }, null);
})();
var SelectionService = class {
  constructor(domEvents, aggregateService, localDataChangesService, navigationService, ctxService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.ctxService = ctxService;
    this.changes = new EventEmitter();
    this.currentSelection = [];
    this.selectAllChecked = false;
    this.active = false;
    this.dragging = false;
    this.lastSelectionData = {};
    this.addSubscriptions();
  }
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent4(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.enabled !== false && !selectableSettings.checkboxOnly && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  init(settings) {
    this.settings = settings;
    if (!isPresent4(this.lastSelectionStartIndex)) {
      this.lastSelectionStartIndex = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.index || 0;
      this.lastSelectionData = this.ctxService?.grid.selectionDirective?.rangeSelectionStartRow?.dataItem || {};
    }
    this.currentSelection = [];
    if (settings.selectable && settings.selectable.enabled !== false) {
      const iterator2 = this.getIterator();
      this._selectAllState = true;
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          if (settings.rowSelected(rowArgs)) {
            this.currentSelection[item.value.index] = rowArgs;
          } else {
            this._selectAllState = void 0;
          }
        }
        item = iterator2.next();
      }
      if (this.currentSelection.length === 0) {
        this._selectAllState = false;
      }
    }
  }
  isSelected(index) {
    if (this.settings && this.active) {
      return this.options.enabled && isPresent4(this.currentSelection[index]);
    }
  }
  handleClick(item, event2) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    let ev;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isSelected(item.index)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if (ctrlKey && !event2.shiftKey) {
        ev = this.toggle(item);
      } else if (event2.shiftKey) {
        ev = this.addAllTo(item, ctrlKey);
      }
    }
    if (!isPresent4(ev)) {
      ev = this.select(item);
      this.currentSelection[item.index] = {
        dataItem: item.data,
        index: item.index
      };
    }
    if (!ev.selectedRows.length && !ev.deselectedRows.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event2.shiftKey;
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartRow = {
        dataItem: this.lastSelectionData,
        index: this.lastSelectionStartIndex
      };
      ev.rangeEndRow = {
        dataItem: item.data,
        index: item.index
      };
    }
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedRows = [];
    const deselectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    const rowArgs = {
      dataItem: item.data,
      index: item.index
    };
    if (this.isSelected(item.index)) {
      deselectedRows.push(rowArgs);
    } else {
      selectedRows.push(rowArgs);
    }
    return {
      deselectedRows,
      selectedRows
    };
  }
  toggleByIndex(index) {
    const iterator2 = this.getIterator();
    if (this.selectAllChecked && this.isSelected(index)) {
      this.selectAllChecked = false;
    }
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.index === index) {
        const itemToToggle = {
          data: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(index) || this.options.mode === "multiple") {
          return this.toggle(itemToToggle);
        } else {
          return this.select(itemToToggle);
        }
      }
      item = iterator2.next();
    }
  }
  select(item) {
    const deselectedRows = [];
    const selectedRows = [];
    this.lastSelectionStartIndex = item.index;
    this.lastSelectionData = item.data;
    if (!this.isSelected(item.index)) {
      selectedRows.push({
        dataItem: item.data,
        index: item.index
      });
    }
    this.currentSelection.forEach((row2) => {
      if (row2.index !== item.index) {
        deselectedRows.push(row2);
      }
    });
    return {
      deselectedRows,
      selectedRows
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        const rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        if (this.isSelected(rowArgs.index)) {
          const ev = {
            ctrlKey: false,
            deselectedRows: [rowArgs],
            selectedRows: []
          };
          this.changes.emit(ev);
        }
      }
      item = iterator2.next();
    }
  }
  addAllTo(item, ctrlKey) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(this.lastSelectionStartIndex, item.index);
    const end2 = Math.max(this.lastSelectionStartIndex, item.index);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx
        };
        if ((idx < start || idx > end2) && this.isSelected(idx) && !ctrlKey) {
          deselectedRows.push(rowArgs);
        }
        if (idx >= start && idx <= end2 && !this.isSelected(idx)) {
          selectedRows.push(rowArgs);
        }
      }
      next = iterator2.next();
    }
    return {
      deselectedRows,
      selectedRows
    };
  }
  updateAll(selectAllChecked) {
    this.selectAllChecked = selectAllChecked;
    const selectedRows = [];
    const deselectedRows = [];
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx
        };
        if (this.isSelected(idx) && !selectAllChecked) {
          deselectedRows.push(rowArgs);
        }
        if (!this.isSelected(idx) && selectAllChecked) {
          selectedRows.push(rowArgs);
        }
      }
      next = iterator2.next();
    }
    if (!selectedRows.length && !deselectedRows.length) {
      return;
    }
    const ev = {
      ctrlKey: true,
      deselectedRows,
      selectedRows,
      shiftKey: true
    };
    if (this.options.cellAggregates) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    this.changes.emit(ev);
  }
  selectRange(startIndex, endIndex) {
    const selectedRows = [];
    const deselectedRows = [];
    const start = Math.min(startIndex, endIndex);
    const end2 = Math.max(startIndex, endIndex);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx = next.value.index;
        const rowArgs = {
          dataItem: next.value.data,
          index: idx
        };
        if ((idx < start || idx > end2) && this.isSelected(idx)) {
          deselectedRows.push(rowArgs);
        }
        if (idx >= start && idx <= end2 && !this.isSelected(idx)) {
          selectedRows.push(rowArgs);
        }
      }
      next = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedRows,
        deselectedRows
      });
    }
    return {
      deselectedRows,
      selectedRows,
      cellAggregates
    };
  }
  get selectAllState() {
    return this._selectAllState;
  }
  get selected() {
    return this.currentSelection.map((item) => {
      return item.index;
    }).filter((n) => typeof n === "number");
  }
  get options() {
    const defaultOptions = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple"
    };
    if (!isPresent4(this.settings)) {
      return defaultOptions;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple"
      };
    } else {
      return Object.assign(defaultOptions, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  targetArgs() {
    return {
      index: this.mouseDownEventArgs.rowIndex,
      dataItem: this.mouseDownEventArgs.dataItem
    };
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent4(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
};
SelectionService.ɵfac = function SelectionService_Factory(t) {
  return new (t || SelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService), ɵɵinject(ContextService));
};
SelectionService.ɵprov = ɵɵdefineInjectable({
  token: SelectionService,
  factory: SelectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], function() {
    return [{
      type: DomEventsService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: LocalDataChangesService
    }, {
      type: NavigationService
    }, {
      type: ContextService
    }];
  }, null);
})();
var CellSelectionService = class {
  constructor(domEvents, aggregateService, localDataChangesService, navigationService) {
    this.domEvents = domEvents;
    this.aggregateService = aggregateService;
    this.localDataChangesService = localDataChangesService;
    this.navigationService = navigationService;
    this.changes = new EventEmitter();
    this.mouseUpEvent = new EventEmitter();
    this.currentSelection = [];
    this.active = false;
    this.dragging = false;
    this.dragSelectDeselect = false;
    this.lastSelectionItem = {
      itemKey: 0,
      columnKey: 0
    };
    this.lastSelectionItemRowIndex = 0;
    this.lastSelectionItemColIndex = 0;
    this.addSubscriptions();
  }
  get enableMarquee() {
    const checkboxOnly = this.settings && typeof this.settings === "object" && this.settings.checkboxOnly;
    if (!this.settings || checkboxOnly) {
      return false;
    }
    const selectableSettings = this.settings.selectable;
    const dragAndMultiple = typeof selectableSettings === "object" && isPresent4(selectableSettings) && selectableSettings.mode === "multiple" && selectableSettings.cell && selectableSettings.enabled !== false && selectableSettings.drag;
    return this.active && dragAndMultiple;
  }
  init(settings) {
    this.settings = settings;
    this.currentSelection = [];
    if (settings.selectable && settings.selectable.enabled !== false) {
      const iterator2 = this.getIterator();
      let item = iterator2.next();
      while (!item.done) {
        if (item.value && item.value.type === "data") {
          const rowArgs = {
            dataItem: item.value.data,
            index: item.value.index
          };
          settings.columns.forEach((col) => {
            const selectedCellArgs = settings.cellSelected(rowArgs, col, col.leafIndex);
            if (selectedCellArgs.selected) {
              this.currentSelection.push(selectedCellArgs.item);
            }
          });
        }
        item = iterator2.next();
      }
    }
  }
  isCellSelected(item, col) {
    if (this.settings && this.active) {
      const selectedCellArgs = this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, col, col.leafIndex);
      return this.options.enabled && selectedCellArgs.selected;
    }
    return false;
  }
  handleClick(item, event2) {
    if (this.dragging) {
      this.dragging = false;
      return;
    }
    let ev;
    const ctrlKey = event2.ctrlKey || event2.metaKey;
    if (this.options.mode === "single" && ctrlKey && this.isCellSelected(item, item.column)) {
      ev = this.toggle(item);
    } else if (this.options.mode === "multiple") {
      if (ctrlKey && !event2.shiftKey) {
        ev = this.toggle(item);
      } else if (event2.shiftKey) {
        const startRowIndex = Math.min(this.lastSelectionItemRowIndex, item.index);
        const startColIndex = Math.min(this.lastSelectionItemColIndex, item.column.leafIndex);
        const endRowIndex = Math.max(this.lastSelectionItemRowIndex, item.index);
        const endColIndex = Math.max(this.lastSelectionItemColIndex, item.column.leafIndex);
        ev = this.selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex);
      }
    }
    if (!isPresent4(ev)) {
      ev = this.select(item);
      this.currentSelection = [this.lastSelectionItem];
    }
    if (!ev.selectedCells.length && !ev.deselectedCells.length) {
      return;
    }
    ev.ctrlKey = ctrlKey;
    ev.shiftKey = event2.shiftKey;
    if (this.options.cellAggregates && !event2.shiftKey) {
      ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
    }
    if (ev.shiftKey) {
      ev.rangeStartCell = this.lastSelectionItem;
      ev.rangeEndCell = __spreadValues({}, this.settings.cellSelected({
        dataItem: item.data,
        index: item.index
      }, item.column, item.column.leafIndex).item);
    }
    this.changes.emit(ev);
  }
  toggle(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (this.isCellSelected(item, item.column)) {
      deselectedCells.push(this.lastSelectionItem);
    } else {
      selectedCells.push(this.lastSelectionItem);
    }
    return {
      deselectedCells,
      selectedCells
    };
  }
  select(item) {
    const selectedCells = [];
    const deselectedCells = [];
    this.lastSelectionItem = this.settings.cellSelected({
      dataItem: item.data,
      index: item.index
    }, item.column, item.column.leafIndex).item;
    this.lastSelectionItemRowIndex = item.index;
    this.lastSelectionItemColIndex = item.column.leafIndex;
    if (!this.isCellSelected(item, item.column)) {
      selectedCells.push(this.lastSelectionItem);
    }
    this.currentSelection.forEach((selectedItem) => {
      if (selectedItem.itemKey !== this.lastSelectionItem.itemKey || selectedItem.columnKey !== this.lastSelectionItem.columnKey) {
        deselectedCells.push(selectedItem);
      }
    });
    return {
      deselectedCells,
      selectedCells
    };
  }
  //Used to manually deselect removed items
  deselect(removedItem) {
    const iterator2 = this.getIterator();
    let item = iterator2.next();
    let rowArgs;
    while (!item.done) {
      if (item.value && item.value.type === "data" && item.value.data === removedItem) {
        rowArgs = {
          dataItem: item.value.data,
          index: item.value.index
        };
        break;
      }
      item = iterator2.next();
    }
    if (rowArgs) {
      const cellsToRemove = this.currentSelection.filter((selectedItem) => {
        const contender = this.settings.cellSelected(rowArgs, null, null).item;
        return selectedItem.itemKey === contender.itemKey;
      });
      if (cellsToRemove.length) {
        const ev = {
          ctrlKey: false,
          deselectedCells: cellsToRemove,
          selectedCells: []
        };
        this.changes.emit(ev);
      }
    }
  }
  selectRange(startRowIndex, startColIndex, endRowIndex, endColIndex) {
    const selectedCells = [];
    const deselectedCells = [];
    const selectionStartRow = Math.min(startRowIndex, endRowIndex);
    const selectionStartCol = Math.min(startColIndex, endColIndex);
    const selectionEndRow = Math.max(startRowIndex, endRowIndex);
    const selectionEndCol = Math.max(startColIndex, endColIndex);
    const iterator2 = this.getIterator();
    let next = iterator2.next();
    while (!next.done) {
      if (next.value && next.value.type === "data") {
        const idx = next.value.index;
        const data = next.value.data;
        const rowArgs = {
          dataItem: data,
          index: idx
        };
        this.settings.columns.forEach((col) => {
          const {
            item
          } = this.settings.cellSelected(rowArgs, col, col.leafIndex);
          const selected = this.isCellSelected(next.value, col);
          const isInRowRange = selectionStartRow <= idx && idx <= selectionEndRow;
          const isInColRange = selectionStartCol <= col.leafIndex && col.leafIndex <= selectionEndCol;
          const isInSelectionRect = isInRowRange && isInColRange;
          if (!isInSelectionRect && selected) {
            deselectedCells.push(item);
          }
          if (isInSelectionRect && !selected) {
            selectedCells.push(item);
          }
        });
      }
      next = iterator2.next();
    }
    let cellAggregates;
    if (this.options.cellAggregates) {
      cellAggregates = this.aggregateService.onSelectionChange({
        selectedCells,
        deselectedCells
      });
    }
    return {
      deselectedCells,
      selectedCells,
      cellAggregates
    };
  }
  get options() {
    const defaultOptions = {
      cellAggregates: false,
      checkboxOnly: false,
      enabled: true,
      mode: "multiple"
    };
    if (!isPresent4(this.settings)) {
      return defaultOptions;
    }
    if (typeof this.settings.selectable === "boolean") {
      return {
        cellAggregates: false,
        checkboxOnly: false,
        enabled: this.settings.selectable,
        mode: "multiple"
      };
    } else {
      return Object.assign(defaultOptions, this.settings.selectable);
    }
  }
  ngOnDestroy() {
    this.removeSubscriptions();
  }
  addSubscriptions() {
    if (!this.cellClickSubscription) {
      this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
        if (this.options.enabled && !this.options.checkboxOnly && args.type !== "contextmenu") {
          if (this.active) {
            this.handleClick({
              index: args.rowIndex,
              data: args.dataItem,
              column: args.column
            }, args.originalEvent);
          }
        }
      });
    }
    if (!this.mousedownSubscription) {
      this.mousedownSubscription = this.domEvents.cellMousedown.subscribe((args) => {
        this.mouseDownEventArgs = args;
        if (this.options.enabled && (!this.options.mode || this.options.mode === "multiple") && !this.options.checkboxOnly && args.originalEvent.shiftKey) {
          if (this.active) {
            args.originalEvent.preventDefault();
            this.navigationService.focusCellByElement(args.originalEvent.target);
          }
        }
      });
    }
    if (this.localDataChangesService && !this.dataChangedSubscription) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe((args) => {
        if (this.active) {
          if (isPresent4(args.action) && args.action === "remove") {
            this.deselect(args.item);
          }
        }
      });
    }
  }
  getIterator() {
    const accessor = this.settings.view.accessor();
    if (!accessor) {
      return;
    }
    return accessor[iterator]();
  }
  removeSubscriptions() {
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
      this.cellClickSubscription = null;
    }
    if (this.mousedownSubscription) {
      this.mousedownSubscription.unsubscribe();
      this.mousedownSubscription = null;
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
      this.dataChangedSubscription = null;
    }
  }
};
CellSelectionService.ɵfac = function CellSelectionService_Factory(t) {
  return new (t || CellSelectionService)(ɵɵinject(DomEventsService), ɵɵinject(CellSelectionAggregateService), ɵɵinject(LocalDataChangesService), ɵɵinject(NavigationService));
};
CellSelectionService.ɵprov = ɵɵdefineInjectable({
  token: CellSelectionService,
  factory: CellSelectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellSelectionService, [{
    type: Injectable
  }], function() {
    return [{
      type: DomEventsService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: LocalDataChangesService
    }, {
      type: NavigationService
    }];
  }, null);
})();
var createElement$1 = () => {
  if (!isDocumentAvailable()) {
    return;
  }
  const marquee = document.createElement("div");
  marquee.className = "k-marquee";
  const marqueeColor = document.createElement("div");
  marqueeColor.className = "k-marquee-color";
  marquee.appendChild(marqueeColor);
  return marquee;
};
var POINTER_OFFSET = 2;
var MINIMAL_DRAG_DISTANCE = 5;
var offsets = {
  topLeft: {
    x: POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  topRight: {
    x: -POINTER_OFFSET,
    y: POINTER_OFFSET
  },
  bottomLeft: {
    x: POINTER_OFFSET,
    y: -POINTER_OFFSET
  },
  bottomRight: {
    x: -POINTER_OFFSET,
    y: -POINTER_OFFSET
  }
};
var GridMarqueeDirective = class {
  constructor(draggable, selection, cellSelection, domEvents, host, renderer) {
    this.draggable = draggable;
    this.selection = selection;
    this.cellSelection = cellSelection;
    this.domEvents = domEvents;
    this.host = host;
    this.renderer = renderer;
    this.selectionStarted = false;
  }
  ngOnInit() {
    this.subscriptions = this.draggable.kendoPress.subscribe(this.start.bind(this));
    this.subscriptions.add(this.draggable.kendoDrag.subscribe(this.moveMarquee.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.clean();
  }
  start(args) {
    const isInvalidTarget = args.originalEvent.target.matches(".k-grid-content, .k-grid-content-locked, .k-grid-aria-root, .k-checkbox");
    const isRowReorderColumn2 = isPresent(args.originalEvent.target.closest(".k-drag-cell"));
    if (isInvalidTarget || isRowReorderColumn2) {
      this.pressArgs = null;
      return;
    }
    this.pressArgs = args;
    this.pressTarget = null;
  }
  moveMarquee(args) {
    if (!this.pressTarget) {
      this.pressTarget = this.cellSelection.active ? this.cellSelection.mouseDownEventArgs : this.selection.mouseDownEventArgs;
    }
    const press = this.pressArgs;
    if (!press) {
      return;
    }
    if (!this.selectionStarted) {
      const distance = Math.sqrt((args.pageX - press.pageX) ** 2 + (args.pageY - press.pageY) ** 2);
      if (distance > MINIMAL_DRAG_DISTANCE) {
        this.selectionStarted = true;
        this.renderer.addClass(this.host.nativeElement, "user-select-none");
        this.renderer.setStyle(this.host.nativeElement, "user-select", "none");
        this.dragEndSubscription = merge(this.domEvents.cellMouseup.pipe(take(1)), this.draggable.kendoRelease.pipe(delay(1), take(1))).subscribe(this.endSelection.bind(this));
      } else {
        return;
      }
    }
    this.initMarquee();
    const element = this.marqueeElement;
    const marqueeQuadrant = this.getMarqueeQuadrant(args.pageX, args.pageY, press.pageX, press.pageY);
    let left = Math.min(args.pageX, press.pageX);
    let top = Math.min(args.pageY, press.pageY);
    const width = Math.abs(args.pageX - press.pageX);
    const height = Math.abs(args.pageY - press.pageY);
    if (marqueeQuadrant) {
      left += offsets[marqueeQuadrant].x;
      top += offsets[marqueeQuadrant].y;
    }
    element.style.left = `${left}px`;
    element.style.top = `${top}px`;
    element.style.width = `${width}px`;
    element.style.height = `${height}px`;
  }
  endSelection(args) {
    if (args.type === "mouseup" || args.type === "touchend") {
      if (this.cellSelection.active) {
        this.cellSelection.dragging = true;
        this.cellSelection.changes.emit(this.cellSelection.selectRange(this.pressTarget.rowIndex, this.pressTarget.column.leafIndex, args.rowIndex, args.column.leafIndex));
      } else if (this.selection.active) {
        this.selection.dragging = true;
        this.selection.changes.emit(this.selection.selectRange(this.pressTarget.rowIndex, args.rowIndex));
      }
    }
    this.clean();
  }
  clean() {
    if (this.marqueeElement) {
      document.body.removeChild(this.marqueeElement);
      this.marqueeElement = null;
    }
    if (this.dragEndSubscription) {
      this.dragEndSubscription.unsubscribe();
    }
    this.renderer.removeClass(this.host.nativeElement, "user-select-none");
    this.renderer.removeStyle(this.host.nativeElement, "user-select");
    this.dragEndSubscription = null;
    this.pressTarget = null;
    this.pressArgs = null;
    this.selectionStarted = false;
    this.cellSelection.active ? this.cellSelection.dragging = false : this.selection.dragging = false;
  }
  initMarquee() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (!this.marqueeElement) {
      this.marqueeElement = createElement$1();
      document.body.appendChild(this.marqueeElement);
    }
  }
  getMarqueeQuadrant(pointerX, pointerY, startX, startY) {
    const leftHalf = pointerX < startX;
    const rightHalf = pointerX > startX;
    const topHalf = pointerY < startY;
    const bottomHalf = pointerY > startY;
    if (leftHalf && topHalf) {
      return "topLeft";
    }
    if (leftHalf && bottomHalf) {
      return "bottomLeft";
    }
    if (rightHalf && topHalf) {
      return "topRight";
    }
    if (rightHalf && bottomHalf) {
      return "bottomRight";
    }
    return null;
  }
};
GridMarqueeDirective.ɵfac = function GridMarqueeDirective_Factory(t) {
  return new (t || GridMarqueeDirective)(ɵɵdirectiveInject(DraggableDirective), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
GridMarqueeDirective.ɵdir = ɵɵdefineDirective({
  type: GridMarqueeDirective,
  selectors: [["", "kendoGridSelectionMarquee", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMarqueeDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionMarquee]"
    }]
  }], function() {
    return [{
      type: DraggableDirective
    }, {
      type: SelectionService
    }, {
      type: CellSelectionService
    }, {
      type: DomEventsService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, null);
})();
var ZoneAwareEventEmitter = class extends EventEmitter {
  constructor(ngZone, isAsync = false) {
    super(isAsync);
    this.ngZone = ngZone;
  }
  subscribe(generatorOrNext, error2, complete) {
    let schedulerFn;
    let errorFn = (_) => null;
    let completeFn = () => null;
    if (generatorOrNext && typeof generatorOrNext === "object") {
      schedulerFn = (value2) => {
        this.ngZone.run(() => generatorOrNext.next(value2));
      };
      if (generatorOrNext.error) {
        errorFn = (err) => {
          this.ngZone.run(() => generatorOrNext.error(err));
        };
      }
      if (generatorOrNext.complete) {
        completeFn = () => {
          this.ngZone.run(() => generatorOrNext.complete());
        };
      }
    } else {
      schedulerFn = (value2) => {
        this.ngZone.run(() => generatorOrNext(value2));
      };
      if (error2) {
        errorFn = (err) => {
          this.ngZone.run(() => error2(err));
        };
      }
      if (complete) {
        completeFn = () => {
          this.ngZone.run(() => complete());
        };
      }
    }
    return super.subscribe(schedulerFn, errorFn, completeFn);
  }
};
var packageMetadata4 = {
  name: "@progress/kendo-angular-grid",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1720608074,
  version: "16.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DetailTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._condition = () => true;
  }
  /**
   * Defines the function that indicates if a given detail row and the associated **Expand** or **Collapse** button will be displayed.
   */
  set showIf(fn) {
    if (typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("showIf", fn));
    }
    this._condition = fn;
  }
  get showIf() {
    return this._condition;
  }
};
DetailTemplateDirective.ɵfac = function DetailTemplateDirective_Factory(t) {
  return new (t || DetailTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
DetailTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: DetailTemplateDirective,
  selectors: [["", "kendoGridDetailTemplate", ""]],
  inputs: {
    showIf: [0, "kendoGridDetailTemplateShowIf", "showIf"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridDetailTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showIf: [{
      type: Input,
      args: ["kendoGridDetailTemplateShowIf"]
    }]
  });
})();
var canCreateElement = () => isDocumentAvailable() && document.createElement;
var cachedScrollbarWidth = null;
var cachedPixelRatio;
var cachedRtlScrollLeft = null;
function scrollbarWidth() {
  if (cachedScrollbarWidth === null && canCreateElement()) {
    cachedPixelRatio = window.devicePixelRatio || 1;
    const div = document.createElement("div");
    div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    cachedScrollbarWidth = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return cachedScrollbarWidth;
}
function rtlScrollLeft() {
  if (cachedRtlScrollLeft === null && canCreateElement()) {
    const outer = document.createElement("div");
    outer.style.direction = "rtl";
    outer.style.display = "block";
    outer.style.clear = "both";
    outer.style.width = "100px";
    outer.style.visibility = "hidden";
    outer.style.position = "absolute";
    outer.style.left = "-10000px";
    outer.style.overflow = "scroll";
    outer.style.zoom = "1";
    const inner = document.createElement("div");
    inner.style.width = "200px";
    inner.style.height = "1px";
    outer.append(inner);
    document.body.appendChild(outer);
    const initial2 = outer.scrollLeft;
    outer.scrollLeft = -1;
    cachedRtlScrollLeft = outer.scrollLeft < 0 ? outer.scrollLeft : initial2;
    document.body.removeChild(outer);
  }
  return cachedRtlScrollLeft;
}
var BrowserSupportService = class {
  constructor(zone, changeDetector) {
    this.zone = zone;
    this.changeDetector = changeDetector;
    this.changes = new EventEmitter();
    if (typeof window === "undefined") {
      return;
    }
    this.zone.runOutsideAngular(() => {
      this.subscriptions = fromEvent(window, "resize").pipe(auditTime(100)).subscribe(() => {
        if (cachedPixelRatio !== window.devicePixelRatio) {
          zone.run(() => {
            cachedScrollbarWidth = null;
            this.changes.emit();
            this.changeDetector.markForCheck();
          });
        }
      });
    });
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
      this.subscriptions = null;
    }
  }
  get scrollbarWidth() {
    return scrollbarWidth();
  }
  get rtlScrollLeft() {
    return rtlScrollLeft();
  }
};
BrowserSupportService.ɵfac = function BrowserSupportService_Factory(t) {
  return new (t || BrowserSupportService)(ɵɵinject(NgZone), ɵɵinject(ChangeDetectorRef));
};
BrowserSupportService.ɵprov = ɵɵdefineInjectable({
  token: BrowserSupportService,
  factory: BrowserSupportService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserSupportService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var isGroupItem = (source) => {
  return source.items !== void 0 && source.field !== void 0;
};
var isVirtualGroupItem = (source) => {
  return source.offset !== void 0 && source.skipHeader !== void 0;
};
var flattenGroups = (groups) => groups.reduce((acc, curr) => {
  if (isGroupItem(curr)) {
    return acc.concat(flattenGroups(curr.items));
  }
  return acc.concat([curr]);
}, []);
var itemAt = (data, index) => {
  const first = data[0];
  if (isPresent4(first) && isGroupItem(first)) {
    return flattenGroups(data)[index];
  }
  return data[index];
};
var getIterator = (data, {
  footers,
  level,
  dataIndex,
  parentGroupIndex,
  groupIndex,
  parentGroup
}) => {
  const first = data[0];
  if (isPresent4(first) && isGroupItem(first)) {
    if (isVirtualGroupItem(first)) {
      groupIndex = isPresent4(first.offset) ? first.offset : groupIndex;
    }
    return new GroupIterator(data, footers, level, dataIndex, parentGroupIndex, groupIndex, parentGroup);
  }
  return new ItemIterator(data, dataIndex, parentGroupIndex, parentGroup);
};
var ArrayIterator = class {
  constructor(arr, idx = 0) {
    this.arr = arr;
    this.idx = idx;
    this.arr = arr || [];
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.idx < this.arr.length ? {
      done: false,
      value: this.arr[this.idx++]
    } : {
      done: true,
      value: void 0
    };
  }
};
var Iterator = class {
  constructor(arr, dataIndex = 0, resultMap = (x) => x) {
    this.dataIndex = dataIndex;
    this.resultMap = resultMap;
    const iter = arr[iterator];
    this._innerIterator = iter ? arr[iterator]() : new ArrayIterator(arr);
  }
  [iterator]() {
    return this;
  }
  next() {
    return this.resultMap(this._innerIterator.next(), this.dataIndex++);
  }
};
var ItemIterator = class extends Iterator {
  constructor(arr, dataIndex, groupIndex, group2) {
    super(arr, dataIndex, (x, idx) => ({
      done: x.done,
      value: {
        data: x.value,
        groupIndex,
        index: idx,
        type: "data",
        group: group2
      }
    }));
  }
  /**
   * The index of the next record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex;
  }
};
var prefix = (s, n) => {
  const p = s ? s + "_" : s;
  return `${p}${n}`;
};
var GroupIterator = class {
  constructor(arr, outputFooters = false, level = 0, dataIndex = 0, parentIndex = "", groupIndex = 0, parentGroup = void 0) {
    this.arr = arr;
    this.outputFooters = outputFooters;
    this.level = level;
    this.dataIndex = dataIndex;
    this.parentIndex = parentIndex;
    this.groupIndex = groupIndex;
    this.parentGroup = parentGroup;
    this.currentGroupIndex = "";
    this.arr = arr || [];
    this._iterator = new Iterator(this.arr, this.dataIndex);
  }
  [iterator]() {
    return this;
  }
  nextGroupItem() {
    this.current = this._iterator.next().value;
    this._innerIterator = null;
    if (this.current) {
      this.currentGroupIndex = prefix(this.parentIndex, this.groupIndex++);
      return {
        done: false,
        value: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  footerItem() {
    if (this.current) {
      const group2 = this.current;
      this.current = null;
      return {
        done: false,
        value: {
          data: group2,
          groupIndex: this.currentGroupIndex,
          level: this.level,
          type: "footer",
          group: {
            data: group2,
            index: this.currentGroupIndex,
            level: this.level,
            type: "group",
            parentGroup: this.parentGroup
          }
        }
      };
    } else {
      this.current = null;
      return {
        done: true,
        value: void 0
      };
    }
  }
  innerIterator(group2) {
    if (!this._innerIterator) {
      this._innerIterator = getIterator(group2.items, {
        dataIndex: this.dataIndex,
        footers: this.outputFooters,
        level: this.level + 1,
        parentGroupIndex: this.currentGroupIndex,
        parentGroup: {
          data: this.current,
          index: this.currentGroupIndex,
          level: this.level,
          type: "group",
          parentGroup: this.parentGroup
        }
      });
    }
    return this._innerIterator;
  }
  nextDataItem(group2) {
    const iterator2 = this.innerIterator(group2);
    const result = iterator2.next();
    if (isPresent4(result.value) && !result.done && result.value.type === "data") {
      this.dataIndex = result.value.index + 1;
    }
    return !result.done ? result : void 0;
  }
  next() {
    if (!isPresent4(this.current)) {
      return this.nextGroupItem();
    }
    const item = this.nextDataItem(this.current);
    return item ? item : this.outputFooters ? this.footerItem() : this.nextGroupItem();
  }
  /**
   * The index of the last iterated data record.
   * @readonly
   * @type {number}
   */
  get index() {
    return this.dataIndex + 1;
  }
};
var DataResultIterator = class {
  constructor(source, skip4 = 0, groupFooters = false) {
    this.source = source;
    this.skip = skip4;
    this.groupFooters = groupFooters;
    this.source = this.source ? this.source : [];
    this.isObject = this.isGridDataResult(this.source);
  }
  isGridDataResult(source) {
    return source.total !== void 0 && source.data !== void 0;
  }
  get total() {
    return this.isObject ? this.source.total : this.source.length;
  }
  get data() {
    return this.isObject ? this.source.data : this.source;
  }
  map(fn) {
    return this.data.map(fn);
  }
  filter(fn) {
    return this.data.filter(fn);
  }
  reduce(fn, init) {
    return this.data.reduce(fn, init);
  }
  forEach(fn) {
    this.data.forEach(fn);
  }
  some(fn) {
    return this.data.some(fn);
  }
  [iterator]() {
    return getIterator(this.data, {
      dataIndex: this.skip,
      footers: this.groupFooters,
      groupIndex: this.skip
    });
  }
  toString() {
    return this.data.toString();
  }
};
var DataCollection = class {
  constructor(accessor) {
    this.accessor = accessor;
  }
  get total() {
    return this.accessor().total;
  }
  get length() {
    return this.accessor().data.length;
  }
  get first() {
    return this.accessor().data[0];
  }
  get last() {
    return this.accessor().data[this.length - 1];
  }
  at(index) {
    return itemAt(this.accessor().data, index);
  }
  map(fn) {
    return this.accessor().map(fn);
  }
  filter(fn) {
    return this.accessor().filter(fn);
  }
  reduce(fn, init) {
    return this.accessor().reduce(fn, init);
  }
  forEach(fn) {
    this.accessor().forEach(fn);
  }
  some(fn) {
    return this.accessor().some(fn);
  }
  [iterator]() {
    return this.accessor()[iterator]();
  }
  toString() {
    return this.accessor().toString();
  }
};
var PairSet = class {
  constructor(items, keyXField, keyYField) {
    this.keysX = /* @__PURE__ */ new Map();
    this.totalKeysCount = 0;
    if (items && keyXField && keyYField) {
      items.forEach((item) => this.add(item[keyXField], item[keyYField]));
    }
  }
  /**
   * Gets the total number of X/Y key pairs.
   */
  get size() {
    return this.totalKeysCount;
  }
  /**
   * Adds a couple of items identified as a combination.
   */
  add(keyX, keyY) {
    if (!this.keysX.has(keyX)) {
      this.keysX.set(keyX, /* @__PURE__ */ new Set());
    }
    if (!this.has(keyX, keyY)) {
      this.keysX.get(keyX).add(keyY);
      this.totalKeysCount += 1;
    }
  }
  /**
   * Adds a combination of a couple of items identified together.
   */
  delete(keyX, keyY) {
    if (this.has(keyX, keyY)) {
      this.keysX.get(keyX).delete(keyY);
      this.totalKeysCount -= 1;
    }
  }
  /**
   * Checks whether the defined combination is stored.
   */
  has(keyX, keyY) {
    return this.keysX.has(keyX) && this.keysX.get(keyX).has(keyY);
  }
  /**
   * Clears all key combinations.
   */
  clear() {
    this.keysX.clear();
    this.totalKeysCount = 0;
  }
  /**
   * Converts the persisted data structure to an array of objects,
   * using the provided field names for the object props.
   */
  toArray(keyXField, keyYField) {
    return Array.from(this.keysX).reduce((pairs, pair) => {
      const [keyX, keysY] = pair;
      Array.from(keysY).forEach((keyY) => pairs.push({
        [keyXField]: keyX,
        [keyYField]: keyY
      }));
      return pairs;
    }, []);
  }
};
var Selection = class {
  constructor(ctx, cd) {
    this.ctx = ctx;
    this.cd = cd;
    this.selectedKeys = [];
    this.rangeSelectionStartColumnIndex = 0;
    this.selectedKeysChange = new EventEmitter();
    this.rowSelectionState = /* @__PURE__ */ new Set();
    this.cellSelectionState = new PairSet();
    this.init();
  }
  /**
   * @hidden
   */
  get isCellSelectionMode() {
    return isPresent4(this.ctx.grid.selectable) && this.ctx.grid.selectable["cell"];
  }
  ngOnChanges(changes) {
    if (isPresent4(changes["selectedKeys"]) && this.lastSelectionState !== this.selectedKeys) {
      this.setState(this.selectedKeys);
    }
  }
  init() {
    if (!isPresent4(this.ctx.grid.rowSelected)) {
      this.ctx.grid.rowSelected = (row2) => this.rowSelectionState.has(this.getItemKey(row2));
    }
    if (!isPresent4(this.ctx.grid.cellSelected)) {
      this.ctx.grid.cellSelected = (row2, column, colIndex) => {
        const contender = this.getSelectionItem(row2, column, colIndex);
        return {
          selected: this.cellSelectionState.has(contender.itemKey, contender.columnKey),
          item: contender
        };
      };
    }
    this.selectionChangeSubscription = this.ctx.grid.selectionChange.subscribe(this.onSelectionChange.bind(this));
  }
  /**
   * @hidden
   */
  destroy() {
    this.selectionChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  reset() {
    this.rowSelectionState.clear();
    this.cellSelectionState.clear();
  }
  /**
   * @hidden
   */
  getItemKey(row2) {
    if (this.selectionKey) {
      if (typeof this.selectionKey === "string") {
        return row2.dataItem[this.selectionKey];
      }
      if (typeof this.selectionKey === "function") {
        return this.selectionKey(row2);
      }
    }
    return row2.index;
  }
  /**
   * @hidden
   */
  stateToArray() {
    return this.isCellSelectionMode ? this.cellSelectionState.toArray("itemKey", "columnKey") : Array.from(this.rowSelectionState);
  }
  getSelectionItem(row2, col, colIndex) {
    const itemIdentifiers = {};
    itemIdentifiers.itemKey = this.getItemKey(row2);
    if (!isPresent4(col) && !isPresent4(colIndex)) {
      return itemIdentifiers;
    }
    if (this.columnKey) {
      if (typeof this.columnKey === "string") {
        itemIdentifiers.columnKey = row2.dataItem[this.columnKey];
      }
      if (typeof this.columnKey === "function") {
        itemIdentifiers.columnKey = this.columnKey(col, colIndex);
      }
    }
    return {
      itemKey: itemIdentifiers.itemKey,
      columnKey: itemIdentifiers.columnKey ? itemIdentifiers.columnKey : colIndex
    };
  }
  onSelectionChange(selection) {
    if (selection.selectedRows) {
      selection.deselectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.delete(itemKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.rowSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedRows.forEach((item) => {
        const itemKey = this.getItemKey(item);
        this.rowSelectionState.add(itemKey);
      });
    } else {
      selection.deselectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.delete(itemKey, columnKey);
      });
      if (this.ctx.grid.selectableSettings.mode === "single" && this.cellSelectionState.size > 0) {
        this.reset();
      }
      selection.selectedCells.forEach(({
        itemKey,
        columnKey
      }) => {
        this.cellSelectionState.add(itemKey, columnKey);
      });
    }
    this.cd.markForCheck();
    this.notifyChange();
  }
  notifyChange() {
    this.lastSelectionState = this.stateToArray();
    this.selectedKeysChange.emit(this.lastSelectionState);
  }
  setState(selectedKeys) {
    this.reset();
    if (this.isCellSelectionMode) {
      this.cellSelectionState = new PairSet(selectedKeys, "itemKey", "columnKey");
    } else {
      this.rowSelectionState = new Set(selectedKeys);
    }
  }
};
Selection.ɵfac = function Selection_Factory(t) {
  return new (t || Selection)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
};
Selection.ɵdir = ɵɵdefineDirective({
  type: Selection,
  selectors: [["kendo-grid-selection-base"]],
  inputs: {
    selectedKeys: "selectedKeys",
    rangeSelectionStartRow: "rangeSelectionStartRow",
    rangeSelectionStartColumnIndex: "rangeSelectionStartColumnIndex",
    selectionKey: [0, "kendoGridSelectBy", "selectionKey"],
    columnKey: "columnKey"
  },
  outputs: {
    selectedKeysChange: "selectedKeysChange"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Selection, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-selection-base"
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    selectedKeys: [{
      type: Input
    }],
    rangeSelectionStartRow: [{
      type: Input
    }],
    rangeSelectionStartColumnIndex: [{
      type: Input
    }],
    selectionKey: [{
      type: Input,
      args: ["kendoGridSelectBy"]
    }],
    columnKey: [{
      type: Input
    }],
    selectedKeysChange: [{
      type: Output
    }]
  });
})();
var forEachColumn = (list, callback) => {
  list.forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachColumn(column.childrenArray, callback);
    }
  });
};
var forEachLevel = (list, callback) => {
  sortColumns(list).forEach((column) => {
    callback(column);
    if (column.isColumnGroup && column.hasChildren) {
      forEachLevel(column.childrenArray, callback);
    }
  });
};
var filterHierarchy = (list, predicate) => {
  const result = [];
  sortColumns(list).forEach((column) => {
    if (predicate(column)) {
      if (column.isColumnGroup) {
        const children2 = filterHierarchy(column.childrenArray, predicate);
        if (children2.length) {
          result.push(column, ...children2);
        }
      } else if (!column.isSpanColumn || filterHierarchy(column.childrenArray, predicate).length) {
        result.push(column);
      }
    }
  });
  return result.sort((a, b) => Number(b.locked) - Number(a.locked));
};
var ColumnList = class _ColumnList {
  constructor(columns) {
    this.columns = columns;
  }
  static empty() {
    return new _ColumnList(new QueryList());
  }
  forEach(callback) {
    forEachColumn(this.columns, callback);
  }
  filter(callback) {
    const result = [];
    forEachColumn(this.columns, (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  filterHierarchy(predicate) {
    return filterHierarchy(this.columns.toArray(), predicate);
  }
  filterSort(callback) {
    const result = [];
    forEachLevel(this.columns.toArray(), (column) => {
      if (callback(column)) {
        result.push(column);
      }
    });
    return result;
  }
  toArray() {
    const result = [];
    forEachColumn(this.columns, (column) => {
      result.push(column);
    });
    return result;
  }
  rootColumns() {
    return this.columns.toArray();
  }
  totalColumnLevels() {
    let totalLevels = 0;
    this.forEach((column) => {
      totalLevels = Math.max(column.level, totalLevels);
    });
    return totalLevels;
  }
};
var GroupInfoService = class {
  constructor() {
    this._columnList = ColumnList.empty;
  }
  get columns() {
    return expandColumns(this._columnList().toArray()).filter(isColumnComponent);
  }
  registerColumnsContainer(columns) {
    this._columnList = columns;
  }
  formatForGroup(item) {
    const column = this.columnForGroup(item);
    return column ? column.format : "";
  }
  isGroupable(groupField) {
    const [column] = this.columns.filter((x) => x.field === groupField);
    return column ? column.groupable : true;
  }
  groupTitle(item) {
    const column = this.columnForGroup(item);
    return column ? column.title || column.field : this.groupField(item);
  }
  groupHeaderTemplate(item) {
    const column = this.columnForGroup(item);
    return column ? column.groupHeaderTemplateRef || column.groupHeaderColumnTemplateRef : void 0;
  }
  groupField(group2) {
    return group2.data ? group2.data.field : group2.field;
  }
  columnForGroup(group2) {
    const field = this.groupField(group2);
    const [column] = this.columns.filter((x) => x.field === field);
    return column;
  }
};
var ChangeNotificationService = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changes = new EventEmitter();
  }
  notify() {
    if (!this.subscription || this.subscription.closed) {
      this.subscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this.changes.emit());
    }
  }
};
ChangeNotificationService.ɵfac = function ChangeNotificationService_Factory(t) {
  return new (t || ChangeNotificationService)(ɵɵinject(NgZone));
};
ChangeNotificationService.ɵprov = ɵɵdefineInjectable({
  token: ChangeNotificationService,
  factory: ChangeNotificationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChangeNotificationService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var NoRecordsTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
NoRecordsTemplateDirective.ɵfac = function NoRecordsTemplateDirective_Factory(t) {
  return new (t || NoRecordsTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
NoRecordsTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: NoRecordsTemplateDirective,
  selectors: [["", "kendoGridNoRecordsTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoRecordsTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridNoRecordsTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var set2 = (value2) => (pair) => pair.forEach((x) => x.style.height = value2);
var clearHeight = (pairs) => pairs.filter(([left, right]) => left.style.height || right.style.height).forEach(set2(""));
var zip2 = (arr1, arr2) => {
  const result = [];
  for (let idx = 0, len = arr1.length; idx < len; idx++) {
    if (!arr2[idx]) {
      break;
    }
    result.push([arr1[idx], arr2[idx]]);
  }
  return result;
};
var setHeight$1 = (heights) => (row2, idx) => set2(`${heights[idx] + 1}px`)(row2);
var getHeights = (rows) => rows.map(([left, right]) => {
  const height = left.offsetHeight;
  const offsetHeight2 = right.offsetHeight;
  if (height < offsetHeight2) {
    return offsetHeight2;
  }
  return height;
});
var syncRowsHeight = (table1, table2) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const activeElement = document.activeElement;
  const rows = zip2(table1.rows, table2.rows);
  clearHeight(rows);
  const heights = getHeights(rows);
  [table1, table2].forEach((x) => x.style.display = "none");
  rows.forEach(setHeight$1(heights));
  [table1, table2].forEach((x) => x.style.display = "");
  if (document.activeElement !== activeElement && (table1.contains(activeElement) || table2.contains(activeElement))) {
    activeElement.focus();
  }
};
var MenuTabbingService = class {
  constructor() {
    this.isColumnMenu = false;
    this.isPopupOpen = false;
    this.isTabbedInterface = false;
  }
};
MenuTabbingService.ɵfac = function MenuTabbingService_Factory(t) {
  return new (t || MenuTabbingService)();
};
MenuTabbingService.ɵprov = ɵɵdefineInjectable({
  token: MenuTabbingService,
  factory: MenuTabbingService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MenuTabbingService, [{
    type: Injectable
  }], null, null);
})();
var FilterService = class {
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.changes = new Subject();
    this.menuTabbingService = menuTabbingService;
  }
  /**
   * Sets the filter descriptor.
   *
   * @param {CompositeFilterDescriptor} value - The filter descriptor that will be set.
   */
  filter(value2) {
    this.changes.next(value2);
  }
};
FilterService.ɵfac = function FilterService_Factory(t) {
  return new (t || FilterService)(ɵɵinject(MenuTabbingService, 8));
};
FilterService.ɵprov = ɵɵdefineInjectable({
  token: FilterService,
  factory: FilterService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterService, [{
    type: Injectable
  }], function() {
    return [{
      type: MenuTabbingService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PagerTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
PagerTemplateDirective.ɵfac = function PagerTemplateDirective_Factory(t) {
  return new (t || PagerTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
PagerTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: PagerTemplateDirective,
  selectors: [["", "kendoPagerTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoPagerTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var PDFService = class {
  constructor() {
    this.savePDF = new EventEmitter();
    this.drawPDF = new EventEmitter();
    this.exportClick = new EventEmitter();
    this.dataChanged = new EventEmitter();
  }
  save(component) {
    this.emitEvent(this.savePDF, component);
  }
  draw(component, promise) {
    this.emitEvent(this.drawPDF, {
      component,
      promise
    });
  }
  /**
   * @hidden
   */
  emitEvent(emitter, args) {
    if (emitter.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("PDF", "PDFModule", "<kendo-grid-pdf>"));
      }
    } else {
      emitter.emit(args);
    }
  }
};
PDFService.ɵfac = function PDFService_Factory(t) {
  return new (t || PDFService)();
};
PDFService.ɵprov = ɵɵdefineInjectable({
  token: PDFService,
  factory: PDFService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFService, [{
    type: Injectable
  }], null, null);
})();
var PDFExportEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor() {
    super();
  }
};
var SuspendService = class {
  constructor() {
    this.scroll = false;
  }
};
SuspendService.ɵfac = function SuspendService_Factory(t) {
  return new (t || SuspendService)();
};
SuspendService.ɵprov = ɵɵdefineInjectable({
  token: SuspendService,
  factory: SuspendService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SuspendService, [{
    type: Injectable
  }], null, null);
})();
var bootstrapToMedia = (media) => ({
  "xs": "(max-width: 576px)",
  "sm": "(min-width: 576px)",
  "md": "(min-width: 768px)",
  "lg": "(min-width: 992px)",
  "xl": "(min-width: 1200px)"
})[media] || media;
var browserMatchMedia = (media) => window.matchMedia(media).matches;
var ResponsiveService = class {
  constructor() {
    this.matchMedia = browserMatchMedia;
  }
  /**
   * @hidden
   */
  matchesMedia(media) {
    return !media || this.matchMedia(bootstrapToMedia(media));
  }
};
ResponsiveService.ɵfac = function ResponsiveService_Factory(t) {
  return new (t || ResponsiveService)();
};
ResponsiveService.ɵprov = ɵɵdefineInjectable({
  token: ResponsiveService,
  factory: ResponsiveService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveService, [{
    type: Injectable
  }], null, null);
})();
var ExcelService = class {
  constructor() {
    this.saveToExcel = new EventEmitter();
    this.exportClick = new EventEmitter();
  }
  save(component) {
    if (this.saveToExcel.observers.length === 0) {
      if (isDevMode()) {
        throw new Error(GridConfigurationErrorMessages.requiredModule("excel", "ExcelModule", "<kendo-grid-excel>"));
      }
    } else {
      this.saveToExcel.emit(component);
    }
  }
};
ExcelService.ɵfac = function ExcelService_Factory(t) {
  return new (t || ExcelService)();
};
ExcelService.ɵprov = ɵɵdefineInjectable({
  token: ExcelService,
  factory: ExcelService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelService, [{
    type: Injectable
  }], null, null);
})();
var ToolbarTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._position = "top";
  }
  /**
   * The position of the toolbar ([see example]({% slug toolbartemplate_grid %}#toc-setting-the-toolbar-position)).
   *
   * @default 'top'
   */
  set position(position2) {
    this._position = position2;
  }
  get position() {
    return this._position;
  }
};
ToolbarTemplateDirective.ɵfac = function ToolbarTemplateDirective_Factory(t) {
  return new (t || ToolbarTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
ToolbarTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: ToolbarTemplateDirective,
  selectors: [["", "kendoGridToolbarTemplate", ""]],
  inputs: {
    position: "position"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridToolbarTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    position: [{
      type: Input,
      args: ["position"]
    }]
  });
})();
var ScrollSyncService = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.changes = new Subject();
    this.elements = [];
    this.subscriptions = new Subscription();
    this.headerSubscription = new Subscription();
    this.bodySubscription = new Subscription();
    this.subscriptions.add(this.changes.subscribe((args) => this.scrollLeft(args)));
  }
  registerEmitter(el, sourceType) {
    this.unregister(sourceType);
    this.elements.push({
      element: el,
      sourceType
    });
    if (sourceType === "body" || sourceType === "header") {
      this.ngZone.runOutsideAngular(() => {
        const obs = fromEvent(el, "scroll").pipe(map(({
          target: {
            scrollLeft
          }
        }) => ({
          scrollLeft,
          sourceType
        })));
        const subscription = obs.pipe(distinctUntilChanged((x, y) => x.scrollLeft === y.scrollLeft), filter((x) => !this.source || this.source === x.sourceType), tap((x) => this.source = x.sourceType)).subscribe((x) => this.changes.next(x));
        subscription.add(obs.pipe(filter((x) => this.source && this.source !== x.sourceType)).subscribe(() => this.source = void 0));
        if (sourceType === "body") {
          this.bodySubscription.add(subscription);
        } else {
          this.headerSubscription.add(subscription);
        }
      });
    }
  }
  /**
   * destroy
   */
  destroy() {
    this.subscriptions.unsubscribe();
    this.headerSubscription.unsubscribe();
    this.bodySubscription.unsubscribe();
  }
  scrollLeft({
    scrollLeft,
    sourceType
  }) {
    this.ngZone.runOutsideAngular(() => {
      this.elements.filter((x) => sourceType !== x.sourceType).forEach(({
        element
      }) => element.scrollLeft = scrollLeft);
    });
  }
  unregister(sourceType) {
    const index = this.elements.findIndex((x) => x.sourceType === sourceType);
    if (index > -1) {
      if (sourceType === "header") {
        this.headerSubscription.unsubscribe();
        this.headerSubscription = new Subscription();
      } else if (sourceType === "body") {
        this.bodySubscription.unsubscribe();
        this.bodySubscription = new Subscription();
      }
      this.elements.splice(index, 1);
    }
  }
};
ScrollSyncService.ɵfac = function ScrollSyncService_Factory(t) {
  return new (t || ScrollSyncService)(ɵɵinject(NgZone));
};
ScrollSyncService.ɵprov = ɵɵdefineInjectable({
  token: ScrollSyncService,
  factory: ScrollSyncService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollSyncService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var ResizeService = class {
  constructor() {
    this.resizeSubscription = new Subscription(() => {
    });
    this.dispatcher = new Subject();
    this.changes = this.dispatcher.asObservable().pipe(throttleTime(100));
  }
  connect(resizes) {
    this.resizeSubscription.add(resizes.subscribe(this.dispatcher));
  }
  destroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
};
ResizeService.ɵfac = function ResizeService_Factory(t) {
  return new (t || ResizeService)();
};
ResizeService.ɵprov = ɵɵdefineInjectable({
  token: ResizeService,
  factory: ResizeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizeService, [{
    type: Injectable
  }], null, null);
})();
var isLocked = (column) => column.parent ? isLocked(column.parent) : !!column.locked;
var resizeArgs = (column, extra) => Object.assign({
  columns: leafColumns([column]),
  locked: isLocked(column)
}, extra);
var ColumnResizingService = class {
  constructor() {
    this.changes = new EventEmitter();
    this.tables = [];
    this.batch = null;
  }
  start(column) {
    this.trackColumns(column);
    const columns = (this.column.isColumnGroup ? [column] : []).concat(leafColumns([column]));
    this.changes.emit({
      columns,
      locked: isLocked(this.column),
      type: "start"
    });
  }
  resizeColumns(deltaPercent) {
    const action = resizeArgs(this.column, {
      deltaPercent,
      type: "resizeColumn"
    });
    this.changes.emit(action);
  }
  resizeTable(column, delta) {
    const action = resizeArgs(column, {
      delta,
      type: "resizeTable"
    });
    this.changes.emit(action);
  }
  resizedColumn(state2) {
    this.resizedColumns.push(state2);
  }
  end() {
    this.changes.emit({
      columns: [],
      resizedColumns: this.resizedColumns,
      type: "end"
    });
  }
  registerTable(tableMetadata) {
    this.tables.push(tableMetadata);
    const unregisterTable = () => {
      this.tables.splice(this.tables.indexOf(tableMetadata), 1);
    };
    return unregisterTable;
  }
  measureColumns(info) {
    if (this.batch !== null) {
      this.batch.push(...info);
    } else {
      this.autoFitBatch(info, () => this.end());
    }
  }
  autoFit(...columns) {
    const nonLockedColumns = columns.filter((column) => !column.isLocked);
    this.autoFitStart(nonLockedColumns);
    this.autoFitBatch(this.batch, () => {
      if (nonLockedColumns.length < columns.length) {
        const lockedColumns = columns.filter((column) => column.isLocked);
        this.autoFitStart(lockedColumns);
        this.autoFitBatch(this.batch, () => this.end());
      } else {
        this.end();
      }
    });
  }
  trackColumns(column) {
    this.resizedColumns = [];
    this.column = column;
  }
  autoFitStart(columns) {
    this.batch = [];
    this.resizedColumns = [];
    if (columns.length === 0) {
      return;
    }
    const locked = columns[0].isLocked;
    this.changes.emit({
      type: "start",
      columns,
      locked
    });
    this.changes.emit({
      type: "triggerAutoFit",
      columns,
      locked
    });
  }
  autoFitBatch(info, onComplete) {
    const locked = info.length > 0 ? info[0].column.isLocked : false;
    const observables = this.tables.filter((table) => table.locked === locked).map((table) => table.autoFit(info));
    zip(...observables).pipe(take(1)).subscribe((widths) => {
      this.changes.emit({
        columns: info.map((i) => i.column),
        type: "autoFitComplete",
        widths,
        locked
      });
      if (onComplete) {
        onComplete();
      }
    });
    this.batch = null;
  }
};
ColumnResizingService.ɵfac = function ColumnResizingService_Factory(t) {
  return new (t || ColumnResizingService)();
};
ColumnResizingService.ɵprov = ɵɵdefineInjectable({
  token: ColumnResizingService,
  factory: ColumnResizingService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizingService, [{
    type: Injectable
  }], null, null);
})();
var isFilterable = (settings) => settings !== false;
var hasFilterMenu = (settings) => typeof settings === "string" && settings.indexOf("menu") > -1;
var hasFilterRow = (settings) => settings === true || typeof settings === "string" && settings.indexOf("row") > -1;
var contains$1 = (node, predicate) => {
  while (node) {
    if (predicate(node)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var PopupCloseEvent = class extends PreventableEvent2 {
  constructor(e) {
    super();
    this.originalEvent = e;
  }
};
var DEFAULT_POPUP_CLASS = "k-grid-filter-popup";
var SinglePopupService = class {
  /**
   * @hidden
   */
  constructor(popupService, renderer, ngZone, scrollSyncService, ctx) {
    this.popupService = popupService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.onClose = new Subject();
    this.pointerEventsSub = new Subscription();
    this.scrollSubscription = scrollSyncService.changes.subscribe(() => this.destroy());
  }
  /**
   * @hidden
   */
  open(anchor2, template, popupRef, popupClass = DEFAULT_POPUP_CLASS) {
    const toggle = isPresent4(popupRef) && this.popupRef === popupRef;
    this.destroy();
    if (!toggle) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        },
        anchor: anchor2,
        popupClass,
        content: template,
        positionMode: "absolute"
      });
      this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
      this.attachClose(anchor2);
    }
    const popupEl = this.popupRef?.popupElement;
    if (popupEl) {
      this.attachMouseListeners(popupEl);
    }
    return this.popupRef;
  }
  /**
   * @hidden
   */
  destroy() {
    if (this.popupRef) {
      this.detachClose();
      this.pointerEventsSub.unsubscribe();
      this.pointerEventsSub = null;
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  ngOnDestroy() {
    this.destroy();
    this.scrollSubscription.unsubscribe();
  }
  detachClose() {
    if (this.removeClick) {
      this.removeClick();
    }
  }
  attachClose(skipElement) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.detachClose();
    this.ngZone.runOutsideAngular(() => this.removeClick = this.renderer.listen("document", "click", (e) => {
      if (!contains$1(e.target, (x) => this.popupRef.popupElement === x || x === skipElement)) {
        const args = new PopupCloseEvent(e);
        this.onClose.next(args);
        if (!args.isDefaultPrevented() && this.canClosePopup) {
          this.destroy();
        }
        this.canClosePopup = true;
      }
    }));
  }
  attachMouseListeners(el) {
    this.pointerEventsSub = new Subscription();
    this.ngZone.runOutsideAngular(() => {
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerdown", (e) => {
        e.stopImmediatePropagation();
        this.canClosePopup = false;
      }));
      this.pointerEventsSub.add(this.renderer.listen(el, "pointerup", () => {
        this.canClosePopup = true;
      }));
    });
  }
};
SinglePopupService.ɵfac = function SinglePopupService_Factory(t) {
  return new (t || SinglePopupService)(ɵɵinject(PopupService), ɵɵinject(Renderer2), ɵɵinject(NgZone), ɵɵinject(ScrollSyncService), ɵɵinject(ContextService));
};
SinglePopupService.ɵprov = ɵɵdefineInjectable({
  token: SinglePopupService,
  factory: SinglePopupService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SinglePopupService, [{
    type: Injectable
  }], function() {
    return [{
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ScrollSyncService
    }, {
      type: ContextService
    }];
  }, null);
})();
var append = (element) => {
  if (!isDocumentAvailable()) {
    return;
  }
  let appended = false;
  return () => {
    if (!appended) {
      document.body.appendChild(element);
      appended = true;
    }
    return element;
  };
};
var getDocument$1 = (element) => element.ownerDocument.documentElement;
var getWindow$1 = (element) => element.ownerDocument.defaultView;
var offset = (element) => {
  const {
    clientTop,
    clientLeft
  } = getDocument$1(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow$1(element);
  const {
    top,
    left
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left + pageXOffset - clientLeft
  };
};
var isTargetBefore = (draggable, target) => (target.compareDocumentPosition(draggable) & 4) !== 0;
var contains2 = (element, container) => element === container || (container.compareDocumentPosition(element) & 16) !== 0;
var position = (target, before) => {
  const targetRect = offset(target);
  const {
    offsetWidth: offsetWidth2,
    offsetHeight
  } = target;
  const left = targetRect.left + (before ? 0 : offsetWidth2);
  const top = targetRect.top;
  const height = offsetHeight;
  return {
    left,
    top,
    height
  };
};
var DragAndDropService = class {
  constructor() {
    this.changes = new EventEmitter();
    this.register = [];
    this.lastTarget = null;
  }
  add(target) {
    this.register.push(target);
  }
  remove(target) {
    this.register = this.register.filter((current3) => current3 !== target);
  }
  notifyDrag(draggable, element, mouseEvent) {
    const target = this.targetFor(element);
    if (this.lastTarget === target) {
      return;
    }
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "leave"
    });
    if (target) {
      this.changes.next({
        draggable,
        mouseEvent,
        target,
        type: "enter"
      });
    }
    this.lastTarget = target;
  }
  notifyDrop(draggable, mouseEvent) {
    this.changes.next({
      draggable,
      mouseEvent,
      target: this.lastTarget,
      type: "drop"
    });
    this.lastTarget = null;
  }
  targetFor(element) {
    const comparer = contains2.bind(null, element);
    return this.register.find(({
      element: {
        nativeElement
      }
    }) => comparer(nativeElement));
  }
};
DragAndDropService.ɵfac = function DragAndDropService_Factory(t) {
  return new (t || DragAndDropService)();
};
DragAndDropService.ɵprov = ɵɵdefineInjectable({
  token: DragAndDropService,
  factory: DragAndDropService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropService, [{
    type: Injectable
  }], null, null);
})();
var updateClass = (element, valid, svg) => {
  const icon = element.querySelector(".k-icon");
  if (svg) {
    const svg2 = icon.firstElementChild;
    svg2.removeChild(svg2.firstElementChild);
    const path = valid ? plusIcon.content : cancelIcon.content;
    icon.firstElementChild.innerHTML = path + icon.firstElementChild.innerHTML;
  }
  icon.setAttribute("class", icon.getAttribute("class").replace(/(plus|cancel)/, valid ? "plus" : "cancel"));
};
var updateLock = (element, locked = null, svg) => {
  const icon = element.querySelectorAll(".k-icon")[1];
  const value2 = locked === null ? "" : locked ? `k${svg ? "-svg" : ""}-i-lock` : `k${svg ? "-svg" : ""}-i-unlock`;
  if (svg) {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-svg-i-unlock|k-svg-i-lock)/, "").trim() + ` ${value2}`);
    icon.firstElementChild.innerHTML = locked ? lockIcon.content : unlockIcon.content;
  } else {
    icon.setAttribute("class", icon.getAttribute("class").replace(/(k-i-unlock|k-i-lock)/, "").trim() + ` ${value2}`);
  }
};
var decorate = (element) => {
  element.className = "k-header k-drag-clue";
  element.style.position = "absolute";
  element.style.zIndex = "20000";
};
var svgIconsMarkup = (viewBox, content, safeTitle) => `
    <span class="k-icon k-svg-icon k-drag-status k-svg-i-cancel">
        <svg 
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            viewBox="${viewBox}"
            aria-hidden="true">
            ${content}
        </svg>
        <span class="k-icon k-svg-icon k-icon-modifier">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                viewBox="${viewBox}"
                aria-hidden="true">
            </svg>
        </span>
    </span>
    ${safeTitle}`;
var fontIconsMarkup = (safeTitle) => `
    <span class="k-icon k-font-icon k-drag-status k-i-cancel">
        <span class="k-icon k-font-icon k-icon-modifier"></span>
    </span>
    ${safeTitle}`;
var DragHintService = class {
  constructor(santizer, iconsService) {
    this.santizer = santizer;
    this.iconsService = iconsService;
    this.cancelIcon = cancelIcon;
  }
  create(title) {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    decorate(this.dom);
    const safeTitle = this.santizer.sanitize(SecurityContext.HTML, title);
    const innerHtml = this.isSVG ? svgIconsMarkup(this.cancelIcon.viewBox, this.cancelIcon.content, safeTitle) : fontIconsMarkup(safeTitle);
    this.dom.innerHTML = innerHtml;
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentNode) {
      (function(el) {
        setTimeout(() => document.body.removeChild(el));
      })(this.dom);
      this.dom = null;
    }
  }
  show() {
    this.dom.style.display = "";
  }
  hide() {
    this.dom.style.display = "none";
  }
  enable() {
    updateClass(this.dom, true, this.isSVG);
  }
  disable() {
    updateClass(this.dom, false, this.isSVG);
  }
  removeLock() {
    updateLock(this.dom, false, this.isSVG);
  }
  toggleLock(locked) {
    updateLock(this.dom, locked, this.isSVG);
  }
  move(move) {
    this.dom.style.top = move.pageY + "px";
    this.dom.style.left = move.pageX + "px";
  }
  get isSVG() {
    return (this.iconsService.iconSettings?.type || this.iconsService.changes.value.type) === "svg";
  }
};
DragHintService.ɵfac = function DragHintService_Factory(t) {
  return new (t || DragHintService)(ɵɵinject(DomSanitizer), ɵɵinject(IconsService));
};
DragHintService.ɵprov = ɵɵdefineInjectable({
  token: DragHintService,
  factory: DragHintService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHintService, [{
    type: Injectable
  }], function() {
    return [{
      type: DomSanitizer
    }, {
      type: IconsService
    }];
  }, null);
})();
var DropCueService = class {
  create() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dom = document.createElement("div");
    this.dom.className = "k-grouping-dropclue";
    this.hide();
  }
  attach() {
    return append(this.dom);
  }
  remove() {
    if (this.dom && this.dom.parentElement) {
      document.body.removeChild(this.dom);
      this.dom = null;
    }
  }
  hide() {
    this.dom.style.display = "none";
  }
  position({
    left,
    top,
    height
  }) {
    this.dom.style.display = "block";
    this.dom.style.height = height + "px";
    this.dom.style.top = top + "px";
    const width = this.dom.offsetWidth / 2;
    this.dom.style.left = left - width + "px";
  }
};
DropCueService.ɵfac = function DropCueService_Factory(t) {
  return new (t || DropCueService)();
};
DropCueService.ɵprov = ɵɵdefineInjectable({
  token: DropCueService,
  factory: DropCueService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropCueService, [{
    type: Injectable
  }], null, null);
})();
var ColumnReorderService = class {
  constructor() {
    this.changes = new EventEmitter();
  }
  reorder(e) {
    this.changes.emit(e);
  }
};
ColumnReorderService.ɵfac = function ColumnReorderService_Factory(t) {
  return new (t || ColumnReorderService)();
};
ColumnReorderService.ɵprov = ɵɵdefineInjectable({
  token: ColumnReorderService,
  factory: ColumnReorderService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnReorderService, [{
    type: Injectable
  }], null, null);
})();
var ColumnReorderEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor({
    column,
    newIndex,
    oldIndex
  }) {
    super();
    this.column = column;
    this.newIndex = newIndex;
    this.oldIndex = oldIndex;
  }
};
var NavigationMetadata = class {
  constructor(dataRows, headerRows, isVirtual, hasPager, hasDetailTemplate, gridElement, virtualColumns, columns) {
    this.dataRows = dataRows;
    this.headerRows = headerRows;
    this.isVirtual = isVirtual;
    this.hasPager = hasPager;
    this.hasDetailTemplate = hasDetailTemplate;
    this.gridElement = gridElement;
    this.virtualColumns = virtualColumns;
    this.columns = columns;
  }
  get maxLogicalRowIndex() {
    const dataRows = this.hasDetailTemplate ? this.dataRows * 2 : this.dataRows;
    return this.headerRows + dataRows - 1;
  }
};
var SortService = class {
  constructor() {
    this.changes = new Subject();
  }
  sort(value2) {
    this.changes.next(value2);
  }
};
var ColumnVisibilityChangeEvent = class {
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var ColumnLockedChangeEvent = class {
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var GROUP_CELL_WIDTH = 32;
var RESPONSIVE_BREAKPOINT_MEDIUM = 600;
var RESPONSIVE_BREAKPOINT_LARGE = 768;
function defaultTrackBy(index, item) {
  if (item.type === "data" && item.isEditing) {
    return item.data;
  }
  return index;
}
var ColumnStickyChangeEvent = class {
  /**
   * @hidden
   */
  constructor(columns) {
    this.columns = columns;
  }
};
var CellLoadingTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
CellLoadingTemplateDirective.ɵfac = function CellLoadingTemplateDirective_Factory(t) {
  return new (t || CellLoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
CellLoadingTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: CellLoadingTemplateDirective,
  selectors: [["", "kendoGridCellLoadingTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellLoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridCellLoadingTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var LoadingTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
LoadingTemplateDirective.ɵfac = function LoadingTemplateDirective_Factory(t) {
  return new (t || LoadingTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
};
LoadingTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: LoadingTemplateDirective,
  selectors: [["", "kendoGridLoadingTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLoadingTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var SizingOptionsService = class {
  constructor() {
    this.changes = new Subject();
  }
};
SizingOptionsService.ɵfac = function SizingOptionsService_Factory(t) {
  return new (t || SizingOptionsService)();
};
SizingOptionsService.ɵprov = ɵɵdefineInjectable({
  token: SizingOptionsService,
  factory: SizingOptionsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SizingOptionsService, [{
    type: Injectable
  }], null, null);
})();
var isNextSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.nextElementSibling;
var isPreviousSibling = (dropTarget, dragTarget) => dropTarget === dragTarget.previousElementSibling;
var isDifferentParent = (dropTarget, dragTarget) => dropTarget?.parentElement !== dragTarget?.parentElement;
function getOffset(element) {
  const {
    clientTop,
    clientLeft
  } = getDocument2(element);
  const {
    pageYOffset,
    pageXOffset
  } = getWindow2(element);
  const {
    top,
    left
  } = element.getBoundingClientRect();
  return {
    top: top + pageYOffset - clientTop,
    left: left + pageXOffset - clientLeft
  };
}
var hintIcons = {
  forbidden: "cancel",
  before: "insert-middle",
  after: "insert-middle"
};
var hintSVGIcons = {
  forbidden: cancelIcon,
  before: insertMiddleIcon,
  after: insertMiddleIcon
};
var dropPosition = {
  forbidden: "forbidden",
  before: "before",
  after: "after"
};
var hintStyles = {
  zIndex: "20000",
  display: "flex",
  position: "fixed"
};
var hintClasses = ["k-drag-clue", "k-reorder-clue"];
var dropIndicatorStyles = {
  zIndex: "19000",
  position: "absolute"
};
var dropIndicatorClasses = ["k-drop-hint", "k-drop-hint-h"];
var defaultSelectors = {
  handle: ".k-table-td.k-drag-cell",
  dragTarget: ".k-master-row",
  dropTarget: ".k-master-row"
};
var getDocument2 = (element) => element?.ownerDocument.documentElement;
var getWindow2 = (element) => element?.ownerDocument.defaultView;
var RowReorderService = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.hintElement = null;
    this.defaultSelectors = defaultSelectors;
    this.hintText = "";
    this.lastDropPosition = dropPosition.forbidden;
    this.dragTarget = null;
    this.dropTarget = null;
    this.rowReorder = new EventEmitter();
  }
  press(ev) {
    this.dragTarget = ev.dragTarget;
    this.offsetY = ev.dragEvent.offsetY;
  }
  dragStart() {
    this.createDropIndicator();
  }
  drag(ev) {
    if (isPresent(ev.hintElement) && !isPresent(this.hintElement)) {
      this.hintElement = ev.hintElement;
      this.decorateHint();
    }
    const position2 = {
      x: ev.dragEvent.clientX,
      y: ev.dragEvent.clientY - this.offsetY
    };
    if (isPresent(this.hintElement)) {
      this.renderer.setStyle(this.hintElement, "left", `${position2.x}px`);
      this.renderer.setStyle(this.hintElement, "top", `${position2.y}px`);
    }
    this.positionDropIndicator(ev);
  }
  dragEnter(ev) {
    this.dropTarget = ev.dropTarget;
  }
  dragLeave() {
    this.dropTarget = null;
    this.hide();
  }
  dragEnd() {
    this.destroyDropIndicator();
    this.dragTarget = null;
    this.dropTarget = null;
    this.hintElement = null;
  }
  drop(ev) {
    this.destroyDropIndicator();
    const rowReorderArgs = this.rowReorderArgs(this.dragTarget, this.dropTarget, ev.dragData);
    this.rowReorder.emit(rowReorderArgs);
  }
  reorderRows(ev, collection) {
    if (this.lastDropPosition === dropPosition.forbidden) {
      return;
    }
    const {
      draggedRows,
      dropTargetRow
    } = ev;
    const draggedDataItem = draggedRows[0].dataItem;
    const dropTargetDataItem = dropTargetRow.dataItem;
    const draggedItemIndex = collection.indexOf(draggedDataItem);
    const dropTargetIndex = collection.indexOf(dropTargetDataItem);
    const idxToAdd = this.calculateIndexToAdd(draggedItemIndex, dropTargetIndex);
    collection.splice(draggedItemIndex, 1);
    collection.splice(idxToAdd, 0, draggedDataItem);
  }
  get hintIcon() {
    return hintIcons[this.lastDropPosition];
  }
  get hintSVGIcon() {
    return hintSVGIcons[this.lastDropPosition];
  }
  getDefaultHintText(columns, data) {
    let hintText = "";
    const columnFieldsArray = columns.toArray().filter((column) => !column.hidden && isPresent(column.field)).map((column) => column.field);
    const draggedDragRow = this.getDragRowPerElement(this.dragTarget, data);
    const draggedDataItem = draggedDragRow?.dataItem;
    isPresent(draggedDataItem) && columnFieldsArray.forEach((column) => {
      const columnValue = draggedDataItem[column];
      isPresent(columnValue) ? hintText += `${columnValue} ` : null;
    });
    return hintText.trim();
  }
  rowReorderArgs(dragRow, dropRow, data) {
    const dragRowData = this.getDragRowPerElement(dragRow, data);
    const dropRowData = this.getDragRowPerElement(dropRow, data);
    return {
      draggedRows: [dragRowData],
      dropTargetRow: dropRowData,
      dropPosition: this.lastDropPosition
    };
  }
  getDragRowPerElement(row2, data) {
    let rowIndex = row2?.getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const skip4 = this.skip || 0;
    const dataItem = rowIndex === -1 ? null : data[rowIndex - skip4];
    return {
      dataItem,
      rowIndex,
      element: row2
    };
  }
  createDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.dropIndicator = document.createElement("div");
    this.decorateDropIndicator();
    this.dropIndicator.innerHTML = `
            <div class="k-drop-hint-start"></div>
            <div class="k-drop-hint-line"></div>
        `;
    document.body.appendChild(this.dropIndicator);
    this.hide();
  }
  destroyDropIndicator() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.dropIndicator && this.dropIndicator.parentElement) {
      document.body.removeChild(this.dropIndicator);
      this.dropIndicator = null;
    }
  }
  decorateHint() {
    hintClasses.forEach((className) => this.renderer.addClass(this.hintElement, className));
    Object.keys(hintStyles).forEach((style2) => this.renderer.setStyle(this.hintElement, style2, hintStyles[style2]));
  }
  positionDropIndicator(ev) {
    this.lastDropPosition = this.getDropPosition(ev.dragEvent);
    this.updateDropIndicatorPosition();
  }
  calculateIndexToAdd(dragIndex, dropIndex) {
    if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex + 1;
    } else if (dragIndex > dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.after) {
      return dropIndex;
    } else if (dragIndex < dropIndex && this.lastDropPosition === dropPosition.before) {
      return dropIndex - 1;
    }
  }
  decorateDropIndicator() {
    dropIndicatorClasses.forEach((className) => this.renderer.addClass(this.dropIndicator, className));
    Object.keys(dropIndicatorStyles).forEach((style2) => this.renderer.setStyle(this.dropIndicator, style2, dropIndicatorStyles[style2]));
  }
  getDropPosition(e) {
    if (this.dropTarget === this.dragTarget || !isPresent(this.dropTarget)) {
      return dropPosition.forbidden;
    }
    if (isDifferentParent(this.dropTarget, this.dragTarget)) {
      return dropPosition.forbidden;
    }
    const itemViewPortCoords = this.dropTarget.getBoundingClientRect();
    const itemDivisionsCount = 2;
    const itemDivisionHeight = itemViewPortCoords.height / itemDivisionsCount;
    const pointerPosition = e.clientY;
    const itemTop = itemViewPortCoords.top;
    let currentDropPosition = null;
    if (pointerPosition < itemTop + itemDivisionHeight) {
      currentDropPosition = dropPosition.before;
    } else if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
      currentDropPosition = dropPosition.after;
    }
    if (currentDropPosition === dropPosition.before && isNextSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    } else if (currentDropPosition === dropPosition.after && isPreviousSibling(this.dropTarget, this.dragTarget)) {
      currentDropPosition = dropPosition.forbidden;
    }
    return currentDropPosition;
  }
  updateDropIndicatorPosition() {
    if (this.shouldHideDropIndicator() || !this.dropTarget) {
      this.hide();
      return;
    }
    this.show();
    const destinationItemOffset = getOffset(this.dropTarget);
    let indicatorOffsetTop = destinationItemOffset.top;
    const indicatorOffsetLeft = destinationItemOffset.left + this.dropIndicator.offsetWidth / 2;
    if (this.lastDropPosition === dropPosition.after) {
      indicatorOffsetTop += this.dropTarget.offsetHeight;
    }
    this.renderer.setStyle(this.dropIndicator, "left", `${indicatorOffsetLeft}px`);
    this.renderer.setStyle(this.dropIndicator, "top", `${indicatorOffsetTop}px`);
  }
  shouldHideDropIndicator() {
    return this.lastDropPosition === dropPosition.forbidden;
  }
  hide() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "none";
    }
  }
  show() {
    if (isPresent(this.dropIndicator)) {
      this.dropIndicator.style.display = "";
    }
  }
};
RowReorderService.ɵfac = function RowReorderService_Factory(t) {
  return new (t || RowReorderService)(ɵɵinject(Renderer2));
};
RowReorderService.ɵprov = ɵɵdefineInjectable({
  token: RowReorderService,
  factory: RowReorderService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, {
    rowReorder: [{
      type: Output
    }]
  });
})();
var StatusBarTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
StatusBarTemplateDirective.ɵfac = function StatusBarTemplateDirective_Factory(t) {
  return new (t || StatusBarTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
};
StatusBarTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: StatusBarTemplateDirective,
  selectors: [["", "kendoGridStatusBarTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridStatusBarTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClipboardService = class {
  constructor(contextService) {
    this.contextService = contextService;
    this.itemToString = (item, cols) => {
      if (!cols.length) {
        return null;
      }
      return cols.map((col) => item[col.field]).join(`	`);
    };
  }
  createClipboardData(data, columns, options) {
    let result = {
      gridItems: [],
      dataString: ""
    };
    const fieldCols = columns.flatMap((c) => c instanceof ColumnComponent2 && isPresent(c.field) ? [c] : []);
    const clipboardData = {
      items: [],
      dataStrings: []
    };
    const colFields = fieldCols.map((c) => c.field);
    if (options.wholeRow) {
      this.targetColField = fieldCols[0]?.field;
      this.targetRowIndex = data[0].dataRowIndex;
      data.forEach((item) => {
        clipboardData.items.push({
          dataItem: __spreadValues({}, item.dataItem),
          fields: colFields
        });
        clipboardData.dataStrings.push(this.itemToString(item.dataItem, fieldCols));
      });
      result = {
        gridItems: options.operationType === "cut" ? clipboardData.items.map((item) => {
          item.fields.forEach((field) => item.dataItem[field] = null);
          return item;
        }) : [...clipboardData.items],
        dataString: options.copyHeaders ? this.addHeaders(clipboardData.dataStrings.join(`\r
`), fieldCols) : clipboardData.dataStrings.join(`
`)
      };
    } else {
      if (options.target === "selection") {
        const {
          tabular,
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        if (tabular) {
          const selectionKeys = groups[0].items.map((item) => item.columnKey);
          const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
          const selectedColFields = selectedFieldCols.map((c) => c.field);
          this.targetColField = selectedColFields[0];
          result.dataString = data.flatMap((item) => {
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && isPresent(itemString)) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (options.operationType === "cut") {
              selectedColFields.forEach((f) => item.dataItem[f] = null);
            }
            result.gridItems.push({
              dataItem: item.dataItem,
              fields: selectedColFields
            });
            return existingItem ? [itemString] : [];
          }).join(`\r
`);
          if (options.copyHeaders) {
            result.dataString = this.addHeaders(result.dataString, selectedFieldCols);
          }
        } else {
          const rowIdentifier = selectionDirective.selectionKey;
          result.dataString = data.flatMap((item) => {
            const key = rowIdentifier ? typeof rowIdentifier === "string" ? item.dataItem[rowIdentifier] : rowIdentifier({
              index: item.dataRowIndex,
              dataItem: item.dataItem
            }) : item.dataRowIndex;
            const selectionKeys = groups.find((gr) => gr.value === key).items.map((item2) => item2.columnKey);
            const selectedFieldCols = columns.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
            const selectedColFields = selectedFieldCols.map((c) => c.field);
            if (!this.targetColField) {
              this.targetColField = selectedColFields[0];
            }
            const itemString = this.itemToString(item.dataItem, selectedFieldCols);
            const existingItem = isPresent(itemString);
            if (!isPresent(this.targetRowIndex) && existingItem) {
              this.targetRowIndex = item.dataRowIndex;
            }
            if (existingItem) {
              if (options.operationType === "cut") {
                selectedColFields.forEach((f) => item.dataItem[f] = null);
              }
              result.gridItems.push({
                dataItem: item.dataItem,
                fields: selectedColFields
              });
            }
            return existingItem ? options.copyHeaders ? [this.addHeaders(itemString, selectedFieldCols)] : [itemString] : [];
          }).join(`\r
`);
        }
      } else {
        const item = data[0];
        const col = columns[item.colIndex];
        const colField = col.field;
        const title = col.title;
        const copiedData = item.dataItem[colField];
        this.targetRowIndex = item.dataRowIndex;
        this.targetColField = colField;
        if (options.operationType === "cut" && colField) {
          item.dataItem[colField] = null;
        }
        result = {
          gridItems: [{
            dataItem: item.dataItem,
            fields: colField ? [colField] : []
          }],
          dataString: options.copyHeaders ? [title || colField, copiedData].join(`\r
`) : colField ? copiedData : ``
        };
      }
    }
    return result;
  }
  getGridData(data, columns, targetType, targetRowIndex, options) {
    const separator = data.includes(`\r
`) ? `\r
` : data.includes(`
`) ? `
` : null;
    const dataRows = separator ? data.split(separator).filter((rowData) => rowData.length) : [data];
    this.targetRowIndex = targetRowIndex;
    if (targetType === "activeCell") {
      if (options.wholeRow) {
        this.targetColField = columns.find((c) => c instanceof ColumnComponent2 && c.field)?.field;
      } else {
        const activeCellIndex = this.contextService.grid.activeCell.colIndex;
        for (let i = 0; i < columns.length; i++) {
          const col = columns[i];
          if (col instanceof ColumnComponent2 && col.field && i >= activeCellIndex) {
            this.targetColField = col.field;
            break;
          }
        }
      }
    } else {
      if (options.wholeRow || !options.isCellSelection) {
        this.targetColField = columns.filter((c) => c instanceof ColumnComponent2 && c.field)[0]["field"];
      } else {
        const {
          groups
        } = this.groupSelection();
        const selectionDirective = this.contextService.grid.selectionDirective;
        const colIdentifier = selectionDirective.columnKey;
        const visibleCols = columns.filter((c) => c.isVisible);
        const selectionKeys = groups[0].items.map((item) => item.columnKey);
        const selectedFieldCols = visibleCols.flatMap((c, i) => c instanceof ColumnComponent2 && c.field && isPresent(selectionKeys.find((k) => typeof colIdentifier === "function" ? k === colIdentifier(c, i) : k === i)) ? [c] : []);
        const selectedColFields = selectedFieldCols.map((c) => c.field);
        this.targetColField = selectedColFields[0];
      }
    }
    const items = dataRows.map((rowString) => {
      const cells = rowString.includes(`	`) ? rowString.split(`	`) : [rowString];
      const colFields = columns.flatMap((c) => c instanceof ColumnComponent2 && c.field ? [c.field] : []);
      const targetColFieldIndex = colFields.indexOf(this.targetColField);
      const affectedFields = colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length);
      const item = {};
      colFields.slice(targetColFieldIndex, targetColFieldIndex + cells.length).forEach((colField, index) => item[colField] = cells[index]);
      return {
        dataItem: item,
        fields: affectedFields
      };
    });
    return items;
  }
  groupSelection() {
    const selection = this.contextService.grid.selection;
    const groups = groupBy(selection, [{
      field: "itemKey"
    }]).map((gr) => {
      gr.items.sort((a, b) => a.columnKey - b.columnKey);
      return gr;
    });
    for (let i = 1; i < groups.length; i++) {
      if (!this.areEqual(groups[i].items, groups[i - 1].items)) {
        return {
          tabular: false,
          groups
        };
      }
    }
    return {
      tabular: true,
      groups
    };
  }
  areEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (let i = 0; i < arr1.length; i++) {
      if (arr1[i].columnKey !== arr2[i].columnKey) {
        return false;
      }
    }
    return true;
  }
  addHeaders(initialData, cols) {
    const headersRowData = cols.map((c) => c.title || c.field).join(`	`);
    return `${headersRowData}\r
${initialData}`;
  }
};
ClipboardService.ɵfac = function ClipboardService_Factory(t) {
  return new (t || ClipboardService)(ɵɵinject(ContextService));
};
ClipboardService.ɵprov = ɵɵdefineInjectable({
  token: ClipboardService,
  factory: ClipboardService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClipboardService, [{
    type: Injectable
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var DropTargetDirective2 = class {
  constructor(element, service) {
    this.element = element;
    this.service = service;
    this.context = {};
    this.enter = new EventEmitter();
    this.leave = new EventEmitter();
    this.drop = new EventEmitter();
    this.subscriptions = new Subscription();
  }
  ngOnInit() {
    this.service.add(this);
    const changes = this.service.changes.pipe(filter(({
      target
    }) => target === this));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "leave")).subscribe((e) => {
      this.leave.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "enter")).subscribe((e) => {
      this.enter.next(this.eventArgs(e));
    }));
    this.subscriptions.add(changes.pipe(filter(({
      type
    }) => type === "drop")).subscribe((e) => {
      this.drop.next(this.eventArgs(e));
    }));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  eventArgs(e) {
    return {
      target: this,
      mouseEvent: e.mouseEvent,
      draggable: e.draggable
    };
  }
};
DropTargetDirective2.ɵfac = function DropTargetDirective_Factory2(t) {
  return new (t || DropTargetDirective2)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragAndDropService));
};
DropTargetDirective2.ɵdir = ɵɵdefineDirective({
  type: DropTargetDirective2,
  selectors: [["", "kendoDropTarget", ""]],
  inputs: {
    context: "context"
  },
  outputs: {
    enter: "enter",
    leave: "leave",
    drop: "drop"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DragAndDropService
    }];
  }, {
    context: [{
      type: Input
    }],
    enter: [{
      type: Output
    }],
    leave: [{
      type: Output
    }],
    drop: [{
      type: Output
    }]
  });
})();
var preventOnDblClick$1 = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var hasClass = (className) => (el) => new RegExp(`(^| )${className}( |$)`).test(el.className);
var isDeleteButton = or(hasClass("k-i-x"), hasClass("k-svg-i-x"), hasClass("k-icon-button"));
var isSortIcon = or(hasClass("k-i-sort-asc-small"), hasClass("k-i-sort-desc-small"), hasClass("k-svg-i-sort-asc-small"), hasClass("k-svg-i-sort-desc-small"));
var skipButtons = and(not(isDeleteButton), not(isSortIcon), not(isFocusableWithTabKey), not(matchesNodeName("label")));
var elementUnderCursor = ({
  clientX,
  clientY
}) => isDocumentAvailable() && document.elementFromPoint(clientX, clientY);
var hideThenShow = (element, cont) => {
  element.style.display = "none";
  const result = cont();
  element.style.display = "block";
  return result;
};
var DraggableColumnDirective = class {
  constructor(draggable, element, zone, service, hint, cue, nav, renderer) {
    this.draggable = draggable;
    this.element = element;
    this.zone = zone;
    this.service = service;
    this.hint = hint;
    this.cue = cue;
    this.nav = nav;
    this.renderer = renderer;
    this.context = {};
    this.drag = new EventEmitter();
    this.subscriptions = new Subscription();
  }
  set enableDrag(enabled) {
    this.enabled = enabled;
    this.updateTouchAction();
  }
  get hostClass() {
    return this.enabled;
  }
  ngOnInit() {
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(filter((_) => this.enabled), filter(({
      originalEvent: {
        target
      }
    }) => target === this.element.nativeElement || skipButtons(target)), tap((e) => {
      const originalEvent = e.originalEvent;
      if (!e.isTouch) {
        originalEvent.preventDefault();
      }
      this.nav.navigateTo(originalEvent.target);
    }), switchMap(preventOnDblClick$1(this.draggable.kendoRelease)), tap((_) => {
      this.hint.create(this.context.hint);
      this.cue.create();
    }), switchMap((down) => this.draggable.kendoDrag.pipe(tap((e) => {
      if (e.isTouch) {
        e.originalEvent.preventDefault();
      }
    }), tap(this.hint.attach()), tap(this.cue.attach()), takeUntil(this.draggable.kendoRelease), map((move) => ({
      move,
      down
    })))), tap(this.performDrag.bind(this)), switchMapTo(this.draggable.kendoRelease)).subscribe(this.drop.bind(this))));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  drop(upEvent) {
    this.hint.remove();
    this.cue.remove();
    this.service.notifyDrop(this, upEvent);
  }
  performDrag({
    move
  }) {
    this.hint.move(move);
    const cursorElement = this.elementUnderCursor(move);
    if (cursorElement) {
      this.service.notifyDrag(this, cursorElement, move);
    }
    this.drag.emit({
      draggable: this,
      mouseEvent: move
    });
  }
  elementUnderCursor(mouseEvent) {
    this.hint.hide();
    let target = elementUnderCursor(mouseEvent);
    if (target && /k-grouping-dropclue/.test(target.className)) {
      target = hideThenShow(target, elementUnderCursor.bind(this, mouseEvent));
    }
    this.hint.show();
    return target;
  }
  updateTouchAction() {
    if (!this.element) {
      return;
    }
    this.enabled ? this.renderer.addClass(this.element.nativeElement, "k-touch-action-none") : this.renderer.removeClass(this.element.nativeElement, "k-touch-action-none");
  }
};
DraggableColumnDirective.ɵfac = function DraggableColumnDirective_Factory(t) {
  return new (t || DraggableColumnDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragAndDropService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2));
};
DraggableColumnDirective.ɵdir = ɵɵdefineDirective({
  type: DraggableColumnDirective,
  selectors: [["", "kendoDraggableColumn", ""]],
  hostVars: 2,
  hostBindings: function DraggableColumnDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-grid-draggable-header", ctx.hostClass);
    }
  },
  inputs: {
    context: "context",
    enableDrag: "enableDrag"
  },
  outputs: {
    drag: "drag"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableColumnDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDraggableColumn]"
    }]
  }], function() {
    return [{
      type: DraggableDirective,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: DragAndDropService
    }, {
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }];
  }, {
    context: [{
      type: Input
    }],
    enableDrag: [{
      type: Input
    }],
    drag: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid-draggable-header"]
    }]
  });
})();
var withoutField = ({
  field
}) => isNullOrEmptyString2(field);
var alreadyGrouped = ({
  groups,
  field
}) => groups.some((group2) => group2.field === field);
var overSameTarget = ({
  target,
  field
}) => target.field === field;
var overLastTarget = ({
  target
}) => target.lastTarget;
var isLastGroup = ({
  groups,
  field
}) => groups.map((group2) => group2.field).indexOf(field) === groups.length - 1;
var isNotGroupable = (groupsService) => ({
  field
}) => !groupsService.isGroupable(field);
var columnRules = (groupService) => or(withoutField, alreadyGrouped, isNotGroupable(groupService));
var indicatorRules = or(overSameTarget, and(overLastTarget, isLastGroup));
var GroupPanelComponent = class {
  constructor(hint, cue, groupInfoService, ctx, cd, popupService, ngZone, renderer) {
    this.hint = hint;
    this.cue = cue;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
    this.cd = cd;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.change = new EventEmitter();
    this.groups = [];
    this.dropTargets = new QueryList();
    this.groupTitles = [];
    this.isChipMenuOpen = false;
    this.rtl = false;
    this.arrowLeftIcon = arrowLeftIcon;
    this.arrowRightIcon = arrowRightIcon;
    this.handleKeyDown = (e) => {
      if (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowUp) {
        e.preventDefault();
        const relatedItemType = e.target.matches(":first-child") ? "next" : "previous";
        this.activateMenuItem(e.target, relatedItemType);
      } else if (e.keyCode === Keys.Escape) {
        this.destroyMenu(true);
      } else if (e.keyCode === Keys.Tab) {
        this.destroyMenu(true);
      } else if (e.keyCode === Keys.Space || e.keyCode === Keys.Enter) {
        this.handleMenuClick(e);
      }
    };
    this.handleClick = (e) => {
      e.preventDefault();
      const menuItemEl = e.target.closest(".k-menu-item");
      if (!menuItemEl.matches('[aria-disabled="true"]')) {
        this.handleMenuClick(e);
        return;
      }
      if (menuItemEl.getAttribute("tabindex") === "0") {
        return;
      }
      const activeMenuItem = menuItemEl.closest(".k-menu-group").querySelector('[tabindex="0"]');
      const relatedItemType = activeMenuItem.matches(":first-child") ? "next" : "previous";
      this.activateMenuItem(activeMenuItem, relatedItemType);
    };
  }
  get groupHeaderClass() {
    return true;
  }
  set text(value2) {
    this.emptyText = value2;
  }
  get text() {
    return this.emptyText ? this.emptyText : this.ctx.localization.get("groupPanelEmpty");
  }
  get gridId() {
    return this.ctx.grid?.ariaRootId;
  }
  ngAfterViewInit() {
    this.subscription = this.ctx.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.cd.markForCheck();
    });
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    const currentTitles = this.groups.map((group2) => this.groupInfoService.groupTitle(group2));
    if (currentTitles.length !== this.groupTitles.length || currentTitles.some((current3, idx) => current3 !== this.groupTitles[idx])) {
      this.groupTitles = currentTitles;
      this.cd.markForCheck();
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.destroyMenu();
  }
  messageFor(token) {
    return this.ctx.localization.get(token);
  }
  getTitle(group2) {
    return this.messageFor(group2.dir === "desc" ? "sortedDescending" : "sortedAscending");
  }
  getDirectionIcon(group2) {
    return group2.dir === "desc" ? "sort-desc-sm" : "sort-asc-sm";
  }
  getDirectionSvgIcon(group2) {
    return group2.dir === "desc" ? sortDescSmallIcon : sortAscSmallIcon;
  }
  directionChange(group2) {
    group2.dir = group2.dir ? group2.dir : "asc";
    group2.dir = group2.dir === "asc" ? "desc" : "asc";
    const index = this.groups.findIndex((x) => x.field === group2.field);
    const groups = [...this.groups.slice(0, index), group2, ...this.groups.slice(index + 1)];
    this.change.emit(groups);
  }
  insert(field, index) {
    const groups = this.groups.filter((x) => x.field !== field);
    if (groups.length || this.groups.length === 0) {
      this.change.emit([...groups.slice(0, index), {
        field
      }, ...groups.slice(index)]);
    }
  }
  remove(group2) {
    this.change.emit(this.groups.filter((x) => x.field !== group2.field));
  }
  toggleMenu(chip, first, last, field) {
    const anchor2 = chip.element.nativeElement.querySelector(".k-chip-action");
    if (this.popupRef) {
      const popupAnchor = this.popupRef.popup.instance.anchor;
      this.destroyMenu();
      if (anchor2 === popupAnchor) {
        return;
      }
    }
    this.first = first;
    this.last = last;
    const direction = this.ctx.localization.rtl ? "right" : "left";
    this.popupRef = this.popupService.open({
      anchor: anchor2,
      content: this.defaultTemplate,
      anchorAlign: {
        vertical: "bottom",
        horizontal: direction
      },
      popupAlign: {
        vertical: "top",
        horizontal: direction
      },
      positionMode: "absolute"
    });
    this.activeItem = this.dropTargets.find((dt) => dt.context.field === field);
    this.renderer.setAttribute(this.popupRef.popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
    const menuItems = Array.from(this.popupRef.popupElement.querySelectorAll(".k-menu-item"));
    this.activateMenuItem(menuItems[1], "previous");
    this.popupSubs = this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.destroyMenu(true);
    });
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.popupSubs.add(fromEvent(document, "click").pipe(filter((event2) => !closest2(event2.target, (node) => node === this.popupRef.popupElement || node.matches && node.matches(".k-chip-action")))).subscribe(() => {
        this.destroyMenu();
      }));
    });
  }
  canDrop(draggable, target) {
    const isIndicator = draggable.type === "groupIndicator";
    const rules2 = isIndicator ? indicatorRules : columnRules(this.groupInfoService);
    return !rules2({
      field: draggable.field,
      groups: this.groups,
      target
    });
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = this.dropTargets.reduce((acc, target) => merge(acc, target.enter), from([]));
    const leaveStream = this.dropTargets.reduce((acc, target) => merge(acc, target.leave), from([]));
    const dropStream = this.dropTargets.reduce((acc, target) => merge(acc, target.drop), from([]));
    this.targetSubscription.add(enterStream.pipe(tap((_) => {
      this.hint.removeLock();
      this.destroyMenu();
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable.context, target.context)), tap(this.enter.bind(this)), switchMapTo(dropStream.pipe(takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  enter({
    draggable,
    target
  }) {
    this.hint.enable();
    let before = target.context.lastTarget || isTargetBefore(draggable.element.nativeElement, target.element.nativeElement);
    if (this.ctx.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    target,
    draggable
  }) {
    const field = draggable.context.field;
    const index = this.dropTargets.toArray().indexOf(target);
    this.insert(field, index);
  }
  destroyMenu(focusAnchor) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.popupSubs && this.popupSubs.unsubscribe();
      focusAnchor && this.activeItem.context.target.focus();
    }
  }
  activateMenuItem(item, relatedItemType) {
    this.renderer.setAttribute(item, "tabindex", "-1");
    this.renderer.removeClass(item, "k-focus");
    const relatedItem = item[`${relatedItemType}ElementSibling`];
    this.renderer.setAttribute(relatedItem, "tabindex", "0");
    this.renderer.addClass(relatedItem, "k-focus");
    this.ngZone.runOutsideAngular(() => setTimeout(() => relatedItem.focus()));
  }
  handleMenuClick(e) {
    e.preventDefault();
    if (e.target.getAttribute("aria-disabled") !== "true") {
      const chips = this.dropTargets.toArray().slice(0, this.dropTargets.length - 1);
      let groupChip, groupChipIndex;
      for (let i = 0; i < chips.length; i++) {
        if (chips[i].element.nativeElement === this.popupRef.popup.instance.anchor.closest(".k-chip")) {
          groupChip = chips[i];
          groupChipIndex = i;
          break;
        }
      }
      const isPrev = e.target.closest(".k-menu-item").matches(":first-child");
      if (isPrev && groupChipIndex > 0) {
        this.insert(groupChip.context.field, groupChipIndex - 1);
      } else if (!isPrev && groupChipIndex < chips.length - 1) {
        this.insert(groupChip.context.field, groupChipIndex + 1);
      }
      this.destroyMenu(true);
    }
  }
};
GroupPanelComponent.ɵfac = function GroupPanelComponent_Factory(t) {
  return new (t || GroupPanelComponent)(ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
};
GroupPanelComponent.ɵcmp = ɵɵdefineComponent({
  type: GroupPanelComponent,
  selectors: [["kendo-grid-group-panel"]],
  viewQuery: function GroupPanelComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c03, 7, TemplateRef);
      ɵɵviewQuery(DropTargetDirective2, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
    }
  },
  hostVars: 2,
  hostBindings: function GroupPanelComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-grouping-header", ctx.groupHeaderClass);
    }
  },
  inputs: {
    text: "text",
    navigable: "navigable",
    groups: "groups"
  },
  outputs: {
    change: "change"
  },
  decls: 5,
  vars: 3,
  consts: [["defaultTemplate", ""], ["chip", ""], ["class", "k-grouping-drop-container", "kendoDropTarget", "", 3, "context", 4, "ngIf"], ["role", "none", 3, "navigable", 4, "ngIf"], ["kendoDropTarget", "", 1, "k-grouping-drop-container", 3, "context"], ["role", "none", 3, "navigable"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon", "contentClick", "remove", "menuToggle", "keydown.alt.arrowdown", 4, "ngFor", "ngForOf"], ["kendoDropTarget", "", "kendoDraggableColumn", "", "kendoDraggable", "", 3, "contentClick", "remove", "menuToggle", "keydown.alt.arrowdown", "title", "enableDrag", "context", "label", "removable", "hasMenu", "icon", "svgIcon"], ["unselectable", "on", "role", "menu", 1, "k-group", "k-menu-group", "k-reset", "k-menu-group-md", 3, "kendoEventsOutsideAngular"], ["role", "menuitem", "unselectable", "on", 1, "k-item", "k-menu-item"], [1, "k-link", "k-menu-link"], [3, "name", "svgIcon"], [1, "k-menu-link-text"]],
  template: function GroupPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, GroupPanelComponent_div_0_Template, 2, 3, "div", 2)(1, GroupPanelComponent_kendo_chiplist_1_Template, 2, 2, "kendo-chiplist", 3)(2, GroupPanelComponent_div_2_Template, 2, 2, "div", 2)(3, GroupPanelComponent_ng_template_3_Template, 11, 16, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.groups.length === 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.groups.length !== 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.groups.length !== 0);
    }
  },
  dependencies: [NgForOf, NgIf, DraggableDirective, EventsOutsideAngularDirective, IconWrapperComponent, DraggableColumnDirective, DropTargetDirective2, ChipComponent, ChipListComponent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupPanelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-grid-group-panel",
      template: `
        <div
            *ngIf="groups.length === 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >
            {{ text }}
        </div>

        <kendo-chiplist
            *ngIf="groups.length !== 0"
            [navigable]="navigable"
            role="none">
            <kendo-chip
                *ngFor="let group of groups; let index = index; let first = first; let last = last;"
                #chip
                kendoDropTarget
                kendoDraggableColumn
                kendoDraggable
                [title]="getTitle(group)"
                [enableDrag]="true"
                [context]="{
                    field: group.field,
                    type: 'groupIndicator',
                    hint:  groupTitles[index],
                    target: chip
                }"
                [label]="groupTitles[index]"
                [removable]="true"
                [hasMenu]="true"
                [icon]="getDirectionIcon(group)"
                [svgIcon]="getDirectionSvgIcon(group)"
                [attr.aria-haspopup]="'menu'"
                [attr.aria-expanded]="isChipMenuOpen"
                [attr.aria-controls]="gridId"
                (contentClick)="directionChange(group)"
                (remove)="remove(group)"
                (menuToggle)="toggleMenu(chip, first, last, group.field)"
                (keydown.alt.arrowdown)="$event.preventDefault(); toggleMenu(chip, first, last, group.field)"
            >
            </kendo-chip>
        </kendo-chiplist>

        <div
            *ngIf="groups.length !== 0"
            class="k-grouping-drop-container"
            [context]="{
                lastTarget: true
            }"
            kendoDropTarget
        >&nbsp;</div>

        <ng-template #defaultTemplate>
            <ul unselectable="on" role="menu" class="k-group k-menu-group k-reset k-menu-group-md" [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                click: handleClick
            }">
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="first">
                    <span class="k-link k-menu-link" [class.k-disabled]="first">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-right' : 'arrow-left'"
                            [svgIcon]="rtl ? arrowRightIcon : arrowLeftIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuPrevious')}}</span>
                    </span>
                </li>
                <li role="menuitem" unselectable="on" class="k-item k-menu-item" [attr.aria-disabled]="last">
                    <span class="k-link k-menu-link" [class.k-disabled]="last">
                        <kendo-icon-wrapper
                            [name]="rtl ? 'arrow-left' : 'arrow-right'"
                            [svgIcon]="rtl ? arrowLeftIcon : arrowRightIcon"></kendo-icon-wrapper>
                        <span class="k-menu-link-text">{{messageFor('groupChipMenuNext')}}</span>
                    </span>
                </li>
            </ul>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: GroupInfoService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PopupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    change: [{
      type: Output
    }],
    groupHeaderClass: [{
      type: HostBinding,
      args: ["class.k-grouping-header"]
    }],
    text: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective2]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }]
  });
})();
var ColGroupComponent = class {
  constructor() {
    this.columns = [];
    this.groups = [];
    this.sort = new Array();
  }
  get columnsToRender() {
    return columnsToRender(this.columns);
  }
  trackBy(index, _item) {
    return index;
  }
  isSorted(column) {
    const state2 = this.sortDescriptor(column.field);
    return this.isSortable(column) && (state2.dir === "asc" || state2.dir === "desc");
  }
  getColumnComponent(column) {
    return column;
  }
  isSortable(column) {
    return !isNullOrEmptyString2(column.field) && isTruthy(column.sortable);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
};
ColGroupComponent.ɵfac = function ColGroupComponent_Factory(t) {
  return new (t || ColGroupComponent)();
};
ColGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: ColGroupComponent,
  selectors: [["", "kendoGridColGroup", ""]],
  inputs: {
    columns: "columns",
    groups: "groups",
    detailTemplate: "detailTemplate",
    sort: "sort"
  },
  attrs: _c4,
  decls: 4,
  vars: 4,
  consts: [[3, "k-group-col", 4, "ngFor", "ngForOf"], [3, "k-hierarchy-col", 4, "ngIf"], [3, "width", "k-sorted", 4, "ngFor", "ngForOf", "ngForTrackBy"]],
  template: function ColGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0);
      ɵɵtemplate(1, ColGroupComponent_col_1_Template, 1, 2, "col", 0)(2, ColGroupComponent_col_2_Template, 1, 2, "col", 1)(3, ColGroupComponent_col_3_Template, 1, 4, "col", 2);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.groups);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.columnsToRender)("ngForTrackBy", ctx.trackBy);
    }
  },
  dependencies: [NgForOf, NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColGroupComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridColGroup]",
      template: `
    <ng-container>
        <col [class.k-group-col]="true" *ngFor="let g of groups" />
        <col [class.k-hierarchy-col]="true" *ngIf="detailTemplate?.templateRef"/>
        <col *ngFor="let column of columnsToRender; trackBy: trackBy;"
        [style.width.px]="column.width"
        [class.k-sorted]="isSorted(getColumnComponent(column))"/>
    </ng-container>
    `
    }]
  }], null, {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }]
  });
})();
var ResizableContainerDirective = class {
  constructor(el, renderer, resizeService, ctx) {
    this.el = el;
    this.renderer = renderer;
    this.resizeService = resizeService;
    this.ctx = ctx;
    this.enabled = false;
  }
  set lockedWidth(value2) {
    this._lockedWidth = value2;
    if (this.enabled) {
      this.attachResize();
      this.resize();
    }
  }
  set kendoGridResizableContainer(enabled) {
    const refresh = enabled !== this.enabled;
    this.enabled = enabled;
    if (refresh) {
      this.attachResize();
      this.resize();
    }
  }
  ngOnDestroy() {
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  attachResize() {
    if (this.resizeSubscription && !this.enabled) {
      this.resizeSubscription.unsubscribe();
      this.resizeSubscription = null;
    }
    if (!this.resizeSubscription && this.enabled) {
      this.resizeSubscription = this.resizeService.changes.subscribe(this.resize.bind(this));
    }
  }
  resize() {
    if (this.ctx.grid && this.ctx.grid.wrapper) {
      const containerElement = this.ctx.grid.wrapper.nativeElement;
      const width = Math.max(containerElement.clientWidth - this._lockedWidth, 0);
      if (this.enabled && width > 0) {
        this.renderer.setStyle(this.el.nativeElement, "width", width + "px");
      } else {
        this.renderer.setStyle(this.el.nativeElement, "width", "");
      }
    }
  }
};
ResizableContainerDirective.ɵfac = function ResizableContainerDirective_Factory(t) {
  return new (t || ResizableContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(ContextService));
};
ResizableContainerDirective.ɵdir = ɵɵdefineDirective({
  type: ResizableContainerDirective,
  selectors: [["", "kendoGridResizableContainer", ""]],
  inputs: {
    lockedWidth: "lockedWidth",
    kendoGridResizableContainer: "kendoGridResizableContainer"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResizableContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridResizableContainer]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ResizeService
    }, {
      type: ContextService
    }];
  }, {
    lockedWidth: [{
      type: Input,
      args: ["lockedWidth"]
    }],
    kendoGridResizableContainer: [{
      type: Input
    }]
  });
})();
var columnsToResize = ({
  columns
}) => Math.max(1, resizableColumns(columns).length);
var row = (selector) => (element) => element.querySelector(selector);
var headerRow = (index) => (element) => element.querySelectorAll("thead>tr")[index];
var cell = (index, selector = "td") => (element) => element.querySelectorAll(`${selector}:not(.k-group-cell):not(.k-hierarchy-cell)`)[index];
var offsetWidth = (element) => element.offsetWidth;
var pipe2 = (...fns) => (data) => fns.reduce((state2, fn) => state2 ? fn(state2) : 0, data);
var TableDirective = class {
  constructor(element, renderer, service, zone, cdr) {
    this.element = element;
    this.renderer = renderer;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.locked = false;
    this.firstResize = false;
  }
  get minWidth() {
    return this.firstResize ? 0 : null;
  }
  ngOnInit() {
    const obs = this.service.changes.pipe(filter((e) => this.locked === e.locked));
    this.subscription = obs.pipe(filter((e) => e.type === "start"), tap(this.initState.bind(this)), map(columnsToResize), switchMap((take4) => obs.pipe(filter((e) => e.type === "resizeTable"), map((e) => e.delta), bufferCount(take4)))).subscribe(this.resize.bind(this));
    this.autoFitSubscription = this.service.registerTable({
      autoFit: this.autoFitObservable.bind(this),
      locked: this.locked
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    if (this.autoFitSubscription) {
      this.autoFitSubscription();
      this.autoFitSubscription = null;
    }
  }
  initState() {
    this.firstResize = true;
    if (!this.virtualColumns || this.locked) {
      this.originalWidth = offsetWidth(this.element.nativeElement);
    }
  }
  resize(deltas) {
    if (!this.virtualColumns || this.locked) {
      const delta = deltas.reduce((sum, item) => sum + item, 0);
      const width = this.originalWidth + delta;
      this.renderer.setStyle(this.element.nativeElement, "width", width + "px");
    }
    this.cdr.detectChanges();
  }
  autoFitObservable(columnInfo) {
    return Observable.create((observer) => {
      this.zone.runOutsideAngular(() => {
        this.renderer.addClass(this.element.nativeElement, "k-autofitting");
        this.cdr.detectChanges();
        const widths = columnInfo.map(this.measureColumn.bind(this));
        this.renderer.removeClass(this.element.nativeElement, "k-autofitting");
        observer.next(widths);
      });
    });
  }
  measureColumn(info) {
    const dom = this.element.nativeElement;
    const header = pipe2(headerRow(info.level), cell(info.headerIndex, "th"), offsetWidth)(dom);
    let data = 0;
    if (!info.isParentSpan || info.isParentSpan && info.isLastInSpan) {
      data = pipe2(row("tbody>tr:not(.k-grouping-row):not(.k-grid-norecords)"), cell(info.index), offsetWidth)(dom);
    }
    const footer = pipe2(row("tfoot>tr"), cell(info.index), offsetWidth)(dom);
    return Math.max(header, data, footer);
  }
};
TableDirective.ɵfac = function TableDirective_Factory(t) {
  return new (t || TableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
};
TableDirective.ɵdir = ɵɵdefineDirective({
  type: TableDirective,
  selectors: [["table"]],
  hostVars: 2,
  hostBindings: function TableDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("min-width", ctx.minWidth);
    }
  },
  inputs: {
    locked: "locked",
    virtualColumns: "virtualColumns"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "table"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ColumnResizingService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    locked: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    minWidth: [{
      type: HostBinding,
      args: ["style.min-width"]
    }]
  });
})();
var LoadingComponent = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.hostClass = true;
  }
  get loadingText() {
    return this.ctx.localization.get("loading");
  }
};
LoadingComponent.ɵfac = function LoadingComponent_Factory(t) {
  return new (t || LoadingComponent)(ɵɵdirectiveInject(ContextService));
};
LoadingComponent.ɵcmp = ɵɵdefineComponent({
  type: LoadingComponent,
  selectors: [["", "kendoGridLoading", ""]],
  hostVars: 2,
  hostBindings: function LoadingComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-loading-mask", ctx.hostClass);
    }
  },
  inputs: {
    loadingTemplate: "loadingTemplate"
  },
  attrs: _c5,
  decls: 2,
  vars: 2,
  consts: [[4, "ngIf"], [1, "k-loading-text"], [1, "k-loading-image"], [1, "k-loading-color"], [3, "ngTemplateOutlet"]],
  template: function LoadingComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, LoadingComponent_ng_container_0_Template, 5, 1, "ng-container", 0)(1, LoadingComponent_1_Template, 1, 1, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.loadingTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.loadingTemplate);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridLoading]",
      template: `
        <ng-container *ngIf="!loadingTemplate">
            <span class="k-loading-text">{{ loadingText }}</span>
            <div class="k-loading-image"></div>
            <div class="k-loading-color"></div>
        </ng-container>
        <ng-template *ngIf="loadingTemplate" [ngTemplateOutlet]="loadingTemplate?.templateRef">
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-loading-mask"]
    }],
    loadingTemplate: [{
      type: Input
    }]
  });
})();
var GridTableDirective = class {
  constructor(wrapper) {
    this.wrapper = wrapper;
    this.hostClass = true;
    this._size = "medium";
  }
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-table-sm", "k-table-md");
    }
  }
  get size() {
    return this._size;
  }
};
GridTableDirective.ɵfac = function GridTableDirective_Factory(t) {
  return new (t || GridTableDirective)(ɵɵdirectiveInject(ElementRef));
};
GridTableDirective.ɵdir = ɵɵdefineDirective({
  type: GridTableDirective,
  selectors: [["", "kendoGridTable", ""]],
  hostVars: 6,
  hostBindings: function GridTableDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-table", ctx.hostClass)("k-table-sm", ctx.sizeSmallClass)("k-table-md", ctx.sizeMediumClass);
    }
  },
  inputs: {
    size: "size"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridTableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTable]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-table-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-table-md"]
    }],
    size: [{
      type: Input
    }]
  });
})();
var NON_DATA_CELL_CLASSES = "k-hierarchy-cell k-detail-cell k-group-cell";
var NON_DATA_ROW_CLASSES = "k-grouping-row k-group-footer k-detail-row k-grid-norecords";
var IGNORE_TARGET_CLASSSES = "k-icon k-svg-icon";
var IGNORE_CONTAINER_CLASSES = "k-grid k-grid-ignore-click";
var FocusGroup = class {
  constructor(root) {
    this.root = root;
    this.active = true;
    this.children = [];
    this.root.registerGroup(this);
  }
  get focusableChildren() {
    return this.children.filter((el) => el.canFocus());
  }
  get isActive() {
    return this.active;
  }
  ngOnDestroy() {
    this.root.unregisterGroup(this);
    this.active = true;
  }
  registerElement(element) {
    this.unregisterElement(element);
    this.children.push(element);
  }
  unregisterElement(element) {
    this.children = this.children.filter((f) => f !== element);
  }
  /**
   * Returns a Boolean value which indicates if the group will receive focus when the cell is focused.
   * Requires a single "simple" focusable element such as a button or a checkbox.
   */
  isNavigable() {
    const focusable = this.focusableChildren;
    return focusable.length === 1 && focusable[0].isNavigable();
  }
  canFocus() {
    return this.focusableChildren.length > 0;
  }
  focus() {
    if (this.canFocus() && !this.hasFocus()) {
      this.focusableChildren[0].focus();
    }
  }
  activate() {
    this.toggleState(true);
  }
  deactivate() {
    this.toggleState(false);
  }
  hasFocus() {
    return this.children.reduce((focused, element) => focused || element.hasFocus(), false);
  }
  toggleState(active) {
    if (this.active !== active) {
      this.active = active;
      this.children.forEach((f) => f.toggle(active));
    }
  }
};
FocusGroup.ɵfac = function FocusGroup_Factory(t) {
  return new (t || FocusGroup)(ɵɵinject(FocusRoot));
};
FocusGroup.ɵprov = ɵɵdefineInjectable({
  token: FocusGroup,
  factory: FocusGroup.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusGroup, [{
    type: Injectable
  }], function() {
    return [{
      type: FocusRoot
    }];
  }, null);
})();
var id$3 = 0;
function nextId$1() {
  return id$3++;
}
var LogicalCellDirective = class {
  constructor(focusGroup, element, columnInfoService, idService, navigationService, renderer, zone, cellContext) {
    this.focusGroup = focusGroup;
    this.element = element;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.zone = zone;
    this.cellContext = cellContext;
    this.logicalSlaveCell = false;
    this.colSpan = 1;
    this.rowSpan = 1;
    this.dataRowIndex = -1;
    this.detailExpandCell = false;
    this.uid = nextId$1();
  }
  get id() {
    if (!this.logicalSlaveCell && this.columnInfoService.isLocked) {
      return this.idService.cellId(this.logicalRowIndex, this.logicalColIndex);
    }
  }
  get ariaColIndex() {
    if (this.logicalSlaveCell || this.logicalColIndex === -1) {
      return void 0;
    }
    return this.logicalColIndex + 1;
  }
  ngOnInit() {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    this.navigationChange = this.navigationService.changes.subscribe((e) => this.onNavigationChange(e));
  }
  ngDoCheck() {
    if (!this.navigationService.tableEnabled || this.logicalColIndex === -1) {
      return;
    }
    if (this.cellContext) {
      this.cellContext.focusGroup = this.focusGroup;
    }
    this.registerNoChanges();
  }
  ngOnChanges(changes) {
    if (!this.navigationService.tableEnabled) {
      return;
    }
    const keys = Object.keys(changes);
    if (keys.length === 1 && keys[0] === "groupItem" || this.logicalColIndex === -1) {
      return;
    }
    const indexChange = changes["logicalColIndex"];
    const rowIndexChange = changes["logicalRowIndex"];
    const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalColIndex;
    const rowIndex = rowIndexChange && !rowIndexChange.isFirstChange() ? rowIndexChange.previousValue : this.logicalRowIndex;
    this.navigationService.unregisterCell(index, rowIndex, this);
    this.registerChanges();
    this.updateElement();
  }
  ngOnDestroy() {
    if (this.navigationChange) {
      this.navigationChange.unsubscribe();
    }
    this.navigationService.unregisterCell(this.logicalColIndex, this.logicalRowIndex, this);
  }
  onNavigationChange(e) {
    const active = this.logicalColIndex === e.colIndex && this.logicalRowIndex === e.rowIndex;
    const wasActive = this.logicalColIndex === e.prevColIndex && this.logicalRowIndex === e.prevRowIndex;
    if (active || wasActive) {
      this.updateElement();
    }
  }
  updateElement() {
    const el = this.element.nativeElement;
    this.renderer.setAttribute(el, "tabIndex", this.isFocusable() && !this.logicalSlaveCell ? "0" : "-1");
    if (this.isFocused()) {
      if (this.focusGroup.isNavigable()) {
        this.focusGroup.focus();
      } else {
        if (!this.logicalSlaveCell && this.navigationService.autoFocusCell(this.logicalColIndex, this.logicalColIndex + this.colSpan - 1)) {
          this.microtask(() => this.isFocused() && el.focus());
        }
        this.renderer.addClass(el, "k-focus");
      }
      if (this.headerLabelText) {
        el.removeAttribute("aria-label");
      }
    } else {
      this.renderer.removeClass(el, "k-focus");
      if (this.headerLabelText) {
        el.setAttribute("aria-label", this.headerLabelText);
      }
    }
  }
  microtask(callback) {
    this.zone.runOutsideAngular(() => Promise.resolve(null).then(callback));
  }
  registerChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCell(this);
    }
  }
  registerNoChanges() {
    if (!this.logicalSlaveCell) {
      this.navigationService.registerCellOnCurrentRow(this);
    }
  }
  isFocusable() {
    return this.navigationService.isCellFocusable(this);
  }
  isFocused() {
    return this.navigationService.isCellFocused(this);
  }
};
LogicalCellDirective.ɵfac = function LogicalCellDirective_Factory(t) {
  return new (t || LogicalCellDirective)(ɵɵdirectiveInject(FocusGroup), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CELL_CONTEXT, 8));
};
LogicalCellDirective.ɵdir = ɵɵdefineDirective({
  type: LogicalCellDirective,
  selectors: [["", "kendoGridLogicalCell", ""]],
  hostVars: 2,
  hostBindings: function LogicalCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id)("aria-colindex", ctx.ariaColIndex);
    }
  },
  inputs: {
    logicalColIndex: "logicalColIndex",
    logicalRowIndex: "logicalRowIndex",
    logicalSlaveCell: "logicalSlaveCell",
    colIndex: "colIndex",
    colSpan: "colSpan",
    rowSpan: "rowSpan",
    groupItem: "groupItem",
    dataRowIndex: "dataRowIndex",
    dataItem: "dataItem",
    detailExpandCell: "detailExpandCell",
    headerLabelText: "headerLabelText"
  },
  features: [ɵɵProvidersFeature([{
    provide: FocusGroup,
    deps: [FocusRoot],
    useClass: FocusGroup
  }]), ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalCellDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: FocusGroup,
        deps: [FocusRoot],
        useClass: FocusGroup
      }],
      selector: "[kendoGridLogicalCell]"
    }]
  }], function() {
    return [{
      type: FocusGroup
    }, {
      type: ElementRef
    }, {
      type: ColumnInfoService
    }, {
      type: IdService
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }];
  }, {
    logicalColIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveCell: [{
      type: Input
    }],
    colIndex: [{
      type: Input
    }],
    colSpan: [{
      type: Input
    }],
    rowSpan: [{
      type: Input
    }],
    groupItem: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    detailExpandCell: [{
      type: Input
    }],
    headerLabelText: [{
      type: Input
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaColIndex: [{
      type: HostBinding,
      args: ["attr.aria-colindex"]
    }]
  });
})();
var id$2 = 0;
function nextId() {
  return id$2++;
}
var LogicalRowDirective = class {
  constructor(idService, navigation) {
    this.idService = idService;
    this.navigation = navigation;
    this.logicalSlaveRow = false;
    this.logicalSlaveCellsCount = 0;
    this.dataRowIndex = -1;
    this.uid = nextId();
    this.tableRowClass = true;
  }
  get hostRole() {
    return this.logicalSlaveRow ? "presentation" : "row";
  }
  get ariaRowIndex() {
    return this.logicalSlaveRow ? null : this.logicalRowIndex + 1;
  }
  get rowIndex() {
    return this.logicalSlaveRow ? this.logicalRowIndex + 1 : null;
  }
  get ariaOwns() {
    if (this.logicalSlaveRow || this.logicalSlaveCellsCount === 0) {
      return void 0;
    }
    const ids = [];
    if (this.dataRowIndex < 0) {
      let total = this.logicalCellsCount + this.logicalSlaveCellsCount;
      this.columnsArray.forEach((column) => {
        if (column.isSpanColumn) {
          total += column.colspan - 1;
        }
      });
      for (let cellIndex = this.logicalCellsCount; cellIndex < total; cellIndex++) {
        ids.push(this.idService.cellId(this.logicalRowIndex, cellIndex));
      }
    } else {
      let columnIndex = 0;
      this.columnsArray.forEach((column) => {
        if (!column.isLocked) {
          ids.push(this.idService.cellId(this.logicalRowIndex, columnIndex));
        }
        columnIndex += column.isSpanColumn ? column.colspan : 1;
      });
    }
    return ids.join(" ");
  }
  ngOnChanges(changes) {
    if (!this.navigation.enabled || this.logicalSlaveRow) {
      return;
    }
    const indexChange = changes.logicalRowIndex;
    const logicalSlaveRowChange = changes.logicalSlaveRow;
    if (indexChange || logicalSlaveRowChange) {
      const index = indexChange && !indexChange.isFirstChange() ? indexChange.previousValue : this.logicalRowIndex;
      this.navigation.unregisterRow(index, this);
      this.navigation.registerRow(this);
    } else if (anyChanged(["dataRowIndex", "dataItem"], changes)) {
      this.navigation.updateRow(this);
    }
  }
  ngOnDestroy() {
    this.navigation.unregisterRow(this.logicalRowIndex, this);
  }
  get columnsArray() {
    return this.totalColumns?.allColumns.toArray() || [];
  }
};
LogicalRowDirective.ɵfac = function LogicalRowDirective_Factory(t) {
  return new (t || LogicalRowDirective)(ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(NavigationService));
};
LogicalRowDirective.ɵdir = ɵɵdefineDirective({
  type: LogicalRowDirective,
  selectors: [["", "kendoGridLogicalRow", ""]],
  hostVars: 6,
  hostBindings: function LogicalRowDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.hostRole)("aria-rowindex", ctx.ariaRowIndex)("data-kendo-grid-row-index", ctx.rowIndex)("aria-owns", ctx.ariaOwns);
      ɵɵclassProp("k-table-row", ctx.tableRowClass);
    }
  },
  inputs: {
    logicalRowIndex: "logicalRowIndex",
    logicalSlaveRow: "logicalSlaveRow",
    logicalCellsCount: "logicalCellsCount",
    logicalSlaveCellsCount: "logicalSlaveCellsCount",
    dataRowIndex: "dataRowIndex",
    dataItem: "dataItem",
    totalColumns: "totalColumns"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogicalRowDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridLogicalRow]"
    }]
  }], function() {
    return [{
      type: IdService
    }, {
      type: NavigationService
    }];
  }, {
    logicalRowIndex: [{
      type: Input
    }],
    logicalSlaveRow: [{
      type: Input
    }],
    logicalCellsCount: [{
      type: Input
    }],
    logicalSlaveCellsCount: [{
      type: Input
    }],
    dataRowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaRowIndex: [{
      type: HostBinding,
      args: ["attr.aria-rowindex"]
    }],
    rowIndex: [{
      type: HostBinding,
      args: ["attr.data-kendo-grid-row-index"]
    }],
    tableRowClass: [{
      type: HostBinding,
      args: ["class.k-table-row"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }]
  });
})();
var TemplateContextDirective = class {
  constructor(viewContainerRef) {
    this.viewContainerRef = viewContainerRef;
  }
  set templateContext(context) {
    this.removeView();
    if (context.templateRef) {
      this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);
    }
  }
  ngOnDestroy() {
    this.removeView();
  }
  removeView() {
    if (this.insertedViewRef) {
      this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));
      this.insertedViewRef = void 0;
    }
  }
};
TemplateContextDirective.ɵfac = function TemplateContextDirective_Factory(t) {
  return new (t || TemplateContextDirective)(ɵɵdirectiveInject(ViewContainerRef));
};
TemplateContextDirective.ɵdir = ɵɵdefineDirective({
  type: TemplateContextDirective,
  selectors: [["", "templateContext", ""]],
  inputs: {
    templateContext: "templateContext"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateContextDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "[templateContext]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    templateContext: [{
      type: Input
    }]
  });
})();
var FORMAT_REGEX = /\{\d+:?/;
var FieldAccessorPipe = class {
  constructor(intlService) {
    this.intlService = intlService;
  }
  transform(dataItem, fieldName, format) {
    if (!isNullOrEmptyString2(fieldName)) {
      const value2 = getter(fieldName)(dataItem);
      if (!isNullOrEmptyString2(format)) {
        return this.formatValue(format, value2);
      }
      return value2;
    }
    return dataItem;
  }
  formatValue(format, value2) {
    const intl = this.intlService;
    if (isString2(format) && format.match(FORMAT_REGEX)) {
      return intl.format(format, value2);
    }
    return intl.toString(value2, format);
  }
};
FieldAccessorPipe.ɵfac = function FieldAccessorPipe_Factory(t) {
  return new (t || FieldAccessorPipe)(ɵɵdirectiveInject(IntlService, 16));
};
FieldAccessorPipe.ɵpipe = ɵɵdefinePipe({
  name: "valueOf",
  type: FieldAccessorPipe,
  pure: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FieldAccessorPipe, [{
    type: Pipe,
    args: [{
      // eslint-disable-next-line @angular-eslint/pipe-prefix
      name: "valueOf",
      pure: false
    }]
  }], function() {
    return [{
      type: IntlService
    }];
  }, null);
})();
var GroupHeaderComponent = class {
  constructor(groupsService, groupInfoService, ctx) {
    this.groupsService = groupsService;
    this.groupInfoService = groupInfoService;
    this.ctx = ctx;
    this.skipGroupDecoration = false;
    this.hasDetails = false;
    this.totalColumnsCount = 0;
    this.groups = [];
    this.groupItemClass = true;
    this.tableGroupRowClass = true;
    this.isExpanded = false;
    this.caretAltDownIcon = caretAltDownIcon;
    this.caretAltRightIcon = caretAltRightIcon;
    this.caretAltLeftIcon = caretAltLeftIcon;
  }
  ngDoCheck() {
    const groupArgs = {
      group: this.item.data,
      groupIndex: this.item.index,
      parentGroup: getGroupRowArgs(this.item.parentGroup)
    };
    this.isExpanded = this.groupsService.isExpanded(groupArgs);
  }
  prefixGroupCell(item) {
    return new Array(item.level);
  }
  toggleGroup(item) {
    this.groupsService.toggleRow(item);
    return false;
  }
  groupSpan(item) {
    const groupCount = (this.groups || []).length;
    const detailOffset = this.hasDetails ? 1 : 0;
    if (this.hasGroupHeaderColumn) {
      return groupCount + 1 + detailOffset - item.level;
    }
    const columnCount = columnsSpan(this.columns);
    if (this.skipGroupDecoration) {
      return columnCount;
    }
    return groupCount + columnCount + detailOffset - item.level;
  }
  logicalColSpan() {
    return this.skipGroupDecoration ? 1 : this.totalColumnsCount;
  }
  ariaRole() {
    if (this.skipGroupDecoration) {
      return "presentation";
    }
    return "gridcell";
  }
  formatForGroup(item) {
    return this.groupInfoService.formatForGroup(item);
  }
  groupTitle(item) {
    return this.groupInfoService.groupTitle(item);
  }
  groupHeaderTemplate(item) {
    return this.groupInfoService.groupHeaderTemplate(item);
  }
  get groupButtonTitle() {
    const messageKey = this.isExpanded ? "groupCollapse" : "groupExpand";
    return this.ctx.localization.get(messageKey);
  }
  get arrowIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? "caret-alt-right" : "caret-alt-left" : "caret-alt-down";
    return icon;
  }
  get arrowSVGIcon() {
    const icon = !this.isExpanded ? !this.ctx.localization.rtl ? this.caretAltRightIcon : this.caretAltLeftIcon : this.caretAltDownIcon;
    return icon;
  }
};
GroupHeaderComponent.ɵfac = function GroupHeaderComponent_Factory(t) {
  return new (t || GroupHeaderComponent)(ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(ContextService));
};
GroupHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: GroupHeaderComponent,
  selectors: [["", "kendoGridGroupHeader", ""]],
  hostVars: 4,
  hostBindings: function GroupHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-grouping-row", ctx.groupItemClass)("k-table-group-row", ctx.tableGroupRowClass);
    }
  },
  inputs: {
    rowIndex: "rowIndex",
    logicalRowIndex: "logicalRowIndex",
    item: "item",
    skipGroupDecoration: "skipGroupDecoration",
    hasDetails: "hasDetails",
    totalColumnsCount: "totalColumnsCount",
    hasGroupHeaderColumn: "hasGroupHeaderColumn",
    groupHeaderColumns: "groupHeaderColumns",
    columns: "columns",
    groups: "groups"
  },
  attrs: _c6,
  decls: 3,
  vars: 3,
  consts: [[4, "ngIf"], ["aria-selected", "false", "class", "k-table-td", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngIf"], ["class", "k-group-cell k-table-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell", "k-table-td"], ["aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [1, "k-reset"], ["href", "#", "tabindex", "-1", "role", "presentation", 3, "click"], [3, "name", "svgIcon"], [3, "templateContext"], ["role", "gridcell", "class", "k-table-td", "aria-selected", "false", "kendoGridLogicalCell", "", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan", 4, "ngFor", "ngForOf"], ["role", "gridcell", "aria-selected", "false", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "logicalSlaveCell", "groupItem", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function GroupHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, GroupHeaderComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, GroupHeaderComponent_td_1_Template, 3, 9, "td", 1)(2, GroupHeaderComponent_ng_container_2_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.skipGroupDecoration);
      ɵɵadvance();
      ɵɵproperty("ngIf", !(ctx.skipGroupDecoration && ctx.hasGroupHeaderColumn));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasGroupHeaderColumn);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, LogicalCellDirective, TemplateContextDirective, IconWrapperComponent, FieldAccessorPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridGroupHeader]",
      template: `
        <ng-container *ngIf="!skipGroupDecoration">
            <td class="k-group-cell k-table-td"
                role="presentation"
                *ngFor="let g of prefixGroupCell(item)"></td>
        </ng-container>
        <td [attr.colspan]="groupSpan(item)" *ngIf="!(skipGroupDecoration && hasGroupHeaderColumn)"
            [attr.role]="ariaRole()"
            aria-selected="false"
            class="k-table-td"
            [attr.aria-expanded]="isExpanded"
            kendoGridLogicalCell
            [logicalRowIndex]="logicalRowIndex"
            [logicalColIndex]="0"
            [logicalSlaveCell]="skipGroupDecoration"
            [groupItem]="item"
            [colSpan]="logicalColSpan()">
            <p class="k-reset">
                <ng-container *ngIf="!skipGroupDecoration">
                    <a href="#" tabindex="-1" (click)="toggleGroup(item)"
                        role="presentation"
                        [attr.title]="groupButtonTitle"
                        [attr.aria-label]="groupButtonTitle">
                        <kendo-icon-wrapper
                            [name]="arrowIcon"
                            [svgIcon]="arrowSVGIcon"></kendo-icon-wrapper>
                    </a>
                    <ng-container *ngIf="!groupHeaderTemplate(item)">
                    {{groupTitle(item)}}: {{item.data | valueOf:"value": formatForGroup(item)}}
                    </ng-container>
                    <ng-template
                        [templateContext]="{
                            templateRef: groupHeaderTemplate(item),
                            group: item.data,
                            aggregates: item.data?.aggregates,
                            value: item.data?.value,
                            field: item.data?.field,
                            index: item.index,
                            expanded: isExpanded,
                            $implicit: item.data
                            }">
                    </ng-template>
                </ng-container>
            </p>
        </td>
        <ng-container *ngIf="hasGroupHeaderColumn">
            <td *ngFor="let column of groupHeaderColumns; let index = index"
                role="gridcell"
                class="k-table-td"
                aria-selected="false"
                kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="index + 1"
                [logicalSlaveCell]="false"
                [groupItem]="item"
                [colSpan]="1"
            >
                <ng-template *ngIf="column.groupHeaderColumnTemplateRef" [ngTemplateOutlet]="column.groupHeaderColumnTemplateRef"
                    [ngTemplateOutletContext]="{
                        group: item.data,
                        aggregates: item.data?.aggregates,
                        value: item.data?.value,
                        field: item.data?.field,
                        index: item.index,
                        $implicit: item.data
                        }">
                </ng-template>
            </td>
        </ng-container>
    `
    }]
  }], function() {
    return [{
      type: GroupsService
    }, {
      type: GroupInfoService
    }, {
      type: ContextService
    }];
  }, {
    rowIndex: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    hasDetails: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    hasGroupHeaderColumn: [{
      type: Input
    }],
    groupHeaderColumns: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    groupItemClass: [{
      type: HostBinding,
      args: ["class.k-grouping-row"]
    }],
    tableGroupRowClass: [{
      type: HostBinding,
      args: ["class.k-table-group-row"]
    }]
  });
})();
var CommandColumnComponent = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
};
CommandColumnComponent.ɵfac = function CommandColumnComponent_Factory(t) {
  return new (t || CommandColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
CommandColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: CommandColumnComponent,
  selectors: [["kendo-grid-command-column"]],
  contentQueries: function CommandColumnComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => CommandColumnComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CommandColumnComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CommandColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CommandColumnComponent)
      }],
      selector: "kendo-grid-command-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var SelectionCheckboxDirective = class {
  constructor(selectionService, aggregateService, el, renderer, ngZone) {
    this.selectionService = selectionService;
    this.aggregateService = aggregateService;
    this.el = el;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.type = "checkbox";
    this.ngZone.runOutsideAngular(() => {
      this.destroyClick = this.renderer.listen(this.el.nativeElement, "click", this.onClick.bind(this));
      this.destroyKeyDown = this.renderer.listen(this.el.nativeElement, "keydown", this.onKeyDown.bind(this));
    });
  }
  ngAfterContentChecked() {
    this.setCheckedState();
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
    if (this.destroyKeyDown) {
      this.destroyKeyDown();
    }
  }
  onClick() {
    if (this.selectionService.options.enabled) {
      this.ngZone.run(() => {
        const ev = this.selectionService.toggleByIndex(this.itemIndex);
        ev.ctrlKey = true;
        ev.shiftKey = false;
        if (this.selectionService.options.cellAggregates) {
          ev.cellAggregates = this.aggregateService.onSelectionChange(ev);
        }
        this.selectionService.changes.emit(ev);
      });
    }
  }
  onKeyDown(e) {
    if (e.keyCode === Keys.Enter) {
      this.onClick();
    }
  }
  /*
   * @hidden
   */
  setCheckedState() {
    this.renderer.setProperty(this.el.nativeElement, "checked", this.selectionService.isSelected(this.itemIndex));
  }
};
SelectionCheckboxDirective.ɵfac = function SelectionCheckboxDirective_Factory(t) {
  return new (t || SelectionCheckboxDirective)(ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(CellSelectionAggregateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
SelectionCheckboxDirective.ɵdir = ɵɵdefineDirective({
  type: SelectionCheckboxDirective,
  selectors: [["", "kendoGridSelectionCheckbox", ""]],
  hostVars: 1,
  hostBindings: function SelectionCheckboxDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    itemIndex: [0, "kendoGridSelectionCheckbox", "itemIndex"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectionCheckbox]"
    }]
  }], function() {
    return [{
      type: SelectionService
    }, {
      type: CellSelectionAggregateService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    itemIndex: [{
      type: Input,
      args: ["kendoGridSelectionCheckbox"]
    }],
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }]
  });
})();
var CellComponent = class {
  constructor(editService, idService, ctx, cellContext) {
    this.editService = editService;
    this.idService = idService;
    this.ctx = ctx;
    this.cellContext = cellContext;
    this.isNew = false;
    this.isLoading = false;
    this.isVirtual = false;
    this.reorderIcon = reorderIcon;
    this._templateContext = {};
    this._editTemplateContext = {};
  }
  get commandCellClass() {
    return this.isCommand(this.column);
  }
  get dragHandleCellClass() {
    return isRowReorderColumn(this.column);
  }
  get dragRowHandleLabel() {
    return isRowReorderColumn(this.column) ? this.ctx.localization.get("dragRowHandleLabel") : void 0;
  }
  set rowIndex(index) {
    this._rowIndex = index;
    this.updateCellContext();
  }
  get rowIndex() {
    return this._rowIndex;
  }
  get isEdited() {
    if (!(this.editService.isEditing() || this.isNew) || !this.isColumnEditable) {
      return false;
    }
    const editContext = this.editService.columnContext(this.rowIndex, this.column);
    return this.isFieldEditable(editContext, this.column);
  }
  get showLoading() {
    return this.isVirtual && this.isLoading;
  }
  get formGroup() {
    return this.editService.context(this.rowIndex).group;
  }
  get templateContext() {
    return this._templateContext;
  }
  get editTemplateContext() {
    this._editTemplateContext.$implicit = this.formGroup;
    this._editTemplateContext.isNew = this.isNew;
    this._editTemplateContext.column = this.column;
    this._editTemplateContext.dataItem = this.dataItem;
    this._editTemplateContext.formGroup = this.formGroup;
    this._editTemplateContext.rowIndex = this.rowIndex;
    return this._editTemplateContext;
  }
  get format() {
    if (isColumnComponent(this.column) && !isNullOrEmptyString2(this.column.format)) {
      return extractFormat(this.column.format);
    }
    return void 0;
  }
  get isBoundColumn() {
    return this.column.field && !this.column.templateRef;
  }
  get isCheckboxColumn() {
    return isCheckboxColumn(this.column) && !this.column.templateRef;
  }
  get selectionCheckboxId() {
    return this.idService.selectionCheckboxId(this.rowIndex);
  }
  get selectionCheckboxLabel() {
    return this.ctx.localization.get("selectionCheckboxLabel");
  }
  get isSpanColumn() {
    return isSpanColumn(this.column) && !this.column.templateRef;
  }
  get childColumns() {
    return columnsToRender([this.column]);
  }
  get isRowReorderColumn() {
    return isRowReorderColumn(this.column) && !this.column.templateRef;
  }
  get isColumnEditable() {
    if (!this.column || this.isCommand(this.column)) {
      return false;
    }
    return this.column.editable !== false;
  }
  ngDoCheck() {
    this.updateCellContext();
  }
  ngOnChanges(_changes) {
    this.updateTemplateContext();
  }
  ngAfterContentChecked() {
    this.updateTemplateContext();
  }
  isCommand(column) {
    return column instanceof CommandColumnComponent;
  }
  isFieldEditable(editContext, column) {
    if (!isPresent4(editContext)) {
      return false;
    }
    if (isPresent4(column.editTemplate)) {
      return true;
    }
    return isPresent4(editContext.group) && isPresent4(editContext.group.get(column.field));
  }
  updateCellContext() {
    if (this.cellContext) {
      this.cellContext.rowIndex = this._rowIndex;
    }
  }
  updateTemplateContext() {
    if (!this.column.templateRef) {
      return;
    }
    const context = this._templateContext;
    context.isNew = this.isNew;
    context.column = this.column;
    context.dataItem = this.dataItem;
    context.rowIndex = this.rowIndex;
    context.columnIndex = this.columnIndex;
    context.$implicit = this.dataItem;
  }
};
CellComponent.ɵfac = function CellComponent_Factory(t) {
  return new (t || CellComponent)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(CELL_CONTEXT, 8));
};
CellComponent.ɵcmp = ɵɵdefineComponent({
  type: CellComponent,
  selectors: [["", "kendoGridCell", ""]],
  hostVars: 7,
  hostBindings: function CellComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.dragRowHandleLabel);
      ɵɵclassProp("k-command-cell", ctx.commandCellClass)("k-drag-cell", ctx.dragHandleCellClass)("k-touch-action-none", ctx.dragHandleCellClass);
    }
  },
  inputs: {
    column: "column",
    columnIndex: "columnIndex",
    isNew: "isNew",
    isLoading: "isLoading",
    isVirtual: "isVirtual",
    loadingTemplate: "loadingTemplate",
    rowIndex: "rowIndex",
    dataItem: "dataItem"
  },
  features: [ɵɵNgOnChangesFeature],
  attrs: _c9,
  decls: 3,
  vars: 3,
  consts: [["loading", ""], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngIf", "ngIfElse"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngFor", "ngForOf"], [1, "k-checkbox-wrap"], [1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "kendoGridSelectionCheckbox"], ["name", "reorder", 3, "svgIcon"], ["class", "k-skeleton-text k-skeleton", 4, "ngIf"], [1, "k-skeleton-text", "k-skeleton"], [3, "ngSwitch", 4, "ngIf"], ["kendoGridFocusable", "", 3, "format", "formControl", 4, "ngSwitchCase"], ["type", "checkbox", "class", "k-checkbox k-checkbox-md k-rounded-md", "kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchCase"], ["type", "text", "class", "k-textbox k-input k-input-md k-input-solid k-rounded-md", "kendoGridFocusable", "", 3, "formControl", 4, "ngSwitchDefault"], ["kendoGridFocusable", "", 3, "format", "formControl"], ["type", "checkbox", "kendoGridFocusable", "", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "formControl"], ["type", "text", "kendoGridFocusable", "", 1, "k-textbox", "k-input", "k-input-md", "k-input-solid", "k-rounded-md", 3, "formControl"]],
  template: function CellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 1);
      ɵɵtemplate(1, CellComponent_ng_container_1_Template, 4, 2, "ng-container", 2)(2, CellComponent_ng_container_2_Template, 3, 2, "ng-container", 2);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.isEdited);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", false);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", true);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, DefaultValueAccessor, CheckboxControlValueAccessor, NgControlStatus, FormControlDirective, FocusableDirective, IconWrapperComponent, NumericTextBoxComponent, DatePickerComponent, SelectionCheckboxDirective, FieldAccessorPipe],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridCell]",
      template: `
        <ng-container [ngSwitch]="isEdited">
            <ng-container *ngSwitchCase="false">
                <ng-container *ngIf="!showLoading; else loading">
                    <ng-template *ngIf="column.templateRef"
                        [ngTemplateOutlet]="column.templateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                    <ng-container *ngIf="isSpanColumn">
                        <ng-container *ngFor="let childColumn of childColumns">
                            {{ dataItem | valueOf: childColumn.field: childColumn.format}}
                        </ng-container>
                    </ng-container>
                    <ng-container *ngIf="isBoundColumn">{{ dataItem | valueOf: column.field: column.format}}</ng-container>
                    <ng-container *ngIf="isCheckboxColumn && !isNew">
                        <span class="k-checkbox-wrap">
                            <input
                                class="k-checkbox k-checkbox-md k-rounded-md"
                                [kendoGridSelectionCheckbox]="rowIndex"
                                [attr.id]="selectionCheckboxId"
                                [attr.aria-label]="selectionCheckboxLabel" />
                        </span>
                    </ng-container>
                    <ng-container *ngIf="isRowReorderColumn && !isNew">
                        <kendo-icon-wrapper
                            name="reorder"
                            [svgIcon]="reorderIcon">
                        </kendo-icon-wrapper>
                    </ng-container>
                </ng-container>
                <ng-template #loading>
                    <ng-template
                        *ngIf="loadingTemplate"
                        [ngTemplateOutlet]="loadingTemplate"
                        [ngTemplateOutletContext]="{$implicit: column}">
                    </ng-template>
                    <div *ngIf="!loadingTemplate" class="k-skeleton-text k-skeleton"></div>
                </ng-template>
            </ng-container>
            <ng-container *ngSwitchCase="true">
                <ng-template
                    *ngIf="column.editTemplateRef"
                    [ngTemplateOutlet]="column.editTemplateRef"
                    [ngTemplateOutletContext]="editTemplateContext">
                </ng-template>
                <ng-container [ngSwitch]="column.editor" *ngIf="!column.editTemplateRef">
                    <kendo-numerictextbox
                        *ngSwitchCase="'numeric'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-numerictextbox>

                    <kendo-datepicker
                        *ngSwitchCase="'date'"
                        [format]="format"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    ></kendo-datepicker>

                    <span class="k-checkbox-wrap">
                        <input
                            *ngSwitchCase="'boolean'"
                            type="checkbox"
                            class="k-checkbox k-checkbox-md k-rounded-md"
                            [formControl]="$any(formGroup.get(column.field))"
                            kendoGridFocusable
                        />
                    </span>

                    <input
                        *ngSwitchDefault
                        type="text"
                        class="k-textbox k-input k-input-md k-input-solid k-rounded-md"
                        [formControl]="$any(formGroup.get(column.field))"
                        kendoGridFocusable
                    />
                </ng-container>
            </ng-container>
        </ng-container>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: IdService
    }, {
      type: ContextService
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }];
  }, {
    commandCellClass: [{
      type: HostBinding,
      args: ["class.k-command-cell"]
    }],
    dragHandleCellClass: [{
      type: HostBinding,
      args: ["class.k-drag-cell"]
    }, {
      type: HostBinding,
      args: ["class.k-touch-action-none"]
    }],
    dragRowHandleLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    column: [{
      type: Input
    }],
    columnIndex: [{
      type: Input
    }],
    isNew: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    rowIndex: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }]
  });
})();
var columnCellIndex = (cell2, cells) => {
  let cellIndex = 0;
  for (let idx = 0; idx < cells.length; idx++) {
    if (cells[idx] === cell2) {
      return cellIndex;
    }
    if (!hasClasses(cells[idx], "k-hierarchy-cell k-group-cell")) {
      cellIndex++;
    }
  }
};
var TableBodyComponent = class {
  constructor(detailsService, groupsService, changeNotification, editService, ctx, ngZone, renderer, element, domEvents, selectionService, cellSelectionService, columnInfoService, navigationService) {
    this.detailsService = detailsService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.editService = editService;
    this.ctx = ctx;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.element = element;
    this.domEvents = domEvents;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.columns = [];
    this.groups = [];
    this.skip = 0;
    this.noRecordsText = this.ctx.localization.get("noRecords");
    this.isLocked = false;
    this.skipGroupDecoration = false;
    this.showGroupFooters = false;
    this.lockedColumnsCount = 0;
    this.totalColumnsCount = 0;
    this.trackBy = defaultTrackBy;
    this.hostClass = true;
    this.minusIcon = minusIcon;
    this.plusIcon = plusIcon;
    this.rowClass = () => null;
    this.cellKeydownSubscription = this.navigationService.cellKeydown.subscribe((args) => this.cellKeydownHandler(args));
    this.trackByWrapper = this.trackByWrapper.bind(this);
    this.trackByColumns = this.trackByColumns.bind(this);
  }
  get newDataItem() {
    return this.editService.newDataItem;
  }
  // Number of unlocked columns in the next table, if any
  unlockedColumnsCount(item) {
    const allColumns = this.allColumns || this.columns;
    let allColumnsCount = allColumns.length;
    allColumns.forEach((column) => {
      if (column.isSpanColumn) {
        allColumnsCount += column.colspan - 1;
      }
    });
    const contentColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - allColumnsCount;
    const headerFooterColumnsCount = this.totalColumnsCount - this.lockedColumnsCount - (this.allColumns || this.columns).length;
    return item && this.isDataItem(item) ? contentColumnsCount : headerFooterColumnsCount;
  }
  isAriaSelected(item, column) {
    return this.cellSelectionService.isCellSelected(item, column) || this.isRowSelected(item) ? "true" : "false";
  }
  toggleRow(index, dataItem) {
    this.detailsService.toggleRow(index, dataItem);
    return false;
  }
  isExpanded(viewItem) {
    return this.detailsService.isExpanded(viewItem.index, viewItem.data);
  }
  detailButtonIconName(viewItem) {
    const expanded = this.isExpanded(viewItem);
    return expanded ? "minus" : "plus";
  }
  detailButtonSvgIcon(viewItem) {
    const expanded = this.isExpanded(viewItem);
    return expanded ? this.minusIcon : this.plusIcon;
  }
  detailButtonTitle(viewItem) {
    const messageKey = this.isExpanded(viewItem) ? "detailCollapse" : "detailExpand";
    return this.ctx.localization.get(messageKey);
  }
  isGroup(item) {
    return item.type === "group";
  }
  isDataItem(item) {
    return !this.isGroup(item) && !this.isFooter(item);
  }
  isFooter(item) {
    return item.type === "footer";
  }
  isFooterItemInExpandedGroup(item) {
    const footerItem = {
      data: item.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(footerItem);
  }
  isDataItemInExpandedGroup(item) {
    const dataItem = {
      data: item.group.data,
      index: item.groupIndex,
      parentGroup: item.group.parentGroup
    };
    return this.isInExpandedGroup(dataItem);
  }
  isInExpandedGroup(item) {
    return this.groupsService.isInExpandedGroup(item);
  }
  isParentGroupExpanded(item) {
    return this.groupsService.isInExpandedGroup(item.parentGroup);
  }
  isOdd(item) {
    return item.index % 2 !== 0;
  }
  isSelectable() {
    return this.selectable && this.selectable.enabled !== false;
  }
  isRowSelected(item) {
    return this.selectionService.isSelected(item.index);
  }
  trackByWrapper(index, item) {
    if (item.type === "data") {
      item.isEditing = this.editService.hasEdited(item.index);
    }
    return this.trackBy(index, item);
  }
  trackByColumns(index, item) {
    return this.virtualColumns ? index : item;
  }
  ngDoCheck() {
    if (this.hasGroupHeaderColumn) {
      this.groupHeaderColumns = columnsToRender(this.skipGroupDecoration ? this.columns : this.columns.toArray().slice(1));
    } else {
      this.groupHeaderColumns = [];
    }
    if (this.isLocked) {
      this.groupHeaderSlaveCellsCount = this.hasGroupHeaderColumn ? this.columnsContainer.nonLockedColumnsToRender.length : 1;
    } else {
      this.groupHeaderSlaveCellsCount = 0;
    }
  }
  ngAfterViewChecked() {
    if (this.rowSticky) {
      this.applyStickyRowsStyling();
    }
  }
  ngOnChanges(changes) {
    if (isChanged("columns", changes, false)) {
      this.changeNotification.notify();
    }
  }
  logicalRowIndex(rowIndex) {
    let pos = this.skip + rowIndex;
    if (this.hasDetailTemplate) {
      pos *= 2;
    }
    const absoluteRowIndex = 1 + pos;
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRowCount = this.columnInfoService.totalLevels + filterRowOffset + addRowOffset;
    return absoluteRowIndex + headerRowCount;
  }
  addRowLogicalIndex() {
    return this.columnInfoService.totalLevels + 1 + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  logicalColIndex(column) {
    if (!isPresent4(column.leafIndex)) {
      return -1;
    }
    return column.leafIndex + (this.hasDetailTemplate ? 1 : 0);
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      const clickHandler = this.clickHandler.bind(this);
      const mousedownSubscription = this.renderer.listen(this.element.nativeElement, "mousedown", clickHandler);
      const mouseupSubscription = this.renderer.listen(this.element.nativeElement, "mouseup", clickHandler);
      const clickSubscription = this.renderer.listen(this.element.nativeElement, "click", clickHandler);
      const contextmenuSubscription = this.renderer.listen(this.element.nativeElement, "contextmenu", clickHandler);
      const touchstartSubscription = this.renderer.listen(this.element.nativeElement, "touchstart", clickHandler);
      const touchendSubscription = this.renderer.listen(this.element.nativeElement, "touchend", clickHandler);
      this.clickSubscription = () => {
        mousedownSubscription();
        mouseupSubscription();
        clickSubscription();
        contextmenuSubscription();
      };
      this.touchSubscription = () => {
        touchstartSubscription();
        touchendSubscription();
      };
    });
    let originalNoRecordText = this.ctx.localization.get("noRecords");
    this.l10nSubscription = this.ctx.localization.changes.subscribe(() => {
      if (this.noRecordsText === originalNoRecordText) {
        this.noRecordsText = this.ctx.localization.get("noRecords");
        originalNoRecordText = this.noRecordsText;
      }
    });
  }
  ngOnDestroy() {
    if (this.clickSubscription) {
      this.clickSubscription();
    }
    if (this.touchSubscription) {
      this.touchSubscription();
    }
    if (this.l10nSubscription) {
      this.l10nSubscription.unsubscribe();
    }
    this.cellKeydownSubscription.unsubscribe();
    clearTimeout(this.clickTimeout);
  }
  isEditingCell(index, column) {
    return this.editService.isEditing() && this.editService.isEditedColumn(index, column);
  }
  isEditingRow(index) {
    return this.editService.isEditing() && this.editService.hasEdited(index);
  }
  get hasGroupHeaderColumn() {
    return this.columnsContainer.hasGroupHeaderColumn;
  }
  get columnsContainer() {
    return this.columnInfoService.columnsContainer;
  }
  get columnsSpan() {
    return columnsSpan(this.columns);
  }
  get allColumnsSpan() {
    return columnsSpan(this.allColumns || this.columns);
  }
  get colSpan() {
    return this.columnsSpan + this.groups.length + (this.hasDetailTemplate ? 1 : 0);
  }
  get footerColumns() {
    const colsToRender = Array.from(this.columns).reduce((cols, col) => {
      const newCols = col instanceof SpanColumnComponent ? Array.from(col.childColumns) : [col];
      return [...cols, ...newCols];
    }, []);
    return colsToRender;
  }
  showGroupHeader(item) {
    return !item.data.skipHeader;
  }
  addStickyColumnStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.style), stickyStyles);
  }
  resizeHandler() {
    this.applyStickyRowsStyling();
  }
  get hasDetailTemplate() {
    return isPresent4(this.detailTemplate);
  }
  clickHandler(eventArg) {
    const element = this.element.nativeElement;
    const target = this.eventTarget(eventArg);
    let cell2, row2, body, gridElement;
    let currentTarget = target;
    do {
      cell2 = closest2(currentTarget, matchesNodeName("td"));
      row2 = closest2(cell2, matchesNodeName("tr"));
      body = closest2(row2, matchesNodeName("tbody"));
      currentTarget = body;
      gridElement = closestInScope(currentTarget, matchesClasses("k-grid"), element);
    } while (body && body !== element && !gridElement);
    if (cell2 && !hasClasses(cell2, NON_DATA_CELL_CLASSES) && !hasClasses(row2, NON_DATA_ROW_CLASSES) && body === element && !gridElement) {
      this.editService.preventCellClose();
      const focusable = target !== cell2 && isFocusableWithTabKey(target, false);
      if (!focusable && !matchesNodeName("label")(target) && !hasClasses(target, IGNORE_TARGET_CLASSSES) && !closestInScope(target, matchesClasses(IGNORE_CONTAINER_CLASSES), cell2)) {
        const args = this.cellClickArgs(cell2, row2, eventArg);
        if (eventArg.type === "mousedown" || eventArg.type === "touchstart") {
          this.domEvents.cellMousedown.emit(args);
        } else if (eventArg.type === "mouseup" || eventArg.type === "touchend") {
          this.domEvents.cellMouseup.emit(args);
        } else {
          if (args.isEditedColumn || !this.editService.closeCell(eventArg)) {
            if (eventArg.type === "click") {
              this.clickTimeout = setTimeout(() => {
                this.emitCellClick(args);
              }, 0);
            } else {
              this.emitCellClick(args);
            }
          }
        }
      }
    }
  }
  emitCellClick(args) {
    this.domEvents.cellClick.emit(Object.assign(args, {
      isEdited: args.isEditedRow || args.isEditedColumn
    }));
  }
  cellKeydownHandler(args) {
    if (args.keyCode === Keys.Enter) {
      this.clickHandler(args);
    }
  }
  cellClickArgs(cell2, row2, eventArg) {
    const index = columnCellIndex(cell2, row2.cells);
    const column = this.columns.toArray()[index];
    const columnIndex = this.lockedColumnsCount + index;
    let rowIndex = row2.getAttribute("data-kendo-grid-item-index");
    rowIndex = rowIndex ? parseInt(rowIndex, 10) : -1;
    const dataItem = rowIndex === -1 ? this.editService.newDataItem : this.data.at(rowIndex - this.skip);
    const isEditedColumn = this.editService.isEditedColumn(rowIndex, column);
    const isEditedRow = this.editService.isEdited(rowIndex);
    const type = eventArg.type === "keydown" ? "click" : eventArg.type;
    return {
      column,
      columnIndex,
      dataItem,
      isEditedColumn,
      isEditedRow,
      originalEvent: eventArg,
      rowIndex,
      type
    };
  }
  eventTarget(args) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (args.type === "touchend") {
      const touch = args.changedTouches[0];
      return document.elementFromPoint(touch.clientX, touch.clientY);
    }
    return args.target;
  }
  applyStickyRowsStyling() {
    if (!isDocumentAvailable()) {
      return;
    }
    const stickyRows = nodesToArray(this.element.nativeElement.querySelectorAll(".k-grid-row-sticky"));
    const length = stickyRows.length;
    if (length) {
      let accumulatedHeight = 0;
      const stickyRowsOffsets = [];
      stickyRows.forEach((row2) => {
        const rowHeight = row2.getBoundingClientRect().height;
        stickyRowsOffsets.push({
          accumulatedHeight,
          rowHeight
        });
        accumulatedHeight += rowHeight;
      });
      stickyRows.forEach((row2, index) => {
        this.renderer.setStyle(row2, "top", `${stickyRowsOffsets[index].accumulatedHeight}px`);
        this.renderer.setStyle(row2, "bottom", `${accumulatedHeight - stickyRowsOffsets[index].accumulatedHeight - stickyRowsOffsets[index].rowHeight}px`);
      });
    }
  }
};
TableBodyComponent.ɵfac = function TableBodyComponent_Factory(t) {
  return new (t || TableBodyComponent)(ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService));
};
TableBodyComponent.ɵcmp = ɵɵdefineComponent({
  type: TableBodyComponent,
  selectors: [["", "kendoGridTableBody", ""]],
  hostVars: 2,
  hostBindings: function TableBodyComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-table-tbody", ctx.hostClass);
    }
  },
  inputs: {
    columns: "columns",
    allColumns: "allColumns",
    groups: "groups",
    detailTemplate: "detailTemplate",
    noRecordsTemplate: "noRecordsTemplate",
    data: "data",
    skip: "skip",
    selectable: "selectable",
    filterable: "filterable",
    noRecordsText: "noRecordsText",
    isLocked: "isLocked",
    isLoading: "isLoading",
    isVirtual: "isVirtual",
    cellLoadingTemplate: "cellLoadingTemplate",
    skipGroupDecoration: "skipGroupDecoration",
    showGroupFooters: "showGroupFooters",
    lockedColumnsCount: "lockedColumnsCount",
    totalColumnsCount: "totalColumnsCount",
    virtualColumns: "virtualColumns",
    trackBy: "trackBy",
    rowSticky: "rowSticky",
    totalColumns: "totalColumns",
    rowClass: "rowClass"
  },
  features: [ɵɵNgOnChangesFeature],
  attrs: _c11,
  decls: 4,
  vars: 5,
  consts: [[4, "ngIf"], ["class", "k-grid-norecords", "role", "row", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "resize", 4, "ngIf"], ["kendoGridLogicalRow", "", 1, "k-grid-add-row", "k-grid-edit-row", "k-master-row", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-hierarchy-cell k-table-td", "kendoGridLogicalCell", "", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", 4, "ngIf"], ["class", "k-table-td", "kendoGridCell", "", "kendoGridLogicalCell", "", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "k-grid-content-sticky", "ngClass", "left", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-group-cell k-table-td", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-group-cell", "k-table-td"], ["kendoGridLogicalCell", "", "aria-selected", "false", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "isNew", "column", "dataItem", "ngClass", "ngStyle", "logicalRowIndex", "logicalColIndex", "colSpan"], ["role", "row", 1, "k-grid-norecords"], [1, "k-table-td"], [3, "templateContext"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "class", "k-grid-row-sticky", "ngClass", "k-master-row", "k-grid-edit-row", "k-selected", 4, "ngIf"], ["class", "k-detail-row", "kendoGridLogicalRow", "", 3, "k-alt", "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", 4, "ngIf"], ["class", "k-group-footer", "kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", 4, "ngIf"], ["kendoGridGroupHeader", "", "kendoGridLogicalRow", "", 3, "columns", "groups", "item", "hasDetails", "skipGroupDecoration", "hasGroupHeaderColumn", "groupHeaderColumns", "rowIndex", "totalColumnsCount", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalRow", "", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount", "ngClass"], ["class", "k-hierarchy-cell k-table-td", "kendoGridLogicalCell", "", "aria-selected", "false", "role", "gridcell", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell", 4, "ngIf"], ["kendoGridCell", "", "kendoGridLogicalCell", "", "class", "k-table-td", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "k-grid-content-sticky", "k-touch-action-none", "k-touch-action-auto", "ngClass", "k-grid-edit-cell", "ngStyle", "k-selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoGridLogicalCell", "", "aria-selected", "false", "role", "gridcell", 1, "k-hierarchy-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "detailExpandCell"], ["href", "#", "tabindex", "-1", 3, "click", 4, "ngIf"], ["href", "#", "tabindex", "-1", 3, "click"], [3, "name", "svgIcon"], ["kendoGridCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "rowIndex", "columnIndex", "column", "dataItem", "isLoading", "isVirtual", "loadingTemplate", "logicalRowIndex", "logicalColIndex", "dataRowIndex", "colIndex", "colSpan", "ngClass", "ngStyle"], ["kendoGridLogicalRow", "", 1, "k-detail-row", 3, "dataRowIndex", "dataItem", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount"], ["class", "k-group-cell k-table-td", 4, "ngFor", "ngForOf"], [1, "k-hierarchy-cell", "k-table-td"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-detail-cell", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "dataRowIndex", "dataItem", "colIndex", "colSpan"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-group-cell", "k-table-td"], ["kendoGridLogicalRow", "", 1, "k-group-footer", 3, "logicalRowIndex", "logicalSlaveRow", "totalColumns", "logicalCellsCount", "logicalSlaveCellsCount"], ["kendoGridLogicalCell", "", "class", "k-table-td", 3, "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["kendoGridLogicalCell", "", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex"], [3, "resize"]],
  template: function TableBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TableBodyComponent_ng_container_0_Template, 5, 9, "ng-container", 0)(1, TableBodyComponent_tr_1_Template, 4, 3, "tr", 1)(2, TableBodyComponent_ng_container_2_Template, 5, 4, "ng-container", 2)(3, TableBodyComponent_kendo_resize_sensor_3_Template, 1, 0, "kendo-resize-sensor", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.editService.hasNewItem);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.data == null ? null : ctx.data.length) === 0 || ctx.data === null);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackByWrapper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.rowSticky);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, LogicalCellDirective, LogicalRowDirective, TemplateContextDirective, IconWrapperComponent, GroupHeaderComponent, ResizeSensorComponent, CellComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableBodyComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridTableBody]",
      template: `
    <ng-container *ngIf="editService.hasNewItem">
        <tr class="k-grid-add-row k-grid-edit-row k-master-row"
            kendoGridLogicalRow
                [logicalRowIndex]="addRowLogicalIndex()"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount()"
                [totalColumns]="totalColumns">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;"
                class="k-table-td"
                kendoGridCell
                    [rowIndex]="-1"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [isNew]="true"
                    [column]="column"
                    [dataItem]="newDataItem"
                [class.k-grid-content-sticky]="column.sticky"
                [ngClass]="column.cssClass"
                [style.left]="column.sticky ? '0' : undefined"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [attr.role]="column.tableCellsRole"
                kendoGridLogicalCell
                    [logicalRowIndex]="addRowLogicalIndex()"
                    [logicalColIndex]="logicalColIndex(column)"
                    [colSpan]="column.colspan">
            </td>
        </tr>
    </ng-container>
    <tr *ngIf="data?.length === 0 || data === null" class="k-grid-norecords" role="row">
        <td [attr.colspan]="colSpan" class="k-table-td">
            <ng-template
                *ngIf="noRecordsTemplate?.templateRef"
                [templateContext]="{
                    templateRef: noRecordsTemplate?.templateRef
                 }">
            </ng-template>
            <ng-container *ngIf="!noRecordsTemplate?.templateRef">
                {{noRecordsText}}
            </ng-container>
        </td>
    </tr>
    <ng-container *ngFor="let item of data; trackBy: trackByWrapper; let rowIndex = index;">
        <tr *ngIf="isGroup(item) && isParentGroupExpanded($any(item)) && showGroupHeader(item)"
            kendoGridGroupHeader
                [columns]="columns"
                [groups]="groups"
                [item]="$any(item)"
                [hasDetails]="!!detailTemplate?.templateRef"
                [skipGroupDecoration]="skipGroupDecoration"
                [hasGroupHeaderColumn]="hasGroupHeaderColumn"
                [groupHeaderColumns]="groupHeaderColumns"
                [rowIndex]="rowIndex + 1"
                [totalColumnsCount]="totalColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="groupHeaderSlaveCellsCount">
        </tr>
        <tr
            *ngIf="isDataItem(item) && (!$any(item).group || isDataItemInExpandedGroup($any(item)))"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)"
            class="{{ isOdd(item) ?  'k-alt k-table-alt-row' : ''}}"
            [class.k-grid-row-sticky]="rowSticky ? rowSticky({ dataItem: item.data, index: $any(item).index }) : false"
            [ngClass]="rowClass({ dataItem: item.data, index: $any(item).index })"
            [class.k-master-row]="true"
            [class.k-grid-edit-row]="isEditingRow($any(item).index)"
            [attr.aria-selected]="lockedColumnsCount < 1 ? isSelectable() && isRowSelected(item) : undefined"
            [attr.data-kendo-grid-item-index]="$any(item).index"
            [class.k-selected]="isSelectable() && isRowSelected(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td" *ngFor="let g of groups" role="presentation"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [detailExpandCell]="true"
                    aria-selected="false"
                    role="gridcell">
                <a
                    *ngIf="detailTemplate.showIf(item.data, $any(item).index)"
                    [attr.title]="detailButtonTitle(item)"
                    [attr.aria-label]="detailButtonTitle(item)"
                    href="#" tabindex="-1" (click)="toggleRow($any(item).index, item.data)">
                    <kendo-icon-wrapper
                        [name]="detailButtonIconName(item)"
                        [svgIcon]="detailButtonSvgIcon(item)"></kendo-icon-wrapper>
                </a>
            </td>
            <td
                kendoGridCell
                    [rowIndex]="$any(item).index"
                    [columnIndex]="lockedColumnsCount + columnIndex"
                    [attr.data-kendo-grid-column-index]="lockedColumnsCount + columnIndex"
                    [column]="column"
                    [dataItem]="item.data"
                    [isLoading]="isLoading"
                    [isVirtual]="isVirtual"
                    [loadingTemplate]="cellLoadingTemplate"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="columnIndex"
                    [colSpan]="column.colspan"
                    [attr.role]="column.tableCellsRole"
                    class="k-table-td"
                    [attr.aria-selected]="lockedColumnsCount < 1 && isSelectable() ? isAriaSelected(item, column) : undefined"
                    [class.k-grid-content-sticky]="column.sticky"
                    [class.k-touch-action-none]="isSelectable() && $any(selectable).drag"
                    [class.k-touch-action-auto]="!(isSelectable() && $any(selectable).drag)"
                [ngClass]="column.cssClass"
                [class.k-grid-edit-cell]="isEditingCell($any(item).index, column)"
                [ngStyle]="column.sticky ? addStickyColumnStyles(column) : column.style"
                [attr.colspan]="column.colspan"
                [class.k-selected]="isSelectable && cellSelectionService.isCellSelected(item, column)"
                *ngFor="let column of columns; let columnIndex = index; trackBy: trackByColumns;">
            </td>
        </tr>
        <tr *ngIf="isDataItem(item) &&
                (!$any(item).group || isDataItemInExpandedGroup($any(item))) &&
                detailTemplate?.templateRef &&
                detailTemplate.showIf(item.data, $any(item).index) &&
                isExpanded(item)"
            class="k-detail-row"
            [class.k-alt]="isOdd(item)"
            kendoGridLogicalRow
                [dataRowIndex]="$any(item).index"
                [dataItem]="item.data"
                [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                [logicalSlaveRow]="false"
                [logicalCellsCount]="1"
            >
            <td class="k-group-cell k-table-td" *ngFor="let g of groups"></td>
            <td class="k-hierarchy-cell k-table-td"></td>
            <td class="k-detail-cell k-table-td"
                [attr.colspan]="columnsSpan"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex) + 1"
                    [logicalColIndex]="0"
                    [dataRowIndex]="$any(item).index"
                    [dataItem]="item.data"
                    [colIndex]="0"
                    [colSpan]="allColumnsSpan + 1"
                    role="gridcell" aria-selected="false"
                >
                <ng-template
                    [ngTemplateOutlet]="detailTemplate.templateRef"
                    [ngTemplateOutletContext]="{
                        dataItem: item.data,
                        rowIndex: $any(item).index,
                        $implicit: item.data
                    }">
                </ng-template>
            </td>
        </tr>
        <tr *ngIf="isFooter(item) &&
                $any(item).group &&
                (isFooterItemInExpandedGroup($any(item)) || (showGroupFooters && isParentGroupExpanded($any(item).group))) &&
                !$any(item.data).hideFooter"
            class="k-group-footer"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex(rowIndex)"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [totalColumns]="totalColumns"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount(item)">
            <ng-container *ngIf="!skipGroupDecoration">
                <td class="k-group-cell k-table-td" *ngFor="let g of groups"></td>
            </ng-container>
            <td class="k-hierarchy-cell k-table-td"
                *ngIf="detailTemplate?.templateRef"
                kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="0"
                    aria-selected="false"
                >
            </td>
            <td kendoGridLogicalCell
                    [logicalRowIndex]="logicalRowIndex(rowIndex)"
                    [logicalColIndex]="logicalColIndex(column)"
                [attr.data-skip]="skipGroupDecoration"
                class="k-table-td"
                *ngFor="let column of footerColumns; let columnIndex = index; trackBy: trackByColumns;">
                <ng-template
                    [templateContext]="{
                        templateRef: $any(column).groupFooterTemplateRef,
                        group: $any(item.data),
                        field: $any(column).field,
                        column: column,
                        aggregates: $any(item.data)?.aggregates,
                        $implicit: $any(item.data)?.aggregates
                    }">
                </ng-template>
           </td>
        </tr>
    </ng-container>
    <kendo-resize-sensor *ngIf="rowSticky" (resize)="resizeHandler()"></kendo-resize-sensor>
    `
    }]
  }], function() {
    return [{
      type: DetailsService
    }, {
      type: GroupsService
    }, {
      type: ChangeNotificationService
    }, {
      type: EditService
    }, {
      type: ContextService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: DomEventsService
    }, {
      type: SelectionService
    }, {
      type: CellSelectionService
    }, {
      type: ColumnInfoService
    }, {
      type: NavigationService
    }];
  }, {
    columns: [{
      type: Input
    }],
    allColumns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    noRecordsText: [{
      type: Input
    }],
    isLocked: [{
      type: Input
    }],
    isLoading: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    skipGroupDecoration: [{
      type: Input
    }],
    showGroupFooters: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tbody"]
    }],
    rowClass: [{
      type: Input
    }]
  });
})();
var DEFAULTS = {
  allowUnsort: true,
  mode: "single",
  showIndexes: true,
  initialDirection: "asc",
  multiSortKey: "none"
};
var normalize$1 = (...settings) => Object.assign({}, DEFAULTS, ...settings);
var hasFilter = (settings, column) => settings.filter !== false && column.field && column.filterable;
var hasSort = (settings, column) => settings.sort !== false && column.field && column.sortable;
var hasLock = (settings, column) => settings.lock && column.lockable && !(column.parent && !column.parent.isSpanColumn);
var hasStick = (settings, column) => settings.stick && column.stickable && !(column.parent && !column.parent.isSpanColumn);
var hasPosition = (settings, column) => settings.setColumnPosition && (column.stickable || column.lockable) && !(column.parent && !column.parent.isSpanColumn);
var hasColumnChooser = (settings) => settings.columnChooser !== false;
var hasAutoSizeColumn = (settings) => settings.autoSizeColumn;
var hasAutoSizeAllColumns = (settings) => settings.autoSizeAllColumns;
var autoSizeColumn = (grid, service, column) => {
  column ? grid.autoFitColumn(column) : grid.autoFitColumns();
  service.close();
};
var hasItems = (settings, column) => hasAutoSizeAllColumns(settings) || hasColumnChooser(settings) || hasFilter(settings, column) || hasAutoSizeColumn(settings) || hasLock(settings, column) || hasSort(settings, column);
var localizeOperators$1 = (operators) => (localization) => Object.keys(operators).reduce((acc, key) => {
  acc[operators[key]] = localization.get(key);
  return acc;
}, {});
var operatorTexts = localizeOperators$1({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterAfterOrEqualOperator": "after-eq",
  "filterAfterOperator": "after",
  "filterBeforeOrEqualOperator": "before-eq",
  "filterBeforeOperator": "before"
});
var toJSON = (xs) => xs.map((x) => x.toJSON());
var FilterOperatorBase = class {
  constructor(operator, ctx) {
    this.operator = operator;
    this.ctx = ctx;
    this.messages = operatorTexts(this.ctx.localization);
    this._text = this.messages[this.operator];
    this.subscription = this.ctx.localization.changes.subscribe(this.refreshText.bind(this));
  }
  /**
   * The text that will be displayed in the drop-down list.
   * @readonly
   * @type {string}
   * @memberOf FilterOperatorBase
   */
  get text() {
    return this._text;
  }
  set text(value2) {
    this._text = isNullOrEmptyString2(value2) ? this.messages[this.operator] : value2;
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: this.operator
    };
  }
  refreshText() {
    const update2 = this._text === this.messages[this.operator];
    this.messages = operatorTexts(this.ctx.localization);
    if (update2) {
      this._text = this.messages[this.operator];
    }
  }
};
FilterOperatorBase.ɵfac = function FilterOperatorBase_Factory(t) {
  return new (t || FilterOperatorBase)(ɵɵdirectiveInject("filterOperator"), ɵɵdirectiveInject(ContextService));
};
FilterOperatorBase.ɵcmp = ɵɵdefineComponent({
  type: FilterOperatorBase,
  selectors: [["kendo-grid-filter-operator-base"]],
  inputs: {
    text: "text"
  },
  decls: 0,
  vars: 0,
  template: function FilterOperatorBase_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterOperatorBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-operator-base",
      template: ``
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: ["filterOperator"]
      }]
    }, {
      type: ContextService
    }];
  }, {
    text: [{
      type: Input
    }]
  });
})();
var insertDefaultFilter = (index, rootFilter, filter4) => {
  rootFilter = rootFilter || {
    filters: [],
    logic: "and"
  };
  rootFilter.filters[index] = filter4;
  return filter4;
};
var setFilter = (index, filter4, field, defaultOperator) => {
  if (isPresent4(filter4) && isPresent4(filter4.filters) && filter4.filters.length > index) {
    return filter4.filters[index];
  } else {
    return insertDefaultFilter(index, filter4, {
      field,
      operator: defaultOperator
    });
  }
};
var logicOperators = (localization) => [{
  text: localization.get("filterAndLogic"),
  value: "and"
}, {
  text: localization.get("filterOrLogic"),
  value: "or"
}];
var flatten = (filter4) => {
  if (isPresent4(filter4.filters)) {
    return filter4.filters.reduce((acc, curr) => acc.concat(isCompositeFilterDescriptor(curr) ? flatten(curr) : [curr]), []);
  }
  return [];
};
var trimFilterByField = (filter4, field) => {
  if (isPresent4(filter4) && isPresent4(filter4.filters)) {
    filter4.filters = filter4.filters.filter((x) => {
      if (isCompositeFilterDescriptor(x)) {
        trimFilterByField(x, field);
        return x.filters.length;
      } else {
        return x.field !== field;
      }
    });
  }
};
var filtersByField = (filter4, field) => flatten(filter4 || {}).filter((x) => x.field === field);
var filterByField = (filter4, field) => {
  const [currentFilter] = filtersByField(filter4, field);
  return currentFilter;
};
var removeFilter = (filter4, field) => {
  trimFilterByField(filter4, field);
  return filter4;
};
var localizeOperators = (operators) => (localization) => Object.keys(operators).map((key) => ({
  text: localization.get(key),
  value: operators[key]
}));
var BaseFilterCellComponent = class {
  constructor(filterService) {
    this.filterService = filterService;
    this.operatorList = new QueryList();
    this.size = "medium";
  }
  get hostClasses() {
    return true;
  }
  get operators() {
    return this._operators?.length ? this._operators : this.defaultOperators;
  }
  set operators(values) {
    this._operators = values;
  }
  /**
   * @hidden
   */
  ngAfterContentInit() {
    this.operationListSubscription = observe(this.operatorList).pipe(map((q) => q.toArray()), map(toJSON)).subscribe((x) => {
      this.operators = x;
    });
  }
  ngOnDestroy() {
    if (this.operationListSubscription) {
      this.operationListSubscription.unsubscribe();
    }
  }
  filterByField(field) {
    return filterByField(this.filter, field);
  }
  filtersByField(field) {
    return filtersByField(this.filter, field);
  }
  removeFilter(field) {
    return removeFilter(this.filter, field);
  }
  updateFilter(filter4) {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    const [currentFilter] = flatten(root).filter((x) => x.field === filter4.field);
    if (!isPresent4(currentFilter)) {
      root.filters.push(filter4);
    } else {
      Object.assign(currentFilter, filter4);
    }
    return root;
  }
  applyFilter(filter4) {
    this.filterService.filter(filter4);
  }
};
BaseFilterCellComponent.ɵfac = function BaseFilterCellComponent_Factory(t) {
  return new (t || BaseFilterCellComponent)(ɵɵdirectiveInject(FilterService));
};
BaseFilterCellComponent.ɵdir = ɵɵdefineDirective({
  type: BaseFilterCellComponent,
  contentQueries: function BaseFilterCellComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, FilterOperatorBase, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.operatorList = _t);
    }
  },
  hostVars: 2,
  hostBindings: function BaseFilterCellComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell", ctx.hostClasses);
    }
  },
  inputs: {
    operators: "operators"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseFilterCellComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    operatorList: [{
      type: ContentChildren,
      args: [FilterOperatorBase]
    }],
    operators: [{
      type: Input
    }]
  });
})();
var areDifferent = (a, b) => a.field !== b.field || a.operator !== b.operator || a.value !== b.value;
var isChanged2 = (a, b) => {
  if (a.length !== b.length) {
    return true;
  }
  for (let idx = 0, len = a.length; idx < len; idx++) {
    const prev = a[idx];
    const curr = b[idx];
    if (isCompositeFilterDescriptor(prev)) {
      if (diffFilters(prev, curr[idx])) {
        return true;
      }
    } else if (areDifferent(prev, curr)) {
      return true;
    }
  }
  return false;
};
var copyObject = (obj) => {
  const result = {};
  Object.assign(result, obj);
  if (obj.constructor !== Object) {
    const proto = obj.constructor.prototype;
    Object.getOwnPropertyNames(proto).forEach((property) => {
      if (property !== "constructor" && proto.hasOwnProperty(property)) {
        result[property] = obj[property];
      }
    });
  }
  return result;
};
var cloneFilter = (filter4) => copyObject(filter4);
var cloneFilters = (filter4) => {
  if (!filter4) {
    return;
  }
  if (isCompositeFilterDescriptor(filter4)) {
    return {
      filters: cloneFilters(filter4.filters),
      logic: filter4.logic
    };
  } else if (Array.isArray(filter4)) {
    return filter4.map(cloneFilters);
  }
  return cloneFilter(filter4);
};
var diffFilters = (a, b) => {
  if (isPresent4(a) && !isPresent4(b)) {
    return true;
  }
  if (!isPresent4(a) && isPresent4(b)) {
    return true;
  }
  return isPresent4(a) && isPresent4(b) && isChanged2(a.filters, b.filters);
};
var FilterHostDirective = class {
  constructor(host, resolver) {
    this.host = host;
    this.resolver = resolver;
  }
  ngOnInit() {
    this.component = this.host.createComponent(this.resolver.resolveComponentFactory(this.componentType()));
    this.initComponent({
      column: this.column,
      filter: this.filter
    });
  }
  ngOnDestroy() {
    if (this.component) {
      this.component.destroy();
      this.component = null;
    }
  }
  ngOnChanges(changes) {
    if (anyChanged(["column", "filter"], changes)) {
      this.initComponent({
        column: this.column,
        filter: this.filter
      });
    }
  }
  initComponent({
    column,
    filter: filter4
  }) {
    const instance = this.component.instance;
    instance.column = column;
    instance.filter = filter4;
  }
};
FilterHostDirective.ɵfac = function FilterHostDirective_Factory(t) {
  return new (t || FilterHostDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1));
};
FilterHostDirective.ɵdir = ɵɵdefineDirective({
  type: FilterHostDirective,
  selectors: [["", "kendoGridFilterHostBase", ""]],
  inputs: {
    column: "column",
    filter: "filter"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridFilterHostBase]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: ComponentFactoryResolver$1
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var stringOperators$1 = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var StringFilterComponent = class extends BaseFilterCellComponent {
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.operator = "contains";
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField((this.column || {}).field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = stringOperators$1(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
};
StringFilterComponent.ɵfac = function StringFilterComponent_Factory(t) {
  return new (t || StringFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
};
StringFilterComponent.ɵdir = ɵɵdefineDirective({
  type: StringFilterComponent,
  inputs: {
    column: "column",
    filter: "filter",
    operator: "operator"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }]
  });
})();
var FilterInputDirective = class {
  constructor(valueAccessors, ngZone, element, renderer) {
    this.element = element;
    this.renderer = renderer;
    this.change = new EventEmitter();
    this.composing = false;
    this.filterDelay = 500;
    this.changeRequests = new Subject();
    this.accessor = valueAccessors[0];
    ngZone.runOutsideAngular(() => {
      const unsubscribeStart = renderer.listen(element.nativeElement, "compositionstart", () => this.composing = true);
      const unsubscribeEnd = renderer.listen(element.nativeElement, "compositionend", () => this.composing = false);
      this.unsubscribeEvents = () => {
        unsubscribeStart();
        unsubscribeEnd();
      };
    });
  }
  set value(value2) {
    this.accessor.writeValue(value2);
  }
  set disabled(value2) {
    this.accessor.setDisabledState(value2);
  }
  ngAfterViewInit() {
    this.addAriaAttributes();
    this.accessor.registerOnChange((x) => this.filterDelay > 0 ? this.changeRequests.next(x) : this.change.emit(x));
    this.subscribeChanges();
  }
  ngOnChanges(changes) {
    if (isChanged("filterDelay", changes)) {
      this.unsubscribeChanges();
      this.subscribeChanges();
    }
  }
  ngOnDestroy() {
    this.unsubscribeChanges();
    this.unsubscribeEvents();
  }
  subscribeChanges() {
    this.changeRequestsSubscription = this.changeRequests.pipe(debounceTime(this.filterDelay), filter(() => !this.composing)).subscribe((x) => this.change.emit(x));
  }
  unsubscribeChanges() {
    if (this.changeRequestsSubscription) {
      this.changeRequestsSubscription.unsubscribe();
    }
  }
  addAriaAttributes() {
    const ariaValue = this.columnLabel;
    if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
      const focusableElement = this.element.nativeElement.querySelector(`#${this.kendoInput.focusableId}`) || this.element.nativeElement;
      this.renderer.setAttribute(focusableElement, "aria-label", ariaValue);
    } else {
      const inputElement = this.element.nativeElement.querySelector(".k-input-inner");
      const elementToSetLabel = inputElement ? inputElement : this.element.nativeElement;
      if (ariaValue) {
        this.renderer.setAttribute(elementToSetLabel, "aria-label", ariaValue);
      }
    }
  }
};
FilterInputDirective.ɵfac = function FilterInputDirective_Factory(t) {
  return new (t || FilterInputDirective)(ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
FilterInputDirective.ɵdir = ɵɵdefineDirective({
  type: FilterInputDirective,
  selectors: [["", "kendoFilterInput", ""]],
  contentQueries: function FilterInputDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, KendoInput, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
    }
  },
  inputs: {
    filterDelay: "filterDelay",
    columnLabel: "columnLabel",
    value: "value"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterInput]"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Self
      }, {
        type: Inject,
        args: [NG_VALUE_ACCESSOR]
      }]
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }],
    filterDelay: [{
      type: Input
    }],
    columnLabel: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var EMPTY_VALUE_OPERATORS = /* @__PURE__ */ new Set(["isnull", "isnotnull", "isempty", "isnotempty"]);
var isEmptyValueOperator = (operator) => EMPTY_VALUE_OPERATORS.has(operator);
var FilterInputWrapperComponent = class extends BaseFilterCellComponent {
  constructor(filterService) {
    super(filterService);
  }
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    const filter4 = this.currentFilter;
    if (!this._operator) {
      this._operator = filter4 ? filter4.operator : this.defaultOperator;
    }
    return this._operator;
  }
  set currentOperator(value2) {
    this._operator = value2;
    const emptyValueOperator = isEmptyValueOperator(value2);
    this.filterInputDisabled = emptyValueOperator;
    if (emptyValueOperator) {
      this.applyNoValueFilter(value2);
    } else if (!isBlank2(value2) && isPresent4(this.currentFilter)) {
      this.onChange(this.currentFilter.value);
    }
  }
  get defaultOperator() {
    if (!isNullOrEmptyString2(this._defaultOperator)) {
      return this._defaultOperator;
    } else if (this.operators && this.operators.length) {
      return this.operators[0].value;
    }
    return "eq";
  }
  set defaultOperator(value2) {
    this._defaultOperator = value2;
  }
  set filterInputDisabled(disabled) {
    if (!this.input) {
      return;
    }
    this.input.disabled = disabled;
  }
  ngAfterContentInit() {
    if (isPresent4(this.input)) {
      this.changeSubscription = this.input.change.subscribe(this.onChange.bind(this));
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.changeSubscription) {
      this.changeSubscription.unsubscribe();
    }
  }
  onChange(value2) {
    if (!isNullOrEmptyString2(value2) || this.filterByField(this.column.field)) {
      this.filterChange(isNullOrEmptyString2(value2) ? this.removeFilter(this.column.field) : this.updateFilter({
        field: this.column.field,
        operator: this.currentOperator,
        value: value2
      }));
    }
  }
  onClear() {
    this.onChange(null);
    this.filterInputDisabled = isEmptyValueOperator(this.defaultOperator);
  }
  applyNoValueFilter(operator) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator,
      value: null
    }));
  }
  ngOnChanges(changes) {
    if (isChanged("filter", changes, false)) {
      this._operator = null;
      this.filterInputDisabled = isEmptyValueOperator(this.currentOperator);
    }
  }
};
FilterInputWrapperComponent.ɵfac = function FilterInputWrapperComponent_Factory(t) {
  return new (t || FilterInputWrapperComponent)(ɵɵdirectiveInject(FilterService));
};
FilterInputWrapperComponent.ɵdir = ɵɵdefineDirective({
  type: FilterInputWrapperComponent,
  contentQueries: function FilterInputWrapperComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, FilterInputDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    defaultOperator: "defaultOperator"
  },
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputWrapperComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    input: [{
      type: ContentChild,
      args: [FilterInputDirective, {
        static: false
      }]
    }],
    defaultOperator: [{
      type: Input
    }]
  });
})();
var FilterMenuDropDownListDirective = class {
  constructor(host) {
    this.host = host;
    this.keydownHandler = (e) => {
      if (e.keyCode === Keys.Escape && this.host.isOpen) {
        e.stopPropagation();
        this.host.toggle(false);
      }
    };
  }
  ngAfterViewInit() {
    const wrapperElement = this.host.wrapper.nativeElement;
    wrapperElement.setAttribute("aria-label", this.filterMenuDropDownLabel);
    wrapperElement.addEventListener("keydown", this.keydownHandler, true);
  }
  ngOnDestroy() {
    this.host.wrapper.nativeElement.removeEventListener("keydown", this.keydownHandler);
  }
};
FilterMenuDropDownListDirective.ɵfac = function FilterMenuDropDownListDirective_Factory(t) {
  return new (t || FilterMenuDropDownListDirective)(ɵɵdirectiveInject(DropDownListComponent));
};
FilterMenuDropDownListDirective.ɵdir = ɵɵdefineDirective({
  type: FilterMenuDropDownListDirective,
  selectors: [["", "kendoFilterMenuDropDown", ""]],
  inputs: {
    filterMenuDropDownLabel: "filterMenuDropDownLabel"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuDropDownListDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuDropDown]"
    }]
  }], function() {
    return [{
      type: DropDownListComponent
    }];
  }, {
    filterMenuDropDownLabel: [{
      type: Input
    }]
  });
})();
var FilterMenuInputWrapperComponent = class extends FilterInputWrapperComponent {
  constructor(ctx) {
    super(null);
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  ngAfterViewInit() {
    const shouldFocusFirstFocusable = this.isFirstDropDown && this.filterService && this.filterService.menuTabbingService;
    const isTabbedInterface = this.menuTabbingService?.isTabbedInterface;
    if (shouldFocusFirstFocusable && !isTabbedInterface) {
      this.filterService.menuTabbingService.firstFocusable = this.firstOperatorDropDown;
      this.firstOperatorDropDown.focus();
    }
  }
  operatorChange(dataItem) {
    this.currentOperator = dataItem;
  }
  filterChange(filter4) {
    this.applyFilter(filter4);
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this._currentFilter;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  set currentFilter(value2) {
    this._currentFilter = value2;
  }
  updateFilter(filter4) {
    Object.assign(this.currentFilter, filter4);
    return this.filter;
  }
  onChange(value2) {
    this.filterChange(this.updateFilter({
      field: this.column.field,
      operator: this.currentOperator,
      value: value2
    }));
  }
  onShiftTab(e) {
    e.stopImmediatePropagation();
    if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.isFirstDropDown && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuOperatorsDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
FilterMenuInputWrapperComponent.ɵfac = function FilterMenuInputWrapperComponent_Factory(t) {
  return new (t || FilterMenuInputWrapperComponent)(ɵɵdirectiveInject(ContextService));
};
FilterMenuInputWrapperComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterMenuInputWrapperComponent,
  selectors: [["kendo-grid-filter-menu-input-wrapper"]],
  viewQuery: function FilterMenuInputWrapperComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(DropDownListComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.firstOperatorDropDown = _t.first);
    }
  },
  inputs: {
    filterService: "filterService",
    isFirstDropDown: "isFirstDropDown",
    menuTabbingService: "menuTabbingService",
    currentFilter: "currentFilter"
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c16,
  decls: 2,
  vars: 4,
  consts: [["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 3, "valueChange", "keydown.shift.tab", "filterMenuDropDownLabel", "data", "value", "valuePrimitive"]],
  template: function FilterMenuInputWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "kendo-dropdownlist", 0);
      ɵɵlistener("valueChange", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
        return ctx.operatorChange($event);
      })("keydown.shift.tab", function FilterMenuInputWrapperComponent_Template_kendo_dropdownlist_keydown_shift_tab_0_listener($event) {
        return ctx.onShiftTab($event);
      });
      ɵɵelementEnd();
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("filterMenuDropDownLabel", ctx.filterMenuDropDownLabel)("data", ctx.operators)("value", ctx.currentOperator)("valuePrimitive", true);
    }
  },
  dependencies: [DropDownListComponent, FilterMenuDropDownListDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuInputWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu-input-wrapper",
      template: `
        <kendo-dropdownlist
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            [data]="operators"
            (valueChange)="operatorChange($event)"
            [value]="currentOperator"
            [valuePrimitive]="true"
            textField="text"
            valueField="value"
            (keydown.shift.tab)="onShiftTab($event)">
        </kendo-dropdownlist>
        <ng-content></ng-content>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    firstOperatorDropDown: [{
      type: ViewChild,
      args: [DropDownListComponent, {
        static: false
      }]
    }],
    currentFilter: [{
      type: Input
    }]
  });
})();
var StringFilterMenuInputComponent = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.operators = [];
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
StringFilterMenuInputComponent.ɵfac = function StringFilterMenuInputComponent_Factory(t) {
  return new (t || StringFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
};
StringFilterMenuInputComponent.ɵcmp = ɵɵdefineComponent({
  type: StringFilterMenuInputComponent,
  selectors: [["kendo-grid-string-filter-menu-input"]],
  inputs: {
    operators: "operators",
    column: "column",
    filter: "filter",
    operator: "operator",
    currentFilter: "currentFilter",
    filterService: "filterService",
    isFirstDropDown: "isFirstDropDown",
    menuTabbingService: "menuTabbingService"
  },
  decls: 2,
  vars: 11,
  consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoTextBox", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "ngModel"]],
  template: function StringFilterMenuInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0);
      ɵɵelement(1, "input", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
      ɵɵadvance();
      ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", 0)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    }
  },
  dependencies: [DefaultValueAccessor, NgControlStatus, NgModel, TextBoxDirective, FilterInputDirective, FilterMenuInputWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
            >
            <input
                kendoTextBox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                [ngModel]="currentFilter?.value" />
        </kendo-grid-filter-menu-input-wrapper>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var StringFilterMenuComponent = class extends StringFilterComponent {
  constructor(ctx) {
    super(null, ctx);
    this.logicOperators = logicOperators(this.ctx.localization);
    this.filter = {
      filters: [],
      logic: "and"
    };
    this.extra = true;
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
};
StringFilterMenuComponent.ɵfac = function StringFilterMenuComponent_Factory(t) {
  return new (t || StringFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
};
StringFilterMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: StringFilterMenuComponent,
  selectors: [["kendo-grid-string-filter-menu"]],
  hostVars: 2,
  hostBindings: function StringFilterMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell", ctx.hostClasses);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    extra: "extra",
    filterService: "filterService",
    menuTabbingService: "menuTabbingService"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 9,
  consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "menuTabbingService"]],
  template: function StringFilterMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "kendo-grid-string-filter-menu-input", 0);
      ɵɵtemplate(1, StringFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1)(2, StringFilterMenuComponent_kendo_grid_string_filter_menu_input_2_Template, 1, 6, "kendo-grid-string-filter-menu-input", 2);
    }
    if (rf & 2) {
      ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
    }
  },
  dependencies: [NgIf, DropDownListComponent, StringFilterMenuInputComponent, FilterMenuDropDownListDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-menu",
      template: `
        <kendo-grid-string-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true" (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-string-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [menuTabbingService]="menuTabbingService">
        </kendo-grid-string-filter-menu-input>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var numericOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterGteOperator": "gte",
  "filterGtOperator": "gt",
  "filterLteOperator": "lte",
  "filterLtOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var NumericFilterComponent = class extends BaseFilterCellComponent {
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.operator = "eq";
    this.step = 1;
    this.spinners = true;
    this.defaultOperators = numericOperators(this.ctx.localization);
  }
  /**
   * Specifies the number format used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   */
  get format() {
    return !isNullOrEmptyString2(this._format) ? this._format : this.columnFormat;
  }
  set format(value2) {
    this._format = value2;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString2(this.column.format) ? extractFormat(this.column.format) : "n2";
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = numericOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
};
NumericFilterComponent.ɵfac = function NumericFilterComponent_Factory(t) {
  return new (t || NumericFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
};
NumericFilterComponent.ɵdir = ɵɵdefineDirective({
  type: NumericFilterComponent,
  inputs: {
    column: "column",
    filter: "filter",
    operator: "operator",
    step: "step",
    min: "min",
    max: "max",
    spinners: "spinners",
    decimals: "decimals",
    format: "format"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuInputComponent = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.operators = [];
    this.step = 1;
    this.spinners = true;
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
NumericFilterMenuInputComponent.ɵfac = function NumericFilterMenuInputComponent_Factory(t) {
  return new (t || NumericFilterMenuInputComponent)(ɵɵdirectiveInject(ContextService));
};
NumericFilterMenuInputComponent.ɵcmp = ɵɵdefineComponent({
  type: NumericFilterMenuInputComponent,
  selectors: [["kendo-grid-numeric-filter-menu-input"]],
  inputs: {
    operators: "operators",
    column: "column",
    filter: "filter",
    operator: "operator",
    currentFilter: "currentFilter",
    filterService: "filterService",
    filterDelay: "filterDelay",
    isFirstDropDown: "isFirstDropDown",
    menuTabbingService: "menuTabbingService",
    step: "step",
    min: "min",
    max: "max",
    spinners: "spinners",
    decimals: "decimals",
    format: "format"
  },
  decls: 3,
  vars: 20,
  consts: [[3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "step"], [3, "increment", "decrement"]],
  template: function NumericFilterMenuInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 0)(1, "kendo-numerictextbox", 1);
      ɵɵelement(2, "kendo-numerictextbox-messages", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
      ɵɵadvance();
      ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step);
      ɵɵadvance();
      ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
    }
  },
  dependencies: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, FilterInputDirective, FilterMenuInputWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-numerictextbox
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [step]="step"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-menu-input-wrapper>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    format: [{
      type: Input
    }]
  });
})();
var NumericFilterMenuComponent = class extends NumericFilterComponent {
  constructor(ctx) {
    super(null, ctx);
    this.logicOperators = logicOperators(this.ctx.localization);
    this.filter = {
      filters: [],
      logic: "and"
    };
    this.extra = true;
    this.filterDelay = 500;
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
};
NumericFilterMenuComponent.ɵfac = function NumericFilterMenuComponent_Factory(t) {
  return new (t || NumericFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
};
NumericFilterMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: NumericFilterMenuComponent,
  selectors: [["kendo-grid-numeric-filter-menu"]],
  hostVars: 2,
  hostBindings: function NumericFilterMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell", ctx.hostClasses);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    extra: "extra",
    filterService: "filterService",
    filterDelay: "filterDelay",
    menuTabbingService: "menuTabbingService"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 16,
  consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "filterDelay", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", "isFirstDropDown"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "format", "decimals", "spinners", "min", "max", "step", "menuTabbingService"]],
  template: function NumericFilterMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "kendo-grid-numeric-filter-menu-input", 0);
      ɵɵtemplate(1, NumericFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1)(2, NumericFilterMenuComponent_kendo_grid_numeric_filter_menu_input_2_Template, 1, 12, "kendo-grid-numeric-filter-menu-input", 2);
    }
    if (rf & 2) {
      ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("filterDelay", ctx.filterDelay)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("step", ctx.step)("menuTabbingService", ctx.menuTabbingService)("isFirstDropDown", true);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
    }
  },
  dependencies: [NgIf, DropDownListComponent, NumericFilterMenuInputComponent, FilterMenuDropDownListDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-menu",
      template: `
        <kendo-grid-numeric-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [filterDelay]="filterDelay"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            [isFirstDropDown]="true"
            >
        </kendo-grid-numeric-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-numeric-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [format]="format"
            [decimals]="decimals"
            [spinners]="spinners"
            [min]="min"
            [max]="max"
            [step]="step"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-numeric-filter-menu-input>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    filterDelay: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var dateOperators = localizeOperators({
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterAfterOrEqualOperator": "gte",
  "filterAfterOperator": "gt",
  "filterBeforeOrEqualOperator": "lte",
  "filterBeforeOperator": "lt",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull"
});
var DateFilterComponent = class extends BaseFilterCellComponent {
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.operator = "gte";
    this.activeView = "month";
    this.bottomView = "month";
    this.topView = "century";
    this.weekNumber = false;
    this.defaultOperators = dateOperators(this.ctx.localization);
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * Specifies the date format that is used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   */
  set format(value2) {
    this._format = value2;
  }
  /**
   * Specifies the date format that is used when the component is not focused.
   * By default, the `column.format` value is used (if set).
   *
   * @readonly
   * @type {string}
   */
  get format() {
    return !isNullOrEmptyString2(this._format) ? this._format : this.columnFormat;
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  get columnFormat() {
    return this.column && !isNullOrEmptyString2(this.column.format) ? extractFormat(this.column.format) : "d";
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.defaultOperators = dateOperators(this.ctx.localization);
    if (this.operatorList.length) {
      this.operators = toJSON(this.operatorList.toArray());
    }
  }
};
DateFilterComponent.ɵfac = function DateFilterComponent_Factory(t) {
  return new (t || DateFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
};
DateFilterComponent.ɵcmp = ɵɵdefineComponent({
  type: DateFilterComponent,
  selectors: [["kendo-grid-date-filter-base"]],
  inputs: {
    column: "column",
    filter: "filter",
    operator: "operator",
    format: "format",
    min: "min",
    max: "max",
    formatPlaceholder: "formatPlaceholder",
    placeholder: "placeholder",
    activeView: "activeView",
    bottomView: "bottomView",
    topView: "topView",
    weekNumber: "weekNumber"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function DateFilterComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-base",
      template: ``
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }]
  });
})();
var DateFilterMenuInputComponent = class {
  constructor(popupService, ctx) {
    this.popupService = popupService;
    this.ctx = ctx;
    this.operators = [];
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  open(picker) {
    this.subscription = this.popupService.onClose.pipe(filter(() => picker.isActive)).subscribe((e) => e.preventDefault());
  }
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
DateFilterMenuInputComponent.ɵfac = function DateFilterMenuInputComponent_Factory(t) {
  return new (t || DateFilterMenuInputComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService));
};
DateFilterMenuInputComponent.ɵcmp = ɵɵdefineComponent({
  type: DateFilterMenuInputComponent,
  selectors: [["kendo-grid-date-filter-menu-input"]],
  inputs: {
    operators: "operators",
    column: "column",
    filter: "filter",
    operator: "operator",
    currentFilter: "currentFilter",
    filterService: "filterService",
    menuTabbingService: "menuTabbingService",
    format: "format",
    formatPlaceholder: "formatPlaceholder",
    placeholder: "placeholder",
    min: "min",
    max: "max",
    activeView: "activeView",
    bottomView: "bottomView",
    topView: "topView",
    weekNumber: "weekNumber",
    isFirstDropDown: "isFirstDropDown"
  },
  decls: 4,
  vars: 22,
  consts: [["picker", ""], [3, "column", "filter", "operators", "defaultOperator", "currentFilter", "filterService", "isFirstDropDown", "menuTabbingService"], ["kendoFilterInput", "", 3, "open", "columnLabel", "filterDelay", "value", "placeholder", "formatPlaceholder", "format", "min", "max", "activeView", "bottomView", "topView", "weekNumber"], [3, "toggle", "today"]],
  template: function DateFilterMenuInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "kendo-grid-filter-menu-input-wrapper", 1)(1, "kendo-datepicker", 2, 0);
      ɵɵlistener("open", function DateFilterMenuInputComponent_Template_kendo_datepicker_open_1_listener() {
        ɵɵrestoreView(_r1);
        const picker_r2 = ɵɵreference(2);
        return ɵɵresetView(ctx.open(picker_r2));
      });
      ɵɵelement(3, "kendo-datepicker-messages", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("currentFilter", ctx.currentFilter)("filterService", ctx.filterService)("isFirstDropDown", ctx.isFirstDropDown)("menuTabbingService", ctx.menuTabbingService);
      ɵɵadvance();
      ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", 0)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("placeholder", ctx.placeholder)("formatPlaceholder", ctx.formatPlaceholder)("format", ctx.format)("min", ctx.min)("max", ctx.max)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("weekNumber", ctx.weekNumber);
      ɵɵadvance(2);
      ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
    }
  },
  dependencies: [DatePickerComponent, DatePickerCustomMessagesComponent, FilterInputDirective, FilterMenuInputWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu-input",
      template: `
        <kendo-grid-filter-menu-input-wrapper
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [currentFilter]="currentFilter"
            [filterService]="filterService"
            [isFirstDropDown]="isFirstDropDown"
            [menuTabbingService]="menuTabbingService"
        >
            <kendo-datepicker
                #picker
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="0"
                (open)="open(picker)"
                [value]="currentFilter?.value"
                [placeholder]="placeholder"
                [formatPlaceholder]="formatPlaceholder"
                [format]="format"
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-menu-input-wrapper>
    `
    }]
  }], function() {
    return [{
      type: SinglePopupService
    }, {
      type: ContextService
    }];
  }, {
    operators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    operator: [{
      type: Input
    }],
    currentFilter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    formatPlaceholder: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    bottomView: [{
      type: Input
    }],
    topView: [{
      type: Input
    }],
    weekNumber: [{
      type: Input
    }],
    isFirstDropDown: [{
      type: Input
    }]
  });
})();
var DateFilterMenuComponent = class extends DateFilterComponent {
  constructor(ctx) {
    super(null, ctx);
    this.logicOperators = logicOperators(this.ctx.localization);
    this.filter = {
      filters: [],
      logic: "and"
    };
    this.extra = true;
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  get firstFilter() {
    return setFilter(0, this.filter, (this.column || {}).field, this.operator);
  }
  get secondFilter() {
    return setFilter(1, this.filter, (this.column || {}).field, this.operator);
  }
  logicChange(value2) {
    this.filter.logic = value2;
  }
  get filterMenuDropDownLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuLogicDropDownLabel") || "";
    const columnName = this.column ? this.column.title || this.column.field : "";
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  localizationChange() {
    this.logicOperators = logicOperators(this.ctx.localization);
    super.localizationChange();
  }
};
DateFilterMenuComponent.ɵfac = function DateFilterMenuComponent_Factory(t) {
  return new (t || DateFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
};
DateFilterMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: DateFilterMenuComponent,
  selectors: [["kendo-grid-date-filter-menu"]],
  hostVars: 2,
  hostBindings: function DateFilterMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell", ctx.hostClasses);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    extra: "extra",
    filterService: "filterService",
    menuTabbingService: "menuTabbingService"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 18,
  consts: [[3, "currentFilter", "operators", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "isFirstDropDown", "menuTabbingService"], ["kendoFilterMenuDropDown", "", "class", "k-filter-and", "textField", "text", "valueField", "value", 3, "filterMenuDropDownLabel", "data", "valuePrimitive", "value", "valueChange", 4, "ngIf"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService", 4, "ngIf"], ["kendoFilterMenuDropDown", "", "textField", "text", "valueField", "value", 1, "k-filter-and", 3, "valueChange", "filterMenuDropDownLabel", "data", "valuePrimitive", "value"], [3, "operators", "currentFilter", "filterService", "column", "filter", "activeView", "bottomView", "topView", "format", "formatPlaceholder", "placeholder", "min", "max", "weekNumber", "menuTabbingService"]],
  template: function DateFilterMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "kendo-grid-date-filter-menu-input", 0);
      ɵɵtemplate(1, DateFilterMenuComponent_kendo_dropdownlist_1_Template, 1, 4, "kendo-dropdownlist", 1)(2, DateFilterMenuComponent_kendo_grid_date_filter_menu_input_2_Template, 1, 15, "kendo-grid-date-filter-menu-input", 2);
    }
    if (rf & 2) {
      ɵɵproperty("currentFilter", ctx.firstFilter)("operators", ctx.operators)("filterService", ctx.filterService)("column", ctx.column)("filter", ctx.filter)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("format", ctx.format)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber)("isFirstDropDown", true)("menuTabbingService", ctx.menuTabbingService);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.extra);
    }
  },
  dependencies: [NgIf, DropDownListComponent, DateFilterMenuInputComponent, FilterMenuDropDownListDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-menu",
      template: `
        <kendo-grid-date-filter-menu-input
            [currentFilter]="firstFilter"
            [operators]="operators"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [isFirstDropDown]="true"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
        <kendo-dropdownlist
            *ngIf="extra"
            kendoFilterMenuDropDown
            [filterMenuDropDownLabel]="filterMenuDropDownLabel"
            class="k-filter-and"
            [data]="logicOperators"
            [valuePrimitive]="true"
            (valueChange)="logicChange($event)"
            [value]="filter?.logic"
            textField="text"
            valueField="value">
        </kendo-dropdownlist>
        <kendo-grid-date-filter-menu-input
            *ngIf="extra"
            [operators]="operators"
            [currentFilter]="secondFilter"
            [filterService]="filterService"
            [column]="column"
            [filter]="filter"
            [activeView]="activeView"
            [bottomView]="bottomView"
            [topView]="topView"
            [format]="format"
            [formatPlaceholder]="formatPlaceholder"
            [placeholder]="placeholder"
            [min]="min"
            [max]="max"
            [weekNumber]="weekNumber"
            [menuTabbingService]="menuTabbingService"
            >
        </kendo-grid-date-filter-menu-input>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    extra: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var BooleanFilterComponent = class extends BaseFilterCellComponent {
  constructor(filterService, ctx) {
    super(filterService);
    this.ctx = ctx;
    this.operator = "eq";
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return true;
  }
  /**
   * The current filter for the associated column field.
   * @readonly
   * @type {FilterDescriptor}
   */
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  /**
   * The current filter operator for the associated column field.
   * @readonly
   * @type {string}
   */
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : this.operator;
  }
  ngOnInit() {
    this.subscription = this.ctx.localization.changes.subscribe(this.localizationChange.bind(this));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.ngOnDestroy();
  }
  localizationChange() {
    this.items = [{
      text: this.ctx.localization.get("filterIsTrue"),
      value: true
    }, {
      text: this.ctx.localization.get("filterIsFalse"),
      value: false
    }];
    this.defaultItem = {
      text: this.ctx.localization.get("filterBooleanAll"),
      value: null
    };
  }
};
BooleanFilterComponent.ɵfac = function BooleanFilterComponent_Factory(t) {
  return new (t || BooleanFilterComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService));
};
BooleanFilterComponent.ɵcmp = ɵɵdefineComponent({
  type: BooleanFilterComponent,
  selectors: [["kendo-grid-boolean-filter-base"]],
  hostVars: 2,
  hostBindings: function BooleanFilterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell-boolean", ctx.hostClasses);
    }
  },
  inputs: {
    column: "column",
    filter: "filter"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function BooleanFilterComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-base",
      template: ``
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-boolean"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var BooleanFilterRadioButtonDirective = class {
  constructor(hostElement, renderer) {
    this.hostElement = hostElement;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    this.radioButtonEl = this.hostElement.nativeElement;
    this.renderer.setAttribute(this.hostElement.nativeElement, "aria-label", this.columnLabel);
  }
};
BooleanFilterRadioButtonDirective.ɵfac = function BooleanFilterRadioButtonDirective_Factory(t) {
  return new (t || BooleanFilterRadioButtonDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
BooleanFilterRadioButtonDirective.ɵdir = ɵɵdefineDirective({
  type: BooleanFilterRadioButtonDirective,
  selectors: [["", "kendoFilterMenuRadioButton", ""]],
  inputs: {
    columnLabel: "columnLabel"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterRadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuRadioButton]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    columnLabel: [{
      type: Input
    }]
  });
})();
var BooleanFilterMenuComponent = class extends BooleanFilterComponent {
  constructor(ctx) {
    super(null, ctx);
    this.filter = {
      filters: [],
      logic: "and"
    };
    this.idPrefix = guid();
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return false;
  }
  ngAfterViewInit() {
    this.filterService.menuTabbingService.firstFocusable = this.radioButtons.first.radioButtonEl;
    if (!this.menuTabbingService?.isTabbedInterface) {
      this.radioButtons.first.radioButtonEl.focus();
    }
  }
  /**
   * @hidden
   */
  radioId(value2) {
    return `${this.idPrefix}_${value2}`;
  }
  /**
   * @hidden
   */
  onChange(value2, input) {
    this.applyFilter(this.updateFilter({
      field: this.column.field,
      operator: "eq",
      value: value2
    }));
    this.filterService.menuTabbingService.firstFocusable = input;
  }
  /**
   * @hidden
   */
  isSelected(radioValue) {
    return this.filtersByField(this.column.field).some(({
      value: value2
    }) => value2 === radioValue);
  }
  /**
   * @hidden
   */
  onShiftTab(e) {
    if ((!this.menuTabbingService || !this.menuTabbingService.isColumnMenu) && this.filterService.menuTabbingService.lastFocusable) {
      e.preventDefault();
      this.filterService.menuTabbingService.lastFocusable.focus();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
BooleanFilterMenuComponent.ɵfac = function BooleanFilterMenuComponent_Factory(t) {
  return new (t || BooleanFilterMenuComponent)(ɵɵdirectiveInject(ContextService));
};
BooleanFilterMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: BooleanFilterMenuComponent,
  selectors: [["kendo-grid-boolean-filter-menu"]],
  viewQuery: function BooleanFilterMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(BooleanFilterRadioButtonDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radioButtons = _t);
    }
  },
  hostVars: 2,
  hostBindings: function BooleanFilterMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell", ctx.hostClasses);
    }
  },
  inputs: {
    filter: "filter",
    filterService: "filterService",
    menuTabbingService: "menuTabbingService"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [["input", ""], [1, "k-radio-list", "k-reset"], [4, "ngFor", "ngForOf"], ["type", "radio", "kendoFilterMenuRadioButton", "", "kendoRadioButton", "", 3, "change", "keydown.shift.tab", "columnLabel", "name", "checked"], [1, "k-radio-label"]],
  template: function BooleanFilterMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 1);
      ɵɵtemplate(1, BooleanFilterMenuComponent_li_1_Template, 5, 6, "li", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.items);
    }
  },
  dependencies: [NgForOf, RadioButtonDirective, BooleanFilterRadioButtonDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-menu",
      template: `
        <ul class="k-radio-list k-reset">
            <li *ngFor="let item of items">
                <input type="radio"
                    kendoFilterMenuRadioButton
                    [columnLabel]="columnLabel"
                    #input
                    [name]="idPrefix"
                    kendoRadioButton
                    [checked]="isSelected(item.value)"
                    [attr.id]="radioId(item.value)"
                    (change)="onChange(item.value, input)"
                    (keydown.shift.tab)="onShiftTab($event)"
                />
                <label class="k-radio-label" [attr.for]="radioId(item.value)">{{item.text}}</label>
            </li>
        </ul>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    filter: [{
      type: Input
    }],
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    radioButtons: [{
      type: ViewChildren,
      args: [BooleanFilterRadioButtonDirective]
    }]
  });
})();
var filterMenuComponentFactory = (type) => ({
  "boolean": BooleanFilterMenuComponent,
  "date": DateFilterMenuComponent,
  "numeric": NumericFilterMenuComponent,
  "text": StringFilterMenuComponent
})[type];
var FilterMenuHostDirective = class extends FilterHostDirective {
  constructor(host, resolver) {
    super(host, resolver);
  }
  componentType() {
    if (isPresent4(this.column) && !isNullOrEmptyString2(this.column.filter)) {
      return filterMenuComponentFactory(this.column.filter);
    }
    return StringFilterMenuComponent;
  }
  initComponent(ctx) {
    super.initComponent(ctx);
    this.component.instance.filterService = this.filterService;
    this.component.instance.menuTabbingService = this.menuTabbingService;
  }
};
FilterMenuHostDirective.ɵfac = function FilterMenuHostDirective_Factory(t) {
  return new (t || FilterMenuHostDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1));
};
FilterMenuHostDirective.ɵdir = ɵɵdefineDirective({
  type: FilterMenuHostDirective,
  selectors: [["", "kendoFilterMenuHost", ""]],
  inputs: {
    filterService: "filterService",
    menuTabbingService: "menuTabbingService"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterMenuHost]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: ComponentFactoryResolver$1
    }];
  }, {
    filterService: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }]
  });
})();
var isNoValueOperator = (operator) => operator === "isnull" || operator === "isnotnull" || operator === "isempty" || operator === "isnotempty";
var validFilters = ({
  value: value2,
  operator
}) => !isNullOrEmptyString2(value2) || isNoValueOperator(operator);
var trimFilters = (filter4) => {
  filter4.filters = filter4.filters.filter(validFilters);
  return filter4;
};
var findParent = (filters, field, parent) => {
  return filters.reduce((acc, filter4) => {
    if (acc) {
      return acc;
    }
    if (filter4.filters) {
      return findParent(filter4.filters, field, filter4);
    } else if (filter4.field === field) {
      return parent;
    }
    return acc;
  }, void 0);
};
var parentLogicOfDefault = (filter4, field, def = "and") => {
  const parent = findParent((filter4 || {}).filters || [], field);
  return isPresent4(parent) ? parent.logic : def;
};
var FilterMenuContainerComponent = class {
  constructor(parentService, childService, ctx, cd, menuTabbingService) {
    this.parentService = parentService;
    this.childService = childService;
    this.ctx = ctx;
    this.cd = cd;
    this.close = new EventEmitter();
    this.actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
    this._templateContext = {};
    this.menuTabbingService = menuTabbingService;
  }
  /**
   * The current root filter.
   * @type {CompositeFilterDescriptor}
   */
  set filter(value2) {
    this._filter = cloneFilters(value2);
  }
  get filter() {
    return this._filter;
  }
  get childFilter() {
    if (!isPresent4(this._childFilter)) {
      this._childFilter = {
        filters: filtersByField(this.filter, (this.column || {}).field),
        logic: parentLogicOfDefault(this.filter, (this.column || {}).field)
      };
    }
    return this._childFilter;
  }
  ngOnInit() {
    this.subscription = this.childService.changes.subscribe((filter4) => this._childFilter = filter4);
    this.subscription.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngAfterViewChecked() {
    if (!this.menuTabbingService.isColumnMenu || this.isLast && this.isExpanded) {
      this.menuTabbingService.lastFocusable = this.disabled ? this.resetButton.nativeElement : this.filterButton.nativeElement;
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.menuTabbingService.lastFocusable = void 0;
  }
  get disabled() {
    return !this.childFilter.filters.some(validFilters);
  }
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.childFilter;
    this._templateContext.filterService = this.childService;
    this._templateContext["$implicit"] = this.childFilter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent4(this.column) && isPresent4(this.column.filterMenuTemplateRef);
  }
  submit() {
    const filter4 = trimFilters(this.childFilter);
    if (filter4.filters.length) {
      const root = this.filter || {
        filters: [],
        logic: "and"
      };
      removeFilter(root, this.column.field);
      root.filters.push(filter4);
      this.parentService.filter(root);
    }
    this.close.emit();
    return false;
  }
  reset() {
    const root = this.filter || {
      filters: [],
      logic: "and"
    };
    removeFilter(root, this.column.field);
    this.parentService.filter(root);
    this.close.emit();
  }
  onTab(e, buttonType) {
    if (this.menuTabbingService.firstFocusable && (!this.menuTabbingService.isColumnMenu || this.isLast)) {
      e.preventDefault();
      if (buttonType === "reset") {
        this.menuTabbingService.firstFocusable.focus();
      } else {
        this.disabled ? this.menuTabbingService.firstFocusable.focus() : this.resetButton.nativeElement.focus();
      }
    }
  }
  get clearText() {
    return this.ctx.localization.get("filterClearButton");
  }
  get filterText() {
    return this.ctx.localization.get("filterFilterButton");
  }
};
FilterMenuContainerComponent.ɵfac = function FilterMenuContainerComponent_Factory(t) {
  return new (t || FilterMenuContainerComponent)(ɵɵdirectiveInject(FilterService, 4), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MenuTabbingService));
};
FilterMenuContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterMenuContainerComponent,
  selectors: [["kendo-grid-filter-menu-container"]],
  viewQuery: function FilterMenuContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c17, 5);
      ɵɵviewQuery(_c18, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterButton = _t.first);
    }
  },
  inputs: {
    column: "column",
    isLast: "isLast",
    isExpanded: "isExpanded",
    menuTabbingService: "menuTabbingService",
    filter: "filter",
    actionsClass: "actionsClass"
  },
  outputs: {
    close: "close"
  },
  features: [ɵɵProvidersFeature([FilterService, MenuTabbingService])],
  decls: 12,
  vars: 7,
  consts: [["filterButton", ""], ["resetButton", ""], [1, "k-filter-menu", 3, "submit", "reset"], [1, "k-filter-menu-container"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "ngClass"], ["type", "submit", 1, "k-button", "k-button-solid-primary", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab", "disabled"], ["type", "reset", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab"], ["kendoFilterMenuHost", "", 3, "filterService", "column", "filter", "menuTabbingService"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function FilterMenuContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "form", 2);
      ɵɵlistener("submit", function FilterMenuContainerComponent_Template_form_submit_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.submit());
      })("reset", function FilterMenuContainerComponent_Template_form_reset_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.reset());
      });
      ɵɵelementStart(1, "div", 3);
      ɵɵelementContainerStart(2, 4);
      ɵɵtemplate(3, FilterMenuContainerComponent_ng_container_3_Template, 2, 4, "ng-container", 5)(4, FilterMenuContainerComponent_ng_container_4_Template, 2, 1, "ng-container", 5);
      ɵɵelementContainerEnd();
      ɵɵelementStart(5, "div", 6)(6, "button", 7, 0);
      ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Template_button_keydown_tab_6_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onTab($event, "filter"));
      });
      ɵɵtext(8);
      ɵɵelementEnd();
      ɵɵelementStart(9, "button", 8, 1);
      ɵɵlistener("keydown.tab", function FilterMenuContainerComponent_Template_button_keydown_tab_9_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onTab($event, "reset"));
      });
      ɵɵtext(11);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngSwitch", ctx.hasTemplate);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", false);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", true);
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.actionsClass);
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.filterText);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.clearText);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, ɵNgNoValidate, NgControlStatusGroup, NgForm, FilterMenuHostDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuContainerComponent, [{
    type: Component,
    args: [{
      providers: [FilterService, MenuTabbingService],
      selector: "kendo-grid-filter-menu-container",
      template: `
        <form (submit)="submit()" (reset)="reset()"
            class="k-filter-menu">
            <div class="k-filter-menu-container">
                <ng-container [ngSwitch]="hasTemplate">
                    <ng-container *ngSwitchCase="false">
                        <ng-container
                            kendoFilterMenuHost
                            [filterService]="childService"
                            [column]="column"
                            [filter]="childFilter"
                            [menuTabbingService]="menuTabbingService">
                        </ng-container>
                    </ng-container>
                    <ng-container *ngSwitchCase="true">
                        <ng-template
                            *ngIf="column.filterMenuTemplateRef"
                            [ngTemplateOutlet]="column.filterMenuTemplateRef"
                            [ngTemplateOutletContext]="templateContext"
                            >
                        </ng-template>
                    </ng-container>
                </ng-container>
                <div [ngClass]="actionsClass">
                    <button #filterButton
                        type="submit"
                        class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        [disabled]="disabled"
                        (keydown.tab)="onTab($event, 'filter')">{{filterText}}</button>
                    <button
                        #resetButton
                        type="reset"
                        class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                        (keydown.tab)="onTab($event, 'reset')">{{clearText}}</button>
                </div>
            </div>
        </form>
    `
    }]
  }], function() {
    return [{
      type: FilterService,
      decorators: [{
        type: SkipSelf
      }]
    }, {
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MenuTabbingService
    }];
  }, {
    close: [{
      type: Output
    }],
    column: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    menuTabbingService: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    resetButton: [{
      type: ViewChild,
      args: ["resetButton", {
        static: false
      }]
    }],
    filterButton: [{
      type: ViewChild,
      args: ["filterButton", {
        static: false
      }]
    }]
  });
})();
var id$1 = 0;
var getId$1 = (gridId) => `${gridId}-filter-menu-${id$1++}`;
var FilterMenuComponent = class {
  constructor(filterService, popupService, ctx, navigationService, renderer, cdr, idService) {
    this.filterService = filterService;
    this.popupService = popupService;
    this.ctx = ctx;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this.cdr = cdr;
    this.idService = idService;
    this.filterIcon = filterIcon;
    this.tabIndex = "-1";
  }
  get hasFilters() {
    return filtersByField(this.filter, (this.column || {}).field).length > 0;
  }
  /**
   * @hidden
   */
  get filterLabel() {
    const localizationMsg = this.ctx.localization.get("filterMenuTitle") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  toggle(anchor2, template) {
    this.popupRef = this.popupService.open(anchor2, template, this.popupRef);
    const ariaRoot = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
    if (this.popupRef) {
      this.popupRef.popup.instance.close.pipe(take(1)).subscribe(() => {
        this.popupRef = null;
        const ariaRoot2 = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
        ariaRoot2 && this.renderer.removeAttribute(ariaRoot2, "aria-controls");
        ariaRoot2 && this.renderer.setAttribute(ariaRoot2, "aria-expanded", "false");
      });
      const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-filter-popup");
      if (popupAriaElement) {
        const popupId = getId$1(this.idService?.gridId());
        this.renderer.setAttribute(popupAriaElement, "id", popupId);
        this.renderer.setAttribute(popupAriaElement, "role", "dialog");
        this.renderer.setAttribute(popupAriaElement, "aria-label", this.filterLabel);
        ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
        ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
      }
    } else {
      if (this.navigationService.tableEnabled) {
        this.navigationService.focusCell(0, this.column.leafIndex);
      } else {
        this.anchor.nativeElement.focus();
      }
    }
    return false;
  }
  close() {
    this.popupService.destroy();
    this.popupRef = null;
    this.cdr.markForCheck();
    if (this.navigationService.tableEnabled) {
      this.navigationService.focusCell(0, this.column.leafIndex);
    } else {
      this.anchor.nativeElement.focus();
    }
  }
};
FilterMenuComponent.ɵfac = function FilterMenuComponent_Factory(t) {
  return new (t || FilterMenuComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IdService, 8));
};
FilterMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterMenuComponent,
  selectors: [["kendo-grid-filter-menu"]],
  viewQuery: function FilterMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c19, 7);
      ɵɵviewQuery(_c20, 7, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    tabIndex: "tabIndex"
  },
  decls: 5,
  vars: 7,
  consts: [["anchor", ""], ["template", ""], ["href", "#", 1, "k-grid-filter-menu", "k-grid-header-menu", 3, "click", "keydown.enter", "tabindex"], ["name", "filter", 3, "svgIcon"], [3, "close", "keydown.escape", "keydown.enter", "column", "filter"]],
  template: function FilterMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "a", 2, 0);
      ɵɵlistener("click", function FilterMenuComponent_Template_a_click_0_listener() {
        ɵɵrestoreView(_r1);
        const anchor_r2 = ɵɵreference(1);
        const template_r3 = ɵɵreference(4);
        return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
      })("keydown.enter", function FilterMenuComponent_Template_a_keydown_enter_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopImmediatePropagation());
      });
      ɵɵelement(2, "kendo-icon-wrapper", 3);
      ɵɵelementEnd();
      ɵɵtemplate(3, FilterMenuComponent_ng_template_3_Template, 1, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵclassProp("k-active", ctx.hasFilters);
      ɵɵproperty("tabindex", ctx.tabIndex);
      ɵɵattribute("title", ctx.filterLabel)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog")("aria-expanded", ctx.isNavigable ? void 0 : false);
      ɵɵadvance(2);
      ɵɵproperty("svgIcon", ctx.filterIcon);
    }
  },
  dependencies: [IconWrapperComponent, FilterMenuContainerComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-menu",
      template: `
        <a #anchor
            class="k-grid-filter-menu k-grid-header-menu"
            [class.k-active]="hasFilters"
            [tabindex]="tabIndex"
            (click)="toggle(anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [attr.title]="filterLabel"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'"
            [attr.aria-expanded]="isNavigable ? undefined : false">
            <kendo-icon-wrapper
                name="filter"
                [svgIcon]="filterIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-filter-menu-container
                [column]="column"
                [filter]="filter"
                (close)="close()"
                (keydown.escape)="close()"
                (keydown.enter)="$event.stopImmediatePropagation()"
                >
            </kendo-grid-filter-menu-container>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: SinglePopupService
    }, {
      type: ContextService
    }, {
      type: NavigationService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabIndex: [{
      type: Input
    }]
  });
})();
var ColumnMenuService = class {
  /**
   * @hidden
   */
  constructor(menuTabbingService) {
    this.closeMenu = new EventEmitter();
    this.menuTabbingService = menuTabbingService;
  }
  /**
   * Closes the column menu.
   */
  close() {
    this.closeMenu.emit();
  }
};
ColumnMenuService.ɵfac = function ColumnMenuService_Factory(t) {
  return new (t || ColumnMenuService)(ɵɵinject(MenuTabbingService));
};
ColumnMenuService.ɵprov = ɵɵdefineInjectable({
  token: ColumnMenuService,
  factory: ColumnMenuService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuService, [{
    type: Injectable
  }], function() {
    return [{
      type: MenuTabbingService
    }];
  }, null);
})();
var ColumnListKeyboardNavigation = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.activeIndex = 0;
  }
  next() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.min(this.activeIndex + 1, this.items.length - 1);
    this.toggle(this.activeIndex, true);
  }
  prev() {
    this.toggle(this.activeIndex, false);
    this.activeIndex = Math.max(this.activeIndex - 1, 0);
    this.toggle(this.activeIndex, true);
  }
  toggle(index, active) {
    const element = this.items[index]?.host.nativeElement;
    element && this.renderer.setAttribute(this.items[index].host.nativeElement, "tabindex", active ? "0" : "-1");
    active && element && element.focus();
  }
  toggleCheckedState() {
    this.items[this.activeIndex].host.nativeElement.firstElementChild.click();
  }
};
ColumnListKeyboardNavigation.ɵfac = function ColumnListKeyboardNavigation_Factory(t) {
  return new (t || ColumnListKeyboardNavigation)(ɵɵinject(Renderer2));
};
ColumnListKeyboardNavigation.ɵprov = ɵɵdefineInjectable({
  token: ColumnListKeyboardNavigation,
  factory: ColumnListKeyboardNavigation.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListKeyboardNavigation, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
var ColumnMenuChooserItemCheckedDirective = class {
  constructor(host, renderer) {
    this.host = host;
    this.renderer = renderer;
    this.checkedChangeSub = new Subscription();
  }
  ngAfterViewInit() {
    this.checkedChangeSub.add(this.renderer.listen(this.host.nativeElement.firstElementChild, "change", (e) => {
      this.kendoColumnMenuChooserItemChecked = e.target.checked;
    }));
  }
  ngOnDestroy() {
    this.checkedChangeSub.unsubscribe();
  }
};
ColumnMenuChooserItemCheckedDirective.ɵfac = function ColumnMenuChooserItemCheckedDirective_Factory(t) {
  return new (t || ColumnMenuChooserItemCheckedDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
ColumnMenuChooserItemCheckedDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnMenuChooserItemCheckedDirective,
  selectors: [["", "kendoColumnMenuChooserItemChecked", ""]],
  hostVars: 1,
  hostBindings: function ColumnMenuChooserItemCheckedDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-checked", ctx.kendoColumnMenuChooserItemChecked);
    }
  },
  inputs: {
    kendoColumnMenuChooserItemChecked: "kendoColumnMenuChooserItemChecked"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuChooserItemCheckedDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoColumnMenuChooserItemChecked]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    kendoColumnMenuChooserItemChecked: [{
      type: HostBinding,
      args: ["attr.aria-checked"]
    }, {
      type: Input
    }]
  });
})();
var ColumnListComponent = class {
  constructor(element, ngZone, renderer, listNavigationService) {
    this.element = element;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.listNavigationService = listNavigationService;
    this.reset = new EventEmitter();
    this.apply = new EventEmitter();
    this.columnChange = new EventEmitter();
    this.autoSync = true;
    this.allowHideAll = false;
    this.actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
    this.unlockedCount = 0;
    this.domSubscriptions = new Subscription();
    this.onKeydown = (e) => {
      if (e.keyCode !== Keys.Tab) {
        e.preventDefault();
      }
      if (e.keyCode === Keys.ArrowDown) {
        this.listNavigationService.next();
      } else if (e.keyCode === Keys.ArrowUp) {
        this.listNavigationService.prev();
      } else if (e.keyCode === Keys.Space && e.target.classList.contains("k-column-list-item")) {
        this.listNavigationService.toggleCheckedState();
      }
    };
  }
  get className() {
    return true;
  }
  isChecked(checkbox) {
    return checkbox.checked;
  }
  set columns(value2) {
    this._columns = value2.filter((column) => column.includeInChooser !== false);
    this.allColumns = value2;
    this.updateColumnState();
  }
  get columns() {
    return this._columns;
  }
  ngOnInit() {
    if (!this.element) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "click", (e) => {
        const closestItem = e.target.closest(".k-column-list-item");
        if (closestItem) {
          const checkbox = closestItem.querySelector(".k-checkbox");
          const index = parseInt(checkbox.getAttribute("data-index"), 10);
          if (e.target === checkbox) {
            closestItem.focus();
          } else {
            e.preventDefault();
            checkbox.checked = !checkbox.checked;
          }
          if (this.autoSync) {
            const column = this.columns[index];
            const hidden = !checkbox.checked;
            if (Boolean(column.hidden) !== hidden) {
              this.ngZone.run(() => {
                column.hidden = hidden;
                this.columnChange.emit([column]);
              });
            }
          } else {
            this.updateDisabled();
          }
          if (index !== this.listNavigationService.activeIndex) {
            this.listNavigationService.toggle(this.listNavigationService.activeIndex, false);
            this.listNavigationService.activeIndex = index;
            this.listNavigationService.toggle(index, true);
          }
        }
      }));
      this.domSubscriptions.add(this.renderer.listen(this.element.nativeElement, "keydown", this.onKeydown));
    });
  }
  ngAfterViewInit() {
    this.listNavigationService.items = this.options.toArray();
    this.listNavigationService.toggle(0, true);
    this.updateDisabled();
  }
  ngOnChanges(changes) {
    if (!this.service) {
      return;
    }
    if (changes["isLast"] && this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
    }
    if (changes["isExpanded"] && this.isExpanded && this.isLast && this.applyButton) {
      this.service.menuTabbingService.lastFocusable = this.applyButton.nativeElement;
    }
  }
  ngOnDestroy() {
    this.domSubscriptions.unsubscribe();
  }
  isDisabled(column) {
    return !(this.allowHideAll || this.hasFiltered || column.hidden || this.columns.find((current3) => current3 !== column && !current3.hidden)) || this.hasVisibleLocked && !this.hasUnlockedFiltered && this.unlockedCount === 1 && !column.locked && !column.hidden;
  }
  cancelChanges() {
    this.forEachCheckBox((element, index) => {
      element.checked = !this.columns[index].hidden;
    });
    this.updateDisabled();
    this.reset.emit();
  }
  applyChanges() {
    const changed = [];
    this.forEachCheckBox((element, index) => {
      const column = this.columns[index];
      const hidden = !element.checked;
      if (Boolean(column.hidden) !== hidden) {
        column.hidden = hidden;
        changed.push(column);
      }
    });
    this.updateDisabled();
    this.apply.emit(changed);
  }
  onTab(e) {
    if (this.isLast) {
      e.preventDefault();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      } else {
        this.listNavigationService.toggle(this.listNavigationService.activeIndex, true);
      }
    }
  }
  forEachCheckBox(callback) {
    const checkboxes = this.element.nativeElement.getElementsByClassName("k-checkbox");
    const length = checkboxes.length;
    for (let idx = 0; idx < length; idx++) {
      callback(checkboxes[idx], idx);
    }
  }
  updateDisabled() {
    if (this.allowHideAll && !this.hasLocked) {
      return;
    }
    const checkedItems = [];
    this.forEachCheckBox((checkbox, index) => {
      if (checkbox.checked) {
        checkedItems.push({
          checkbox,
          index
        });
      }
      this.setDisabledState(checkbox, false);
    });
    if (!this.allowHideAll && checkedItems.length === 1 && !this.hasFiltered) {
      this.setDisabledState(checkedItems[0].checkbox, true);
    } else if (this.hasLocked && !this.hasUnlockedFiltered) {
      const columns = this.columns;
      const checkedUnlocked = checkedItems.filter((item) => !columns[item.index].locked);
      if (checkedUnlocked.length === 1) {
        this.setDisabledState(checkedUnlocked[0].checkbox, true);
      }
    }
  }
  updateColumnState() {
    this.hasLocked = this.allColumns.filter((column) => column.locked && (!column.hidden || column.includeInChooser !== false)).length > 0;
    this.hasVisibleLocked = this.allColumns.filter((column) => column.locked && !column.hidden).length > 0;
    this.unlockedCount = this.columns.filter((column) => !column.locked && !column.hidden).length;
    const filteredColumns = this.allColumns.filter((column) => column.includeInChooser === false && !column.hidden);
    if (filteredColumns.length) {
      this.hasFiltered = filteredColumns.length > 0;
      this.hasUnlockedFiltered = filteredColumns.filter((column) => !column.locked).length > 0;
    } else {
      this.hasFiltered = false;
      this.hasUnlockedFiltered = false;
    }
  }
  setDisabledState(element, disabled) {
    element.disabled = disabled;
    const parent = element.parentElement;
    const classCommand = disabled ? "addClass" : "removeClass";
    const attributeCommand = disabled ? "setAttribute" : "removeAttribute";
    this.renderer[classCommand](parent, "k-disabled");
    this.renderer[attributeCommand](parent, "aria-disabled", disabled ? "true" : void 0);
  }
};
ColumnListComponent.ɵfac = function ColumnListComponent_Factory(t) {
  return new (t || ColumnListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ColumnListKeyboardNavigation));
};
ColumnListComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnListComponent,
  selectors: [["kendo-grid-columnlist"]],
  viewQuery: function ColumnListComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c17, 5);
      ɵɵviewQuery(_c21, 5);
      ɵɵviewQuery(ColumnMenuChooserItemCheckedDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resetButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.applyButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  hostVars: 2,
  hostBindings: function ColumnListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-column-list-wrapper", ctx.className);
    }
  },
  inputs: {
    columns: "columns",
    autoSync: "autoSync",
    ariaLabel: "ariaLabel",
    allowHideAll: "allowHideAll",
    applyText: "applyText",
    resetText: "resetText",
    actionsClass: "actionsClass",
    isLast: "isLast",
    isExpanded: "isExpanded",
    service: "service"
  },
  outputs: {
    reset: "reset",
    apply: "apply",
    columnChange: "columnChange"
  },
  features: [ɵɵProvidersFeature([ColumnListKeyboardNavigation]), ɵɵNgOnChangesFeature],
  decls: 3,
  vars: 3,
  consts: [["applyButton", ""], ["resetButton", ""], ["role", "listbox", "aria-multiselectable", "true", 1, "k-column-list"], ["class", "k-column-list-item", "role", "option", 3, "kendoColumnMenuChooserItemChecked", 4, "ngFor", "ngForOf"], [3, "ngClass", 4, "ngIf"], ["role", "option", 1, "k-column-list-item", 3, "kendoColumnMenuChooserItemChecked"], ["type", "checkbox", "tabindex", "-1", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md", 3, "checked", "disabled"], [1, "k-checkbox-label"], [3, "ngClass"], ["type", "button", 1, "k-button", "k-button-solid-primary", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "click", "keydown.enter", "keydown.space"], ["type", "button", 1, "k-button", "k-button-solid-base", "k-button-solid", "k-button-md", "k-rounded-md", "k-button-rectangle", 3, "keydown.tab", "click", "keydown.enter", "keydown.space"]],
  template: function ColumnListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 2);
      ɵɵtemplate(1, ColumnListComponent_label_1_Template, 4, 6, "label", 3);
      ɵɵelementEnd();
      ɵɵtemplate(2, ColumnListComponent_div_2_Template, 7, 3, "div", 4);
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.ariaLabel);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.columns);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.autoSync);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, ColumnMenuChooserItemCheckedDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnlist",
      providers: [ColumnListKeyboardNavigation],
      template: `
        <div 
            class="k-column-list"
            role="listbox"
            aria-multiselectable="true"
            [attr.aria-label]="ariaLabel">
            <label 
                *ngFor="let column of columns; let index = index;" 
                class='k-column-list-item'
                [kendoColumnMenuChooserItemChecked]="!column.hidden"
                role="option">
                <input 
                    class="k-checkbox k-checkbox-md k-rounded-md" 
                    type="checkbox" 
                    [attr.data-index]="index"
                    [checked]="!column.hidden" 
                    tabindex="-1"
                    [attr.aria-hidden]="true"
                    [disabled]="isDisabled(column)" />
                <span class="k-checkbox-label">{{ column.displayTitle }}</span>
            </label>
        </div>
        <div [ngClass]="actionsClass" *ngIf="!autoSync">
            <button
                #applyButton
                type="button"
                class="k-button k-button-solid-primary k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="applyChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; applyChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; applyChanges();">{{ applyText }}</button>
            <button
                #resetButton
                type="button"
                (keydown.tab)="onTab($event)"
                class="k-button k-button-solid-base k-button-solid k-button-md k-rounded-md k-button-rectangle"
                (click)="cancelChanges()"
                (keydown.enter)="$event.preventDefault(); $event.stopPropagation; cancelChanges();"
                (keydown.space)="$event.preventDefault(); $event.stopPropagation; cancelChanges();">{{ resetText }}</button>
        </div>
    `
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ColumnListKeyboardNavigation
    }];
  }, {
    className: [{
      type: HostBinding,
      args: ["class.k-column-list-wrapper"]
    }],
    reset: [{
      type: Output
    }],
    apply: [{
      type: Output
    }],
    columnChange: [{
      type: Output
    }],
    columns: [{
      type: Input
    }],
    autoSync: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    applyText: [{
      type: Input
    }],
    resetText: [{
      type: Input
    }],
    actionsClass: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    resetButton: [{
      type: ViewChild,
      args: ["resetButton", {
        static: false
      }]
    }],
    applyButton: [{
      type: ViewChild,
      args: ["applyButton", {
        static: false
      }]
    }],
    options: [{
      type: ViewChildren,
      args: [ColumnMenuChooserItemCheckedDirective]
    }]
  });
})();
var ColumnMenuItemBase = class {
  constructor() {
    this.hostClass = true;
  }
  ngOnInit() {
    if (isDevMode() && !this.service) {
      throw new Error(ColumnMenuErrorMessages.serviceInput);
    }
  }
  /**
   * @hidden
   */
  close() {
    this.service.close();
  }
};
ColumnMenuItemBase.ɵfac = function ColumnMenuItemBase_Factory(t) {
  return new (t || ColumnMenuItemBase)();
};
ColumnMenuItemBase.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuItemBase,
  selectors: [["kendo-grid-column-menu-item-base"]],
  hostVars: 2,
  hostBindings: function ColumnMenuItemBase_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-columnmenu-item-wrapper", ctx.hostClass);
    }
  },
  inputs: {
    service: "service"
  },
  decls: 0,
  vars: 0,
  template: function ColumnMenuItemBase_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemBase, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-menu-item-base",
      template: ``
    }]
  }], null, {
    service: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-columnmenu-item-wrapper"]
    }]
  });
})();
var ColumnMenuItemContentTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
ColumnMenuItemContentTemplateDirective.ɵfac = function ColumnMenuItemContentTemplateDirective_Factory(t) {
  return new (t || ColumnMenuItemContentTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
ColumnMenuItemContentTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnMenuItemContentTemplateDirective,
  selectors: [["", "kendoGridColumnMenuItemContentTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemContentTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItemContentTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ColumnMenuItemComponent = class {
  constructor() {
    this.itemClick = new EventEmitter();
    this.expand = new EventEmitter();
    this.collapse = new EventEmitter();
    this.contentState = "collapsed";
  }
  ngAfterViewInit() {
    this.contentTemplate && (this.contentId = `k-${guid()}`);
  }
  ngOnChanges(changes) {
    if (changes.expanded) {
      this.updateContentState();
    }
  }
  /**
   * @hidden
   */
  onClick(e) {
    this.itemClick.emit(e);
    if (this.contentTemplate) {
      this.expanded = !this.expanded;
      this.updateContentState();
      if (this.expanded) {
        this.expand.emit();
      } else {
        this.collapse.emit();
      }
    }
  }
  updateContentState() {
    this.contentState = this.expanded ? "expanded" : "collapsed";
  }
};
ColumnMenuItemComponent.ɵfac = function ColumnMenuItemComponent_Factory(t) {
  return new (t || ColumnMenuItemComponent)();
};
ColumnMenuItemComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuItemComponent,
  selectors: [["kendo-grid-columnmenu-item"]],
  contentQueries: function ColumnMenuItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnMenuItemContentTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    }
  },
  inputs: {
    icon: "icon",
    svgIcon: "svgIcon",
    text: "text",
    selected: "selected",
    disabled: "disabled",
    expanded: "expanded",
    service: "service"
  },
  outputs: {
    itemClick: "itemClick",
    expand: "expand",
    collapse: "collapse"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 10,
  consts: [["role", "button", 1, "k-columnmenu-item", 3, "click", "keydown.enter"], [3, "name", "svgIcon"], ["class", "k-columnmenu-item-content", 3, "overflow", 4, "ngIf"], [1, "k-columnmenu-item-content"], [3, "ngTemplateOutlet"]],
  template: function ColumnMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function ColumnMenuItemComponent_Template_div_click_0_listener($event) {
        return ctx.onClick($event);
      })("keydown.enter", function ColumnMenuItemComponent_Template_div_keydown_enter_0_listener($event) {
        return ctx.onClick($event);
      });
      ɵɵelement(1, "kendo-icon-wrapper", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ColumnMenuItemComponent_div_3_Template, 3, 5, "div", 2);
    }
    if (rf & 2) {
      ɵɵclassProp("k-selected", ctx.selected)("k-disabled", ctx.disabled);
      ɵɵattribute("aria-expanded", ctx.expanded)("aria-controls", ctx.expanded ? ctx.contentId : void 0);
      ɵɵadvance();
      ɵɵproperty("name", ctx.icon)("svgIcon", ctx.svgIcon);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.text, " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.contentTemplate);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, IconWrapperComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("state", [state("collapsed", style({
      display: "none"
    })), state("expanded", style({
      display: "block"
    })), transition("collapsed => expanded", [style({
      height: "0px",
      display: "block"
    }), animate("100ms ease-in", style({
      height: "*"
    }))]), transition("expanded => collapsed", [style({
      height: "*"
    }), animate("100ms ease-in", style({
      height: "0px"
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemComponent, [{
    type: Component,
    args: [{
      animations: [trigger("state", [state("collapsed", style({
        display: "none"
      })), state("expanded", style({
        display: "block"
      })), transition("collapsed => expanded", [style({
        height: "0px",
        display: "block"
      }), animate("100ms ease-in", style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate("100ms ease-in", style({
        height: "0px"
      }))])])],
      selector: "kendo-grid-columnmenu-item",
      template: `
        <div
            class="k-columnmenu-item"
            (click)="onClick($event)"
            (keydown.enter)="onClick($event)"
            [class.k-selected]="selected"
            [class.k-disabled]="disabled"
            role="button"
            [attr.aria-expanded]="expanded"
            [attr.aria-controls]="expanded ? contentId : undefined">
            <kendo-icon-wrapper
                [name]="icon"
                [svgIcon]="svgIcon"></kendo-icon-wrapper>
            {{ text }}
        </div>
        <div *ngIf="contentTemplate" [attr.id]="contentId" [@state]="contentState" [style.overflow]="'hidden'" class="k-columnmenu-item-content">
            <ng-container [ngTemplateOutlet]="contentTemplate.templateRef">
            </ng-container>
        <div>
    `
    }]
  }], null, {
    itemClick: [{
      type: Output
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    expanded: [{
      type: Input
    }],
    service: [{
      type: Input
    }],
    contentTemplate: [{
      type: ContentChild,
      args: [ColumnMenuItemContentTemplateDirective]
    }]
  });
})();
var ColumnMenuChooserComponent = class extends ColumnMenuItemBase {
  constructor(ctx, columnInfoService, changeDetector, hostElement) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
    this.expand = new EventEmitter();
    this.collapse = new EventEmitter();
    this.expanded = false;
    this.isLast = false;
    this.actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
    this.columnsIcon = columnsIcon;
  }
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close();
    if (changed.length) {
      this.changeDetector.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
};
ColumnMenuChooserComponent.ɵfac = function ColumnMenuChooserComponent_Factory(t) {
  return new (t || ColumnMenuChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
};
ColumnMenuChooserComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuChooserComponent,
  selectors: [["kendo-grid-columnmenu-chooser"]],
  inputs: {
    expanded: "expanded",
    isLast: "isLast"
  },
  outputs: {
    expand: "expand",
    collapse: "collapse"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [["icon", "columns", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "apply", "applyText", "resetText", "ariaLabel", "columns", "autoSync", "allowHideAll", "actionsClass", "isLast", "isExpanded", "service"]],
  template: function ColumnMenuChooserComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("collapse", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
        return ctx.onCollapse();
      })("expand", function ColumnMenuChooserComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
        return ctx.onExpand();
      });
      ɵɵtemplate(1, ColumnMenuChooserComponent_ng_template_1_Template, 1, 10, "ng-template", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.ctx.localization.get("columns"))("svgIcon", ctx.columnsIcon)("expanded", ctx.expanded);
    }
  },
  dependencies: [ColumnListComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-chooser",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnlist
                    [applyText]="ctx.localization.get('columnsApply')"
                    [resetText]="ctx.localization.get('columnsReset')"
                    [ariaLabel]="ctx.localization.get('columns')"
                    [columns]="columns"
                    [autoSync]="false"
                    [allowHideAll]="false"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    [service]="service"
                    (apply)="onApply($event)">
                </kendo-grid-columnlist>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuFilterComponent = class extends ColumnMenuItemBase {
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
    this.expand = new EventEmitter();
    this.collapse = new EventEmitter();
    this.expanded = false;
    this.isLast = false;
    this.actionsClass = "k-actions k-actions-stretched k-actions-horizontal";
    this.filterIcon = filterIcon;
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.hostElement.nativeElement.querySelector(".k-columnmenu-item");
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    this.expand.emit();
  }
};
ColumnMenuFilterComponent.ɵfac = function ColumnMenuFilterComponent_Factory(t) {
  return new (t || ColumnMenuFilterComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
};
ColumnMenuFilterComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuFilterComponent,
  selectors: [["kendo-grid-columnmenu-filter"]],
  inputs: {
    expanded: "expanded",
    isLast: "isLast"
  },
  outputs: {
    expand: "expand",
    collapse: "collapse"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [["icon", "filter", 3, "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass", "isLast", "isExpanded"]],
  template: function ColumnMenuFilterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("collapse", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
        return ctx.onCollapse();
      })("expand", function ColumnMenuFilterComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
        return ctx.onExpand();
      });
      ɵɵtemplate(1, ColumnMenuFilterComponent_ng_template_1_Template, 1, 6, "ng-template", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.ctx.localization.get("filter"))("svgIcon", ctx.filterIcon)("expanded", ctx.expanded);
    }
  },
  dependencies: [FilterMenuContainerComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuFilterComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-filter",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('filter')"
            icon="filter"
            [svgIcon]="filterIcon"
            [expanded]="expanded"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-filter-menu-container
                    [column]="service.column"
                    [menuTabbingService]="service.menuTabbingService"
                    [filter]="service.filter"
                    [actionsClass]="actionsClass"
                    [isLast]="isLast"
                    [isExpanded]="expanded"
                    (keydown.shift.tab)="$event.stopImmediatePropagation()"
                    (close)="close()">
                </kendo-grid-filter-menu-container>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuSortComponent = class extends ColumnMenuItemBase {
  constructor(ctx, sortService, renderer) {
    super();
    this.ctx = ctx;
    this.sortService = sortService;
    this.renderer = renderer;
    this.sortAscSmallIcon = sortAscSmallIcon;
    this.sortDescSmallIcon = sortDescSmallIcon;
  }
  get sortedAsc() {
    const descriptor = this.descriptor;
    return descriptor && (!descriptor.dir || descriptor.dir === "asc");
  }
  get sortedDesc() {
    const descriptor = this.descriptor;
    return descriptor && descriptor.dir === "desc";
  }
  /**
   * @hidden
   */
  toggleSort(dir2) {
    const field = this.service.column.field;
    const {
      mode,
      allowUnsort
    } = normalize$1(this.service.sortable);
    const descriptor = this.descriptor;
    const sort2 = mode === "multiple" ? this.service.sort.filter((s) => s.field !== field) : [];
    if (descriptor && descriptor.dir === dir2) {
      if (!allowUnsort) {
        return;
      }
    } else {
      sort2.push({
        field,
        dir: dir2
      });
    }
    this.sortService.sort(sort2);
    this.close();
  }
  get descriptor() {
    return [].concat(this.service.sort || []).find((s) => s.field === this.service.column.field);
  }
};
ColumnMenuSortComponent.ɵfac = function ColumnMenuSortComponent_Factory(t) {
  return new (t || ColumnMenuSortComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(Renderer2));
};
ColumnMenuSortComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuSortComponent,
  selectors: [["kendo-grid-columnmenu-sort"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 6,
  consts: [["icon", "sort-asc-small", 3, "itemClick", "text", "svgIcon", "selected"], ["icon", "sort-desc-small", 3, "itemClick", "text", "svgIcon", "selected"]],
  template: function ColumnMenuSortComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
        return ctx.toggleSort("asc");
      });
      ɵɵelementEnd();
      ɵɵelementStart(1, "kendo-grid-columnmenu-item", 1);
      ɵɵlistener("itemClick", function ColumnMenuSortComponent_Template_kendo_grid_columnmenu_item_itemClick_1_listener() {
        return ctx.toggleSort("desc");
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.ctx.localization.get("sortAscending"))("svgIcon", ctx.sortAscSmallIcon)("selected", ctx.sortedAsc);
      ɵɵadvance();
      ɵɵproperty("text", ctx.ctx.localization.get("sortDescending"))("svgIcon", ctx.sortDescSmallIcon)("selected", ctx.sortedDesc);
    }
  },
  dependencies: [ColumnMenuItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuSortComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-sort",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortAscending')"
            icon="sort-asc-small"
            [svgIcon]="sortAscSmallIcon"
            (itemClick)="toggleSort('asc')"
            [selected]="sortedAsc">
        </kendo-grid-columnmenu-item>
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('sortDescending')"
            icon="sort-desc-small"
            [svgIcon]="sortDescSmallIcon"
            (itemClick)="toggleSort('desc')"
            [selected]="sortedDesc">
        </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: SortService
    }, {
      type: Renderer2
    }];
  }, null);
})();
var ColumnMenuLockComponent = class extends ColumnMenuItemBase {
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
    this.unlockIcon = unlockIcon;
    this.lockIcon = lockIcon;
  }
  get text() {
    return this.ctx.localization.get(this.locked ? "unlock" : "lock");
  }
  get icon() {
    return this.locked ? "unlock" : "lock";
  }
  get svgIcon() {
    return this.locked ? this.unlockIcon : this.lockIcon;
  }
  get disabled() {
    return !this.locked && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.locked);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(locked) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.locked = locked;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeLocked(allChanged);
  }
  get locked() {
    return this.service.column.locked;
  }
};
ColumnMenuLockComponent.ɵfac = function ColumnMenuLockComponent_Factory(t) {
  return new (t || ColumnMenuLockComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ColumnMenuLockComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuLockComponent,
  selectors: [["kendo-grid-columnmenu-lock"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 4,
  consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
  template: function ColumnMenuLockComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("itemClick", function ColumnMenuLockComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
        return ctx.toggleColumn();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
    }
  },
  dependencies: [ColumnMenuItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuLockComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-lock",
      template: `
       <kendo-grid-columnmenu-item
            [text]="text"
            [icon]="icon"
            [svgIcon]="svgIcon"
            (itemClick)="toggleColumn()"
            [disabled]="disabled">
       </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ColumnMenuStickComponent = class extends ColumnMenuItemBase {
  constructor(ctx, columnInfoService, changeDetector) {
    super();
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.changeDetector = changeDetector;
    this.stickIcon = stickIcon;
    this.unstickIcon = unstickIcon;
  }
  get text() {
    return this.ctx.localization.get(this.sticky ? "unstick" : "stick");
  }
  get icon() {
    return this.sticky ? "unstick" : "stick";
  }
  get svgIcon() {
    return this.sticky ? this.unstickIcon : this.stickIcon;
  }
  get disabled() {
    return !this.sticky && this.columnInfoService.unlockedRootCount < 2;
  }
  /**
   * @hidden
   */
  toggleColumn() {
    this.toggleHierarchy(!this.sticky);
    this.close();
    this.changeDetector.markForCheck();
  }
  toggleHierarchy(sticky) {
    let root = this.service.column;
    while (root.parent) {
      root = root.parent;
    }
    const columns = [root];
    const allChanged = [];
    while (columns.length) {
      const column = columns.shift();
      column.sticky = sticky;
      allChanged.push(column);
      if (column.hasChildren) {
        columns.push(...column.childrenArray);
      }
    }
    this.columnInfoService.changeStuck(allChanged);
  }
  get sticky() {
    return this.service.column.sticky;
  }
};
ColumnMenuStickComponent.ɵfac = function ColumnMenuStickComponent_Factory(t) {
  return new (t || ColumnMenuStickComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ColumnMenuStickComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuStickComponent,
  selectors: [["kendo-grid-columnmenu-stick"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 4,
  consts: [[3, "itemClick", "text", "icon", "svgIcon", "disabled"]],
  template: function ColumnMenuStickComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("itemClick", function ColumnMenuStickComponent_Template_kendo_grid_columnmenu_item_itemClick_0_listener() {
        return ctx.toggleColumn();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.text)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("disabled", ctx.disabled);
    }
  },
  dependencies: [ColumnMenuItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuStickComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-stick",
      template: `
        <kendo-grid-columnmenu-item
           [text]="text"
           [icon]="icon"
           [svgIcon]="svgIcon"
           (itemClick)="toggleColumn()"
           [disabled]="disabled">
        </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ColumnMenuPositionComponent = class extends ColumnMenuItemBase {
  constructor(ctx, hostElement) {
    super();
    this.ctx = ctx;
    this.hostElement = hostElement;
    this.expand = new EventEmitter();
    this.collapse = new EventEmitter();
    this.expanded = false;
    this.actionsClass = "k-actions";
    this.setColumnPositionIcon = setColumnPositionIcon;
    this._isLast = false;
  }
  /**
   * @hidden
   */
  set isLast(value2) {
    this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    this._isLast = value2;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  /**
   * @hidden
   */
  onTab(e, isLastItem) {
    if (this.isLast && isLastItem) {
      e.preventDefault();
      e.stopImmediatePropagation();
      if (this.service) {
        this.service.menuTabbingService.firstFocusable.focus();
      }
    }
  }
  /**
   * @hidden
   */
  onCollapse() {
    this.expanded = false;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.collapse.emit();
  }
  /**
   * @hidden
   */
  onExpand() {
    this.expanded = true;
    if (this.isLast) {
      this.service.menuTabbingService.lastFocusable = this.getLastFocusableItem();
    }
    this.expand.emit();
  }
  getLastFocusableItem() {
    const menuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    const lastFocusableIndex = this.expanded ? menuItems.length - 1 : 0;
    return menuItems[lastFocusableIndex];
  }
};
ColumnMenuPositionComponent.ɵfac = function ColumnMenuPositionComponent_Factory(t) {
  return new (t || ColumnMenuPositionComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
};
ColumnMenuPositionComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuPositionComponent,
  selectors: [["kendo-grid-columnmenu-position"]],
  inputs: {
    expanded: "expanded",
    showLock: "showLock",
    showStick: "showStick",
    isLast: "isLast"
  },
  outputs: {
    expand: "expand",
    collapse: "collapse"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 3,
  consts: [["icon", "set-column-position", 3, "keydown.tab", "collapse", "expand", "text", "svgIcon", "expanded"], ["kendoGridColumnMenuItemContentTemplate", ""], [3, "service", "keydown.tab", 4, "ngIf"], [3, "keydown.tab", "service"]],
  template: function ColumnMenuPositionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-columnmenu-item", 0);
      ɵɵlistener("keydown.tab", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_keydown_tab_0_listener($event) {
        return ctx.onTab($event, !ctx.expanded);
      })("collapse", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_collapse_0_listener() {
        return ctx.onCollapse();
      })("expand", function ColumnMenuPositionComponent_Template_kendo_grid_columnmenu_item_expand_0_listener() {
        return ctx.onExpand();
      });
      ɵɵtemplate(1, ColumnMenuPositionComponent_ng_template_1_Template, 2, 2, "ng-template", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("text", ctx.ctx.localization.get("setColumnPosition"))("svgIcon", ctx.setColumnPositionIcon)("expanded", ctx.expanded);
    }
  },
  dependencies: [NgIf, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuLockComponent, ColumnMenuStickComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuPositionComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-position",
      template: `
        <kendo-grid-columnmenu-item
            [text]="ctx.localization.get('setColumnPosition')"
            icon="set-column-position"
            [svgIcon]="setColumnPositionIcon"
            [expanded]="expanded"
            (keydown.tab)="onTab($event, !expanded)"
            (collapse)="onCollapse()"
            (expand)="onExpand()">
            <ng-template kendoGridColumnMenuItemContentTemplate>
                <kendo-grid-columnmenu-lock
                    *ngIf="showLock"
                    (keydown.tab)="onTab($event, !showStick)"
                    [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick
                    *ngIf="showStick"
                    (keydown.tab)="onTab($event, true)"
                    [service]="service">
                </kendo-grid-columnmenu-stick>
            </ng-template>
        </kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    showLock: [{
      type: Input
    }],
    showStick: [{
      type: Input
    }],
    isLast: [{
      type: Input
    }]
  });
})();
var ColumnMenuItemDirective = class {
  constructor(hostElement, renderer, ngZone) {
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this._isFirst = false;
    this._isLast = false;
    this.subs = new Subscription();
    this.onTab = (e) => {
      if (e.keyCode !== Keys.Tab) {
        return;
      }
      if (this.isFirst && e.shiftKey && e.target === this.columnMenuItems[0]) {
        e.preventDefault();
        this.menuItemComponent.service.menuTabbingService.lastFocusable.focus();
      }
      if (this.isLast && !e.shiftKey) {
        const lastColumnMenuItem = this.getLastColumnMenuItem();
        const isExpanded = this.menuItemComponent.expanded;
        if (lastColumnMenuItem === e.target && !isExpanded) {
          e.preventDefault();
          this.menuItemComponent.service.menuTabbingService.firstFocusable.focus();
        }
      }
    };
  }
  /**
   * @hidden
   */
  set isFirst(value2) {
    if (value2) {
      const focusableElement = this.columnMenuItems[0];
      this.menuItemComponent.service.menuTabbingService.firstFocusable = focusableElement;
      this.ngZone.runOutsideAngular(() => {
        const firstItemKeydownSub = this.renderer.listen(focusableElement, "keydown", this.onTab);
        this.subs.add(firstItemKeydownSub);
      });
    }
    this._isFirst = value2;
  }
  /**
   * @hidden
   */
  get isFirst() {
    return this._isFirst;
  }
  /**
   * @hidden
   */
  set isLast(value2) {
    if (!this.columnMenuItems) {
      return;
    }
    if (value2) {
      const lastFocusableElement = this.getLastColumnMenuItem();
      this.menuItemComponent.service.menuTabbingService.lastFocusable = lastFocusableElement;
      this.ngZone.runOutsideAngular(() => {
        const lastItemKeydownSub = this.renderer.listen(lastFocusableElement, "keydown", this.onTab);
        this.subs.add(lastItemKeydownSub);
      });
      if (this.isExpandableItem()) {
        this.menuItemComponent.isLast = true;
      }
    }
    this._isLast = value2;
  }
  /**
   * @hidden
   */
  get isLast() {
    return this._isLast;
  }
  ngAfterViewInit() {
    this.columnMenuItems = this.hostElement.nativeElement.querySelectorAll(".k-columnmenu-item");
    [].slice.apply(this.columnMenuItems).forEach((el) => this.renderer.setAttribute(el, "tabindex", "0"));
    if (this.menuItemComponent instanceof ColumnMenuFilterComponent) {
      this.menuItemComponent.service.menuTabbingService.isColumnMenu = true;
    }
    this.menuItemComponent.service?.columnMenuContainer.templateMenuItems.push(this);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  getLastColumnMenuItem() {
    return this.columnMenuItems.length === 1 ? this.columnMenuItems[0] : this.columnMenuItems[1];
  }
  isExpandableItem() {
    return this.menuItemComponent instanceof ColumnMenuFilterComponent || this.menuItemComponent instanceof ColumnMenuChooserComponent || this.menuItemComponent instanceof ColumnMenuPositionComponent;
  }
};
ColumnMenuItemDirective.ɵfac = function ColumnMenuItemDirective_Factory(t) {
  return new (t || ColumnMenuItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
ColumnMenuItemDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnMenuItemDirective,
  selectors: [["", "kendoGridColumnMenuItem", ""]],
  inputs: {
    menuItemComponent: [0, "kendoGridColumnMenuItem", "menuItemComponent"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnMenuItem]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    menuItemComponent: [{
      type: Input,
      args: ["kendoGridColumnMenuItem"]
    }]
  });
})();
var ColumnMenuContainerComponent = class {
  constructor(service, ngZone) {
    this.service = service;
    this.ngZone = ngZone;
    this.templateMenuItems = [];
    service.columnMenuContainer = this;
  }
  ngAfterViewInit() {
    if (this.columnMenuItems.length) {
      this.columnMenuItems.first.isFirst = true;
      this.columnMenuItems.last.isLast = true;
    } else if (this.templateMenuItems.length) {
      this.templateMenuItems[0].isFirst = true;
      this.templateMenuItems[this.templateMenuItems.length - 1].isLast = true;
    } else {
      return;
    }
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.service.menuTabbingService.firstFocusable.focus());
  }
};
ColumnMenuContainerComponent.ɵfac = function ColumnMenuContainerComponent_Factory(t) {
  return new (t || ColumnMenuContainerComponent)(ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(NgZone));
};
ColumnMenuContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuContainerComponent,
  selectors: [["kendo-grid-columnmenu-container"]],
  contentQueries: function ColumnMenuContainerComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnMenuItemDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuItems = _t);
    }
  },
  ngContentSelectors: _c16,
  decls: 1,
  vars: 0,
  template: function ColumnMenuContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-container",
      template: `
        <ng-content></ng-content>
    `
    }]
  }], function() {
    return [{
      type: ColumnMenuService
    }, {
      type: NgZone,
      decorators: [{
        type: Inject,
        args: [NgZone]
      }]
    }];
  }, {
    columnMenuItems: [{
      type: ContentChildren,
      args: [ColumnMenuItemDirective, {
        descendants: true
      }]
    }]
  });
})();
var ColumnMenuAutoSizeColumnComponent = class extends ColumnMenuItemBase {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.maxWidthIcon = maxWidthIcon;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeColumn);
    }
  }
  /**
   * Resizes a specified column to the minimum possible width so that it fits the widest header or cell content without wrapping.
   */
  autoSizeColumn() {
    autoSizeColumn(this.ctx.grid, this.service, this.column);
  }
};
ColumnMenuAutoSizeColumnComponent.ɵfac = function ColumnMenuAutoSizeColumnComponent_Factory(t) {
  return new (t || ColumnMenuAutoSizeColumnComponent)(ɵɵdirectiveInject(ContextService));
};
ColumnMenuAutoSizeColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuAutoSizeColumnComponent,
  selectors: [["kendo-grid-columnmenu-autosize-column"]],
  inputs: {
    column: "column"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "k-grid-columnmenu-autosize-column", "icon", "max-width", 3, "text", "svgIcon", "itemClick", 4, "ngIf"], ["icon", "max-width", 1, "k-grid-columnmenu-autosize-column", 3, "itemClick", "text", "svgIcon"]],
  template: function ColumnMenuAutoSizeColumnComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ColumnMenuAutoSizeColumnComponent_kendo_grid_columnmenu_item_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.ctx.grid.virtualColumns);
    }
  },
  dependencies: [NgIf, ColumnMenuItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeColumnComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-column",
      template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            class="k-grid-columnmenu-autosize-column"
            [text]="ctx.localization.get('autosizeThisColumn')"
            icon="max-width"
            [svgIcon]="maxWidthIcon"
            (itemClick)="autoSizeColumn()"
        ></kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, {
    column: [{
      type: Input
    }]
  });
})();
var ColumnMenuAutoSizeAllColumnsComponent = class extends ColumnMenuItemBase {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.displayInlineFlexIcon = displayInlineFlexIcon;
  }
  ngOnInit() {
    const isVirtualColumns = this.ctx.grid.columnMenuTemplate && this.ctx.grid.virtualColumns;
    if (isVirtualColumns && isDevMode()) {
      console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
    }
  }
  /**
   * Resizes all columns to the minimum possible width so that they fit the widest header or cell content without wrapping.
   */
  autoSizeAllColumns() {
    autoSizeColumn(this.ctx.grid, this.service);
  }
};
ColumnMenuAutoSizeAllColumnsComponent.ɵfac = function ColumnMenuAutoSizeAllColumnsComponent_Factory(t) {
  return new (t || ColumnMenuAutoSizeAllColumnsComponent)(ɵɵdirectiveInject(ContextService));
};
ColumnMenuAutoSizeAllColumnsComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuAutoSizeAllColumnsComponent,
  selectors: [["kendo-grid-columnmenu-autosize-all-columns"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 1,
  consts: [["icon", "display-inline-flex", 3, "text", "svgIcon", "itemClick", 4, "ngIf"], ["icon", "display-inline-flex", 3, "itemClick", "text", "svgIcon"]],
  template: function ColumnMenuAutoSizeAllColumnsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ColumnMenuAutoSizeAllColumnsComponent_kendo_grid_columnmenu_item_0_Template, 1, 2, "kendo-grid-columnmenu-item", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.ctx.grid.virtualColumns);
    }
  },
  dependencies: [NgIf, ColumnMenuItemComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuAutoSizeAllColumnsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-columnmenu-autosize-all-columns",
      template: `
        <kendo-grid-columnmenu-item
            *ngIf="!this.ctx.grid.virtualColumns"
            [text]="ctx.localization.get('autosizeAllColumns')"
            icon="display-inline-flex"
            [svgIcon]="displayInlineFlexIcon"
            (itemClick)="autoSizeAllColumns()"
        ></kendo-grid-columnmenu-item>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var POPUP_CLASSES = "k-grid-columnmenu-popup k-column-menu";
var id = 0;
var getId = (gridId) => `${gridId}-column-menu-${id++}`;
var ColumnMenuComponent = class {
  constructor(navigationService, popupService, service, ctx, renderer, cdr, columnInfoService, idService) {
    this.navigationService = navigationService;
    this.popupService = popupService;
    this.service = service;
    this.ctx = ctx;
    this.renderer = renderer;
    this.cdr = cdr;
    this.columnInfoService = columnInfoService;
    this.idService = idService;
    this.standalone = true;
    this.settings = {};
    this.sortable = true;
    this.tabIndex = "-1";
    this.columnsIcon = columnsIcon;
    this.actionsClass = "k-actions";
    this.slidersIcon = slidersIcon;
    this.filterIcon = filterIcon;
    this.expandedFilter = false;
    this.expandedColumns = false;
    this.expandedPosition = false;
    this.moreVerticalIcon = moreVerticalIcon;
    this.closeSubscription = service.closeMenu.subscribe(this.close.bind(this, true));
  }
  /**
   * @hidden
   */
  get showGeneralTab() {
    return this.hasSort || this.hasLock || this.hasStick || this.hasPosition || this.hasAutoSizeColumn || this.hasAutoSizeAllColumns;
  }
  /**
   * @hidden
   */
  get isActive() {
    return this.hasFilter && filtersByField(this.filter, this.column.field).length > 0 || !this.sortable && this.hasSort && this.sort.find((descriptor) => descriptor.field === this.column.field);
  }
  /**
   * @hidden
   */
  get hasFilter() {
    return hasFilter(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   * @hidden
   */
  get hasSort() {
    return hasSort(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasColumnChooser() {
    return hasColumnChooser(this.settings);
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close(true);
    if (changed.length) {
      this.cdr.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  get hasAutoSizeColumn() {
    return hasAutoSizeColumn(this.settings);
  }
  /**
   * @hidden
   */
  get hasAutoSizeAllColumns() {
    return hasAutoSizeAllColumns(this.settings);
  }
  /**
   * @hidden
   */
  get hasLock() {
    return hasLock(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasStick() {
    return hasStick(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get hasPosition() {
    return hasPosition(this.settings, this.column);
  }
  /**
   * @hidden
   */
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  ngAfterViewInit() {
    if (this.ctx.grid.virtualColumns && isDevMode()) {
      if (this.settings.autoSizeAllColumns) {
        this.settings.autoSizeAllColumns = false;
        console.warn(ColumnMenuErrorMessages.autoSizeAllColumns);
      }
      if (this.settings.autoSizeColumn) {
        this.settings.autoSizeColumn = false;
        console.warn(ColumnMenuErrorMessages.autoSizeColumn);
      }
    }
    this.service.menuTabbingService.isTabbedInterface = this.settings.view === "tabbed" ? true : false;
  }
  ngOnChanges() {
    this.service.column = this.column;
    this.service.sort = this.sort;
    this.service.filter = this.filter;
    this.service.sortable = this.sortable;
  }
  ngOnDestroy() {
    this.close();
    this.closeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  toggle(e, anchor2, template) {
    if (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    this.expandedFilter = this.getExpandedState(this.settings.filter);
    this.expandedColumns = this.getExpandedState(this.settings.columnChooser);
    this.expandedPosition = this.getExpandedState(this.settings.setColumnPosition);
    this.popupRef = this.popupService.open(anchor2, template, this.popupRef, POPUP_CLASSES);
    const ariaRoot = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
    if (this.popupRef) {
      this.popupRef.popup.instance.close.pipe(take(1)).subscribe(() => {
        this.popupRef = null;
        const ariaRoot2 = this.isNavigable ? anchor2.closest(".k-table-th") : anchor2;
        ariaRoot2 && this.renderer.removeAttribute(ariaRoot2, "aria-controls");
        ariaRoot2 && this.renderer.setAttribute(ariaRoot2, "aria-expanded", "false");
      });
      const popupAriaElement = this.popupRef.popupElement.querySelector(".k-grid-columnmenu-popup");
      if (popupAriaElement) {
        const popupId = getId(this.idService?.gridId());
        this.renderer.setAttribute(popupAriaElement, "id", popupId);
        this.renderer.setAttribute(popupAriaElement, "role", "dialog");
        this.renderer.setAttribute(popupAriaElement, "aria-label", this.columnMenuTitle);
        ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-controls", popupId);
        ariaRoot && this.renderer.setAttribute(ariaRoot, "aria-expanded", "true");
      }
      if (this.settings.view === "tabbed") {
        this.renderer.addClass(popupAriaElement, "k-column-menu-tabbed");
        this.renderer.addClass(popupAriaElement, "k-column-menu");
        this.cdr.detectChanges();
        this.tabStrip?.selectTab(0);
      }
    } else {
      if (this.navigationService.tableEnabled) {
        this.navigationService.focusCell(0, this.column.leafIndex);
      } else {
        this.anchor.nativeElement.focus();
      }
    }
  }
  /**
   * @hidden
   */
  close(triggerFocus = false) {
    this.popupService.destroy();
    this.popupRef = null;
    this.cdr.markForCheck();
    if (!triggerFocus) {
      return;
    }
    if (this.navigationService.tableEnabled) {
      this.navigationService.focusCell(0, this.column.leafIndex);
    } else {
      this.anchor.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  get columnMenuTitle() {
    const localizationMsg = this.ctx.localization.get("columnMenu") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  getExpandedState(menuItemSettings) {
    return typeof menuItemSettings === "object" ? menuItemSettings.expanded : false;
  }
};
ColumnMenuComponent.ɵfac = function ColumnMenuComponent_Factory(t) {
  return new (t || ColumnMenuComponent)(ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(ColumnMenuService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(IdService, 8));
};
ColumnMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnMenuComponent,
  selectors: [["kendo-grid-column-menu"]],
  viewQuery: function ColumnMenuComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c19, 7);
      ɵɵviewQuery(_c20, 7, TemplateRef);
      ɵɵviewQuery(_c03, 7, TemplateRef);
      ɵɵviewQuery(_c22, 7, TemplateRef);
      ɵɵviewQuery(TabStripComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabbedInterfaceTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabStrip = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ColumnMenuComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-grid-column-menu-standalone", ctx.standalone);
    }
  },
  inputs: {
    standalone: "standalone",
    column: "column",
    settings: "settings",
    sort: "sort",
    filter: "filter",
    sortable: "sortable",
    columnMenuTemplate: "columnMenuTemplate",
    tabIndex: "tabIndex"
  },
  features: [ɵɵProvidersFeature([ColumnMenuService, MenuTabbingService]), ɵɵNgOnChangesFeature],
  decls: 9,
  vars: 8,
  consts: [["anchor", ""], ["template", ""], ["defaultTemplate", ""], ["tabbedInterfaceTemplate", ""], ["sortItem", ""], ["lockItem", ""], ["stickItem", ""], ["positionItem", ""], ["chooserItem", ""], ["autoSizeColumnItem", ""], ["autoSizeAllColumnsItem", ""], ["filterItem", ""], ["tabstrip", ""], ["href", "#", 1, "k-grid-header-menu", "k-grid-column-menu", 3, "click", "keydown.enter", "ngClass", "tabindex"], ["name", "more-vertical", 3, "svgIcon"], [3, "keydown.escape", "keydown.enter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "kendoGridColumnMenuItem", "service", 4, "ngIf"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], ["class", "k-separator", 3, "borderColor", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service", "expanded", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", "column", 4, "ngIf"], [3, "service", "kendoGridColumnMenuItem", 4, "ngIf"], [3, "kendoGridColumnMenuItem", "service"], [3, "showLock", "showStick", "kendoGridColumnMenuItem", "service", "expanded"], [1, "k-separator"], [3, "kendoGridColumnMenuItem", "service", "expanded"], [3, "service", "kendoGridColumnMenuItem", "column"], [3, "service", "kendoGridColumnMenuItem"], [3, "keydown.escape"], [4, "ngIf"], ["kendoTabTitle", ""], ["kendoTabContent", ""], ["name", "filter", 3, "svgIcon"], [3, "keydown.shift.tab", "close", "column", "menuTabbingService", "filter", "actionsClass"], ["name", "sliders", 3, "svgIcon"], ["name", "columns", 3, "svgIcon"], [3, "apply", "applyText", "resetText", "columns", "autoSync", "allowHideAll", "actionsClass", "service"]],
  template: function ColumnMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "a", 13, 0);
      ɵɵlistener("click", function ColumnMenuComponent_Template_a_click_0_listener($event) {
        ɵɵrestoreView(_r1);
        const anchor_r2 = ɵɵreference(1);
        const template_r3 = ɵɵreference(4);
        return ɵɵresetView(ctx.toggle($event, anchor_r2, template_r3));
      })("keydown.enter", function ColumnMenuComponent_Template_a_keydown_enter_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView($event.stopImmediatePropagation());
      });
      ɵɵelement(2, "kendo-icon-wrapper", 14);
      ɵɵelementEnd();
      ɵɵtemplate(3, ColumnMenuComponent_ng_template_3_Template, 2, 5, "ng-template", null, 1, ɵɵtemplateRefExtractor)(5, ColumnMenuComponent_ng_template_5_Template, 11, 10, "ng-template", null, 2, ɵɵtemplateRefExtractor)(7, ColumnMenuComponent_ng_template_7_Template, 5, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngClass", ɵɵpureFunction1(6, _c23, ctx.isActive))("tabindex", ctx.tabIndex);
      ɵɵattribute("title", ctx.columnMenuTitle)("aria-expanded", ctx.isNavigable ? void 0 : false)("aria-haspopup", ctx.isNavigable ? void 0 : "dialog");
      ɵɵadvance(2);
      ɵɵproperty("svgIcon", ctx.moreVerticalIcon);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, FilterMenuContainerComponent, IconWrapperComponent, TabStripComponent, TabStripTabComponent, TabContentDirective, TabTitleDirective, ColumnListComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuComponent, [{
    type: Component,
    args: [{
      providers: [ColumnMenuService, MenuTabbingService],
      selector: "kendo-grid-column-menu",
      template: `
        <a #anchor
            class="k-grid-header-menu k-grid-column-menu"
            [ngClass]="{ 'k-active': isActive }"
            (click)="toggle($event, anchor, template)"
            (keydown.enter)="$event.stopImmediatePropagation()"
            href="#"
            [tabindex]="tabIndex"
            [attr.title]="columnMenuTitle"
            [attr.aria-expanded]="isNavigable ? undefined: false"
            [attr.aria-haspopup]="isNavigable ? undefined : 'dialog'">
            <kendo-icon-wrapper
                name="more-vertical"
                [svgIcon]="moreVerticalIcon"></kendo-icon-wrapper>
        </a>
        <ng-template #template>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <ng-container
                    [ngTemplateOutlet]="this.column.columnMenuTemplateRef || this.columnMenuTemplate || (this.settings.view === 'tabbed' ? this.tabbedInterfaceTemplate : this.defaultTemplate)"
                    [ngTemplateOutletContext]="{ service: service, column: column }">
                </ng-container>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #defaultTemplate>
            <kendo-grid-columnmenu-container
                (keydown.escape)="close(true)"
                (keydown.enter)="$event.stopImmediatePropagation()">
                <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                </kendo-grid-columnmenu-sort>
                <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                </kendo-grid-columnmenu-lock>
                <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                </kendo-grid-columnmenu-stick>
                <kendo-grid-columnmenu-position
                    #positionItem
                    *ngIf="hasPosition"
                    [showLock]="hasLock"
                    [showStick]="hasStick"
                    [kendoGridColumnMenuItem]="positionItem"
                    [service]="service"
                    [expanded]="expandedPosition">
                </kendo-grid-columnmenu-position>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-chooser
                    #chooserItem
                    *ngIf="hasColumnChooser"
                    [kendoGridColumnMenuItem]="chooserItem"
                    [service]="service"
                    [expanded]="expandedColumns">
                </kendo-grid-columnmenu-chooser>
                <kendo-grid-columnmenu-autosize-column
                    #autoSizeColumnItem
                    *ngIf="hasAutoSizeColumn"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeColumnItem"
                    [column]="column"
                >
                </kendo-grid-columnmenu-autosize-column>

                <kendo-grid-columnmenu-autosize-all-columns
                    #autoSizeAllColumnsItem
                    *ngIf="hasAutoSizeAllColumns"
                    [service]="service"
                    [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                >
                </kendo-grid-columnmenu-autosize-all-columns>
                <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasColumnChooser || hasAutoSizeColumn || hasAutoSizeAllColumns" class="k-separator"></span>
                <kendo-grid-columnmenu-filter
                    #filterItem
                    *ngIf="hasFilter"
                    [kendoGridColumnMenuItem]="filterItem"
                    [service]="service"
                    [expanded]="expandedFilter">
                </kendo-grid-columnmenu-filter>
            </kendo-grid-columnmenu-container>
        </ng-template>
        <ng-template #tabbedInterfaceTemplate>
            <kendo-tabstrip #tabstrip
                (keydown.escape)="close(true)">
                <kendo-tabstrip-tab *ngIf="hasFilter">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuFilterTabTitle')"
                            name="filter"
                            [svgIcon]="filterIcon">
                        </kendo-icon-wrapper>
                    </ng-template> 
                    <ng-template kendoTabContent>
                        <kendo-grid-filter-menu-container
                            [column]="service.column"
                            [menuTabbingService]="service.menuTabbingService"
                            [filter]="service.filter"
                            [actionsClass]="actionsClass"
                            (keydown.shift.tab)="$event.stopImmediatePropagation()"
                            (close)="close()">
                        </kendo-grid-filter-menu-container>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="showGeneralTab">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuGeneralTabTitle')"
                            name="sliders"
                            [svgIcon]="slidersIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnmenu-sort #sortItem [kendoGridColumnMenuItem]="sortItem" *ngIf="hasSort" [service]="service">
                        </kendo-grid-columnmenu-sort>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasSort && (hasLock || hasStick || hasPosition || hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-lock #lockItem *ngIf="hasLock && !hasPosition" [kendoGridColumnMenuItem]="lockItem" [service]="service">
                        </kendo-grid-columnmenu-lock>
                        <kendo-grid-columnmenu-stick #stickItem *ngIf="hasStick && !hasPosition" [kendoGridColumnMenuItem]="stickItem" [service]="service">
                        </kendo-grid-columnmenu-stick>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="(hasLock || hasStick) && !hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-position
                            #positionItem
                            *ngIf="hasPosition"
                            [showLock]="hasLock"
                            [showStick]="hasStick"
                            [kendoGridColumnMenuItem]="positionItem"
                            [service]="service"
                            [expanded]="expandedPosition">
                        </kendo-grid-columnmenu-position>
                        <span [style.borderColor]="'rgba(0, 0, 0, 0.08)'" *ngIf="hasPosition && (hasAutoSizeColumn || hasAutoSizeAllColumns)" class="k-separator"></span>
                        <kendo-grid-columnmenu-autosize-column
                            #autoSizeColumnItem
                            *ngIf="hasAutoSizeColumn"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeColumnItem"
                            [column]="column"
                        >
                        </kendo-grid-columnmenu-autosize-column>
                        <kendo-grid-columnmenu-autosize-all-columns
                            #autoSizeAllColumnsItem
                            *ngIf="hasAutoSizeAllColumns"
                            [service]="service"
                            [kendoGridColumnMenuItem]="autoSizeAllColumnsItem"
                        >
                        </kendo-grid-columnmenu-autosize-all-columns>
                    </ng-template>
                </kendo-tabstrip-tab>
                <kendo-tabstrip-tab *ngIf="hasColumnChooser">
                    <ng-template kendoTabTitle>
                        <kendo-icon-wrapper
                            [attr.title]="ctx.localization.get('columnMenuColumnsTabTitle')"
                            name="columns"
                            [svgIcon]="columnsIcon">
                        </kendo-icon-wrapper>
                    </ng-template>
                    <ng-template kendoTabContent>
                        <kendo-grid-columnlist
                            [applyText]="ctx.localization.get('columnsApply')"
                            [resetText]="ctx.localization.get('columnsReset')"
                            [columns]="columns"
                            [autoSync]="false"
                            [allowHideAll]="false"
                            [actionsClass]="actionsClass"
                            [service]="service"
                            (apply)="onApply($event)">
                        </kendo-grid-columnlist>
                    </ng-template>
                </kendo-tabstrip-tab>
            </kendo-tabstrip>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: NavigationService
    }, {
      type: SinglePopupService
    }, {
      type: ColumnMenuService
    }, {
      type: ContextService
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: ColumnInfoService
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    standalone: [{
      type: HostBinding,
      args: ["class.k-grid-column-menu-standalone"]
    }, {
      type: Input
    }],
    column: [{
      type: Input
    }],
    settings: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        static: true
      }]
    }],
    template: [{
      type: ViewChild,
      args: ["template", {
        static: true,
        read: TemplateRef
      }]
    }],
    defaultTemplate: [{
      type: ViewChild,
      args: ["defaultTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabbedInterfaceTemplate: [{
      type: ViewChild,
      args: ["tabbedInterfaceTemplate", {
        static: true,
        read: TemplateRef
      }]
    }],
    tabStrip: [{
      type: ViewChild,
      args: [TabStripComponent]
    }]
  });
})();
var FilterCellOperatorsComponent = class {
  constructor(ctx, sizing) {
    this.ctx = ctx;
    this.sizing = sizing;
    this.clearText = "Clear";
    this.filterClearIcon = filterClearIcon;
    this.filterSVGIcon = filterIcon;
    this.size = "medium";
    this.operators = [];
    this.showOperators = true;
    this.valueChange = new EventEmitter();
    this.clear = new EventEmitter();
  }
  /**
   * @hidden
   */
  get hostClasses() {
    return true;
  }
  /**
   * @hidden
   */
  onChange(dataItem) {
    this.valueChange.emit(dataItem);
  }
  /**
   * @hidden
   */
  clearClick() {
    this.clear.emit();
    return false;
  }
  /**
   * @hidden
   */
  clearKeydown(args) {
    if (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) {
      this.clear.emit();
    }
  }
  /**
   * @hidden
   */
  dropdownKeydown(args) {
    if (args.defaultPrevented) {
      return;
    }
    if (args.keyCode === Keys.Enter && !this.dropdown.isOpen) {
      this.dropdown.toggle(true);
      args.preventDefault();
    }
  }
  ngOnInit() {
    this.subs = this.ctx.localization.changes.subscribe(() => this.clearText = this.ctx.localization.get("filterClearButton"));
    this.subs.add(this.sizing.changes.subscribe((size) => this.size = size));
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterCellOperatorLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
FilterCellOperatorsComponent.ɵfac = function FilterCellOperatorsComponent_Factory(t) {
  return new (t || FilterCellOperatorsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
};
FilterCellOperatorsComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterCellOperatorsComponent,
  selectors: [["kendo-grid-filter-cell-operators"]],
  viewQuery: function FilterCellOperatorsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c25, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropdown = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function FilterCellOperatorsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell-operator", ctx.hostClasses);
    }
  },
  inputs: {
    operators: "operators",
    showButton: "showButton",
    showOperators: "showOperators",
    value: "value",
    column: "column"
  },
  outputs: {
    valueChange: "valueChange",
    clear: "clear"
  },
  decls: 2,
  vars: 2,
  consts: [["dropdown", ""], ["kendoGridFocusable", "", "class", "k-dropdown-operator", "icon", "filter", "textField", "text", "valueField", "value", 3, "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size", "valueChange", "keydown", 4, "ngIf"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "svgIcon", "title", "size", "click", "keydown", 4, "ngIf"], ["kendoGridFocusable", "", "icon", "filter", "textField", "text", "valueField", "value", 1, "k-dropdown-operator", 3, "valueChange", "keydown", "data", "value", "svgIcon", "valuePrimitive", "popupSettings", "size"], ["type", "button", "kendoButton", "", "kendoGridFocusable", "", "icon", "filter-clear", 3, "click", "keydown", "svgIcon", "title", "size"]],
  template: function FilterCellOperatorsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, FilterCellOperatorsComponent_kendo_dropdownlist_0_Template, 2, 8, "kendo-dropdownlist", 1)(1, FilterCellOperatorsComponent_button_1_Template, 1, 3, "button", 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showOperators);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showButton);
    }
  },
  dependencies: [NgIf, DropDownListComponent, FocusableDirective, ButtonComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellOperatorsComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-cell-operators",
      template: `
        <kendo-dropdownlist
            #dropdown
            *ngIf="showOperators"
            kendoGridFocusable
            [attr.aria-label]="column && columnLabel"
            [data]="operators"
            class="k-dropdown-operator"
            (valueChange)="onChange($event)"
            [value]="value"
            icon="filter"
            [svgIcon]="filterSVGIcon"
            [valuePrimitive]="true"
            textField="text"
            [popupSettings]="{ width: 'auto' }"
            valueField="value"
            [size]="size"
            (keydown)="dropdownKeydown($event)">
        </kendo-dropdownlist>
        <button type="button"
            kendoButton
            kendoGridFocusable
            *ngIf="showButton"
            icon="filter-clear"
            [svgIcon]="filterClearIcon"
            [title]="clearText"
            [size]="size"
            (click)="clearClick()"
            (keydown)="clearKeydown($event)"></button>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-operator"]
    }],
    dropdown: [{
      type: ViewChild,
      args: ["dropdown", {
        static: false
      }]
    }],
    operators: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    clear: [{
      type: Output
    }]
  });
})();
var EMPTY_FILTER_OPERATORS = ["isnull", "isnotnull", "isempty", "isnotempty"];
var FilterCellWrapperComponent = class extends FilterInputWrapperComponent {
  constructor(filterService) {
    super(filterService);
    this.showOperators = true;
  }
  get hostClasses() {
    return true;
  }
  get overrideBaseClasses() {
    return false;
  }
  get showButton() {
    const filter4 = this.currentFilter;
    return isPresent4(filter4) && (!isNullOrEmptyString2(filter4.value) || EMPTY_FILTER_OPERATORS.indexOf(String(filter4.operator)) >= 0);
  }
  filterChange(filter4) {
    this.applyFilter(filter4);
  }
};
FilterCellWrapperComponent.ɵfac = function FilterCellWrapperComponent_Factory(t) {
  return new (t || FilterCellWrapperComponent)(ɵɵdirectiveInject(FilterService));
};
FilterCellWrapperComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterCellWrapperComponent,
  selectors: [["kendo-grid-filter-wrapper-cell"]],
  hostVars: 4,
  hostBindings: function FilterCellWrapperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filtercell-wrapper", ctx.hostClasses)("k-filtercell", ctx.overrideBaseClasses);
    }
  },
  inputs: {
    showOperators: "showOperators"
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c16,
  decls: 2,
  vars: 5,
  consts: [[3, "clear", "valueChange", "showOperators", "column", "operators", "showButton", "value"]],
  template: function FilterCellWrapperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵelementStart(1, "kendo-grid-filter-cell-operators", 0);
      ɵɵlistener("clear", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_clear_1_listener() {
        return ctx.onClear();
      });
      ɵɵtwoWayListener("valueChange", function FilterCellWrapperComponent_Template_kendo_grid_filter_cell_operators_valueChange_1_listener($event) {
        ɵɵtwoWayBindingSet(ctx.currentOperator, $event) || (ctx.currentOperator = $event);
        return $event;
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("showOperators", ctx.showOperators)("column", ctx.column)("operators", ctx.operators)("showButton", ctx.showButton);
      ɵɵtwoWayProperty("value", ctx.currentOperator);
    }
  },
  dependencies: [FilterCellOperatorsComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellWrapperComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-filter-wrapper-cell",
      template: `
        <ng-content></ng-content>
        <kendo-grid-filter-cell-operators
            [showOperators]="showOperators"
            [column]="column"
            [operators]="operators"
            (clear)="onClear()"
            [showButton]="showButton"
            [(value)]="currentOperator">
        </kendo-grid-filter-cell-operators>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell-wrapper"]
    }],
    overrideBaseClasses: [{
      type: HostBinding,
      args: ["class.k-filtercell"]
    }],
    showOperators: [{
      type: Input
    }]
  });
})();
var StringFilterCellComponent = class extends StringFilterComponent {
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.filterDelay = 500;
    this.showOperators = true;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
StringFilterCellComponent.ɵfac = function StringFilterCellComponent_Factory(t) {
  return new (t || StringFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
};
StringFilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: StringFilterCellComponent,
  selectors: [["kendo-grid-string-filter-cell"]],
  inputs: {
    filterDelay: "filterDelay",
    showOperators: "showOperators"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 9,
  consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoTextBox", "", "kendoGridFocusable", "", "kendoFilterInput", "", 3, "size", "columnLabel", "filterDelay", "ngModel"]],
  template: function StringFilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
      ɵɵelement(1, "kendo-textbox", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
      ɵɵadvance();
      ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("ngModel", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    }
  },
  dependencies: [NgControlStatus, NgModel, TextBoxComponent, FocusableDirective, FilterInputDirective, FilterCellWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-string-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators">
            <kendo-textbox
                kendoTextBox
                [size]="size"
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [ngModel]="currentFilter?.value"></kendo-textbox>
        </kendo-grid-filter-wrapper-cell>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }]
  });
})();
var NumericFilterCellComponent = class extends NumericFilterComponent {
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.filterDelay = 500;
    this.showOperators = true;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
NumericFilterCellComponent.ɵfac = function NumericFilterCellComponent_Factory(t) {
  return new (t || NumericFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
};
NumericFilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: NumericFilterCellComponent,
  selectors: [["kendo-grid-numeric-filter-cell"]],
  inputs: {
    filterDelay: "filterDelay",
    showOperators: "showOperators"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 18,
  consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoGridFocusable", "", "kendoFilterInput", "", 3, "columnLabel", "filterDelay", "autoCorrect", "value", "format", "decimals", "spinners", "min", "max", "size", "step"], [3, "increment", "decrement"]],
  template: function NumericFilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-numerictextbox", 1);
      ɵɵelement(2, "kendo-numerictextbox-messages", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
      ɵɵadvance();
      ɵɵproperty("columnLabel", ctx.columnLabel)("filterDelay", ctx.filterDelay)("autoCorrect", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("decimals", ctx.decimals)("spinners", ctx.spinners)("min", ctx.min)("max", ctx.max)("size", ctx.size)("step", ctx.step);
      ɵɵadvance();
      ɵɵproperty("increment", ctx.messageFor("filterNumericIncrement"))("decrement", ctx.messageFor("filterNumericDecrement"));
    }
  },
  dependencies: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, FocusableDirective, FilterInputDirective, FilterCellWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-numeric-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-numerictextbox
                kendoGridFocusable
                kendoFilterInput
                [columnLabel]="columnLabel"
                [filterDelay]="filterDelay"
                [autoCorrect]="true"
                [value]="currentFilter?.value"
                [format]="format"
                [decimals]="decimals"
                [spinners]="spinners"
                [min]="min"
                [max]="max"
                [size]="size"
                [step]="step"
            >
                <kendo-numerictextbox-messages
                    [increment]="messageFor('filterNumericIncrement')"
                    [decrement]="messageFor('filterNumericDecrement')"
                >
                </kendo-numerictextbox-messages>
            </kendo-numerictextbox>
        </kendo-grid-filter-wrapper-cell>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    filterDelay: [{
      type: Input
    }],
    showOperators: [{
      type: Input
    }]
  });
})();
var BooleanFilterCellComponent = class extends BooleanFilterComponent {
  constructor(filterService, ctx, cd, sizingService) {
    super(filterService, ctx);
    this.cd = cd;
    this.size = "medium";
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  localizationChange() {
    super.localizationChange();
    this.cd.markForCheck();
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("booleanFilterCellLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
BooleanFilterCellComponent.ɵfac = function BooleanFilterCellComponent_Factory(t) {
  return new (t || BooleanFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(SizingOptionsService));
};
BooleanFilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: BooleanFilterCellComponent,
  selectors: [["kendo-grid-boolean-filter-cell"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 12,
  consts: [[3, "column", "filter", "showOperators", "defaultOperator"], ["kendoFilterInput", "", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 3, "size", "columnLabel", "defaultItem", "data", "popupSettings", "valuePrimitive", "value"]],
  template: function BooleanFilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
      ɵɵelement(1, "kendo-dropdownlist", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("showOperators", false)("defaultOperator", ctx.operator);
      ɵɵadvance();
      ɵɵproperty("size", ctx.size)("columnLabel", ctx.columnLabel)("defaultItem", ctx.defaultItem)("data", ctx.items)("popupSettings", ɵɵpureFunction0(11, _c26))("valuePrimitive", true)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    }
  },
  dependencies: [DropDownListComponent, FocusableDirective, FilterInputDirective, FilterCellWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-boolean-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [showOperators]="false"
            [defaultOperator]="operator">
            <kendo-dropdownlist
                kendoFilterInput
                kendoGridFocusable
                [size]="size"
                [columnLabel]="columnLabel"
                [defaultItem]="defaultItem"
                [data]="items"
                textField="text"
                valueField="value"
                [popupSettings]="{ width: 'auto' }"
                [valuePrimitive]="true"
                [value]="currentFilter?.value">
            </kendo-dropdownlist>
        </kendo-grid-filter-wrapper-cell>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: SizingOptionsService
    }];
  }, null);
})();
var DateFilterCellComponent = class extends DateFilterComponent {
  constructor(filterService, ctx, sizingService) {
    super(filterService, ctx);
    this.ctx = ctx;
    this.showOperators = true;
    this.subs = sizingService.changes.subscribe((size) => this.size = size);
  }
  ngOnDestroy() {
    this.subs && this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   */
  get columnLabel() {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = this.column.title || this.column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
};
DateFilterCellComponent.ɵfac = function DateFilterCellComponent_Factory(t) {
  return new (t || DateFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
};
DateFilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: DateFilterCellComponent,
  selectors: [["kendo-grid-date-filter-cell"]],
  inputs: {
    showOperators: "showOperators"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 19,
  consts: [[3, "column", "filter", "operators", "defaultOperator", "showOperators"], ["kendoFilterInput", "", "kendoGridFocusable", "", 3, "columnLabel", "value", "format", "size", "formatPlaceholder", "placeholder", "activeView", "bottomView", "topView", "min", "max", "weekNumber"], [3, "toggle", "today"]],
  template: function DateFilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0)(1, "kendo-datepicker", 1);
      ɵɵelement(2, "kendo-datepicker-messages", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("defaultOperator", ctx.operator)("showOperators", ctx.showOperators);
      ɵɵadvance();
      ɵɵproperty("columnLabel", ctx.columnLabel)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value)("format", ctx.format)("size", ctx.size)("formatPlaceholder", ctx.formatPlaceholder)("placeholder", ctx.placeholder)("activeView", ctx.activeView)("bottomView", ctx.bottomView)("topView", ctx.topView)("min", ctx.min)("max", ctx.max)("weekNumber", ctx.weekNumber);
      ɵɵadvance();
      ɵɵproperty("toggle", ctx.messageFor("filterDateToggle"))("today", ctx.messageFor("filterDateToday"));
    }
  },
  dependencies: [DatePickerComponent, DatePickerCustomMessagesComponent, FocusableDirective, FilterInputDirective, FilterCellWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-date-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [defaultOperator]="operator"
            [showOperators]="showOperators"
        >
            <kendo-datepicker
                kendoFilterInput
                kendoGridFocusable
                [columnLabel]="columnLabel"
                [value]="currentFilter?.value"
                [format]="format"
                [size]="size"
                [formatPlaceholder]="formatPlaceholder"
                [placeholder]="placeholder"
                [activeView]="activeView"
                [bottomView]="bottomView"
                [topView]="topView"
                [min]="min"
                [max]="max"
                [weekNumber]="weekNumber"
            >
                <kendo-datepicker-messages
                    [toggle]="messageFor('filterDateToggle')"
                    [today]="messageFor('filterDateToday')"
                >
                </kendo-datepicker-messages>
            </kendo-datepicker>
        </kendo-grid-filter-wrapper-cell>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    showOperators: [{
      type: Input
    }]
  });
})();
var filterComponentFactory = (type) => ({
  "boolean": BooleanFilterCellComponent,
  "date": DateFilterCellComponent,
  "numeric": NumericFilterCellComponent,
  "text": StringFilterCellComponent
})[type];
var FilterCellHostDirective = class extends FilterHostDirective {
  constructor(host, resolver) {
    super(host, resolver);
  }
  componentType() {
    if (!isNullOrEmptyString2(this.column.filter)) {
      return filterComponentFactory(this.column.filter);
    }
    return StringFilterCellComponent;
  }
};
FilterCellHostDirective.ɵfac = function FilterCellHostDirective_Factory(t) {
  return new (t || FilterCellHostDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1));
};
FilterCellHostDirective.ɵdir = ɵɵdefineDirective({
  type: FilterCellHostDirective,
  selectors: [["", "kendoFilterCellHost", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellHostDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoFilterCellHost]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: ComponentFactoryResolver$1
    }];
  }, null);
})();
var FilterCellComponent = class {
  constructor() {
    this.hostRole = "gridcell";
    this.size = "medium";
    this._templateContext = {};
  }
  get filter() {
    return this._filter;
  }
  set filter(value2) {
    this._filter = cloneFilters(value2);
  }
  get templateContext() {
    this._templateContext.column = this.column;
    this._templateContext.filter = this.filter;
    this._templateContext["$implicit"] = this.filter;
    return this._templateContext;
  }
  get hasTemplate() {
    return isPresent4(this.column.filterCellTemplateRef);
  }
  get isFilterable() {
    return isPresent4(this.column) && !isNullOrEmptyString2(this.column.field) && this.column.filterable;
  }
};
FilterCellComponent.ɵfac = function FilterCellComponent_Factory(t) {
  return new (t || FilterCellComponent)();
};
FilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterCellComponent,
  selectors: [["", "kendoGridFilterCell", ""]],
  hostVars: 1,
  hostBindings: function FilterCellComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.hostRole);
    }
  },
  inputs: {
    column: "column",
    filter: "filter",
    size: "size"
  },
  attrs: _c27,
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["kendoFilterCellHost", "", 3, "column", "filter"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function FilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, FilterCellComponent_ng_container_0_Template, 4, 3, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isFilterable);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, FilterCellHostDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterCellComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterCell]",
      template: `
        <ng-container *ngIf="isFilterable">
            <ng-container [ngSwitch]="hasTemplate">
                <ng-container *ngSwitchCase="false">
                    <ng-container kendoFilterCellHost [column]="column" [filter]="filter"></ng-container>
                </ng-container>
                <ng-container *ngSwitchCase="true">
                    <ng-template
                        *ngIf="column.filterCellTemplateRef"
                        [ngTemplateOutlet]="column.filterCellTemplateRef"
                        [ngTemplateOutletContext]="templateContext">
                    </ng-template>
                </ng-container>
            </ng-container>
        </ng-container>
    `
    }]
  }], null, {
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }]
  });
})();
var FilterRowComponent = class {
  constructor(ctx, columnInfoService) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.columns = [];
    this.groups = [];
    this.filterRowClass = true;
  }
  addStickyStyles(column) {
    const sticky = column.sticky ? this.columnInfoService.stickyColumnsStyles(column) : null;
    return __spreadValues(__spreadValues({}, sticky), column.filterStyle);
  }
  filterLabel(column) {
    const localizationMsg = this.ctx.localization.get("filterInputLabel") || "";
    const columnName = column.title || column.field;
    return replaceMessagePlaceholder(localizationMsg, "columnName", columnName);
  }
  getLogicalColIndex(columnIndex) {
    const colIndex = this.lockedColumnsCount + columnIndex;
    return this.detailTemplate?.templateRef ? colIndex + 1 : colIndex;
  }
};
FilterRowComponent.ɵfac = function FilterRowComponent_Factory(t) {
  return new (t || FilterRowComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
};
FilterRowComponent.ɵcmp = ɵɵdefineComponent({
  type: FilterRowComponent,
  selectors: [["", "kendoGridFilterRow", ""]],
  hostVars: 2,
  hostBindings: function FilterRowComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-filter-row", ctx.filterRowClass);
    }
  },
  inputs: {
    columns: "columns",
    filter: "filter",
    groups: "groups",
    detailTemplate: "detailTemplate",
    logicalRowIndex: "logicalRowIndex",
    lockedColumnsCount: "lockedColumnsCount"
  },
  attrs: _c28,
  decls: 3,
  vars: 3,
  consts: [["class", "k-table-td", "role", "presentation", 3, "k-group-cell", 4, "ngFor", "ngForOf"], ["class", "k-table-td", "role", "presentation", 3, "k-hierarchy-cell", 4, "ngIf"], ["class", "k-table-td", "kendoGridFilterCell", "", "kendoGridLogicalCell", "", 3, "k-grid-header-sticky", "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex", 4, "ngFor", "ngForOf"], ["role", "presentation", 1, "k-table-td"], ["kendoGridFilterCell", "", "kendoGridLogicalCell", "", 1, "k-table-td", 3, "ngStyle", "ngClass", "column", "filter", "logicalRowIndex", "logicalColIndex"]],
  template: function FilterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, FilterRowComponent_td_0_Template, 1, 2, "td", 0)(1, FilterRowComponent_td_1_Template, 1, 2, "td", 1)(2, FilterRowComponent_td_2_Template, 1, 9, "td", 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.groups);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.columns);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgStyle, LogicalCellDirective, FilterCellComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterRowComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFilterRow]",
      template: `
        <td
            class="k-table-td"
            [class.k-group-cell]="true"
            *ngFor="let g of groups"
            role="presentation">
        </td>
        <td
            class="k-table-td"
            [class.k-hierarchy-cell]="true"
            *ngIf="detailTemplate?.templateRef"
            role="presentation">
        </td>
        <td *ngFor="let column of columns; let columnIndex = index"
            class="k-table-td"
            [class.k-grid-header-sticky]="column.sticky"
            [ngStyle]="addStickyStyles(column)"
            [ngClass]="column.filterClass"
            [attr.aria-label]="filterLabel($any(column))"
            kendoGridFilterCell
                [column]="$any(column)"
                [filter]="filter"
            kendoGridLogicalCell
                [logicalRowIndex]="logicalRowIndex"
                [logicalColIndex]="getLogicalColIndex(columnIndex)"
      ></td>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }];
  }, {
    columns: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    filterRowClass: [{
      type: HostBinding,
      args: ["class.k-filter-row"]
    }]
  });
})();
var fromPercentage = (value2, percent) => {
  const sign = percent < 0 ? -1 : 1;
  return Math.ceil(Math.abs(percent) / 100 * value2) * sign;
};
var toPercentage = (value2, whole) => value2 / whole * 100;
var headerWidth = (handle) => handle.nativeElement.parentElement.offsetWidth;
var allLeafColumns = (columns) => expandColumns(columns).filter((c) => !c.isColumnGroup);
var stopPropagation = ({
  originalEvent: event2
}) => {
  event2.stopPropagation();
  event2.preventDefault();
};
var createMoveStream = (service, draggable) => (mouseDown) => draggable.kendoDrag.pipe(takeUntil(draggable.kendoRelease.pipe(tap(() => service.end()))), map(({
  pageX
}) => ({
  originalX: mouseDown.pageX,
  pageX
})));
var preventOnDblClick = (release) => (mouseDown) => of(mouseDown).pipe(delay(150), takeUntil(release));
var isInSpanColumn = (column) => !!(column.parent && column.parent.isSpanColumn);
var indexOf2 = (target, list) => {
  let index = 0;
  let ignore = 0;
  let skip4 = 0;
  while (index < list.length) {
    const current3 = list[index];
    const isParentSpanColumn = isInSpanColumn(current3);
    if (current3 === target) {
      break;
    }
    if (ignore-- <= 0 && isParentSpanColumn) {
      ignore = current3.parent.childColumns.length - 1;
      skip4 += ignore;
    }
    index++;
  }
  return index - skip4;
};
var ColumnHandleDirective = class {
  constructor(draggable, element, service, zone, cdr, ctx, columnInfoService) {
    this.draggable = draggable;
    this.element = element;
    this.service = service;
    this.zone = zone;
    this.cdr = cdr;
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.columns = [];
    this.subscriptions = new Subscription();
    this.rtl = false;
  }
  get visible() {
    return this.column.resizable ? "block" : "none";
  }
  get leftStyle() {
    return isTruthy(this.rtl) ? 0 : null;
  }
  get rightStyle() {
    return isTruthy(this.rtl) ? null : 0;
  }
  autoFit() {
    const allLeafs = allLeafColumns(this.columns);
    const currentLeafs = leafColumns([this.column]).filter((column) => isTruthy(column.resizable));
    const columnInfo = currentLeafs.map((column) => {
      const isParentSpan = isInSpanColumn(column);
      const isLastInSpan = isParentSpan ? column.parent.childColumns.last === column : false;
      const index = indexOf2(column, allLeafs);
      return {
        column,
        headerIndex: this.columnsForLevel(column.level).indexOf(column),
        index,
        isLastInSpan,
        isParentSpan,
        level: column.level
      };
    });
    currentLeafs.forEach((column) => column.width = 0);
    this.service.measureColumns(columnInfo);
  }
  ngOnInit() {
    if (isBlank2(this.column.width)) {
      this.column.implicitWidth = headerWidth(this.element);
    }
    const service = this.service.changes.pipe(filter(() => this.column.resizable), filter((e) => isPresent4(e.columns.find((column) => column === this.column))));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "start")).subscribe(this.initState.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "resizeColumn")).subscribe(this.resize.bind(this)));
    this.subscriptions.add(this.service.changes.pipe(
      filter((e) => e.type === "start"),
      filter(this.shouldUpdate.bind(this)),
      take(1)
      //on first resize only
    ).subscribe(this.initColumnWidth.bind(this)));
    this.subscriptions.add(this.zone.runOutsideAngular(() => this.draggable.kendoPress.pipe(tap(stopPropagation), tap(() => this.service.start(this.column)), switchMap(preventOnDblClick(this.draggable.kendoRelease)), switchMap(createMoveStream(this.service, this.draggable))).subscribe(({
      pageX,
      originalX
    }) => {
      const delta = pageX - originalX;
      const percent = toPercentage(delta, this.column.resizeStartWidth || this.column.width);
      this.service.resizeColumns(percent);
    })));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "autoFitComplete")).subscribe(this.sizeToFit.bind(this)));
    this.subscriptions.add(service.pipe(filter((e) => e.type === "triggerAutoFit")).subscribe(this.autoFit.bind(this)));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  shouldUpdate() {
    return !allLeafColumns(this.columns).map((column) => column.width).some(isBlank2);
  }
  initColumnWidth() {
    this.column.width = headerWidth(this.element);
  }
  initState() {
    this.column.resizeStartWidth = headerWidth(this.element);
    this.service.resizedColumn({
      column: this.column,
      oldWidth: this.column.resizeStartWidth
    });
  }
  resize({
    deltaPercent
  }) {
    let delta = fromPercentage(this.column.resizeStartWidth, deltaPercent);
    if (isTruthy(this.rtl)) {
      delta *= -1;
    }
    let newWidth = Math.max(this.column.resizeStartWidth + delta, this.column.minResizableWidth);
    if (isPresent4(this.column.maxResizableWidth)) {
      newWidth = Math.min(newWidth, this.column.maxResizableWidth);
    }
    const tableDelta = this.getTableDelta(newWidth, delta);
    this.updateWidth(this.column, newWidth);
    this.service.resizeTable(this.column, tableDelta);
  }
  sizeToFit({
    columns,
    widths
  }) {
    const index = columns.indexOf(this.column);
    const width = Math.max(...widths.map((w) => w[index])) + 1;
    const tableDelta = width - this.column.resizeStartWidth;
    this.updateWidth(this.column, width);
    this.service.resizeTable(this.column, tableDelta);
  }
  updateWidth(column, width) {
    column.width = width;
    this.columnInfoService.hiddenColumns.forEach((col) => {
      if (isBlank2(col.width) && isPresent4(col.implicitWidth)) {
        col.width = col.implicitWidth;
      }
    });
    this.cdr.markForCheck();
  }
  columnsForLevel(level) {
    return columnsToRender(this.columns ? this.columns.filter((column) => column.level === level) : []);
  }
  getTableDelta(newWidth, delta) {
    const minWidth = this.column.minResizableWidth;
    const maxWidth = this.column.maxResizableWidth;
    const startWidth = this.column.resizeStartWidth;
    const isAboveMin = newWidth > minWidth;
    const isBelowMax = newWidth < maxWidth;
    const isInBoundaries = isPresent4(maxWidth) ? isAboveMin && isBelowMax : isAboveMin;
    if (isInBoundaries) {
      return delta;
    } else if (newWidth <= minWidth) {
      return minWidth - startWidth;
    } else {
      return startWidth - maxWidth;
    }
  }
};
ColumnHandleDirective.ɵfac = function ColumnHandleDirective_Factory(t) {
  return new (t || ColumnHandleDirective)(ɵɵdirectiveInject(DraggableDirective, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService));
};
ColumnHandleDirective.ɵdir = ɵɵdefineDirective({
  type: ColumnHandleDirective,
  selectors: [["", "kendoGridColumnHandle", ""]],
  hostVars: 6,
  hostBindings: function ColumnHandleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("dblclick", function ColumnHandleDirective_dblclick_HostBindingHandler() {
        return ctx.autoFit();
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.visible)("left", ctx.leftStyle)("right", ctx.rightStyle);
    }
  },
  inputs: {
    columns: "columns",
    column: "column"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridColumnHandle]"
    }]
  }], function() {
    return [{
      type: DraggableDirective,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: ColumnResizingService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: ColumnInfoService
    }];
  }, {
    columns: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    leftStyle: [{
      type: HostBinding,
      args: ["style.left"]
    }],
    rightStyle: [{
      type: HostBinding,
      args: ["style.right"]
    }],
    autoFit: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var SelectAllCheckboxDirective = class {
  constructor(selectionService, el, renderer, ngZone) {
    this.selectionService = selectionService;
    this.el = el;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.selectAllChange = new EventEmitter();
    this.type = "checkbox";
    this.stateSet = false;
    this.ngZone.runOutsideAngular(() => {
      this.destroyClick = this.renderer.listen(this.el.nativeElement, "click", this.onClick.bind(this));
    });
  }
  ngAfterContentChecked() {
    this.setState();
  }
  ngOnChanges() {
    this.stateSet = true;
  }
  ngOnDestroy() {
    if (this.destroyClick) {
      this.destroyClick();
    }
  }
  /**
   * @hidden
   */
  onClick() {
    const undefinedCheckedStateInIE = detectIE() && this.selectionService.selectAllState === void 0;
    const isChecked = undefinedCheckedStateInIE ? true : this.el.nativeElement.checked;
    const options = this.selectionService.options;
    const enabledAndMultiple = options.enabled && options.mode === "multiple";
    const shouldEmitSelectAll = hasObservers(this.selectAllChange);
    if (enabledAndMultiple || shouldEmitSelectAll) {
      this.ngZone.run(() => {
        if (enabledAndMultiple) {
          this.selectionService.updateAll(isChecked);
        }
        if (shouldEmitSelectAll) {
          this.selectAllChange.emit(isChecked ? "checked" : "unchecked");
        }
      });
    }
  }
  /**
   * @hidden
   */
  setState() {
    const state2 = this.stateSet ? this.stateToBool() : this.selectionService.selectAllState;
    const elem = this.el.nativeElement;
    this.renderer.setProperty(elem, "indeterminate", !isPresent4(state2));
    this.renderer.setProperty(elem, "checked", isPresent4(state2) ? state2 : false);
  }
  /**
   * @hidden
   */
  stateToBool() {
    switch (this.state) {
      case "checked":
        return true;
      case "unchecked":
        return false;
      default:
        return void 0;
    }
  }
};
SelectAllCheckboxDirective.ɵfac = function SelectAllCheckboxDirective_Factory(t) {
  return new (t || SelectAllCheckboxDirective)(ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
SelectAllCheckboxDirective.ɵdir = ɵɵdefineDirective({
  type: SelectAllCheckboxDirective,
  selectors: [["", "kendoGridSelectAllCheckbox", ""]],
  hostVars: 1,
  hostBindings: function SelectAllCheckboxDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    state: "state"
  },
  outputs: {
    selectAllChange: "selectAllChange"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectAllCheckboxDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectAllCheckbox]"
    }]
  }], function() {
    return [{
      type: SelectionService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    state: [{
      type: Input
    }],
    selectAllChange: [{
      type: Output
    }],
    type: [{
      type: HostBinding,
      args: ["attr.type"]
    }]
  });
})();
var mergeObjects = (...args) => Object.assign.apply(null, [{}].concat(args));
var directions = (initialDirection) => initialDirection === "asc" ? ["asc", "desc"] : ["desc", "asc"];
var isRootLevel = ({
  parent
}) => !isTruthy(parent);
var ofColumnType = ({
  draggable
}) => ["column", "columnGroup"].indexOf(draggable.context.type) >= 0;
var notSameElement = ({
  draggable,
  target
}) => draggable.element.nativeElement !== target.element.nativeElement;
var inSameParent = (x, y) => x.parent === y.parent || isInSpanColumn$1(y) && inSameParent(x, y.parent);
var sameParent = ({
  draggable,
  target
}) => inSameParent(draggable.context.column, target.context.column);
var lastNonLocked = ({
  draggable
}) => !isTruthy(draggable.context.column.locked) && isRootLevel(draggable.context.column) && draggable.context.lastColumn;
var notInSpanColumn = ({
  draggable
}) => !isInSpanColumn$1(draggable.context.column);
var reorderable = ({
  draggable
}) => draggable.context.column.reorderable;
var lockable = ({
  draggable,
  target
}) => draggable.context.column.lockable !== false || draggable.context.column.isLocked === target.context.column.isLocked;
var rules = and(ofColumnType, reorderable, notInSpanColumn, notSameElement, sameParent, not(lastNonLocked), lockable);
var modifierKeys = ["alt", "ctrl", "shift", "meta"];
var HeaderComponent = class {
  constructor(popupService, hint, cue, reorderService, idService, sortService, columnInfoService, cd, contextService, navigationService) {
    this.popupService = popupService;
    this.hint = hint;
    this.cue = cue;
    this.reorderService = reorderService;
    this.idService = idService;
    this.sortService = sortService;
    this.columnInfoService = columnInfoService;
    this.cd = cd;
    this.contextService = contextService;
    this.navigationService = navigationService;
    this.columns = [];
    this.groups = [];
    this.sort = new Array();
    this.sortable = false;
    this.groupable = false;
    this.lockedColumnsCount = 0;
    this.resizable = false;
    this.reorderable = false;
    this.columnMenu = false;
    this.totalColumnsCount = 0;
    this.size = "medium";
    this.sortedFields = {};
    this.hostClass = true;
    this.dropTargets = new QueryList();
    this.sortAscSmallIcon = sortAscSmallIcon;
    this.sortDescSmallIcon = sortDescSmallIcon;
    this.subscription = new Subscription();
  }
  get headerClass() {
    return !this.scrollable;
  }
  get sortableLabel() {
    return this.contextService.localization.get("sortable");
  }
  get columnMenuSettings() {
    return this.columnMenu;
  }
  // Number of unlocked columns in the next table, if any
  get unlockedColumnsCount() {
    return this.totalColumnsCount - this.lockedColumnsCount - this.columns.length;
  }
  sortColumn(descriptor) {
    this.sortService.sort(descriptor);
  }
  getColumnComponent(column) {
    return column;
  }
  onSortClick(column, event2, link) {
    const target = event2.target;
    if (column.headerTemplateRef && target !== link) {
      const hasFocusableParent = Boolean(closestInScope(target, isFocusable2, link));
      if (hasFocusableParent) {
        return;
      }
    }
    const modifier = this.matchModifier(event2);
    const toggledColumn = this.toggleSort(column, modifier);
    this.sortColumn(toggledColumn);
  }
  onHeaderKeydown(column, args) {
    if (args.keyCode === Keys.ArrowDown && args.altKey && this.showFilterMenu) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const filterMenu = this.filterMenus.find((fm) => fm.column === column);
      filterMenu.toggle(filterMenu.anchor.nativeElement, filterMenu.template);
      return;
    }
    if (args.keyCode === Keys.ArrowDown && args.altKey && this.showColumnMenu(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const columnMenu = this.columnMenus.find((cm) => cm.column === column);
      columnMenu.toggle(null, columnMenu.anchor.nativeElement, columnMenu.template);
      return;
    }
    const isCtrlOrMeta = args.ctrlKey || args.metaKey;
    const isGroupingKeyShortcut = (args.keyCode === Keys.Enter || args.keyCode === Keys.Space) && isCtrlOrMeta;
    if (isGroupingKeyShortcut && this.isGroupable(column)) {
      args.preventDefault();
      args.stopImmediatePropagation();
      const isGroupedByField = this.groups.some((gr) => gr.field === column.field);
      if (isGroupedByField) {
        this.groups = this.groups.filter((gr) => gr.field !== column.field);
      } else {
        this.groups.push({
          field: column.field
        });
      }
      this.contextService.grid.groupChange.emit(this.groups);
      return;
    }
    const isLeftOrRightArrow = args.keyCode === Keys.ArrowLeft || args.keyCode === Keys.ArrowRight;
    const isReorderingKeyShortcut = isLeftOrRightArrow && isCtrlOrMeta;
    if (isReorderingKeyShortcut && this.isReorderable(column)) {
      args.preventDefault();
      const columnsCount = this.columnInfoService.leafNamedColumns.length;
      const reorderDirection = args.keyCode === Keys.ArrowLeft ? -1 : 1;
      const rtlMultiplier = this.contextService.localization.rtl ? -1 : 1;
      const reorderDirectionOffset = reorderDirection * rtlMultiplier;
      const newIndex = column.leafIndex + reorderDirectionOffset;
      const normalizedNewIndex = Math.min(Math.max(0, newIndex), columnsCount - 1);
      const gridInstance = this.contextService.grid;
      gridInstance.reorderColumn(column, normalizedNewIndex, {
        before: reorderDirectionOffset < 0
      });
      gridInstance.columnReorder.emit(new ColumnReorderEvent({
        column,
        newIndex: normalizedNewIndex,
        oldIndex: column.leafIndex
      }));
      return;
    }
    if (!this.sortable || args.defaultPrevented || column.sortable === false) {
      return;
    }
    if (args.keyCode === Keys.Enter && isPresent4(column.field)) {
      const modifier = this.matchModifier(args);
      this.sortService.sort(this.toggleSort(column, modifier));
    }
  }
  showSortNumbering(column) {
    const {
      showIndexes
    } = normalize$1(this.sortable);
    return showIndexes && this.sort && this.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).length > 1 && this.sortOrder(column.field) > 0;
  }
  sortOrder(field) {
    return this.sort.filter(({
      dir: dir2
    }) => isPresent4(dir2)).findIndex((x) => x.field === field) + 1;
  }
  sortState(column) {
    if (!this.isSortable(column)) {
      return;
    }
    const state2 = this.sortDescriptor(column.field);
    if (state2.dir === "asc") {
      return "ascending";
    }
    if (state2.dir === "desc") {
      return "descending";
    }
  }
  get isNavigable() {
    return this.navigationService.tableEnabled;
  }
  /**
   *
   * @param column
   * @param modifier - Indicates whether the client-defined `multiSortKey` modifier is met. Defaults to `true`.
   * @returns - SortDescriptor[]
   */
  toggleSort(column, modifier = true) {
    const {
      allowUnsort,
      mode,
      initialDirection
    } = normalize$1(this.sortable, column.sortable);
    const descriptor = this.toggleDirection(column.field, allowUnsort, initialDirection);
    if (mode === "single" || !modifier) {
      return [descriptor];
    }
    return [...this.sort.filter((desc) => desc.field !== column.field), descriptor];
  }
  /**
   *
   * Determines whether the modifier key (if any) passed
   * with a click/keyboard event matches the user-defined multiSortKey.
   */
  matchModifier(event2) {
    const {
      multiSortKey
    } = normalize$1(this.sortable);
    if (multiSortKey === "none") {
      return modifierKeys.every((key) => !event2[`${key}Key`]);
    }
    return multiSortKey === "ctrl" ? event2.ctrlKey || event2.metaKey : event2[`${multiSortKey}Key`];
  }
  ngAfterViewInit() {
    this.subscription.add(observe(this.dropTargets).subscribe(this.attachTargets.bind(this)));
  }
  ngDoCheck() {
    this._leafColumns = columnsToRender(this.columns || []).filter((x) => !isColumnGroupComponent(x));
  }
  ngOnChanges(changes) {
    const sortChange = changes.sort;
    if (sortChange && !sortChange.isFirstChange()) {
      sortChange.currentValue.forEach((change) => {
        this.sortedFields[change.field] = true;
      });
    }
  }
  ngOnInit() {
    this.subscription.add(this.contextService.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    if (this.popupService) {
      this.popupService.destroy();
    }
    this.subscription.unsubscribe();
  }
  selectAllCheckboxId() {
    return this.idService.selectAllCheckboxId();
  }
  get selectAllCheckboxLabel() {
    return this.contextService.localization.get("selectAllCheckboxLabel");
  }
  isFirstOnRow(column, index) {
    const isTailing = (c) => c && (this.columnsForLevel(c.level).indexOf(c) > 0 || isTailing(c.parent));
    return index === 0 && !this.groups.length && !this.detailTemplate && isTailing(column.parent);
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent4(index)) {
      return index + (isPresent4(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  get showFilterMenu() {
    return !this.columnMenu && hasFilterMenu(this.filterable);
  }
  get showFilterRow() {
    return hasFilterRow(this.filterable);
  }
  showColumnMenu(column) {
    return this.columnMenu && column.columnMenu && (this.columnMenuTemplate || column.columnMenuTemplates.length || hasItems(this.columnMenu, column));
  }
  isFilterable(column) {
    return !isNullOrEmptyString2(column.field) && column.filterable === true;
  }
  canDrop(draggable, target) {
    return this.reorderable && rules({
      draggable,
      target
    });
  }
  shouldActivate(column) {
    const canReorder = this.isReorderable(column);
    if (!canReorder && !isColumnComponent(column)) {
      return false;
    }
    const groupable = this.isGroupable(column);
    return groupable || canReorder;
  }
  isSortable(column) {
    return !isNullOrEmptyString2(column.field) && isTruthy(this.sortable) && isTruthy(column.sortable);
  }
  isCheckboxColumn(column) {
    return isCheckboxColumn(column) && !column.templateRef;
  }
  trackByIndex(index, _item) {
    return index;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.headerStyle), stickyStyles);
  }
  toggleDirection(field, allowUnsort, initialDirection) {
    const descriptor = this.sortDescriptor(field);
    const [first, second] = directions(initialDirection);
    let dir2 = first;
    if (descriptor.dir === first) {
      dir2 = second;
    } else if (descriptor.dir === second && allowUnsort) {
      dir2 = void 0;
    }
    return {
      dir: dir2,
      field
    };
  }
  columnsForLevel(level) {
    const columns = this.columns ? this.columns.filter((column) => column.level === level) : [];
    return sortColumns(columnsToRender(columns));
  }
  isColumnGroupComponent(column) {
    return isColumnGroupComponent(column);
  }
  sortDescriptor(field) {
    return this.sort.find((item) => item.field === field) || {
      field
    };
  }
  get columnLevels() {
    return new Array((this.totalColumnLevels || 0) + 1);
  }
  get leafColumns() {
    return this._leafColumns;
  }
  isReorderable(column) {
    return this.reorderable && column.reorderable;
  }
  isGroupable(column) {
    return this.groupable && isColumnComponent(column) && column.groupable !== false;
  }
  attachTargets() {
    if (this.targetSubscription) {
      this.targetSubscription.unsubscribe();
    }
    this.targetSubscription = new Subscription();
    const enterStream = merge(...this.dropTargets.map((target) => target.enter));
    const leaveStream = merge(...this.dropTargets.map((target) => target.leave));
    const dropStream = merge(...this.dropTargets.map((target) => target.drop));
    this.targetSubscription.add(enterStream.pipe(tap(({
      target,
      draggable
    }) => {
      if (draggable.context.type === "groupIndicator") {
        return;
      }
      const targetLocked = isTruthy(target.context.column.isLocked);
      const draggableLocked = isTruthy(draggable.context.column.isLocked);
      if (this.lockedColumnsCount > 0 || targetLocked || draggableLocked) {
        this.hint.toggleLock(targetLocked);
      }
    }), filter(({
      draggable,
      target
    }) => this.canDrop(draggable, target)), switchMap(this.trackMove.bind(this, leaveStream, dropStream)), map((e) => mergeObjects(e, {
      before: this.calculateBefore(e),
      changeContainer: e.changeContainer
    })), map(this.normalizeTarget.bind(this)), tap(this.enter.bind(this)), switchMap((args) => dropStream.pipe(map(() => args), takeUntil(leaveStream.pipe(tap(this.leave.bind(this))))))).subscribe(this.drop.bind(this)));
  }
  normalizeTarget(e) {
    let target = e.target;
    const parent = target.context.column.parent;
    if (parent && parent.isSpanColumn) {
      const arr = this.dropTargets.toArray();
      const firstSpan = arr.find((t) => t.context.column.parent === parent);
      const index = arr.indexOf(firstSpan);
      const adjust = e.before ? 0 : parent.childColumns.length - 1;
      target = arr[index + adjust];
    }
    return mergeObjects(e, {
      target
    });
  }
  trackMove(leaveStream, dropStream, e) {
    const column = e.target.context.column;
    const levelColumns = this.columnsForLevel(column.level);
    const index = levelColumns.indexOf(column);
    const isFirst = column.locked ? index === levelColumns.length - 1 : index === 0;
    const changed = e.draggable.context.column.isLocked !== column.isLocked;
    if (changed && isFirst) {
      return e.draggable.drag.pipe(takeUntil(leaveStream), takeUntil(dropStream), map(({
        mouseEvent
      }) => mergeObjects({
        changeContainer: true
      }, e, {
        mouseEvent
      })));
    }
    return of(mergeObjects({
      changeContainer: changed
    }, e));
  }
  calculateBefore({
    draggable,
    target,
    mouseEvent,
    changeContainer = false
  }) {
    const targetElement = target.element.nativeElement;
    let before = false;
    if (changeContainer) {
      const {
        left
      } = offset(targetElement);
      const halfWidth = targetElement.offsetWidth / 2;
      const middle = left + halfWidth;
      before = middle > mouseEvent.pageX;
      if (this.contextService.localization.rtl) {
        before = !before;
      }
    } else {
      before = isTargetBefore(draggable.element.nativeElement, targetElement);
    }
    return before;
  }
  enter({
    target,
    before
  }) {
    this.hint.enable();
    if (this.contextService.localization.rtl) {
      before = !before;
    }
    this.cue.position(position(target.element.nativeElement, before));
  }
  leave() {
    this.hint.disable();
    this.cue.hide();
  }
  drop({
    draggable,
    target,
    before,
    changeContainer
  }) {
    this.reorderService.reorder({
      before,
      changeContainer,
      source: draggable.context.column,
      target: target.context.column
    });
  }
};
HeaderComponent.ɵfac = function HeaderComponent_Factory(t) {
  return new (t || HeaderComponent)(ɵɵdirectiveInject(SinglePopupService), ɵɵdirectiveInject(DragHintService), ɵɵdirectiveInject(DropCueService), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(IdService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NavigationService));
};
HeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: HeaderComponent,
  selectors: [["", "kendoGridHeader", ""]],
  viewQuery: function HeaderComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(DropTargetDirective2, 5);
      ɵɵviewQuery(FilterMenuComponent, 5);
      ɵɵviewQuery(ColumnMenuComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargets = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterMenus = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenus = _t);
    }
  },
  hostVars: 4,
  hostBindings: function HeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-grid-header", ctx.headerClass)("k-table-thead", ctx.hostClass);
    }
  },
  inputs: {
    totalColumnLevels: "totalColumnLevels",
    columns: "columns",
    groups: "groups",
    detailTemplate: "detailTemplate",
    scrollable: "scrollable",
    filterable: "filterable",
    sort: "sort",
    filter: "filter",
    sortable: "sortable",
    groupable: "groupable",
    lockedColumnsCount: "lockedColumnsCount",
    resizable: "resizable",
    reorderable: "reorderable",
    columnMenu: "columnMenu",
    columnMenuTemplate: "columnMenuTemplate",
    totalColumnsCount: "totalColumnsCount",
    totalColumns: "totalColumns",
    tabIndex: "tabIndex",
    size: "size"
  },
  features: [ɵɵNgOnChangesFeature],
  attrs: _c29,
  decls: 3,
  vars: 2,
  consts: [["link", ""], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns", 4, "ngFor", "ngForOf"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns", 4, "ngIf"], ["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-group-cell k-header k-table-th", "role", "presentation", 4, "ngFor", "ngForOf"], ["class", "k-hierarchy-cell k-header k-table-th", "role", "presentation", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", 1, "k-group-cell", "k-header", "k-table-th"], ["role", "presentation", 1, "k-hierarchy-cell", "k-header", "k-table-th"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header k-table-th", 3, "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "k-sorted", "enableDrag", "context", "k-filterable", "k-first", "k-grid-header-sticky", "ngClass", "ngStyle", "keydown", 4, "ngIf"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", "class", "k-header k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "k-first", "k-filterable", "k-grid-content-sticky", "ngClass", "ngStyle", 4, "ngIf"], ["kendoGridLogicalCell", "", "role", "columnheader", "aria-selected", "false", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "keydown", "logicalRowIndex", "logicalColIndex", "headerLabelText", "colSpan", "rowSpan", "enableDrag", "context", "ngClass", "ngStyle"], [4, "ngIf"], ["kendoGridColumnHandle", "", "kendoDraggable", "", "class", "k-column-resizer", 3, "column", "columns", 4, "ngIf"], [1, "k-cell-inner"], [1, "k-link", "!k-cursor-default"], [3, "templateContext"], [3, "column", "filter", "tabIndex", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex", 4, "ngIf"], [1, "k-column-title"], [3, "column", "filter", "tabIndex"], [3, "standalone", "settings", "column", "columnMenuTemplate", "sort", "filter", "sortable", "tabIndex"], [1, "k-link", 3, "click"], [1, "k-sort-icon"], ["role", "note", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-sort-order", 4, "ngIf"], ["role", "note", 3, "name", "svgIcon"], [1, "k-sort-order"], [1, "k-checkbox-wrap"], ["kendoGridSelectAllCheckbox", "", "kendoGridFocusable", "", 1, "k-checkbox", "k-checkbox-md", "k-rounded-md"], ["kendoGridColumnHandle", "", "kendoDraggable", "", 1, "k-column-resizer", 3, "column", "columns"], ["kendoGridLogicalCell", "", "kendoDropTarget", "", "kendoDraggable", "", "kendoDraggableColumn", "", 1, "k-header", "k-table-th", 3, "logicalRowIndex", "logicalColIndex", "rowSpan", "colSpan", "headerLabelText", "enableDrag", "context", "ngClass", "ngStyle"], [1, "k-link"], [3, "standalone", "settings", "column", "columnMenuTemplate", 4, "ngIf"], [3, "standalone", "settings", "column", "columnMenuTemplate"], ["kendoGridFilterRow", "", "kendoGridLogicalRow", "", 3, "columns", "filter", "groups", "detailTemplate", "lockedColumnsCount", "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"]],
  template: function HeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0);
      ɵɵtemplate(1, HeaderComponent_tr_1_Template, 4, 9, "tr", 1)(2, HeaderComponent_tr_2_Template, 1, 10, "tr", 2);
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.columnLevels);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showFilterRow);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgStyle, FilterRowComponent, LogicalCellDirective, LogicalRowDirective, FocusableDirective, TemplateContextDirective, DraggableDirective, IconWrapperComponent, FilterMenuComponent, DraggableColumnDirective, DropTargetDirective2, ColumnMenuComponent, ColumnHandleDirective, SelectAllCheckboxDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridHeader]",
      template: `
    <ng-container>
        <tr *ngFor="let i of columnLevels; let levelIndex = index"
            kendoGridLogicalRow
                [logicalRowIndex]="levelIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns">
            <th
                class="k-group-cell k-header k-table-th"
                role="presentation"
                *ngFor="let g of groups">
            </th>
            <th class="k-hierarchy-cell k-header k-table-th"
                role="presentation"
                *ngIf="detailTemplate?.templateRef"
            >
            </th>
            <ng-container *ngFor="let column of columnsForLevel(levelIndex); trackBy: trackByIndex; let columnIndex = index; let last = last;">
                <th *ngIf="!isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    [colSpan]="column.colspan"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    role="columnheader"
                    aria-selected="false"
                    [attr.aria-sort]="sortState(getColumnComponent(column))"
                    [class.k-sorted]="!!sortState(getColumnComponent(column))"
                    (keydown)="onHeaderKeydown(getColumnComponent(column), $event)"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        field: getColumnComponent(column).field,
                        type: 'column',
                        column: column,
                        hint: column.title || getColumnComponent(column).field,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-filterable]="(showFilterMenu && isFilterable(getColumnComponent(column))) || showColumnMenu(column)"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-grid-header-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.sticky ? addStickyStyles(column) : column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan"
                    [attr.aria-haspopup]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? 'dialog' : undefined"
                    [attr.aria-expanded]="isNavigable && (showFilterMenu || showColumnMenu(column)) ? false : undefined"
                    [attr.aria-keyshortcuts]="isNavigable ? 'Alt + ArrowDown' : undefined">

                    <ng-container *ngIf="!isSortable(getColumnComponent(column))">
                        <span class="k-cell-inner">
                            <span class="k-link !k-cursor-default">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isSortable(getColumnComponent(column))">
                        <span class="k-cell-inner">
                            <span #link class="k-link" (click)="onSortClick(getColumnComponent(column), $event, link)">
                                <ng-template
                                    [templateContext]="{
                                        templateRef: column.headerTemplateRef,
                                        columnIndex: column.leafIndex,
                                        column: column,
                                        $implicit: column
                                    }">
                                </ng-template>
                                <ng-container *ngIf="!column.headerTemplateRef">
                                    <span class="k-column-title">{{column.displayTitle}}</span>
                                </ng-container>
                                <span class="k-sort-icon">
                                    <kendo-icon-wrapper
                                        *ngIf="sortDescriptor(getColumnComponent(column).field).dir"
                                        role="note" [attr.aria-label]="sortableLabel"
                                        name="sort-{{sortDescriptor(getColumnComponent(column).field).dir}}-small"
                                        [svgIcon]="sortDescriptor(getColumnComponent(column).field).dir === 'asc' ? sortAscSmallIcon : sortDescSmallIcon"
                                        ></kendo-icon-wrapper>
                                </span>
                                <span *ngIf="showSortNumbering(getColumnComponent(column))" class="k-sort-order">{{sortOrder(getColumnComponent(column).field)}}</span>
                            </span>
                            <kendo-grid-filter-menu
                                *ngIf="showFilterMenu && isFilterable(getColumnComponent(column))"
                                [column]="getColumnComponent(column)"
                                [filter]="filter"
                                [tabIndex]="tabIndex">
                            </kendo-grid-filter-menu>
                            <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                                [standalone]="false"
                                [settings]="columnMenuSettings"
                                [column]="column"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [sort]="sort"
                                [filter]="filter"
                                [sortable]="sortable"
                                [tabIndex]="tabIndex">
                            </kendo-grid-column-menu>
                        </span>
                    </ng-container>

                    <ng-container *ngIf="isCheckboxColumn(column) && !column.headerTemplateRef && $any(column).showSelectAll">
                        <span class="k-checkbox-wrap">
                            <input
                                class="k-checkbox k-checkbox-md k-rounded-md"
                                [attr.id]="selectAllCheckboxId()"
                                [attr.aria-label]="selectAllCheckboxLabel"
                                kendoGridSelectAllCheckbox
                                kendoGridFocusable>
                        </span>
                    </ng-container>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
                <th *ngIf="isColumnGroupComponent(column)"
                    kendoGridLogicalCell
                    [logicalRowIndex]="levelIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    [rowSpan]="column.rowspan(totalColumnLevels)"
                    [colSpan]="column.colspan"
                    [headerLabelText]="column.title || getColumnComponent(column).field"
                    kendoDropTarget
                    kendoDraggable
                    kendoDraggableColumn
                    [enableDrag]="shouldActivate(column)"
                    [context]="{
                        type: 'columnGroup',
                        column: column,
                        hint: column.title,
                        lastColumn: last && columnIndex === 0
                    }"
                    class="k-header k-table-th"
                    [class.k-first]="isFirstOnRow(getColumnComponent(column), columnIndex)"
                    [class.k-filterable]="showColumnMenu(column)"
                    [class.k-grid-content-sticky]="column.sticky"
                    [ngClass]="column.headerClass"
                    [ngStyle]="column.headerStyle"
                    [attr.rowspan]="column.rowspan(totalColumnLevels)"
                    [attr.colspan]="column.colspan">
                    <span class="k-cell-inner">
                        <span class="k-link">
                            <ng-template
                                [templateContext]="{
                                    templateRef: column.headerTemplateRef,
                                    columnIndex: lockedColumnsCount + columnIndex,
                                    column: column,
                                    $implicit: column
                                }">
                            </ng-template>
                            <ng-container *ngIf="!column.headerTemplateRef">
                                <span class="k-column-title">{{column.displayTitle}}</span>
                            </ng-container>
                        </span>
                        <kendo-grid-column-menu *ngIf="showColumnMenu(column)"
                            [standalone]="false"
                            [settings]="columnMenuSettings"
                            [column]="column"
                            [columnMenuTemplate]="columnMenuTemplate">
                        </kendo-grid-column-menu>
                    </span>
                    <span kendoGridColumnHandle
                        kendoDraggable
                        class="k-column-resizer"
                        *ngIf="resizable"
                        [column]="column"
                        [columns]="columns">
                    </span>
                </th>
            </ng-container>
        </tr>
        <tr *ngIf="showFilterRow"
            kendoGridFilterRow
                [columns]="leafColumns"
                [filter]="filter"
                [groups]="groups"
                [detailTemplate]="detailTemplate"
                [lockedColumnsCount]="lockedColumnsCount"
            kendoGridLogicalRow
                [logicalRowIndex]="totalColumnLevels + 1"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="unlockedColumnsCount"
                [totalColumns]="totalColumns"
        ></tr>
    </ng-container>
    `
    }]
  }], function() {
    return [{
      type: SinglePopupService
    }, {
      type: DragHintService
    }, {
      type: DropCueService
    }, {
      type: ColumnReorderService
    }, {
      type: IdService
    }, {
      type: SortService
    }, {
      type: ColumnInfoService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ContextService
    }, {
      type: NavigationService
    }];
  }, {
    totalColumnLevels: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    columnMenuTemplate: [{
      type: Input
    }],
    totalColumnsCount: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    headerClass: [{
      type: HostBinding,
      args: ["class.k-grid-header"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-thead"]
    }],
    dropTargets: [{
      type: ViewChildren,
      args: [DropTargetDirective2]
    }],
    filterMenus: [{
      type: ViewChildren,
      args: [FilterMenuComponent]
    }],
    columnMenus: [{
      type: ViewChildren,
      args: [ColumnMenuComponent]
    }]
  });
})();
var FooterComponent = class {
  constructor(columnInfoService) {
    this.columnInfoService = columnInfoService;
    this.columns = [];
    this.groups = [];
    this.lockedColumnsCount = 0;
    this.logicalRowIndex = 0;
    this.hostClass = true;
    this.hostRole = "rowgroup";
  }
  get footerClass() {
    return !this.scrollable;
  }
  get columnsToRender() {
    return columnsToRender(this.columns || []);
  }
  trackByIndex(index, _item) {
    return index;
  }
  logicalColumnIndex(column) {
    const index = column.leafIndex;
    if (isPresent4(index)) {
      return index + (isPresent4(this.detailTemplate) ? 1 : 0);
    }
    return -1;
  }
  addStickyStyles(column) {
    const stickyStyles = this.columnInfoService.stickyColumnsStyles(column);
    return __spreadValues(__spreadValues({}, column.footerStyle), stickyStyles);
  }
};
FooterComponent.ɵfac = function FooterComponent_Factory(t) {
  return new (t || FooterComponent)(ɵɵdirectiveInject(ColumnInfoService));
};
FooterComponent.ɵcmp = ɵɵdefineComponent({
  type: FooterComponent,
  selectors: [["", "kendoGridFooter", ""]],
  hostVars: 5,
  hostBindings: function FooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.hostRole);
      ɵɵclassProp("k-grid-footer", ctx.footerClass)("k-table-tfoot", ctx.hostClass);
    }
  },
  inputs: {
    columns: "columns",
    groups: "groups",
    detailTemplate: "detailTemplate",
    scrollable: "scrollable",
    lockedColumnsCount: "lockedColumnsCount",
    logicalRowIndex: "logicalRowIndex",
    totalColumns: "totalColumns"
  },
  attrs: _c33,
  decls: 5,
  vars: 11,
  consts: [["kendoGridLogicalRow", "", 3, "logicalRowIndex", "logicalSlaveRow", "logicalCellsCount", "logicalSlaveCellsCount", "totalColumns"], ["class", "k-table-td k-group-cell", "role", "presentation", 4, "ngFor", "ngForOf"], ["role", "presentation", "class", "k-table-td k-hierarchy-cell", 4, "ngIf"], ["kendoGridLogicalCell", "", "class", "k-table-td", "role", "gridcell", "aria-selected", "false", 3, "logicalRowIndex", "logicalColIndex", "k-grid-footer-sticky", "ngClass", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "presentation", 1, "k-table-td", "k-group-cell"], ["role", "presentation", 1, "k-table-td", "k-hierarchy-cell"], ["kendoGridLogicalCell", "", "role", "gridcell", "aria-selected", "false", 1, "k-table-td", 3, "logicalRowIndex", "logicalColIndex", "ngClass", "ngStyle"], [3, "templateContext"]],
  template: function FooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0);
      ɵɵelementStart(1, "tr", 0);
      ɵɵtemplate(2, FooterComponent_td_2_Template, 1, 0, "td", 1)(3, FooterComponent_td_3_Template, 1, 0, "td", 2)(4, FooterComponent_td_4_Template, 2, 12, "td", 3);
      ɵɵelementEnd();
      ɵɵelementContainerEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵclassProp("k-footer-template", true);
      ɵɵproperty("logicalRowIndex", ctx.logicalRowIndex)("logicalSlaveRow", ctx.lockedColumnsCount > 0)("logicalCellsCount", ctx.columns.length)("logicalSlaveCellsCount", ctx.columns.length - ctx.lockedColumnsCount)("totalColumns", ctx.totalColumns);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.groups);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.detailTemplate == null ? null : ctx.detailTemplate.templateRef);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.columnsToRender)("ngForTrackBy", ctx.trackByIndex);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgStyle, LogicalCellDirective, LogicalRowDirective, TemplateContextDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent, [{
    type: Component,
    args: [{
      selector: "[kendoGridFooter]",
      template: `
    <ng-container>
        <tr
            [class.k-footer-template]="true"
            kendoGridLogicalRow
                [logicalRowIndex]="logicalRowIndex"
                [logicalSlaveRow]="lockedColumnsCount > 0"
                [logicalCellsCount]="columns.length"
                [logicalSlaveCellsCount]="columns.length - lockedColumnsCount"
                [totalColumns]="totalColumns"
            >
            <td
                class="k-table-td k-group-cell"
                role="presentation"
                *ngFor="let g of groups">
            </td>
            <td
                role="presentation"
                class="k-table-td k-hierarchy-cell"
                *ngIf="detailTemplate?.templateRef">
            </td>
            <td
                *ngFor="let column of columnsToRender; let columnIndex = index; trackBy: trackByIndex;"
                kendoGridLogicalCell
                class="k-table-td"
                    [logicalRowIndex]="logicalRowIndex"
                    [logicalColIndex]="logicalColumnIndex(column)"
                    role="gridcell"
                    aria-selected="false"
                [class.k-grid-footer-sticky]="column.sticky"
                [ngClass]="column.footerClass"
                [ngStyle]="column.sticky ? addStickyStyles(column) : column.footerStyle">
                <ng-template
                    [templateContext]="{
                        templateRef: column.footerTemplateRef,
                        columnIndex: column.leafIndex,
                        column: column,
                        $implicit: column
                    }">
                </ng-template>
            </td>
        </tr>
    </ng-container>
    `
    }]
  }], function() {
    return [{
      type: ColumnInfoService
    }];
  }, {
    columns: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    lockedColumnsCount: [{
      type: Input
    }],
    logicalRowIndex: [{
      type: Input
    }],
    totalColumns: [{
      type: Input
    }],
    footerClass: [{
      type: HostBinding,
      args: ["class.k-grid-footer"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-table-tfoot"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var normalizeSettings = ({
  buttonCount = 10,
  info = true,
  type = "numeric",
  pageSizes = false,
  previousNext = true,
  responsive = true,
  position: position2 = "bottom"
}) => ({
  buttonCount,
  info,
  pageSizes: pageSizes === true ? [5, 10, 20] : pageSizes,
  previousNext,
  type,
  responsive,
  position: position2
});
var normalize = (settings) => normalizeSettings(settings === true ? {} : settings);
var PagerElementComponent = class {
  constructor(ctx, pagerContext, cd) {
    this.ctx = ctx;
    this.pagerContext = pagerContext;
    this.cd = cd;
    this.total = this.pagerContext.total;
    this.skip = this.pagerContext.skip;
    this.pageSize = this.pagerContext.pageSize;
    this.caretAltLeftIcon = caretAltLeftIcon;
    this.caretAltToLeftIcon = caretAltToLeftIcon;
    this.caretAltRightIcon = caretAltRightIcon;
    this.caretAltToRightIcon = caretAltToRightIcon;
    this.size = "medium";
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerElementComponent
   */
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  /**
   * @hidden
   *
   * @param {string} key
   * @returns {string}
   *
   * @memberOf PagerElementComponent
   */
  textFor(key) {
    return this.ctx.localization.get(key);
  }
  /**
   * @hidden
   *
   * @param {number} page
   *
   * @memberOf PagerElementComponent
   */
  changePage(page) {
    this.pagerContext.changePage(page);
    return false;
  }
  /**
   * @hidden
   *
   * @memberOf PagerElementComponent
   */
  ngOnInit() {
    this.subscriptions = this.pagerContext.changes.subscribe(this.onChanges.bind(this));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(() => this.cd.markForCheck()));
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  get prevArrowIcons() {
    return !this.ctx.localization.rtl ? ["caret-alt-to-left", "caret-alt-left"] : ["caret-alt-to-right", "caret-alt-right"];
  }
  get prevArrowSVGIcons() {
    return !this.ctx.localization.rtl ? [this.caretAltToLeftIcon, this.caretAltLeftIcon] : [this.caretAltToRightIcon, this.caretAltRightIcon];
  }
  get nextArrowIcons() {
    return !this.ctx.localization.rtl ? ["caret-alt-right", "caret-alt-to-right"] : ["caret-alt-left", "caret-alt-to-left"];
  }
  get nextArrowSVGIcons() {
    return !this.ctx.localization.rtl ? [this.caretAltRightIcon, this.caretAltToRightIcon] : [this.caretAltLeftIcon, this.caretAltToLeftIcon];
  }
};
PagerElementComponent.ɵfac = function PagerElementComponent_Factory(t) {
  return new (t || PagerElementComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef));
};
PagerElementComponent.ɵdir = ɵɵdefineDirective({
  type: PagerElementComponent,
  inputs: {
    size: "size"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerElementComponent, [{
    type: Directive,
    args: [{}]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    size: [{
      type: Input
    }]
  });
})();
var PagerInfoComponent = class extends PagerElementComponent {
  constructor(ctx, cd, pagerContext) {
    super(ctx, pagerContext, cd);
    this.pagerContext = pagerContext;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get maxItems() {
    return Math.min(this.currentPage * this.pageSize, this.total);
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number}
   * @memberOf PagerInfoComponent
   */
  get currentPageText() {
    return this.total ? (this.currentPage - 1) * this.pageSize + 1 : 0;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerInfoComponent
   */
  get classes() {
    return true;
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
};
PagerInfoComponent.ɵfac = function PagerInfoComponent_Factory(t) {
  return new (t || PagerInfoComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService));
};
PagerInfoComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerInfoComponent,
  selectors: [["kendo-pager-info"]],
  hostVars: 4,
  hostBindings: function PagerInfoComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-pager-info", ctx.classes)("k-label", ctx.classes);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 5,
  template: function PagerInfoComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtext(0);
    }
    if (rf & 2) {
      ɵɵtextInterpolate5("", ctx.currentPageText, " - ", ctx.maxItems, " ", ctx.textFor("pagerOf"), " ", ctx.total, " ", ctx.textFor("pagerItems"), "");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInfoComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-pager-info",
      template: `{{currentPageText}} - {{maxItems}} {{textFor('pagerOf')}} {{total}} {{textFor('pagerItems')}}`
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }];
  }, {
    classes: [{
      type: HostBinding,
      args: ["class.k-pager-info"]
    }, {
      type: HostBinding,
      args: ["class.k-label"]
    }]
  });
})();
var PagerDropDownListDirective = class {
  constructor(host) {
    this.host = host;
    this.keydownHandler = (e) => {
      if (e.keyCode === Keys.Escape && this.host.isOpen) {
        e.stopPropagation();
        this.host.toggle(false);
      }
    };
  }
  ngAfterViewInit() {
    const wrapperElement = this.host.wrapper.nativeElement;
    wrapperElement.addEventListener("keydown", this.keydownHandler, true);
  }
  ngOnDestroy() {
    this.host.wrapper.nativeElement.removeEventListener("keydown", this.keydownHandler);
  }
};
PagerDropDownListDirective.ɵfac = function PagerDropDownListDirective_Factory(t) {
  return new (t || PagerDropDownListDirective)(ɵɵdirectiveInject(DropDownListComponent));
};
PagerDropDownListDirective.ɵdir = ɵɵdefineDirective({
  type: PagerDropDownListDirective,
  selectors: [["", "kendoGridPagerDropDown", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerDropDownListDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPagerDropDown]"
    }]
  }], function() {
    return [{
      type: DropDownListComponent
    }];
  }, null);
})();
var PagerPageSizesComponent = class extends PagerElementComponent {
  constructor(ctx, cd, pagerContext, navigationService) {
    super(ctx, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.navigationService = navigationService;
    this._pageSizes = [];
  }
  /**
   * The page sizes collection. Can be an Array of numbers and/or [`PageSizeItem`](slug:api_grid_pagesizeitem) objects
   * ([see example]({% slug paging_grid %}#toc-pager-templates))
   */
  set pageSizes(pageSizes) {
    let normalizedItems = [];
    pageSizes.forEach((item) => {
      if (typeof item === "number") {
        normalizedItems.push({
          text: item.toString(),
          value: item
        });
      } else {
        normalizedItems.push(item);
      }
    });
    if (this.pageSize && !normalizedItems.some((item) => item.value === this.pageSize)) {
      normalizedItems = [{
        text: this.pageSize.toString(),
        value: this.pageSize
      }, ...normalizedItems];
    }
    this._pageSizes = normalizedItems;
  }
  get pageSizes() {
    return this._pageSizes;
  }
  /**
   * @hidden
   *
   * @readonly
   */
  get classes() {
    return true;
  }
  /**
   * @hidden
   *
   * @readonly
   */
  get showInitialPageSize() {
    return this.pageSizes.filter((item) => {
      if (typeof item.value === "number") {
        return item.value === Number(this.pageSize);
      }
      return this.total === Number(this.pageSize);
    }).length === 0;
  }
  /**
   * @hidden
   */
  pageSizeChange(value2) {
    this.pageSize = typeof value2 === "number" ? value2 : this.total;
    this.pagerContext.changePageSize(this.pageSize);
  }
  /**
   * @hidden
   */
  getValue(page) {
    return typeof page.value === "number" ? page.value : this.total;
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = typeof pageSize === "number" ? pageSize : this.total;
    this.cd.markForCheck();
  }
};
PagerPageSizesComponent.ɵfac = function PagerPageSizesComponent_Factory(t) {
  return new (t || PagerPageSizesComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(NavigationService));
};
PagerPageSizesComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerPageSizesComponent,
  selectors: [["kendo-pager-page-sizes"]],
  hostVars: 4,
  hostBindings: function PagerPageSizesComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("k-pager-sizes", ctx.classes)("k-label", ctx.classes);
    }
  },
  inputs: {
    pageSizes: "pageSizes"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 7,
  consts: [["dropdownlist", ""], ["kendoGridPagerDropDown", "", "kendoGridFocusable", "", "textField", "text", "valueField", "value", 1, "k-dropdown", 3, "valueChange", "size", "tabindex", "data", "valuePrimitive", "value"], [3, "for", "text"]],
  template: function PagerPageSizesComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "kendo-dropdownlist", 1, 0);
      ɵɵlistener("valueChange", function PagerPageSizesComponent_Template_kendo_dropdownlist_valueChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.pageSizeChange($event));
      });
      ɵɵelementEnd();
      ɵɵelement(2, "kendo-label", 2);
    }
    if (rf & 2) {
      const dropdownlist_r2 = ɵɵreference(1);
      ɵɵproperty("size", ctx.size)("tabindex", 0)("data", ctx.pageSizes)("valuePrimitive", true)("value", ctx.pageSize);
      ɵɵadvance(2);
      ɵɵproperty("for", dropdownlist_r2)("text", ctx.textFor("pagerItemsPerPage"));
    }
  },
  dependencies: [LabelComponent, DropDownListComponent, FocusableDirective, PagerDropDownListDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPageSizesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-pager-page-sizes",
      template: `
        <kendo-dropdownlist
            class="k-dropdown"
            #dropdownlist
            [size]="size"
            kendoGridPagerDropDown
            [tabindex]="0"
            kendoGridFocusable
            [data]="pageSizes"
            textField="text"
            valueField="value"
            [valuePrimitive]="true"
            [value]="pageSize"
            (valueChange)="pageSizeChange($event)"></kendo-dropdownlist>
        <kendo-label [for]="dropdownlist" [text]="textFor('pagerItemsPerPage')"></kendo-label>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }, {
      type: NavigationService
    }];
  }, {
    pageSizes: [{
      type: Input
    }],
    classes: [{
      type: HostBinding,
      args: ["class.k-pager-sizes"]
    }, {
      type: HostBinding,
      args: ["class.k-label"]
    }]
  });
})();
var PagerNumericButtonsComponent = class extends PagerElementComponent {
  constructor(ctx, cd, pagerContext) {
    super(ctx, pagerContext, cd);
    this.pagerContext = pagerContext;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {number[]}
   * @memberOf PagerNumericButtonsComponent
   */
  get buttons() {
    const result = [];
    for (let idx = this.start; idx <= this.end; idx++) {
      result.push(idx);
    }
    return result;
  }
  /**
   * @hidden
   */
  get end() {
    return Math.min(this.start + this.buttonCount - 1, this.totalPages);
  }
  /**
   * @hidden
   */
  get start() {
    const page = this.currentPage;
    const buttonCount = this.buttonCount;
    if (page > buttonCount) {
      const reminder = page % buttonCount;
      return reminder === 0 ? page - buttonCount + 1 : page - reminder + 1;
    }
    return 1;
  }
  /**
   * @hidden
   */
  pageLabel(num) {
    const pageText = this.textFor("pagerPage");
    if (pageText) {
      return pageText + " " + num;
    }
    return num.toString();
  }
  /**
   * @hidden
   */
  onSelectChange(e) {
    const target = e.target;
    const valueAsNumber = Number(target.value);
    if (!Number.isNaN(valueAsNumber)) {
      this.changePage(valueAsNumber - 1);
    } else {
      if (target.value === "previousButtons") {
        this.changePage(this.start - 2);
      } else {
        this.changePage(this.end);
      }
    }
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
};
PagerNumericButtonsComponent.ɵfac = function PagerNumericButtonsComponent_Factory(t) {
  return new (t || PagerNumericButtonsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PagerContextService));
};
PagerNumericButtonsComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerNumericButtonsComponent,
  selectors: [["kendo-pager-numeric-buttons"]],
  viewQuery: function PagerNumericButtonsComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c34, 5, ElementRef);
      ɵɵviewQuery(_c35, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectElement = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numbersElement = _t.first);
    }
  },
  inputs: {
    buttonCount: "buttonCount"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 14,
  consts: [["select", ""], ["numbers", ""], ["kendoGridFocusable", "", 1, "k-dropdown-list", "k-dropdown", "k-picker", "k-picker-solid", "k-rounded-md", 3, "change", "ngClass"], ["value", "previousButtons", 3, "selected", 4, "ngIf"], [3, "value", "selected", "ngClass", 4, "ngFor", "ngForOf"], ["value", "nextButtons", 3, "selected", 4, "ngIf"], [1, "k-pager-numbers"], ["type", "button", "kendoGridFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "class", "k-pager-nav", "rounded", "none", 3, "size", "click", 4, "ngIf"], ["type", "button", "kendoGridFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "class", "k-pager-nav", "rounded", "none", 3, "size", "selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", "kendoGridFocusable", "", "kendoButton", "", "class", "k-pager-nav", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 3, "size", "click", 4, "ngIf"], ["value", "previousButtons", 3, "selected"], [3, "value", "selected", "ngClass"], ["value", "nextButtons", 3, "selected"], ["type", "button", "kendoGridFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 1, "k-pager-nav", 3, "click", "size"], ["type", "button", "kendoGridFocusable", "", "kendoButton", "", "fillMode", "flat", "themeColor", "primary", "rounded", "none", 1, "k-pager-nav", 3, "click", "size", "selected"]],
  template: function PagerNumericButtonsComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "select", 2, 0);
      ɵɵlistener("change", function PagerNumericButtonsComponent_Template_select_change_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onSelectChange($event));
      });
      ɵɵtemplate(2, PagerNumericButtonsComponent_option_2_Template, 2, 2, "option", 3)(3, PagerNumericButtonsComponent_option_3_Template, 2, 8, "option", 4)(4, PagerNumericButtonsComponent_option_4_Template, 2, 2, "option", 5);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 6, 1);
      ɵɵtemplate(7, PagerNumericButtonsComponent_button_7_Template, 2, 3, "button", 7)(8, PagerNumericButtonsComponent_button_8_Template, 2, 6, "button", 8)(9, PagerNumericButtonsComponent_button_9_Template, 2, 3, "button", 9);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵstyleProp("display", "none");
      ɵɵproperty("ngClass", ɵɵpureFunction2(11, _c36, ctx.size === "small", ctx.size === "medium" || !ctx.size));
      ɵɵattribute("title", ctx.textFor("selectPage"))("aria-label", ctx.textFor("selectPage"));
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.start > 1);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.buttons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.start > 1);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.buttons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.end < ctx.totalPages);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, ButtonComponent, FocusableDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNumericButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-pager-numeric-buttons",
      template: `
        <select
            #select
            class="k-dropdown-list k-dropdown k-picker k-picker-solid k-rounded-md"
            kendoGridFocusable
            [style.display]="'none'"
            [attr.title]="textFor('selectPage')"
            [attr.aria-label]="textFor('selectPage')"
            [ngClass]="{
                'k-picker-sm': size === 'small',
                'k-picker-md': size === 'medium' || !size
            }"
            (change)="onSelectChange($event)">
            <option *ngIf="start > 1"
                value="previousButtons"
                [selected]="false"
                [attr.aria-label]="pageLabel(start - 1)">...
            </option>
            <option *ngFor="let num of buttons"
                [value]="num.toString()"
                [selected]="num === currentPage"
                [attr.aria-label]="pageLabel(num)"
                [attr.aria-current]="currentPage === num ? 'page' : undefined"
                [ngClass]="{'k-selected':currentPage === num}">
                {{num}}
            </option>
            <option *ngIf="end < totalPages"
                value="nextButtons"
                [selected]="false"
                [attr.aria-label]="pageLabel(end + 1)">...
            </option>
        </select>
        <div class="k-pager-numbers" #numbers>
            <button *ngIf="start > 1"
                type="button"
                kendoGridFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                class="k-pager-nav"
                rounded="none"
                [attr.aria-label]="pageLabel(start - 1)"
                [attr.title]="pageLabel(start - 1)"
                (click)="changePage(start - 2)">...</button>
            <button *ngFor="let num of buttons"
                type="button"
                kendoGridFocusable
                kendoButton
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                class="k-pager-nav"
                rounded="none"
                [attr.aria-label]="pageLabel(num)"
                [attr.title]="pageLabel(num)"
                [attr.aria-current]="currentPage === num ? 'page' : undefined"
                [selected]="currentPage === num"
                (click)="changePage(num - 1)">
                {{num}}
            </button>
            <button *ngIf="end < totalPages"
                type="button"
                kendoGridFocusable
                kendoButton
                class="k-pager-nav"
                [size]="size"
                fillMode="flat"
                themeColor="primary"
                rounded="none"
                [attr.aria-label]="pageLabel(end + 1)"
                [attr.title]="pageLabel(end + 1)"
                (click)="changePage(end)">...</button>
        </div>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PagerContextService
    }];
  }, {
    selectElement: [{
      type: ViewChild,
      args: ["select", {
        read: ElementRef
      }]
    }],
    numbersElement: [{
      type: ViewChild,
      args: ["numbers", {
        read: ElementRef
      }]
    }],
    buttonCount: [{
      type: Input
    }]
  });
})();
var PagerPrevButtonsComponent = class extends PagerElementComponent {
  constructor(ctx, pagerContext, cd, navigationService) {
    super(ctx, pagerContext, cd);
    this.navigationService = navigationService;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerPrevButtonsComponent
   */
  get disabled() {
    return this.currentPage === 1 || !this.total;
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
};
PagerPrevButtonsComponent.ɵfac = function PagerPrevButtonsComponent_Factory(t) {
  return new (t || PagerPrevButtonsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NavigationService));
};
PagerPrevButtonsComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerPrevButtonsComponent,
  selectors: [["kendo-pager-prev-buttons"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 14,
  consts: [["kendoButton", "", "type", "button", "role", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-first", 3, "click", "kendoGridFocusable", "title", "icon", "svgIcon", "disabled", "size"], ["kendoButton", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "kendoGridFocusable", "disabled", "icon", "svgIcon", "size", "title"]],
  template: function PagerPrevButtonsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_0_listener() {
        return ctx.currentPage !== 1 ? ctx.changePage(0) : false;
      });
      ɵɵelementEnd();
      ɵɵelementStart(1, "button", 1);
      ɵɵlistener("click", function PagerPrevButtonsComponent_Template_button_click_1_listener() {
        return ctx.currentPage !== 1 ? ctx.changePage(ctx.currentPage - 2) : false;
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("kendoGridFocusable", !ctx.disabled)("title", ctx.textFor("pagerFirstPage"))("icon", ctx.prevArrowIcons[0])("svgIcon", ctx.prevArrowSVGIcons[0])("disabled", ctx.disabled)("size", ctx.size);
      ɵɵattribute("aria-label", ctx.textFor("pagerFirstPage"));
      ɵɵadvance();
      ɵɵproperty("kendoGridFocusable", !ctx.disabled)("disabled", ctx.disabled)("icon", ctx.prevArrowIcons[1])("svgIcon", ctx.prevArrowSVGIcons[1])("size", ctx.size)("title", ctx.textFor("pagerPreviousPage"));
      ɵɵattribute("aria-label", ctx.textFor("pagerPreviousPage"));
    }
  },
  dependencies: [ButtonComponent, FocusableDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerPrevButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-pager-prev-buttons",
      template: `
        <button
            [kendoGridFocusable]="!disabled"
            kendoButton
            type="button"
            [title]="textFor('pagerFirstPage')"
            [attr.aria-label]="textFor('pagerFirstPage')"
            (click)="currentPage !== 1 ? changePage(0) : false"
            role="button"
            [icon]="prevArrowIcons[0]"
            [svgIcon]="prevArrowSVGIcons[0]"
            class="k-pager-nav k-pager-first"
            [disabled]="disabled"
            fillMode="flat"
            rounded="none"
            [size]="size">
        </button>
        <button
            kendoButton
            [kendoGridFocusable]="!disabled"
            type="button"
            class="k-pager-nav"
            [disabled]="disabled"
            [icon]="prevArrowIcons[1]"
            [svgIcon]="prevArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            [size]="size"
            [title]="textFor('pagerPreviousPage')"
            [attr.aria-label]="textFor('pagerPreviousPage')"
            (click)="currentPage !== 1 ? changePage(currentPage-2) : false">
        </button>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NavigationService
    }];
  }, null);
})();
var PagerNextButtonsComponent = class extends PagerElementComponent {
  constructor(ctx, pagerContext, cd, navigationService) {
    super(ctx, pagerContext, cd);
    this.navigationService = navigationService;
  }
  /**
   * @hidden
   *
   * @readonly
   * @type {boolean}
   * @memberOf PagerNextButtonsComponent
   */
  get disabled() {
    return this.currentPage === this.totalPages || !this.total;
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
};
PagerNextButtonsComponent.ɵfac = function PagerNextButtonsComponent_Factory(t) {
  return new (t || PagerNextButtonsComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NavigationService));
};
PagerNextButtonsComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerNextButtonsComponent,
  selectors: [["kendo-pager-next-buttons"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 14,
  consts: [["kendoButton", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", 3, "click", "kendoGridFocusable", "size", "icon", "svgIcon", "disabled", "title"], ["kendoButton", "", "type", "button", "fillMode", "flat", "rounded", "none", 1, "k-pager-nav", "k-pager-last", 3, "click", "kendoGridFocusable", "size", "icon", "svgIcon", "disabled", "title"]],
  template: function PagerNextButtonsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_0_listener() {
        return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.currentPage) : false;
      });
      ɵɵelementEnd();
      ɵɵelementStart(1, "button", 1);
      ɵɵlistener("click", function PagerNextButtonsComponent_Template_button_click_1_listener() {
        return ctx.currentPage !== ctx.totalPages ? ctx.changePage(ctx.totalPages - 1) : false;
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("kendoGridFocusable", !ctx.disabled)("size", ctx.size)("icon", ctx.nextArrowIcons[0])("svgIcon", ctx.nextArrowSVGIcons[0])("disabled", ctx.disabled)("title", ctx.textFor("pagerNextPage"));
      ɵɵattribute("aria-label", ctx.textFor("pagerNextPage"));
      ɵɵadvance();
      ɵɵproperty("kendoGridFocusable", !ctx.disabled)("size", ctx.size)("icon", ctx.nextArrowIcons[1])("svgIcon", ctx.nextArrowSVGIcons[1])("disabled", ctx.disabled)("title", ctx.textFor("pagerLastPage"));
      ɵɵattribute("aria-label", ctx.textFor("pagerLastPage"));
    }
  },
  dependencies: [ButtonComponent, FocusableDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerNextButtonsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-pager-next-buttons",
      template: `
        <button
            kendoButton
            [kendoGridFocusable]="!disabled"
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[0]"
            [svgIcon]="nextArrowSVGIcons[0]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav"
            [disabled]="disabled"
            [title]="textFor('pagerNextPage')"
            [attr.aria-label]="textFor('pagerNextPage')"
            (click)="currentPage !== totalPages ? changePage(currentPage) : false">
        </button>
        <button
            kendoButton
            [kendoGridFocusable]="!disabled"
            type="button"
            [size]="size"
            [icon]="nextArrowIcons[1]"
            [svgIcon]="nextArrowSVGIcons[1]"
            fillMode="flat"
            rounded="none"
            class="k-pager-nav k-pager-last"
            [disabled]="disabled"
            [title]="textFor('pagerLastPage')"
            [attr.aria-label]="textFor('pagerLastPage')"
            (click)="currentPage !== totalPages ? changePage(totalPages-1) : false">
        </button>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: PagerContextService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NavigationService
    }];
  }, null);
})();
var PagerInputDirective = class {
  constructor(host, renderer) {
    this.host = host;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    const inputElement = this.host.numericInput.nativeElement;
    this.renderer.addClass(inputElement, "k-pager-nav");
  }
};
PagerInputDirective.ɵfac = function PagerInputDirective_Factory(t) {
  return new (t || PagerInputDirective)(ɵɵdirectiveInject(NumericTextBoxComponent), ɵɵdirectiveInject(Renderer2));
};
PagerInputDirective.ɵdir = ɵɵdefineDirective({
  type: PagerInputDirective,
  selectors: [["", "kendoGridPagerInput", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInputDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPagerInput]"
    }]
  }], function() {
    return [{
      type: NumericTextBoxComponent
    }, {
      type: Renderer2
    }];
  }, null);
})();
var PagerInputComponent = class extends PagerElementComponent {
  constructor(ctx, pagerContext, zone, navigationService, cd) {
    super(ctx, pagerContext, cd);
    this.pagerContext = pagerContext;
    this.zone = zone;
    this.navigationService = navigationService;
    this.handleKeyDown = (event2) => {
      const incomingValue = this.numericInput.value || this.current;
      if (event2.keyCode === Keys.Enter) {
        event2.preventDefault();
        if (incomingValue !== this.current) {
          this.zone.run(() => {
            this.changePage(incomingValue - 1);
          });
        }
      }
    };
    this.handleBlur = () => {
      const inputValue = this.numericInput.value;
      if (!inputValue) {
        this.numericInput.writeValue(this.current);
        return;
      }
      if (inputValue !== this.current) {
        this.zone.run(() => {
          this.changePage(inputValue - 1);
        });
      }
    };
  }
  /**
   * @hidden
   */
  get current() {
    return this.hasPages ? this.currentPage : 0;
  }
  get hasPages() {
    return this.totalPages !== 0;
  }
  onChanges({
    total,
    skip: skip4,
    pageSize
  }) {
    this.total = total;
    this.skip = skip4;
    this.pageSize = pageSize;
    this.cd.markForCheck();
  }
};
PagerInputComponent.ɵfac = function PagerInputComponent_Factory(t) {
  return new (t || PagerInputComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(ChangeDetectorRef));
};
PagerInputComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerInputComponent,
  selectors: [["kendo-pager-input"]],
  viewQuery: function PagerInputComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NumericTextBoxComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericInput = _t.first);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 17,
  consts: [[1, "k-pager-input", "k-label"], ["kendoGridPagerInput", "", "format", "n0", 3, "kendoGridFocusable", "spinners", "decimals", "disabled", "value", "min", "max", "size", "autoCorrect", "title", "kendoEventsOutsideAngular"]],
  template: function PagerInputComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelement(2, "kendo-numerictextbox", 1);
      ɵɵtext(3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.textFor("pagerPage"), " ");
      ɵɵadvance();
      ɵɵproperty("kendoGridFocusable", ctx.hasPages)("spinners", false)("decimals", 0)("disabled", !ctx.hasPages)("value", ctx.current)("min", ctx.hasPages ? 1 : 0)("max", ctx.totalPages)("size", ctx.size)("autoCorrect", true)("title", ctx.textFor("pagerPageNumberInputTitle"))("kendoEventsOutsideAngular", ɵɵpureFunction2(14, _c38, ctx.handleKeyDown, ctx.handleBlur));
      ɵɵadvance();
      ɵɵtextInterpolate2(" ", ctx.textFor("pagerOf"), " ", ctx.totalPages, " ");
    }
  },
  dependencies: [EventsOutsideAngularDirective, NumericTextBoxComponent, FocusableDirective, PagerInputDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager-input",
      template: `
     <span class="k-pager-input k-label">
        {{textFor('pagerPage')}}
        <kendo-numerictextbox
            kendoGridPagerInput
            [kendoGridFocusable]="hasPages"
            [spinners]="false"
            [decimals]="0"
            format="n0"
            [disabled]="!hasPages"
            [value]="current"
            [min]="hasPages ? 1 : 0"
            [max]="totalPages"
            [size]="size"
            [autoCorrect]="true"
            [title]="textFor('pagerPageNumberInputTitle')"
            [kendoEventsOutsideAngular]="{
                keydown: handleKeyDown,
                focusout: handleBlur
            }"
        >
        </kendo-numerictextbox>
        {{textFor('pagerOf')}} {{totalPages}}
     </span>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: PagerContextService
    }, {
      type: NgZone
    }, {
      type: NavigationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    numericInput: [{
      type: ViewChild,
      args: [NumericTextBoxComponent, {
        static: false
      }]
    }]
  });
})();
var PagerComponent = class {
  constructor(pagerContext, navigationService, element, renderer, zone, ctx, cellContext, focusRoot, focusGroup) {
    this.pagerContext = pagerContext;
    this.navigationService = navigationService;
    this.element = element;
    this.renderer = renderer;
    this.zone = zone;
    this.ctx = ctx;
    this.cellContext = cellContext;
    this.focusRoot = focusRoot;
    this.focusGroup = focusGroup;
    this.total = 0;
    this.skip = 1;
    this.pageChange = new EventEmitter();
    this.gridPagerClass = true;
    this.settings = normalize({});
    this.subscriptions = new Subscription();
    this._templateContext = {};
    this._isFocused = false;
    this._size = "medium";
    this.resizeHandler = () => {
      const element2 = this.element.nativeElement;
      if (this.template || !element2) {
        return;
      }
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          const width = element2.offsetWidth;
          if (this.numericButtons) {
            const selectElement = this.numericButtons.selectElement.nativeElement;
            const numbersElement = this.numericButtons.numbersElement.nativeElement;
            this.renderer.removeStyle(numbersElement, "display");
            this.renderer.setStyle(selectElement, "display", "none");
            if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
              this.renderer.removeStyle(selectElement, "display");
              this.renderer.setStyle(numbersElement, "display", "none");
            }
          }
          if (this.pagerInfo) {
            this.renderer.removeStyle(this.pagerInfo.nativeElement, "display");
            if (width < RESPONSIVE_BREAKPOINT_LARGE) {
              this.renderer.setStyle(this.pagerInfo.nativeElement, "display", "none");
            }
          }
          if (this.pagerPageSizes) {
            this.renderer.removeStyle(this.pagerPageSizes.nativeElement, "display");
            if (width < RESPONSIVE_BREAKPOINT_MEDIUM) {
              this.renderer.setStyle(this.pagerPageSizes.nativeElement, "display", "none");
            }
          }
        });
      });
    };
  }
  set options(value2) {
    this.settings = normalize(value2);
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.element.nativeElement.classList.remove("k-pager-sm", "k-pager-md");
    }
  }
  get size() {
    return this._size;
  }
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  get isFocused() {
    return this._isFocused;
  }
  get pagerAriaLabel() {
    return this.navigationService.pagerEnabled ? this.pagerLabel : void 0;
  }
  get pagerLabel() {
    const localizationMsg = this.ctx.localization.get("pagerLabel") || "";
    return replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, "currentPage", this.currentPage.toString()), "totalPages", this.totalPages.toString());
  }
  get focusTrapTabIndex() {
    return this.focusGroup.isActive ? "0" : "-1";
  }
  onFocusIn(event2) {
    if (this.navigationService.pagerEnabled) {
      const shouldFocusPager = event2.target === this.element.nativeElement;
      if (shouldFocusPager) {
        this._isFocused = true;
        this.focusRoot.deactivate();
      } else {
        this.focusRoot.activate();
      }
    }
  }
  onFocusOut() {
    if (this.navigationService.pagerEnabled) {
      this._isFocused = false;
    }
  }
  onEscape() {
    if (this.navigationService.pagerEnabled) {
      this.focusRoot.deactivate();
      this.element.nativeElement.focus();
    }
  }
  onEnter(event2) {
    if (this.navigationService.pagerEnabled && event2.target === this.element.nativeElement) {
      event2.preventDefault();
      this.focusRoot.activate();
      this.focusFirstElement();
    }
  }
  navigateToPreviousPage(e) {
    e.preventDefault();
    if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
      this.pagerContext.prevPage();
    }
  }
  navigateToNextPage(e) {
    e.preventDefault();
    if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
      this.pagerContext.nextPage();
    }
  }
  navigateToFirstPage(e) {
    e.preventDefault();
    if (this.shouldTriggerPageChange(e.target, this.currentPage > 1)) {
      this.pagerContext.changePage(0);
    }
  }
  navigateToLastPage(e) {
    e.preventDefault();
    if (this.shouldTriggerPageChange(e.target, this.currentPage < this.totalPages)) {
      this.pagerContext.changePage(this.totalPages - 1);
    }
  }
  get totalPages() {
    return Math.ceil((this.total || 0) / this.pageSize);
  }
  get currentPage() {
    return Math.floor((this.skip || 0) / this.pageSize) + 1;
  }
  get templateContext() {
    const context = this._templateContext;
    context.totalPages = this.totalPages;
    context.total = this.total;
    context.skip = this.skip;
    context.pageSize = this.pageSize;
    context.currentPage = this.currentPage;
    return context;
  }
  ngOnInit() {
    this.subscriptions.add(this.pagerContext.pageChange.subscribe(this.changePage.bind(this)));
    if (this.navigationService.pagerEnabled) {
      this.focusRoot.deactivate();
    }
  }
  ngDoCheck() {
    this.updateCellContext();
  }
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "total"], changes, false)) {
      this.pagerContext.notifyChanges({
        pageSize: this.pageSize,
        skip: this.skip,
        total: this.total
      });
    }
    const changesInTemplate = changes["template"];
    if (changesInTemplate) {
      changesInTemplate.currentValue ? this.clearResponsiveStyling() : this.resizeHandler();
    }
    if (changes["options"]) {
      this.settings.responsive ? this.resizeHandler() : this.clearResponsiveStyling();
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  changePage(event2) {
    this.pageChange.emit(event2);
  }
  onInnerFocusIn(event2, position2) {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      if (position2 === "start") {
        if (event2.relatedTarget === this.element.nativeElement) {
          this.focusFirstElement();
        } else {
          this.focusLastElement();
        }
      } else {
        this.focusFirstElement();
      }
    });
  }
  shouldTriggerPageChange(target, condition) {
    return this.navigationService.pagerEnabled && target === this.element.nativeElement && condition;
  }
  focusFirstElement() {
    const first = findFocusableChild(this.element.nativeElement, true);
    if (first) {
      first.focus();
    }
  }
  focusLastElement() {
    const last = findLastFocusableChild(this.element.nativeElement, true);
    if (last) {
      last.focus();
    }
  }
  updateCellContext() {
    if (this.cellContext) {
      this.cellContext.focusGroup = this.focusGroup;
    }
  }
  clearResponsiveStyling() {
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        if (this.numericButtons) {
          this.renderer.removeStyle(this.numericButtons.numbersElement.nativeElement, "display");
          this.renderer.setStyle(this.numericButtons.selectElement.nativeElement, "display", "none");
        }
        this.pagerInfo && this.renderer.removeStyle(this.pagerInfo.nativeElement, "display");
        this.pagerPageSizes && this.renderer.removeStyle(this.pagerPageSizes.nativeElement, "display");
      });
    });
  }
};
PagerComponent.ɵfac = function PagerComponent_Factory(t) {
  return new (t || PagerComponent)(ɵɵdirectiveInject(PagerContextService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(CELL_CONTEXT, 8), ɵɵdirectiveInject(FocusRoot), ɵɵdirectiveInject(FocusGroup));
};
PagerComponent.ɵcmp = ɵɵdefineComponent({
  type: PagerComponent,
  selectors: [["kendo-pager"]],
  viewQuery: function PagerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(PagerInfoComponent, 5, ElementRef);
      ɵɵviewQuery(PagerPageSizesComponent, 5, ElementRef);
      ɵɵviewQuery(PagerNumericButtonsComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerInfo = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerPageSizes = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericButtons = _t.first);
    }
  },
  hostVars: 9,
  hostBindings: function PagerComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focusin", function PagerComponent_focusin_HostBindingHandler($event) {
        return ctx.onFocusIn($event);
      })("focusout", function PagerComponent_focusout_HostBindingHandler() {
        return ctx.onFocusOut();
      })("keydown.escape", function PagerComponent_keydown_escape_HostBindingHandler() {
        return ctx.onEscape();
      })("keydown.enter", function PagerComponent_keydown_enter_HostBindingHandler($event) {
        return ctx.onEnter($event);
      })("keydown.arrowleft", function PagerComponent_keydown_arrowleft_HostBindingHandler($event) {
        return ctx.navigateToPreviousPage($event);
      })("keydown.pageup", function PagerComponent_keydown_pageup_HostBindingHandler($event) {
        return ctx.navigateToPreviousPage($event);
      })("keydown.arrowright", function PagerComponent_keydown_arrowright_HostBindingHandler($event) {
        return ctx.navigateToNextPage($event);
      })("keydown.pagedown", function PagerComponent_keydown_pagedown_HostBindingHandler($event) {
        return ctx.navigateToNextPage($event);
      })("keydown.home", function PagerComponent_keydown_home_HostBindingHandler($event) {
        return ctx.navigateToFirstPage($event);
      })("keydown.end", function PagerComponent_keydown_end_HostBindingHandler($event) {
        return ctx.navigateToLastPage($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.pagerAriaLabel);
      ɵɵclassProp("k-grid-pager", ctx.gridPagerClass)("k-pager-sm", ctx.sizeSmallClass)("k-pager-md", ctx.sizeMediumClass)("k-focus", ctx.isFocused);
    }
  },
  inputs: {
    total: "total",
    skip: "skip",
    pageSize: "pageSize",
    options: "options",
    size: "size",
    template: "template"
  },
  outputs: {
    pageChange: "pageChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: FOCUS_ROOT_ACTIVE,
    useValue: true
  }, {
    provide: FocusRoot,
    deps: [FOCUS_ROOT_ACTIVE],
    useClass: FocusRoot
  }, {
    provide: FocusGroup,
    deps: [FocusRoot],
    useClass: FocusGroup
  }]), ɵɵNgOnChangesFeature],
  decls: 5,
  vars: 5,
  consts: [["class", "k-sr-only", 3, "tabindex", "focusin", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [4, "ngIf"], [3, "resize", 4, "ngIf"], [1, "k-sr-only", 3, "focusin", "tabindex"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-pager-numbers-wrap"], [3, "size", 4, "ngIf"], [3, "size", "buttonCount", 4, "ngIf"], [3, "size", "pageSizes", 4, "ngIf"], [3, "size"], [3, "size", "buttonCount"], [3, "size", "pageSizes"], [3, "resize"]],
  template: function PagerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, PagerComponent_div_0_Template, 1, 2, "div", 0)(1, PagerComponent_ng_container_1_Template, 1, 2, "ng-container", 1)(2, PagerComponent_ng_container_2_Template, 8, 6, "ng-container", 2)(3, PagerComponent_div_3_Template, 1, 2, "div", 0)(4, PagerComponent_kendo_resize_sensor_4_Template, 1, 0, "kendo-resize-sensor", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.navigationService.pagerEnabled);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.template == null ? null : ctx.template.templateRef);
      ɵɵadvance();
      ɵɵproperty("ngIf", !(ctx.template == null ? null : ctx.template.templateRef));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.navigationService.pagerEnabled);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.settings.responsive);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, ResizeSensorComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-pager",
      providers: [{
        provide: FOCUS_ROOT_ACTIVE,
        useValue: true
      }, {
        provide: FocusRoot,
        deps: [FOCUS_ROOT_ACTIVE],
        useClass: FocusRoot
      }, {
        provide: FocusGroup,
        deps: [FocusRoot],
        useClass: FocusGroup
      }],
      template: `
        <div
            *ngIf="navigationService.pagerEnabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'start')">
        </div>
        <ng-container
            *ngIf="template?.templateRef"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext">
        </ng-container>
        <ng-container *ngIf="!template?.templateRef">
            <div class="k-pager-numbers-wrap">
                <kendo-pager-prev-buttons [size]="size" *ngIf="settings.previousNext"></kendo-pager-prev-buttons>
                <kendo-pager-numeric-buttons
                    [size]="size"
                    *ngIf="settings.type === 'numeric'"
                    [buttonCount]="settings.buttonCount">
                </kendo-pager-numeric-buttons>
                <kendo-pager-input [size]="size" *ngIf="settings.type === 'input'"></kendo-pager-input>
                <kendo-pager-next-buttons [size]="size" *ngIf="settings.previousNext"></kendo-pager-next-buttons>
            </div>
            <kendo-pager-info *ngIf='settings.info'></kendo-pager-info>
            <kendo-pager-page-sizes
                [size]="size"
                *ngIf="settings.pageSizes"
                [pageSizes]="$any(settings.pageSizes)"
            ></kendo-pager-page-sizes>
        </ng-container>
        <div
            *ngIf="navigationService.pagerEnabled"
            class="k-sr-only"
            [tabindex]="focusTrapTabIndex"
            [attr.aria-hidden]="true"
            (focusin)="onInnerFocusIn($event, 'end')">
        </div>
        <kendo-resize-sensor *ngIf="settings.responsive" (resize)="resizeHandler()"></kendo-resize-sensor>
  `
    }]
  }], function() {
    return [{
      type: PagerContextService
    }, {
      type: NavigationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ContextService
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: FocusRoot
    }, {
      type: FocusGroup
    }];
  }, {
    pagerInfo: [{
      type: ViewChild,
      args: [PagerInfoComponent, {
        read: ElementRef
      }]
    }],
    pagerPageSizes: [{
      type: ViewChild,
      args: [PagerPageSizesComponent, {
        read: ElementRef
      }]
    }],
    numericButtons: [{
      type: ViewChild,
      args: [PagerNumericButtonsComponent]
    }],
    total: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    gridPagerClass: [{
      type: HostBinding,
      args: ["class.k-grid-pager"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-pager-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-pager-md"]
    }],
    isFocused: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    pagerAriaLabel: [{
      type: HostBinding,
      args: ["attr.aria-label"]
    }],
    onFocusIn: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    onFocusOut: [{
      type: HostListener,
      args: ["focusout"]
    }],
    onEscape: [{
      type: HostListener,
      args: ["keydown.escape"]
    }],
    onEnter: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }],
    navigateToPreviousPage: [{
      type: HostListener,
      args: ["keydown.arrowleft", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.pageup", ["$event"]]
    }],
    navigateToNextPage: [{
      type: HostListener,
      args: ["keydown.arrowright", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.pagedown", ["$event"]]
    }],
    navigateToFirstPage: [{
      type: HostListener,
      args: ["keydown.home", ["$event"]]
    }],
    navigateToLastPage: [{
      type: HostListener,
      args: ["keydown.end", ["$event"]]
    }]
  });
})();
var update = (arr, idx, value2) => [...arr.slice(0, idx + 1), ...arr.slice(idx + 1).map((x) => x + value2)];
var RowHeightService = class {
  constructor(total = 0, rowHeight, detailRowHeight) {
    this.total = total;
    this.rowHeight = rowHeight;
    this.detailRowHeight = detailRowHeight;
    this.offsets = [];
    this.heights = [];
    let agg = 0;
    for (let idx = 0; idx < total; idx++) {
      this.offsets.push(agg);
      agg += rowHeight;
      this.heights.push(rowHeight);
    }
  }
  height(rowIndex) {
    return this.heights[rowIndex];
  }
  expandDetail(rowIndex) {
    if (this.height(rowIndex) === this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight);
    }
  }
  collapseDetail(rowIndex) {
    if (this.height(rowIndex) > this.rowHeight) {
      this.updateRowHeight(rowIndex, this.detailRowHeight * -1);
    }
  }
  isExpanded(rowIndex) {
    return this.height(rowIndex) > this.rowHeight;
  }
  index(position2) {
    if (position2 < 0) {
      return void 0;
    }
    const result = this.offsets.reduce((prev, current3, idx) => {
      if (prev !== void 0) {
        return prev;
      } else if (current3 === position2) {
        return idx;
      } else if (current3 > position2) {
        return idx - 1;
      }
      return void 0;
    }, void 0);
    return result === void 0 ? this.total - 1 : result;
  }
  offset(rowIndex, adjustIndex = false) {
    if (adjustIndex) {
      let targetOffset = 0;
      let targetIndex = 0;
      for (let i = 0; i < rowIndex; i++) {
        targetOffset += this.rowHeight;
        targetIndex++;
        if (targetIndex === rowIndex) {
          return targetOffset;
        }
        if (this.isExpanded(i)) {
          targetOffset += this.detailRowHeight;
          targetIndex++;
          if (targetIndex === rowIndex) {
            return targetOffset;
          }
        }
      }
      return targetOffset;
    }
    return this.offsets[rowIndex];
  }
  totalHeight() {
    return this.heights.reduce((prev, curr) => prev + curr, 0);
  }
  updateRowHeight(rowIndex, value2) {
    if (this.total > 0) {
      this.heights[rowIndex] += value2;
      this.offsets = update(this.offsets, rowIndex, value2);
    }
  }
};
var ScrollAction = class {
  constructor(offset2) {
    this.offset = offset2;
  }
};
var PageAction = class {
  constructor(skip4, take4) {
    this.skip = skip4;
    this.take = take4;
  }
};
var ScrollBottomAction = class {
};
var SCROLL_BOTTOM_THRESHOLD = 2;
var ScrollerService = class {
  constructor(scrollObservable) {
    this.scrollObservable = scrollObservable;
    this.firstLoaded = 0;
  }
  create(rowHeightService, skip4, take4, total) {
    this.rowHeightService = rowHeightService;
    this.firstLoaded = skip4;
    this.lastLoaded = skip4 + take4;
    this.take = take4;
    this.total = total;
    this.lastScrollTop = 0;
    const subject = new BehaviorSubject(new ScrollAction(this.rowHeightService.offset(skip4)));
    this.subscription = Observable.create((observer) => {
      this.unsubscribe();
      this.scrollSubscription = this.scrollObservable.subscribe((x) => this.onScroll(x, observer));
    }).subscribe((x) => subject.next(x));
    return subject;
  }
  destroy() {
    this.unsubscribe();
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  onScroll({
    scrollTop,
    offsetHeight,
    scrollHeight,
    clientHeight
  }, observer) {
    if (!isDocumentAvailable() || this.lastScrollTop === scrollTop) {
      return;
    }
    const up = this.lastScrollTop >= scrollTop;
    this.lastScrollTop = scrollTop;
    let firstItemIndex = this.rowHeightService.index(scrollTop);
    let firstItemOffset = this.rowHeightService.offset(firstItemIndex);
    const lastItemIndex = this.rowHeightService.index(scrollTop + offsetHeight);
    if (!up) {
      if (lastItemIndex >= this.lastLoaded && this.lastLoaded < this.total) {
        const overflow = firstItemIndex + this.take - this.total;
        if (overflow > 0) {
          firstItemIndex = firstItemIndex - overflow;
          firstItemOffset = this.rowHeightService.offset(firstItemIndex);
        }
        this.firstLoaded = firstItemIndex;
        observer.next(new ScrollAction(firstItemOffset));
        let nextTake = this.firstLoaded + this.take;
        this.lastLoaded = Math.min(nextTake, this.total);
        nextTake = nextTake > this.total ? this.total - this.firstLoaded : this.take;
        observer.next(new PageAction(this.firstLoaded, this.take));
      } else {
        const atBottom = scrollHeight - clientHeight - scrollTop < SCROLL_BOTTOM_THRESHOLD;
        if (atBottom) {
          observer.next(new ScrollBottomAction());
        }
      }
    }
    if (up && firstItemIndex < this.firstLoaded) {
      const nonVisibleBuffer = Math.floor(this.take * 0.3);
      this.firstLoaded = Math.max(firstItemIndex - nonVisibleBuffer, 0);
      observer.next(new ScrollAction(this.rowHeightService.offset(this.firstLoaded)));
      this.lastLoaded = Math.min(this.firstLoaded + this.take, this.total);
      observer.next(new PageAction(this.firstLoaded, this.take));
    }
  }
  unsubscribe() {
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
      this.scrollSubscription = void 0;
    }
  }
};
var elementAt = (index, elements, elementOffset) => {
  for (let idx = 0, elementIdx = 0; idx < elements.length; idx++) {
    const offset2 = elementOffset(elements[idx]);
    if (elementIdx <= index && index <= elementIdx + offset2 - 1) {
      return elements[idx];
    }
    elementIdx += offset2;
  }
};
var rowAt = (index, rows) => elementAt(index, rows, () => 1);
var cellAt = (index, cells) => elementAt(index, cells, (cell2) => !hasClasses(cell2, NON_DATA_CELL_CLASSES) ? parseInt(cell2.getAttribute("colSpan"), 10) || 1 : 0);
var EMPTY_OBJECT = {};
var SCROLLER_FACTORY_TOKEN = new InjectionToken("grid-scroll-service-factory");
function DEFAULT_SCROLLER_FACTORY(observable) {
  return new ScrollerService(observable);
}
var wheelDeltaY = (e) => {
  const deltaY = e.wheelDeltaY;
  if (e.wheelDelta && (deltaY === void 0 || deltaY)) {
    return e.wheelDelta;
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    return -e.detail * 10;
  }
  return 0;
};
var preventLockedScroll = (args, element) => {
  const delta = wheelDeltaY(args);
  const scrollTop = element.scrollTop;
  const allowScroll = scrollTop === 0 && 0 < delta || element.scrollHeight <= element.offsetHeight + scrollTop && delta < 0;
  if (!allowScroll) {
    event.preventDefault();
  }
};
var translateY = (renderer, value2) => (el) => renderer.setStyle(el, "transform", `translateY(${value2}px)`);
var maybeNativeElement = (el) => el ? el.nativeElement : null;
var hasScrollbar = (el, parent) => el.nativeElement.offsetWidth > parent.nativeElement.clientWidth;
var setHeight = (renderer) => ({
  el,
  height
}) => renderer.setStyle(el, "height", `${height}px`);
var bufferSize = 1;
var ListComponent = class {
  constructor(scrollerFactory, detailsService, changeNotification, suspendService, groupsService, ngZone, renderer, scrollSyncService, resizeService, editService, supportService, navigationService, scrollRequestService, ctx, columnResizingService, changeDetector, pdfService, columnInfo) {
    this.changeNotification = changeNotification;
    this.suspendService = suspendService;
    this.groupsService = groupsService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.scrollSyncService = scrollSyncService;
    this.resizeService = resizeService;
    this.editService = editService;
    this.supportService = supportService;
    this.navigationService = navigationService;
    this.ctx = ctx;
    this.columnResizingService = columnResizingService;
    this.changeDetector = changeDetector;
    this.pdfService = pdfService;
    this.columnInfo = columnInfo;
    this.hostClass = true;
    this.hostRole = "presentation";
    this.groups = [];
    this.skip = 0;
    this.columns = new ColumnsContainer(() => []);
    this.selectable = false;
    this.groupable = false;
    this.trackBy = defaultTrackBy;
    this.sort = new Array();
    this.size = "medium";
    this.contentScroll = new EventEmitter();
    this.pageChange = new EventEmitter();
    this.scrollBottom = new EventEmitter();
    this.columnsStartIdx = 0;
    this.resizeSensors = new QueryList();
    this.dispatcher = new Subject();
    this.containerScrollTop = 0;
    this.scrollLeft = 0;
    this.rtl = false;
    this.scroller = scrollerFactory(this.dispatcher);
    this.subscriptions = detailsService.changes.subscribe((x) => this.detailExpand(x));
    this.subscriptions.add(scrollRequestService.requests.subscribe((req) => isPresent4(req.adjustIndex) ? this.scrollTo(req.request, req.adjustIndex) : this.scrollToItem(req.request)));
  }
  get showFooter() {
    return this.groupable && this.groupable.showFooter;
  }
  get totalWidth() {
    if (this.virtualColumns && this.columns.unlockedWidth) {
      return this.columns.unlockedWidth;
    }
  }
  get lockedLeafColumns() {
    return this.columns.lockedLeafColumns;
  }
  get nonLockedLeafColumns() {
    return this.columns.nonLockedLeafColumns;
  }
  get nonLockedColumnsToRender() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.viewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columns.leafColumnsToRender;
  }
  get lockedWidth() {
    const groupCellsWidth = this.groups.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {
      return sumColumnWidths(expandColumns(this.nonLockedColumnsToRender.toArray()));
    }
    return void 0;
  }
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  ngOnInit() {
    this.init();
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowSync.bind(this)));
    this.subscriptions.add(this.ngZone.runOutsideAngular(this.handleRowNavigationLocked.bind(this)));
    this.subscriptions.add(merge(this.columns.changes, this.resizeService.changes).subscribe(() => {
      if (this.virtualColumns) {
        this.ngZone.run(() => {
          this.updateViewportColumns();
          this.changeDetector.markForCheck();
        });
      }
    }));
    this.subscriptions.add(this.ctx.localization.changes.subscribe(({
      rtl
    }) => this.rtl = rtl));
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    const changesInSkip = changes["skip"];
    const hasInitialSkip = changesInSkip && changesInSkip.firstChange && changesInSkip.currentValue > 0;
    if (hasInitialSkip) {
      this.handleInitialScrollToSkip();
    }
    if (isChanged("skip", changes) && !this.rebind) {
      this.skipScroll = true;
      this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
    }
    if (anyChanged(["total", "take"], changes)) {
      this.init();
    }
    this.rebind = false;
  }
  ngDoCheck() {
    if (this.virtualColumns && (!this.viewportColumns || this.viewportWidthChange())) {
      this.updateViewportColumns();
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.skip && this.isVirtual) {
      this.container.nativeElement.scrollTop = this.rowHeightService.offset(this.skip);
    }
    this.resetNavigationViewport();
    this.attachContainerScroll();
    this.initResizeService();
  }
  ngAfterViewChecked() {
    const isLocked2 = this.isLocked;
    if (isLocked2 && !this.hasLockedContainer) {
      this.syncRowsHeight();
    }
    this.hasLockedContainer = isLocked2;
  }
  syncRowsHeight() {
    if (this.lockedContainer) {
      syncRowsHeight(this.lockedTable.nativeElement, this.table.nativeElement);
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    if (this.resizeService) {
      this.resizeService.destroy();
    }
    this.cleanupScroller();
  }
  init() {
    if (this.suspendService.scroll) {
      return;
    }
    this.rowHeightService = new RowHeightService(this.total, this.rowHeight, this.detailRowHeight);
    this.totalHeight = this.rowHeightService.totalHeight();
    if (!isUniversal()) {
      this.ngZone.runOutsideAngular(this.createScroller.bind(this));
    }
  }
  lockedScroll() {
    if (!this.suspendService.scroll) {
      const lockedScrollTop = this.lockedContainer.nativeElement.scrollTop;
      if (lockedScrollTop !== this.containerScrollTop) {
        this.container.nativeElement.scrollTop = this.containerScrollTop = lockedScrollTop;
      }
    }
  }
  lockedMousewheel(args) {
    if (!args.ctrlKey) {
      preventLockedScroll(args, this.container.nativeElement);
      const scrollDelta = wheelDeltaY(args);
      this.container.nativeElement.scrollTop -= scrollDelta;
    }
  }
  lockedKeydown(args) {
    if (args.keyCode === Keys.PageDown || args.keyCode === Keys.PageUp) {
      const dir2 = args.keyCode === Keys.PageDown ? 1 : -1;
      const element = this.container.nativeElement;
      element.scrollTop += element.offsetHeight * dir2 * 0.8;
      args.preventDefault();
    }
  }
  detailExpand({
    index,
    expand
  }) {
    if (expand) {
      this.rowHeightService.expandDetail(index);
    } else {
      this.rowHeightService.collapseDetail(index);
    }
    this.totalHeight = this.rowHeightService.totalHeight();
    this.resetNavigationViewport();
  }
  attachContainerScroll() {
    if (isUniversal()) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(fromEvent(this.container.nativeElement, "scroll").pipe(map((event2) => event2.target), filter(() => !this.suspendService.scroll), tap((target) => {
        this.onContainerScroll(target);
        this.resetNavigationViewport();
        if (this.virtualColumns || this.isVirtual) {
          this.handleColumnScroll();
        }
        const rowViewport = this.navigationService.viewport || EMPTY_OBJECT;
        const columnViewport = this.navigationService.columnViewport || EMPTY_OBJECT;
        this.contentScroll.emit({
          scrollLeft: target.scrollLeft,
          scrollTop: target.scrollTop,
          startRow: rowViewport.firstItemIndex,
          endRow: rowViewport.lastItemIndex,
          startColumn: columnViewport.firstItemIndex,
          endColumn: columnViewport.lastItemIndex
        });
      })).subscribe(this.dispatcher));
    });
    this.scrollSyncService.registerEmitter(this.container.nativeElement, "body");
  }
  createScroller() {
    this.cleanupScroller();
    const observable = this.scroller.create(this.rowHeightService, this.skip, this.take, this.total);
    this.skipScroll = false;
    this.scrollerSubscription = observable.pipe(filter((x) => x instanceof PageAction), filter(() => {
      const temp = this.skipScroll;
      this.skipScroll = false;
      return !temp;
    }), tap(() => this.rebind = true)).subscribe((x) => this.ngZone.run(() => this.pageChange.emit(x)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollAction)).subscribe(this.scroll.bind(this)));
    this.scrollerSubscription.add(observable.pipe(filter((x) => x instanceof ScrollBottomAction)).subscribe(() => this.scrollBottom.emit()));
  }
  scroll({
    offset: offset2 = 0
  }) {
    if (this.isVirtual) {
      [maybeNativeElement(this.table), maybeNativeElement(this.lockedTable)].filter(isPresent4).forEach(translateY(this.renderer, offset2));
    }
    this.resetNavigationViewport();
  }
  onContainerScroll({
    scrollTop
  }) {
    this.containerScrollTop = scrollTop;
    if (this.lockedContainer) {
      this.lockedContainer.nativeElement.scrollTop = scrollTop;
    }
  }
  handleInitialScrollToSkip() {
    const shouldScroll = () => this.isVirtual && this.skip > 0 && this.total > 0;
    const sub = this.changeNotification.changes.pipe(filter(shouldScroll)).subscribe((_) => {
      this.scrollTo({
        row: this.skip
      });
      sub.unsubscribe();
    });
  }
  handleRowSync() {
    const isLocked2 = () => isPresent4(this.lockedContainer);
    const onStable = () => this.ngZone.onStable.asObservable().pipe(take(1));
    return merge(this.changeNotification.changes, this.groupsService.changes.pipe(filter(isLocked2), switchMapTo(onStable())), this.editService.changed, this.resizeService.changes, this.columnResizingService.changes.pipe(filter((change) => change.type === "end")), this.supportService.changes).pipe(tap(() => this.resetNavigationViewport()), filter(isLocked2)).subscribe(() => {
      const scrollTop = this.container.nativeElement.scrollTop;
      const scrollLeft = this.container.nativeElement.scrollLeft;
      this.syncRowsHeight();
      this.syncContainerHeight();
      this.lockedContainer.nativeElement.scrollTop = this.container.nativeElement.scrollTop = scrollTop;
      this.container.nativeElement.scrollLeft = scrollLeft;
      this.resizeSensors.forEach((sensor) => sensor.acceptSize());
    });
  }
  handleRowNavigationLocked() {
    return this.navigationService.changes.pipe(filter(() => isPresent4(this.lockedContainer)), delay(10)).subscribe((args) => {
      if (this.lockedLeafColumns.length <= args.prevColIndex && args.colIndex < this.lockedLeafColumns.length) {
        const cell2 = this.navigationService.activeCell;
        if (cell2 && cell2.colIndex + cell2.colSpan < args.prevColIndex) {
          this.container.nativeElement.scrollLeft = 0;
        }
      }
    });
  }
  scrollToVirtualRow(itemIndex, adjustIndexForDetailTemplate = true) {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent4(this.detailTemplate) && adjustIndexForDetailTemplate) {
      itemIndex = Math.floor(itemIndex / 2);
    }
    const offset2 = this.rowHeightService.offset(itemIndex, !adjustIndexForDetailTemplate);
    this.container.nativeElement.scrollTop = offset2;
    this.resetNavigationViewport();
  }
  scrollTo({
    row: row2,
    column
  }, adjustIndex = false) {
    if (isNumber(row2)) {
      if (this.isVirtual) {
        this.scrollToVirtualRow(row2, adjustIndex);
      } else {
        const element = rowAt(row2, this.table.nativeElement.rows);
        if (element) {
          this.container.nativeElement.scrollTop = element.offsetTop;
        }
      }
    }
    if (isNumber(column)) {
      column -= this.lockedLeafColumns.length;
      if (this.virtualColumns) {
        const columns = this.columns.leafColumnsToRender;
        let offset2 = 0;
        for (let idx = 0; idx < column; idx++) {
          offset2 += columns[idx].width || 0;
        }
        const startOffset = this.lockedLeafColumns.length ? 0 : this.groups.length * GROUP_CELL_WIDTH + (this.detailTemplate && column > 0 ? GROUP_CELL_WIDTH : 0);
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(offset2 + startOffset);
      } else if (column === 0 && this.detailTemplate) {
        this.container.nativeElement.scrollLeft = this.normalizeScrollLeft(0);
      } else {
        const firstRow = rowAt(0, this.table.nativeElement.rows);
        if (firstRow) {
          const element = cellAt(column, firstRow.cells);
          if (element) {
            this.container.nativeElement.scrollLeft = this.elementScrollLeft(element);
          }
        }
      }
    }
  }
  scrollToItem(item) {
    if (!isDocumentAvailable()) {
      return;
    }
    const data = this.ctx.grid.data;
    const gridData = Array.isArray(data) ? data : data.data;
    const gridDataItems = gridData.flatMap(recursiveFlatMap);
    const dataItemIndex = gridDataItems.findIndex((dataItem) => dataItem[item.idField] === item.id);
    if (dataItemIndex !== -1) {
      const row2 = Array.from(this.table.nativeElement.rows).find((r) => {
        const dataAttribute = r.getAttribute("data-kendo-grid-item-index");
        return dataAttribute && +dataAttribute === this.ctx.grid.skip + dataItemIndex;
      });
      row2 && row2.scrollIntoView();
      this.isVirtual && this.resetNavigationViewport();
    }
  }
  resetNavigationViewport() {
    if (!isDocumentAvailable) {
      return;
    }
    if (!this.container || !this.navigationService.tableEnabled || !this.navigationService.needsViewport() || this.data.length === 0) {
      return;
    }
    const {
      scrollTop,
      offsetHeight
    } = this.container.nativeElement;
    const scrollBottom = scrollTop + offsetHeight;
    const firstItemIndex = this.rowHeightService.index(scrollTop);
    const lastItemIndex = this.rowHeightService.index(scrollBottom);
    const lastItemOffset = this.rowHeightService.offset(lastItemIndex);
    let viewportStart = firstItemIndex;
    let viewportEnd = lastItemIndex;
    if (isPresent4(this.detailTemplate)) {
      viewportStart *= 2;
      viewportEnd *= 2;
      const firstItemHeight = this.rowHeightService.offset(firstItemIndex);
      if (firstItemHeight + this.rowHeight < scrollTop) {
        viewportStart++;
      }
      const lastItemHeight = this.rowHeightService.height(lastItemIndex);
      const lastItemExpanded = this.rowHeightService.isExpanded(lastItemIndex);
      const lastItemDetailOverflows = lastItemOffset + lastItemHeight > scrollBottom;
      if (lastItemExpanded && !lastItemDetailOverflows) {
        viewportEnd++;
      }
    }
    this.navigationService.setViewport(viewportStart, viewportEnd);
  }
  cleanupScroller() {
    if (this.scrollerSubscription) {
      this.scrollerSubscription.unsubscribe();
    }
    if (this.scroller) {
      this.scroller.destroy();
    }
  }
  initResizeService() {
    this.resizeService.connect(merge(...this.resizeSensors.map((sensor) => sensor.resize)));
  }
  syncContainerHeight() {
    [maybeNativeElement(this.lockedContainer)].filter(isPresent4).map((el) => {
      el.style.height = "";
      let height = this.container.nativeElement.offsetHeight;
      if (hasScrollbar(this.table, this.container)) {
        height -= this.supportService.scrollbarWidth;
      }
      return {
        el,
        height
      };
    }).forEach(setHeight(this.renderer));
  }
  updateViewportColumns(range) {
    const columns = this.columns.nonLockedLeafColumns.toArray();
    let {
      startIdx,
      endIdx,
      offset: offset2
    } = range || this.calculateViewportColumns();
    const start = Math.max(0, startIdx - bufferSize);
    const end2 = Math.min(endIdx + bufferSize, columns.length - 1);
    if (start < startIdx) {
      for (let idx = startIdx - 1; idx >= start; idx--) {
        offset2 -= columns[idx].width;
      }
    }
    let currentColumns = columns.slice(start, end2 + 1);
    this.viewportColumnsWidth = currentColumns.reduce((total, column) => total + column.width, 0);
    const stickyBeforeStart = columns.slice(0, start).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    const stickyAfterEnd = columns.slice(end2, columns.length).filter((c) => c.sticky && !currentColumns.some((col) => col === c));
    currentColumns = [...stickyBeforeStart, ...currentColumns, ...stickyAfterEnd];
    if (start > 0) {
      const offsetColumn = new ColumnBase2();
      offsetColumn.width = offset2;
      currentColumns.unshift(offsetColumn);
    }
    this.viewportColumns = new QueryList();
    this.viewportColumns.reset(currentColumns);
    this.columnsStartIdx = start;
    this.columnsEndIdx = end2;
    this.columnInfo.columnRangeChange.emit({
      start,
      end: end2,
      offset: offset2
    });
    if (!range) {
      this.updateColumnViewport(startIdx, endIdx);
    }
  }
  handleColumnScroll() {
    const container = this.container.nativeElement;
    const scrollLeft = container.scrollLeft;
    if (this.scrollLeft !== scrollLeft) {
      this.scrollLeft = scrollLeft;
      const range = this.calculateViewportColumns();
      this.updateColumnViewport(range.startIdx, range.endIdx);
      if (range.startIdx < this.columnsStartIdx || this.columnsEndIdx < range.endIdx) {
        cancelAnimationFrame(this.columnUpdateFrame);
        this.columnUpdateFrame = requestAnimationFrame(() => {
          this.ngZone.run(() => {
            this.updateViewportColumns(range);
            this.changeDetector.markForCheck();
          });
        });
      }
    }
  }
  updateColumnViewport(startIdx, endIdx) {
    const lockedCount = this.lockedLeafColumns.length;
    const leafColumns2 = this.nonLockedLeafColumns.toArray();
    const viewportStart = lockedCount + startIdx + (this.detailTemplate && startIdx > 0 ? 1 : 0);
    let viewportEnd = lockedCount + endIdx + (this.detailTemplate ? 1 : 0);
    for (let idx = 0; idx < leafColumns2.length; idx++) {
      const column = leafColumns2[idx];
      if (column.isSpanColumn) {
        viewportEnd += column.childColumns.length;
      }
    }
    this.navigationService.setColumnViewport(viewportStart, viewportEnd);
  }
  calculateViewportColumns() {
    const {
      scrollLeft,
      clientWidth
    } = this.container.nativeElement;
    const columns = this.columns.nonLockedLeafColumns.toArray();
    const normalizedScrollLeft = this.normalizeScrollLeft(scrollLeft);
    const viewportEnd = normalizedScrollLeft + clientWidth;
    let startIdx;
    let endIdx = 0;
    let current3 = 0;
    let offset2 = 0;
    let idx;
    for (idx = 0; idx < columns.length; idx++) {
      const column = columns[idx];
      current3 += column.width || 0;
      if (startIdx === void 0 && current3 > normalizedScrollLeft) {
        startIdx = idx;
        offset2 = current3 - (column.width || 0);
      }
      if (current3 >= viewportEnd) {
        endIdx = idx;
        break;
      }
    }
    if (!endIdx && idx > 0) {
      endIdx = columns.length - 1;
    }
    return {
      startIdx,
      endIdx,
      offset: offset2
    };
  }
  viewportWidthChange() {
    const currentWidth = this.viewportColumns.toArray().reduce((total, column) => total + column.width, 0);
    return currentWidth !== this.viewportColumnsWidth;
  }
  normalizeScrollLeft(position2) {
    return this.rtl ? rtlScrollPosition(position2, this.container.nativeElement, this.supportService.rtlScrollLeft) : position2;
  }
  elementScrollLeft(element) {
    if (this.rtl) {
      return this.normalizeScrollLeft(this.container.nativeElement.scrollWidth - element.offsetLeft - element.offsetWidth);
    }
    return element.offsetLeft;
  }
};
ListComponent.ɵfac = function ListComponent_Factory(t) {
  return new (t || ListComponent)(ɵɵdirectiveInject(SCROLLER_FACTORY_TOKEN), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ScrollSyncService), ɵɵdirectiveInject(ResizeService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ColumnInfoService));
};
ListComponent.ɵcmp = ɵɵdefineComponent({
  type: ListComponent,
  selectors: [["kendo-grid-list"]],
  viewQuery: function ListComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c39, 7);
      ɵɵviewQuery(_c40, 5);
      ɵɵviewQuery(_c41, 5);
      ɵɵviewQuery(_c42, 7);
      ɵɵviewQuery(ResizeSensorComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedTable = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.table = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeSensors = _t);
    }
  },
  hostVars: 3,
  hostBindings: function ListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.hostRole);
      ɵɵclassProp("k-grid-container", ctx.hostClass);
    }
  },
  inputs: {
    data: "data",
    groups: "groups",
    total: "total",
    rowHeight: "rowHeight",
    stickyRowHeight: "stickyRowHeight",
    detailRowHeight: "detailRowHeight",
    take: "take",
    skip: "skip",
    columns: "columns",
    detailTemplate: "detailTemplate",
    noRecordsTemplate: "noRecordsTemplate",
    selectable: "selectable",
    groupable: "groupable",
    filterable: "filterable",
    rowClass: "rowClass",
    rowSticky: "rowSticky",
    loading: "loading",
    trackBy: "trackBy",
    virtualColumns: "virtualColumns",
    isVirtual: "isVirtual",
    cellLoadingTemplate: "cellLoadingTemplate",
    loadingTemplate: "loadingTemplate",
    sort: "sort",
    size: "size"
  },
  outputs: {
    contentScroll: "contentScroll",
    pageChange: "pageChange",
    scrollBottom: "scrollBottom"
  },
  features: [ɵɵProvidersFeature([{
    provide: SCROLLER_FACTORY_TOKEN,
    useValue: DEFAULT_SCROLLER_FACTORY
  }]), ɵɵNgOnChangesFeature],
  decls: 13,
  vars: 38,
  consts: [["container", ""], ["table", ""], ["lockedContainer", ""], ["lockedTable", ""], ["class", "k-grid-content-locked", "role", "presentation", "tabindex", "-1", 3, "width", "kendoEventsOutsideAngular", "scope", 4, "ngIf"], [1, "k-grid-content", "k-virtual-content", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", 1, "k-grid-table-wrap"], ["kendoGridTable", "", "role", "presentation", 1, "k-grid-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "groups", "columns", "detailTemplate", "sort"], ["kendoGridTableBody", "", "role", "rowgroup", 3, "skipGroupDecoration", "data", "groups", "showGroupFooters", "columns", "allColumns", "detailTemplate", "noRecordsTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "skip", "selectable", "trackBy", "filterable", "rowClass", "rowSticky", "virtualColumns", "isLoading", "isVirtual", "cellLoadingTemplate"], [4, "ngIf"], ["role", "presentation", 1, "k-height-container"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", "tabindex", "-1", 1, "k-grid-content-locked", 3, "kendoEventsOutsideAngular", "scope"], ["role", "presentation", "kendoGridTable", "", 1, "k-grid-table", 3, "locked", "size"], ["kendoGridTableBody", "", "role", "presentation", 3, "groups", "isLocked", "data", "noRecordsText", "columns", "totalColumnsCount", "totalColumns", "detailTemplate", "showGroupFooters", "skip", "selectable", "trackBy", "filterable", "rowClass", "isLoading", "isVirtual", "cellLoadingTemplate"], ["role", "presentation", 1, "k-width-container"]],
  template: function ListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ListComponent_div_0_Template, 10, 36, "div", 4);
      ɵɵelementStart(1, "div", 5, 0)(3, "div", 6)(4, "table", 7, 1);
      ɵɵelement(6, "colgroup", 8)(7, "tbody", 9);
      ɵɵelementEnd();
      ɵɵtemplate(8, ListComponent_kendo_resize_sensor_8_Template, 1, 0, "kendo-resize-sensor", 10);
      ɵɵelementEnd();
      ɵɵtemplate(9, ListComponent_kendo_resize_sensor_9_Template, 1, 0, "kendo-resize-sensor", 10);
      ɵɵelementStart(10, "div", 11);
      ɵɵelement(11, "div");
      ɵɵelementEnd();
      ɵɵtemplate(12, ListComponent_div_12_Template, 2, 2, "div", 12);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isLocked);
      ɵɵadvance();
      ɵɵproperty("kendoGridResizableContainer", ctx.lockedLeafColumns.length > 0)("lockedWidth", ctx.lockedWidth + 1);
      ɵɵadvance(3);
      ɵɵstyleProp("width", ctx.nonLockedWidth, "px");
      ɵɵproperty("virtualColumns", ctx.virtualColumns)("size", ctx.size);
      ɵɵadvance(2);
      ɵɵproperty("groups", ctx.isLocked ? ɵɵpureFunction0(37, _c43) : ctx.groups)("columns", ctx.nonLockedColumnsToRender)("detailTemplate", ctx.detailTemplate)("sort", ctx.sort);
      ɵɵadvance();
      ɵɵproperty("skipGroupDecoration", ctx.isLocked)("data", ctx.data)("groups", ctx.groups)("showGroupFooters", ctx.showFooter)("columns", ctx.nonLockedColumnsToRender)("allColumns", ctx.nonLockedLeafColumns)("detailTemplate", ctx.detailTemplate)("noRecordsTemplate", ctx.noRecordsTemplate)("lockedColumnsCount", ctx.lockedLeafColumns.length)("totalColumnsCount", ctx.leafColumns.length)("totalColumns", ctx.columns)("skip", ctx.skip)("selectable", ctx.selectable)("trackBy", ctx.trackBy)("filterable", ctx.filterable)("rowClass", ctx.rowClass)("rowSticky", ctx.rowSticky)("virtualColumns", ctx.virtualColumns)("isLoading", ctx.loading)("isVirtual", ctx.isVirtual)("cellLoadingTemplate", ctx.cellLoadingTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isLocked);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isLocked || ctx.virtualColumns);
      ɵɵadvance(2);
      ɵɵstyleProp("height", ctx.totalHeight, "px");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.virtualColumns);
    }
  },
  dependencies: [NgIf, ColGroupComponent, ResizableContainerDirective, TableDirective, GridTableDirective, EventsOutsideAngularDirective, TableBodyComponent, ResizeSensorComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SCROLLER_FACTORY_TOKEN,
        useValue: DEFAULT_SCROLLER_FACTORY
      }],
      selector: "kendo-grid-list",
      template: `
    <div #lockedContainer class="k-grid-content-locked" role="presentation"
        *ngIf="isLocked" [style.width.px]="lockedWidth" tabindex="-1"
        [kendoEventsOutsideAngular]="{
            keydown: lockedKeydown,
            scroll: lockedScroll,
            mousewheel: lockedMousewheel,
            DOMMouseScroll: lockedMousewheel
        }"
        [scope]="this"
        >
        <div role="presentation" class="k-grid-table-wrap">
            <table
                [locked]="true"
                #lockedTable
                class="k-grid-table"
                role="presentation"
                kendoGridTable
                [size]="size"
                [style.width.px]="lockedWidth">
                <colgroup kendoGridColGroup
                    [groups]="groups"
                    [columns]="$any(lockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="presentation"
                    [groups]="groups"
                    [isLocked]="true"
                    [data]="data"
                    [noRecordsText]="''"
                    [columns]="$any(lockedLeafColumns)"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [detailTemplate]="detailTemplate"
                    [showGroupFooters]="showFooter"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor></kendo-resize-sensor>
        </div>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
    </div>
    <div 
        #container
        class="k-grid-content k-virtual-content"
        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
        [lockedWidth]="lockedWidth + 1"
    >
        <div role="presentation" class="k-grid-table-wrap">
            <table
                [style.width.px]="nonLockedWidth"
                #table
                [virtualColumns]="virtualColumns"
                class="k-grid-table"
                kendoGridTable
                [size]="size"
                role="presentation">
                <colgroup kendoGridColGroup
                    [groups]="isLocked ? [] : groups"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [detailTemplate]="detailTemplate"
                    [sort]="sort">
                </colgroup>
                <tbody kendoGridTableBody
                    role="rowgroup"
                    [skipGroupDecoration]="isLocked"
                    [data]="data"
                    [groups]="groups"
                    [showGroupFooters]="showFooter"
                    [columns]="$any(nonLockedColumnsToRender)"
                    [allColumns]="$any(nonLockedLeafColumns)"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [lockedColumnsCount]="lockedLeafColumns.length"
                    [totalColumnsCount]="leafColumns.length"
                    [totalColumns]="columns"
                    [skip]="skip"
                    [selectable]="selectable"
                    [trackBy]="trackBy"
                    [filterable]="filterable"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [virtualColumns]="virtualColumns"
                    [isLoading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate">
                </tbody>
            </table>
            <kendo-resize-sensor *ngIf="isLocked"></kendo-resize-sensor>
        </div>
        <kendo-resize-sensor *ngIf="isLocked || virtualColumns"></kendo-resize-sensor>
        <div class="k-height-container" role="presentation">
            <div [style.height.px]="totalHeight"></div>
        </div>
        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
            <div [style.width.px]="totalWidth"></div>
        </div>
    </div>
    `
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [SCROLLER_FACTORY_TOKEN]
      }]
    }, {
      type: DetailsService
    }, {
      type: ChangeNotificationService
    }, {
      type: SuspendService
    }, {
      type: GroupsService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ScrollSyncService
    }, {
      type: ResizeService
    }, {
      type: EditService
    }, {
      type: BrowserSupportService
    }, {
      type: NavigationService
    }, {
      type: ScrollRequestService
    }, {
      type: ContextService
    }, {
      type: ColumnResizingService
    }, {
      type: ChangeDetectorRef
    }, {
      type: PDFService
    }, {
      type: ColumnInfoService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid-container"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    data: [{
      type: Input
    }],
    groups: [{
      type: Input
    }],
    total: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    stickyRowHeight: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    take: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    detailTemplate: [{
      type: Input
    }],
    noRecordsTemplate: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    isVirtual: [{
      type: Input
    }],
    cellLoadingTemplate: [{
      type: Input
    }],
    loadingTemplate: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    contentScroll: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        static: true
      }]
    }],
    lockedContainer: [{
      type: ViewChild,
      args: ["lockedContainer", {
        static: false
      }]
    }],
    lockedTable: [{
      type: ViewChild,
      args: ["lockedTable", {
        static: false
      }]
    }],
    table: [{
      type: ViewChild,
      args: ["table", {
        static: true
      }]
    }],
    resizeSensors: [{
      type: ViewChildren,
      args: [ResizeSensorComponent]
    }]
  });
})();
var ToolbarComponent = class {
  constructor(ctx, wrapper) {
    this.ctx = ctx;
    this.wrapper = wrapper;
    this.context = {};
    this.role = "toolbar";
    this._size = "medium";
    this.navigationService = this.ctx[`${this.wrapper.nativeElement.getAttribute("position")}ToolbarNavigation`];
  }
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  set position(value2) {
    this.context.position = value2;
  }
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-toolbar-sm", "k-toolbar-md");
    }
  }
  get size() {
    return this._size;
  }
  clickHandler(ev) {
    if (this.navigable && isDocumentAvailable()) {
      const closestFocusable = closest(ev.target, isFocusable);
      const targetIndex = this.navigationService.navigableElements.indexOf(closestFocusable);
      if (targetIndex > -1) {
        this.navigationService.currentActiveIndex = targetIndex;
      }
      this.navigationService.updateFocus();
      if (ev.target === this.wrapper.nativeElement) {
        this.navigationService.focus();
      }
    }
  }
  arrowLeftListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex--;
      if (this.navigationService.currentActiveIndex < 0) {
        this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      }
      this.navigationService.updateFocus();
    }
  }
  arrowRightListener() {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      this.navigationService.currentActiveIndex++;
      if (this.navigationService.currentActiveIndex >= this.navigationService.navigableElements.length) {
        this.navigationService.currentActiveIndex = 0;
      }
      this.navigationService.updateFocus();
    }
  }
  homeKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = 0;
      this.navigationService.updateFocus();
    }
  }
  endKeyListener(e) {
    if (this.navigable && isDocumentAvailable() && this.navigationService.navigableElements.length) {
      e.preventDefault();
      this.navigationService.currentActiveIndex = this.navigationService.navigableElements.length - 1;
      this.navigationService.updateFocus();
    }
  }
  get toolbarTemplateRef() {
    return this.ctx.grid.toolbarTemplate ? this.ctx.grid.toolbarTemplate.templateRef : void 0;
  }
};
ToolbarComponent.ɵfac = function ToolbarComponent_Factory(t) {
  return new (t || ToolbarComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ElementRef));
};
ToolbarComponent.ɵcmp = ɵɵdefineComponent({
  type: ToolbarComponent,
  selectors: [["kendo-grid-toolbar"]],
  hostVars: 5,
  hostBindings: function ToolbarComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ToolbarComponent_click_HostBindingHandler($event) {
        return ctx.clickHandler($event);
      })("keydown.arrowleft", function ToolbarComponent_keydown_arrowleft_HostBindingHandler($event) {
        return ctx.arrowLeftListener($event);
      })("keydown.arrowright", function ToolbarComponent_keydown_arrowright_HostBindingHandler($event) {
        return ctx.arrowRightListener($event);
      })("keydown.home", function ToolbarComponent_keydown_home_HostBindingHandler($event) {
        return ctx.homeKeyListener($event);
      })("keydown.end", function ToolbarComponent_keydown_end_HostBindingHandler($event) {
        return ctx.endKeyListener($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("k-toolbar-sm", ctx.sizeSmallClass)("k-toolbar-md", ctx.sizeMediumClass);
    }
  },
  inputs: {
    position: "position",
    size: "size",
    navigable: "navigable"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function ToolbarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ToolbarComponent_0_Template, 1, 2, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.toolbarTemplateRef);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToolbarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-toolbar",
      template: `
        <ng-template
            *ngIf="toolbarTemplateRef"
            [ngTemplateOutlet]="toolbarTemplateRef"
            [ngTemplateOutletContext]="context"></ng-template>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ElementRef
    }];
  }, {
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-toolbar-md"]
    }],
    position: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    clickHandler: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    arrowLeftListener: [{
      type: HostListener,
      args: ["keydown.arrowleft", ["$event"]]
    }],
    arrowRightListener: [{
      type: HostListener,
      args: ["keydown.arrowright", ["$event"]]
    }],
    homeKeyListener: [{
      type: HostListener,
      args: ["keydown.home", ["$event"]]
    }],
    endKeyListener: [{
      type: HostListener,
      args: ["keydown.end", ["$event"]]
    }],
    navigable: [{
      type: Input
    }]
  });
})();
var GridMessages = class extends ComponentMessages {
};
GridMessages.ɵfac = /* @__PURE__ */ (() => {
  let ɵGridMessages_BaseFactory;
  return function GridMessages_Factory(t) {
    return (ɵGridMessages_BaseFactory || (ɵGridMessages_BaseFactory = ɵɵgetInheritedFactory(GridMessages)))(t || GridMessages);
  };
})();
GridMessages.ɵdir = ɵɵdefineDirective({
  type: GridMessages,
  selectors: [["kendo-grid-messages-base"]],
  inputs: {
    groupPanelEmpty: "groupPanelEmpty",
    noRecords: "noRecords",
    pagerLabel: "pagerLabel",
    pagerFirstPage: "pagerFirstPage",
    pagerLastPage: "pagerLastPage",
    pagerPreviousPage: "pagerPreviousPage",
    pagerNextPage: "pagerNextPage",
    pagerPage: "pagerPage",
    pagerItemsPerPage: "pagerItemsPerPage",
    pagerOf: "pagerOf",
    pagerItems: "pagerItems",
    pagerPageNumberInputTitle: "pagerPageNumberInputTitle",
    selectPage: "selectPage",
    filter: "filter",
    filterInputLabel: "filterInputLabel",
    filterMenuTitle: "filterMenuTitle",
    filterMenuOperatorsDropDownLabel: "filterMenuOperatorsDropDownLabel",
    filterMenuLogicDropDownLabel: "filterMenuLogicDropDownLabel",
    filterCellOperatorLabel: "filterCellOperatorLabel",
    booleanFilterCellLabel: "booleanFilterCellLabel",
    filterEqOperator: "filterEqOperator",
    filterNotEqOperator: "filterNotEqOperator",
    filterIsNullOperator: "filterIsNullOperator",
    filterIsNotNullOperator: "filterIsNotNullOperator",
    filterIsEmptyOperator: "filterIsEmptyOperator",
    filterIsNotEmptyOperator: "filterIsNotEmptyOperator",
    filterStartsWithOperator: "filterStartsWithOperator",
    filterContainsOperator: "filterContainsOperator",
    filterNotContainsOperator: "filterNotContainsOperator",
    filterEndsWithOperator: "filterEndsWithOperator",
    filterGteOperator: "filterGteOperator",
    filterGtOperator: "filterGtOperator",
    filterLteOperator: "filterLteOperator",
    filterLtOperator: "filterLtOperator",
    filterIsTrue: "filterIsTrue",
    filterIsFalse: "filterIsFalse",
    filterBooleanAll: "filterBooleanAll",
    filterAfterOrEqualOperator: "filterAfterOrEqualOperator",
    filterAfterOperator: "filterAfterOperator",
    filterBeforeOperator: "filterBeforeOperator",
    filterBeforeOrEqualOperator: "filterBeforeOrEqualOperator",
    filterFilterButton: "filterFilterButton",
    filterClearButton: "filterClearButton",
    filterAndLogic: "filterAndLogic",
    filterOrLogic: "filterOrLogic",
    loading: "loading",
    gridLabel: "gridLabel",
    columnMenu: "columnMenu",
    setColumnPosition: "setColumnPosition",
    columns: "columns",
    lock: "lock",
    unlock: "unlock",
    stick: "stick",
    unstick: "unstick",
    sortable: "sortable",
    sortAscending: "sortAscending",
    sortDescending: "sortDescending",
    autosizeThisColumn: "autosizeThisColumn",
    autosizeAllColumns: "autosizeAllColumns",
    sortedAscending: "sortedAscending",
    sortedDescending: "sortedDescending",
    sortedDefault: "sortedDefault",
    columnsApply: "columnsApply",
    columnsReset: "columnsReset",
    detailExpand: "detailExpand",
    detailCollapse: "detailCollapse",
    filterDateToday: "filterDateToday",
    filterDateToggle: "filterDateToggle",
    filterNumericDecrement: "filterNumericDecrement",
    filterNumericIncrement: "filterNumericIncrement",
    selectionCheckboxLabel: "selectionCheckboxLabel",
    selectAllCheckboxLabel: "selectAllCheckboxLabel",
    groupCollapse: "groupCollapse",
    groupExpand: "groupExpand",
    topToolbarLabel: "topToolbarLabel",
    bottomToolbarLabel: "bottomToolbarLabel",
    groupPanelLabel: "groupPanelLabel",
    dragRowHandleLabel: "dragRowHandleLabel",
    columnMenuFilterTabTitle: "columnMenuFilterTabTitle",
    columnMenuGeneralTabTitle: "columnMenuGeneralTabTitle",
    columnMenuColumnsTabTitle: "columnMenuColumnsTabTitle",
    groupChipMenuPrevious: "groupChipMenuPrevious",
    groupChipMenuNext: "groupChipMenuNext"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-grid-messages-base"
    }]
  }], null, {
    groupPanelEmpty: [{
      type: Input
    }],
    noRecords: [{
      type: Input
    }],
    pagerLabel: [{
      type: Input
    }],
    pagerFirstPage: [{
      type: Input
    }],
    pagerLastPage: [{
      type: Input
    }],
    pagerPreviousPage: [{
      type: Input
    }],
    pagerNextPage: [{
      type: Input
    }],
    pagerPage: [{
      type: Input
    }],
    pagerItemsPerPage: [{
      type: Input
    }],
    pagerOf: [{
      type: Input
    }],
    pagerItems: [{
      type: Input
    }],
    pagerPageNumberInputTitle: [{
      type: Input
    }],
    selectPage: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    filterInputLabel: [{
      type: Input
    }],
    filterMenuTitle: [{
      type: Input
    }],
    filterMenuOperatorsDropDownLabel: [{
      type: Input
    }],
    filterMenuLogicDropDownLabel: [{
      type: Input
    }],
    filterCellOperatorLabel: [{
      type: Input
    }],
    booleanFilterCellLabel: [{
      type: Input
    }],
    filterEqOperator: [{
      type: Input
    }],
    filterNotEqOperator: [{
      type: Input
    }],
    filterIsNullOperator: [{
      type: Input
    }],
    filterIsNotNullOperator: [{
      type: Input
    }],
    filterIsEmptyOperator: [{
      type: Input
    }],
    filterIsNotEmptyOperator: [{
      type: Input
    }],
    filterStartsWithOperator: [{
      type: Input
    }],
    filterContainsOperator: [{
      type: Input
    }],
    filterNotContainsOperator: [{
      type: Input
    }],
    filterEndsWithOperator: [{
      type: Input
    }],
    filterGteOperator: [{
      type: Input
    }],
    filterGtOperator: [{
      type: Input
    }],
    filterLteOperator: [{
      type: Input
    }],
    filterLtOperator: [{
      type: Input
    }],
    filterIsTrue: [{
      type: Input
    }],
    filterIsFalse: [{
      type: Input
    }],
    filterBooleanAll: [{
      type: Input
    }],
    filterAfterOrEqualOperator: [{
      type: Input
    }],
    filterAfterOperator: [{
      type: Input
    }],
    filterBeforeOperator: [{
      type: Input
    }],
    filterBeforeOrEqualOperator: [{
      type: Input
    }],
    filterFilterButton: [{
      type: Input
    }],
    filterClearButton: [{
      type: Input
    }],
    filterAndLogic: [{
      type: Input
    }],
    filterOrLogic: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    gridLabel: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    setColumnPosition: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    lock: [{
      type: Input
    }],
    unlock: [{
      type: Input
    }],
    stick: [{
      type: Input
    }],
    unstick: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    sortAscending: [{
      type: Input
    }],
    sortDescending: [{
      type: Input
    }],
    autosizeThisColumn: [{
      type: Input
    }],
    autosizeAllColumns: [{
      type: Input
    }],
    sortedAscending: [{
      type: Input
    }],
    sortedDescending: [{
      type: Input
    }],
    sortedDefault: [{
      type: Input
    }],
    columnsApply: [{
      type: Input
    }],
    columnsReset: [{
      type: Input
    }],
    detailExpand: [{
      type: Input
    }],
    detailCollapse: [{
      type: Input
    }],
    filterDateToday: [{
      type: Input
    }],
    filterDateToggle: [{
      type: Input
    }],
    filterNumericDecrement: [{
      type: Input
    }],
    filterNumericIncrement: [{
      type: Input
    }],
    selectionCheckboxLabel: [{
      type: Input
    }],
    selectAllCheckboxLabel: [{
      type: Input
    }],
    groupCollapse: [{
      type: Input
    }],
    groupExpand: [{
      type: Input
    }],
    topToolbarLabel: [{
      type: Input
    }],
    bottomToolbarLabel: [{
      type: Input
    }],
    groupPanelLabel: [{
      type: Input
    }],
    dragRowHandleLabel: [{
      type: Input
    }],
    columnMenuFilterTabTitle: [{
      type: Input
    }],
    columnMenuGeneralTabTitle: [{
      type: Input
    }],
    columnMenuColumnsTabTitle: [{
      type: Input
    }],
    groupChipMenuPrevious: [{
      type: Input
    }],
    groupChipMenuNext: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class extends GridMessages {
  constructor(service) {
    super();
    this.service = service;
  }
};
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {
  return new (t || LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
};
LocalizedMessagesDirective.ɵdir = ɵɵdefineDirective({
  type: LocalizedMessagesDirective,
  selectors: [["", "kendoGridLocalizedMessages", ""]],
  features: [ɵɵProvidersFeature([{
    provide: GridMessages,
    useExisting: forwardRef(() => LocalizedMessagesDirective)
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoGridLocalizedMessages]"
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var StatusBarComponent = class {
  constructor(aggregateService) {
    this.aggregateService = aggregateService;
    this.hostClasses = true;
  }
  get isStatusBarTemplate() {
    return this.statusBarTemplate ? "" : "none";
  }
  ngOnInit() {
    this.aggregateService.init();
  }
  get aggregates() {
    return this.aggregateService.aggregates;
  }
};
StatusBarComponent.ɵfac = function StatusBarComponent_Factory(t) {
  return new (t || StatusBarComponent)(ɵɵdirectiveInject(CellSelectionAggregateService));
};
StatusBarComponent.ɵcmp = ɵɵdefineComponent({
  type: StatusBarComponent,
  selectors: [["kendo-grid-status-bar"]],
  hostVars: 6,
  hostBindings: function StatusBarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.isStatusBarTemplate);
      ɵɵclassProp("k-selection-aggregates", ctx.hostClasses)("k-grid-selection-aggregates", ctx.hostClasses);
    }
  },
  inputs: {
    statusBarTemplate: "statusBarTemplate"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function StatusBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, StatusBarComponent_0_Template, 1, 4, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.statusBarTemplate);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StatusBarComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-status-bar",
      template: `
        <ng-template
            *ngIf="statusBarTemplate"
            [ngTemplateOutlet]="statusBarTemplate?.templateRef"
            [ngTemplateOutletContext]="{ aggregates: aggregates }">
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: CellSelectionAggregateService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-selection-aggregates"]
    }, {
      type: HostBinding,
      args: ["class.k-grid-selection-aggregates"]
    }],
    isStatusBarTemplate: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    statusBarTemplate: [{
      type: Input
    }]
  });
})();
var createControl = (source) => (acc, key) => {
  acc[key] = new FormControl(source[key]);
  return acc;
};
var validateColumnsField = (columns) => expandColumns(columns.toArray()).filter(isColumnComponent).filter(({
  field
}) => !isValidFieldName(field)).forEach(({
  field
}) => console.warn(ColumnConfigurationErrorMessages.fieldName(field)));
var handleExpandCollapseGroupsService = (service, expandEmitter, collapseEmitter, map4) => service.changes.pipe(filter(({
  group: group2,
  emit: emit2
}) => emit2 && isPresent4(group2))).subscribe((x) => x.expand ? expandEmitter.emit(map4(x)) : collapseEmitter.emit(map4(x)));
var handleExpandCollapseDetailsService = (service, expandEmitter, collapseEmitter, map4) => service.changes.pipe(filter(({
  dataItem
}) => isPresent4(dataItem))).subscribe((x) => x.expand ? expandEmitter.emit(map4(x)) : collapseEmitter.emit(map4(x)));
var isInEditedCell = (element, gridElement) => closest2(element, matchesClasses("k-grid-edit-cell")) && closest2(element, matchesNodeName("kendo-grid")) === gridElement;
var NOTIFY_DELAY = 500;
var GridComponent = class {
  constructor(supportService, selectionService, cellSelectionService, wrapper, groupInfoService, groupsService, changeNotification, detailsService, editService, filterService, pdfService, responsiveService, renderer, excelService, ngZone, scrollSyncService, domEvents, columnResizingService, changeDetectorRef, columnReorderService, columnInfoService, navigationService, sortService, scrollRequestService, localization, ctx, sizingService, rowReorderService) {
    this.supportService = supportService;
    this.selectionService = selectionService;
    this.cellSelectionService = cellSelectionService;
    this.wrapper = wrapper;
    this.groupInfoService = groupInfoService;
    this.groupsService = groupsService;
    this.changeNotification = changeNotification;
    this.detailsService = detailsService;
    this.editService = editService;
    this.filterService = filterService;
    this.pdfService = pdfService;
    this.responsiveService = responsiveService;
    this.renderer = renderer;
    this.excelService = excelService;
    this.ngZone = ngZone;
    this.scrollSyncService = scrollSyncService;
    this.domEvents = domEvents;
    this.columnResizingService = columnResizingService;
    this.changeDetectorRef = changeDetectorRef;
    this.columnReorderService = columnReorderService;
    this.columnInfoService = columnInfoService;
    this.navigationService = navigationService;
    this.sortService = sortService;
    this.scrollRequestService = scrollRequestService;
    this.localization = localization;
    this.ctx = ctx;
    this.sizingService = sizingService;
    this.rowReorderService = rowReorderService;
    this.scrollable = "scrollable";
    this.selectable = false;
    this.trackBy = defaultTrackBy;
    this.virtualColumns = false;
    this.gridData = () => {
      return this.flatData;
    };
    this.filterable = false;
    this.sortable = false;
    this.pageable = false;
    this.groupable = false;
    this.autoSize = false;
    this.resizable = false;
    this.reorderable = false;
    this.columnMenu = false;
    this.hideHeader = false;
    this.filterChange = new EventEmitter();
    this.pageChange = new EventEmitter();
    this.groupChange = new ZoneAwareEventEmitter(this.ngZone);
    this.sortChange = new EventEmitter();
    this.selectionChange = new EventEmitter();
    this.rowReorder = new EventEmitter();
    this.dataStateChange = new EventEmitter();
    this.groupExpand = new EventEmitter();
    this.groupCollapse = new EventEmitter();
    this.detailExpand = new EventEmitter();
    this.detailCollapse = new EventEmitter();
    this.edit = new EventEmitter();
    this.cancel = new EventEmitter();
    this.save = new EventEmitter();
    this.remove = new EventEmitter();
    this.add = new EventEmitter();
    this.cellClose = new EventEmitter();
    this.cellClick = new ZoneAwareEventEmitter(this.ngZone);
    this.pdfExport = new EventEmitter();
    this.excelExport = new EventEmitter();
    this.columnResize = new ZoneAwareEventEmitter(this.ngZone);
    this.columnReorder = new EventEmitter();
    this.columnVisibilityChange = new EventEmitter();
    this.columnLockedChange = new EventEmitter();
    this.columnStickyChange = new EventEmitter();
    this.scrollBottom = new EventEmitter();
    this.contentScroll = new EventEmitter();
    this.columns = new QueryList();
    this.hostClass = true;
    this.footer = new QueryList();
    this.selectionDirective = false;
    this.ariaRootId = `k-${guid()}`;
    this.showLicenseWatermark = false;
    this.columnsContainer = new ColumnsContainer(() => this.columnList.filterHierarchy((column) => {
      if (!isUniversal()) {
        column.matchesMedia = this.matchesMedia(column);
      }
      return column.isVisible;
    }));
    this.view = new DataCollection(() => new DataResultIterator(this.data, this.skip, this.hasGroupFooters));
    this.shouldGenerateColumns = true;
    this.notifyTimeout = null;
    this._sort = new Array();
    this._group = new Array();
    this._skip = 0;
    this._data = [];
    this.cachedWindowWidth = 0;
    this._rowSelected = null;
    this._cellSelected = null;
    this._rowReorderable = false;
    this._navigable = [];
    this._size = "medium";
    this._loading = false;
    this.rtl = false;
    this._rowClass = () => null;
    const isValid = validatePackage(packageMetadata4);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.ctx.grid = this;
    this.localizationSubscription = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    });
    this.groupInfoService.registerColumnsContainer(() => this.columnList);
    this.columnInfoService.init(this.columnsContainer, () => this.columnList);
    this.columnVisibilityChangeSubscription = this.columnInfoService.visibilityChange.subscribe((changed) => {
      this.columnVisibilityChange.emit(new ColumnVisibilityChangeEvent(changed));
    });
    this.columnLockedChangeSubscription = this.columnInfoService.lockedChange.subscribe((changed) => {
      this.columnLockedChange.emit(new ColumnLockedChangeEvent(changed));
    });
    this.columnStickyChangeSubscription = this.columnInfoService.stickyChange.subscribe((changed) => {
      this.columnStickyChange.emit(new ColumnStickyChangeEvent(changed));
    });
    this.groupExpandCollapseSubscription = handleExpandCollapseGroupsService(groupsService, this.groupExpand, this.groupCollapse, ({
      group: group2,
      groupIndex,
      parentGroup
    }) => ({
      group: group2,
      groupIndex,
      parentGroup
    }));
    this.detailsServiceSubscription = handleExpandCollapseDetailsService(detailsService, this.detailExpand, this.detailCollapse, (args) => args);
    this.filterSubscription = this.filterService.changes.subscribe((x) => {
      this.filterChange.emit(x);
    });
    this.sortSubscription = this.sortService.changes.subscribe((x) => {
      this.sortChange.emit(x);
    });
    this.attachStateChangesEmitter();
    this.attachEditHandlers();
    this.attachDomEventHandlers();
    this.pdfSubscription = this.pdfService.exportClick.subscribe(this.emitPDFExportEvent.bind(this));
    this.excelSubscription = this.excelService.exportClick.subscribe(this.saveAsExcel.bind(this));
    this.columnsContainerChange();
    this.handleColumnResize();
    this.columnList = new ColumnList(this.columns);
    this.columnReorderSubscription = this.columnReorderService.changes.subscribe(this.reorder.bind(this));
    this.columnRangeChangeSubscription = this.columnInfoService.columnRangeChange.subscribe(this.onColumnRangeChange.bind(this));
  }
  /**
   * Sets the data of the Grid. If an array is provided, the Grid automatically gets the total count
   * ([more information and example]({% slug binding_grid %})).
   */
  set data(value2) {
    this._data = value2;
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
      this.notifyTimeout = null;
    }
    if (this.rowReorderable) {
      this.ngZone.runOutsideAngular(() => {
        this.notifyTimeout = setTimeout(() => {
          this.notifyReorderContainers();
        }, NOTIFY_DELAY);
      });
    }
  }
  get data() {
    return this._data;
  }
  get hintText() {
    return this.rowReorderService.getDefaultHintText(this.columnList, this.flatData);
  }
  /**
   * Defines the number of records to be skipped by the pager.
   * Required by the [paging]({% slug paging_grid %}) functionality.
   */
  get skip() {
    return this._skip;
  }
  set skip(value2) {
    if (typeof value2 === "number" && value2 >= 0) {
      this._skip = this.rowReorderService.skip = value2;
    }
  }
  /**
   * The descriptors by which the data will be sorted ([see example]({% slug sorting_grid %})).
   */
  set sort(value2) {
    if (isArray2(value2)) {
      this._sort = value2;
    }
  }
  get sort() {
    return this._sort;
  }
  /**
   * Specifies the sizing of various Grid building blocks (e.g. tables, buttons, inputs, dropdowns, etc.)
   * @default 'medium'
   */
  set size(size) {
    this._size = size;
    if (size === "none") {
      this.wrapper.nativeElement.classList.remove("k-grid-sm", "k-grid-md");
    }
    this.sizingService.changes.next(this.size);
  }
  get size() {
    return this._size;
  }
  /**
   * The descriptors by which the data will be grouped ([see example]({% slug grouping_grid %})).
   */
  set group(value2) {
    if (isArray2(value2)) {
      this._group = value2;
    }
  }
  /**
   */
  get group() {
    return this._group;
  }
  /**
   * @hidden
   */
  get showStatusBar() {
    return !!this.selectable;
  }
  /**
   * @hidden
   */
  get showTopToolbar() {
    return this.toolbarTemplate && ["top", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get showBottomToolbar() {
    return this.toolbarTemplate && ["bottom", "both"].indexOf(this.toolbarTemplate.position) > -1;
  }
  /**
   * @hidden
   */
  get isLocked() {
    return this.lockedLeafColumns.length > 0;
  }
  /**
   * @hidden
   */
  get showTopPager() {
    const position2 = this.pageable.position;
    return !this.isVirtual && this.pageable !== false && ["top", "both"].indexOf(position2) > -1;
  }
  /**
   * @hidden
   */
  get showBottomPager() {
    const position2 = this.pageable.position;
    return !this.isVirtual && this.pageable !== false && position2 !== "top";
  }
  /**
   * @hidden
   */
  get hasPager() {
    return this.showTopPager || this.showBottomPager;
  }
  /**
   * @hidden
   */
  get showGroupPanel() {
    return this.groupable && this.groupable.enabled !== false;
  }
  /**
   * @hidden
   */
  get groupableEmptyText() {
    return this.groupable.emptyText;
  }
  /**
   * @hidden
   */
  get marqueeSelection() {
    return this.selectionService.enableMarquee || this.cellSelectionService.enableMarquee;
  }
  /**
   * Enables the [row reordering]({% slug reordering_rows_grid %}) of the Grid.
   * @default false
   */
  set rowReorderable(value2) {
    this._rowReorderable = value2;
    if (value2) {
      this.rowReorderSubscription = this.rowReorderService.rowReorder.subscribe((args) => {
        this.ngZone.run(() => {
          this.rowReorder.emit(args);
        });
      });
    } else {
      this.rowReorderSubscription?.unsubscribe();
    }
  }
  get rowReorderable() {
    return this._rowReorderable;
  }
  /**
   * If set to `true`, the user can use dedicated shortcuts to interact with the Grid.
   * By default, navigation is disabled and the Grid content is accessible in the normal tab sequence.
   * To enable navigation through separate Grid sections only, provide a [`GridNavigableSection`]({% slug api_grid_gridnavigablesection %}) array.
   */
  set navigable(value2) {
    if (typeof value2 === "boolean") {
      this._navigable = value2 ? ["table", "pager", "toolbar"] : [];
      this.ctx.navigable = value2;
      return;
    } else {
      this.ctx.navigable = value2.includes("table");
    }
    this._navigable = value2;
  }
  get navigable() {
    return this._navigable;
  }
  /**
   * @hidden
   *
   * An alias for `navigable` for users who migrate from Kendo UI for jQuery.
   */
  set navigatable(value2) {
    this.navigable = value2;
  }
  /**
   * @hidden
   */
  get navigatable() {
    return this.navigable;
  }
  /**
   * Defines a function that is executed for every data row in the component
   * ([see example](slug:styling_grid_rows)).
   */
  set rowClass(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowClass", fn));
    }
    this._rowClass = fn;
  }
  get rowClass() {
    return this._rowClass;
  }
  /**
   * Defines a function that is executed for every data row in the component,
   * and determines whether the row will be sticky, i.e. always visible after scrolling.
   */
  set rowSticky(fn) {
    if (isDevMode() && isPresent4(fn) && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSticky", fn));
    }
    if (isPresent4(fn)) {
      this._rowSticky = fn;
    }
  }
  get rowSticky() {
    return this._rowSticky;
  }
  /**
   * Defines a Boolean function that is executed for each data row in the component
   * ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-rows)).
   * Determines whether the row will be selected.
   */
  set rowSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("rowSelected", fn));
    }
    this._rowSelected = fn;
  }
  get rowSelected() {
    return this._rowSelected;
  }
  /**
   * Defines a function that determines the selected state of a data cell.
   * Returns an object with `selected` and `item` properties.
   * The cell is marked as selected only if the `selected` property equals `true`.
   *
   * The function is executed for each data cell and may be called more than once
   * as part of a change detection cycle. ([see example]({% slug grid_selection_custom %}#toc-setting-the-selected-cells))
   */
  set cellSelected(fn) {
    if (isDevMode() && typeof fn !== "function") {
      throw new Error(GridConfigurationErrorMessages.functionType("cellSelected", fn));
    }
    this._cellSelected = fn;
  }
  get cellSelected() {
    return this._cellSelected;
  }
  /**
   * Returns the currently focused cell (if any).
   */
  get activeCell() {
    return this.navigationService.activeCell;
  }
  /**
   * Returns the currently focused row (if any).
   */
  get activeRow() {
    return this.navigationService.activeRow;
  }
  /**
   * Returns the current Grid selection.
   *
   * @hidden
   */
  get selection() {
    return this.selectable || this.selectionDirective ? this.defaultSelection ? this.defaultSelection.stateToArray() : this.selectionDirective.stateToArray() : [];
  }
  /**
   * Specifies if the loading indicator of the Grid will be displayed ([see example]({% slug binding_grid %})).
   *
   * @default false
   */
  set loading(value2) {
    this._loading = value2;
    this.rowReorderable && this.notifyReorderContainers();
  }
  get loading() {
    return this._loading;
  }
  get dir() {
    return this.direction;
  }
  get sizeSmallClass() {
    return this.size === "small";
  }
  get sizeMediumClass() {
    return this.size === "medium" || !this.size;
  }
  get lockedClasses() {
    return this.lockedLeafColumns.length > 0;
  }
  get virtualClasses() {
    return this.isVirtual;
  }
  get noScrollbarClass() {
    return this.scrollbarWidth === 0;
  }
  get detailTemplate() {
    if (this._customDetailTemplate) {
      return this._customDetailTemplate;
    }
    return this.detailTemplateChildren ? this.detailTemplateChildren.first : void 0;
  }
  set detailTemplate(detailTemplate) {
    this._customDetailTemplate = detailTemplate;
  }
  get cellLoadingTemplate() {
    if (this._cellLoadingTemplate) {
      return this._customDetailTemplate;
    }
    return this.cellLoadingTemplateChildren ? this.cellLoadingTemplateChildren.first : void 0;
  }
  set cellLoadingTemplate(cellLoadingTemplate) {
    this._cellLoadingTemplate = cellLoadingTemplate;
  }
  get loadingTemplate() {
    if (this._loadingTemplate) {
      return this._loadingTemplate;
    }
    return this.loadingTemplateChildren ? this.loadingTemplateChildren.first : void 0;
  }
  set loadingTemplate(loadingTemplate) {
    this._loadingTemplate = loadingTemplate;
  }
  get statusBarTemplate() {
    if (this._statusBarTemplate) {
      return this._statusBarTemplate;
    }
    return this.statusBarTemplateChildren ? this.statusBarTemplateChildren.first : void 0;
  }
  set statusBarTemplate(statusBarTemplate) {
    this._statusBarTemplate = statusBarTemplate;
  }
  get noRecordsTemplate() {
    if (this._customNoRecordsTemplate) {
      return this._customNoRecordsTemplate;
    }
    return this.noRecordsTemplateChildren ? this.noRecordsTemplateChildren.first : void 0;
  }
  set noRecordsTemplate(customNoRecordsTemplate) {
    this._customNoRecordsTemplate = customNoRecordsTemplate;
  }
  get pagerTemplate() {
    if (this._customPagerTemplate) {
      return this._customPagerTemplate;
    }
    return this.pagerTemplateChildren ? this.pagerTemplateChildren.first : void 0;
  }
  set pagerTemplate(customPagerTemplate) {
    this._customPagerTemplate = customPagerTemplate;
  }
  get toolbarTemplate() {
    if (this._customToolbarTemplate) {
      return this._customToolbarTemplate;
    }
    return this.toolbarTemplateChildren ? this.toolbarTemplateChildren.first : void 0;
  }
  set toolbarTemplate(customToolbarTemplate) {
    this._customToolbarTemplate = customToolbarTemplate;
  }
  get scrollbarWidth() {
    return this.supportService.scrollbarWidth;
  }
  get headerPadding() {
    if (isUniversal()) {
      return "";
    }
    const padding = Math.max(0, this.scrollbarWidth) + "px";
    const right = this.rtl ? 0 : padding;
    const left = this.rtl ? padding : 0;
    return `0 ${right} 0 ${left}`;
  }
  get hasGroupFooters() {
    return this.columnsContainer.hasGroupFooter;
  }
  get showFooter() {
    return this.columnsContainer.hasFooter;
  }
  get showGroupFooters() {
    return this.groupable && this.groupable.showFooter;
  }
  get ariaRowCount() {
    return this.totalColumnLevels + 1 + this.view.total + (hasFilterRow(this.filterable) ? 1 : 0);
  }
  get ariaColCount() {
    return this.columnsContainer.leafColumnsToRender.length;
  }
  get navigation() {
    return this.navigationService;
  }
  get isVirtual() {
    return this.scrollable === "virtual";
  }
  get isScrollable() {
    return this.scrollable !== "none";
  }
  get visibleColumns() {
    return this.columnsContainer.allColumns;
  }
  get lockedColumns() {
    return this.columnsContainer.lockedColumns;
  }
  get nonLockedColumns() {
    return this.columnsContainer.nonLockedColumns;
  }
  get lockedLeafColumns() {
    return this.columnsContainer.lockedLeafColumns;
  }
  get stickyColumns() {
    return this.columns.filter((column) => column.sticky);
  }
  get nonLockedLeafColumns() {
    return this.columnsContainer.nonLockedLeafColumns;
  }
  get leafColumns() {
    return this.columnsContainer.leafColumns;
  }
  get totalColumnLevels() {
    return this.columnsContainer.totalLevels;
  }
  get headerColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.viewportColumns;
    }
    return this.nonLockedColumns;
  }
  get headerLeafColumns() {
    if (this.virtualColumns && !this.pdfService.exporting) {
      return this.leafViewportColumns;
    }
    return this.nonLockedLeafColumns;
  }
  get lockedWidth() {
    const groupCellsWidth = this.group.length * GROUP_CELL_WIDTH;
    return expandColumns(this.lockedLeafColumns.toArray()).reduce((prev, curr) => prev + (curr.width || 0), groupCellsWidth);
  }
  get nonLockedWidth() {
    if (!this.rtl && this.lockedLeafColumns.length || this.virtualColumns) {
      return !this.virtualColumns ? this.columnsContainer.unlockedWidth : this.leafViewportColumns.reduce((acc, column) => acc + (column.width || 0), 0);
    }
    return void 0;
  }
  get selectableSettings() {
    if (this.selectionService) {
      return this.selectionService.options;
    }
    return void 0;
  }
  get columnMenuTemplate() {
    const template = this.columnMenuTemplates.first;
    return template ? template.templateRef : null;
  }
  get totalCount() {
    if (this.isVirtual || !isPresent4(this.pageSize)) {
      return this.view.total;
    }
    return this.pageSize;
  }
  /**
   * @hidden
   */
  getDefaultSelectors(type) {
    return this.rowReorderService.defaultSelectors[type];
  }
  /**
   * @hidden
   */
  getHintSettings(type) {
    return this.rowReorderService[type];
  }
  /**
   * Expands the specified master row ([see example]({% slug hierarchy_grid %})).
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded state internally using the data row index.
   *
   * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
   * for examples on how to control the expanded state.
   *
   * @param index - The data row index of the master row.
   */
  expandRow(index) {
    this.toggleDetailRowLegacy(index, true);
  }
  /**
   * Collapses the specified master row ([see example]({% slug hierarchy_grid %})).
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded state internally using the data row index.
   *
   * For new development, use the [kendoGridDetailsExpandBy directive]({% slug api_grid_expanddetailsdirective %})
   * or provide an isDetailExpanded callback. See [Controlling the Expanded State]({% slug master_detail_expanded_state_grid %})
   * for examples on how to control the expanded state.
   *
   * @param index - The data row index of the master row.
   */
  collapseRow(index) {
    this.toggleDetailRowLegacy(index, false);
  }
  /**
   * Expands a group header item for the given index. For example,
   * `0_1` expands the second inner group of the first master group.
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded group state internally using the hierarchical group index.
   *
   * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index - The underscore separated hierarchical index of the group.
   */
  expandGroup(index) {
    this.toggleGroupRowLegacy(index, true);
  }
  /**
   * Collapses a group header item for the given index. For example,
   * `0_1` collapses the second inner group of the first master group.
   *
   * This method is provided only for backwards-compatibility with legacy versions.
   * These versions tracked the expanded group state internally using the hierarchical group index.
   *
   * When a Grid is pageable, the indexes of the groups are offset by the current Grid [skip]({% slug api_grid_gridcomponent %}#toc-skip).
   *
   * @param {string} index - The underscore separated hierarchical index of the group.
   */
  collapseGroup(index) {
    this.toggleGroupRowLegacy(index, false);
  }
  /**
   * @hidden
   */
  resetGroupsState() {
    this.groupsService.reset();
  }
  /**
   * @hidden
   */
  onDataChange() {
    this.autoGenerateColumns();
    this.changeNotification.notify();
    this.pdfService.dataChanged.emit();
    if (isPresent4(this.defaultSelection)) {
      this.defaultSelection.reset();
    }
    this.initSelectionService();
    this.updateNavigationMetadata();
  }
  ngOnChanges(changes) {
    if (isChanged("data", changes)) {
      this.onDataChange();
    }
    if (this.lockedLeafColumns.length && anyChanged(["pageSize", "skip", "sort", "group"], changes)) {
      this.changeNotification.notify();
    }
    if (anyChanged(["pageSize", "scrollable", "virtualColumns"], changes)) {
      this.updateNavigationMetadata();
    }
    if (isChanged("virtualColumns", changes)) {
      this.viewportColumns = this.leafViewportColumns = null;
    }
    if (isChanged("height", changes, false)) {
      this.renderer.setStyle(this.wrapper.nativeElement, "height", `${this.height}px`);
    }
    if (isChanged("filterable", changes) && this.lockedColumns.length) {
      this.syncHeaderHeight(this.ngZone.onStable.asObservable().pipe(take(1)));
    }
    if (anyChanged(["columnMenu", "sortable", "filterable"], changes, false)) {
      this.columnMenuOptions = this.columnMenu && Object.assign({
        filter: Boolean(this.filterable),
        sort: Boolean(this.sortable)
      }, this.columnMenu);
    }
    if (isChanged("scrollable", changes) && this.isScrollable) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => this.attachScrollSync());
    }
    if (isChanged("selectable", changes) && this.shouldResetSelection(changes["selectable"])) {
      if (this.defaultSelection) {
        this.defaultSelection.reset();
      } else if (this.selectionDirective) {
        this.selectionDirective.reset();
      }
    }
    if (isChanged("groupable", changes, true)) {
      this.groupable = changes["groupable"].currentValue;
    }
    if (isChanged("navigable", changes, true)) {
      if (this.navigationService.enabled) {
        this.navigationService.setActiveSections(this.navigable);
      } else {
        if (this.navigable.length) {
          this.navigationService.init(this.navigationMetadata(), this.navigable);
        }
      }
    }
  }
  ngAfterViewInit() {
    this.attachScrollSync();
    this.attachElementEventHandlers();
    this.updateNavigationMetadata();
    this.applyAutoSize();
  }
  ngAfterContentChecked() {
    this.columnsContainer.refresh();
    this.verifySettings();
    this.initSelectionService();
  }
  ngAfterContentInit() {
    this.shouldGenerateColumns = !this.columns.length;
    this.autoGenerateColumns();
    this.columnList = new ColumnList(this.columns);
    this.columnsChangeSubscription = this.columns.changes.subscribe(() => this.verifySettings());
  }
  ngOnInit() {
    if (this.navigable.length) {
      this.navigationService.init(this.navigationMetadata(), this.navigable);
    }
  }
  ngOnDestroy() {
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.groupExpandCollapseSubscription) {
      this.groupExpandCollapseSubscription.unsubscribe();
    }
    if (this.detailsServiceSubscription) {
      this.detailsServiceSubscription.unsubscribe();
    }
    if (this.editServiceSubscription) {
      this.editServiceSubscription.unsubscribe();
    }
    if (this.pdfSubscription) {
      this.pdfSubscription.unsubscribe();
    }
    if (this.filterSubscription) {
      this.filterSubscription.unsubscribe();
    }
    if (this.sortSubscription) {
      this.sortSubscription.unsubscribe();
    }
    if (this.columnsChangeSubscription) {
      this.columnsChangeSubscription.unsubscribe();
    }
    if (this.excelSubscription) {
      this.excelSubscription.unsubscribe();
    }
    if (this.columnsContainerChangeSubscription) {
      this.columnsContainerChangeSubscription.unsubscribe();
    }
    if (this.scrollSyncService) {
      this.scrollSyncService.destroy();
    }
    if (this.detachElementEventHandlers) {
      this.detachElementEventHandlers();
    }
    if (this.defaultSelection) {
      this.defaultSelection.destroy();
    }
    if (this.cellClickSubscription) {
      this.cellClickSubscription.unsubscribe();
    }
    if (this.footerChangeSubscription) {
      this.footerChangeSubscription.unsubscribe();
    }
    this.ngZone = null;
    if (this.columnResizingSubscription) {
      this.columnResizingSubscription.unsubscribe();
    }
    if (this.columnReorderSubscription) {
      this.columnReorderSubscription.unsubscribe();
    }
    if (this.localizationSubscription) {
      this.localizationSubscription.unsubscribe();
    }
    if (this.columnVisibilityChangeSubscription) {
      this.columnVisibilityChangeSubscription.unsubscribe();
    }
    if (this.columnLockedChangeSubscription) {
      this.columnLockedChangeSubscription.unsubscribe();
    }
    if (this.columnStickyChangeSubscription) {
      this.columnStickyChangeSubscription.unsubscribe();
    }
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
    this.columnRangeChangeSubscription.unsubscribe();
  }
  /**
   * @hidden
   */
  attachScrollSync() {
    if (isUniversal()) {
      return;
    }
    if (this.header) {
      this.scrollSyncService.registerEmitter(this.header.nativeElement, "header");
    }
    if (this.footer) {
      this.footerChangeSubscription = observe(this.footer).subscribe((footers) => footers.map((footer) => footer.nativeElement).filter(isPresent4).forEach((element) => {
        this.scrollSyncService.registerEmitter(element, "footer");
        element.scrollLeft = this.wrapper.nativeElement.querySelector(".k-grid-content")?.scrollLeft;
      }));
    }
  }
  /**
   * @hidden
   */
  get ariaLabel() {
    return this.localization.get("gridLabel");
  }
  /**
   * @hidden
   */
  messageFor(token) {
    return this.localization.get(token);
  }
  /**
   * Switches the specified table row in the edit mode ([see example]({% slug inline_editing_grid %}#toc-editing-records-1)).
   *
   * @param rowIndex - The data row index that will be switched in the edit mode.
   * @param group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
   * that describes the edit form.
   * @param options - Additional options configuring the focus target once the editor opens.
   */
  editRow(rowIndex, group2, options) {
    this.editService.editRow(rowIndex, group2);
    if (isPresent4(options) && options.skipFocus) {
      return;
    }
    const row2 = `tr[data-kendo-grid-item-index="${rowIndex}"]`;
    const columnIndex = options && options.columnIndex;
    const target = isNaN(columnIndex) ? row2 : `${row2} td[data-kendo-grid-column-index="${columnIndex}"]`;
    this.focusEditElement(target);
  }
  /**
   * Closes the editor for a given row ([see example]({% slug inline_editing_grid %}#toc-canceling-editing-1)).
   *
   * @param {number} index - The row index that will be switched out of the edit mode. If no index is provided, it is assumed
   * that the new item editor will be closed.
   */
  closeRow(index) {
    this.editService.close(index);
  }
  /**
   * Creates a new row editor ([see example]({% slug inline_editing_grid %}#toc-adding-records-1)).
   *
   * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi']) that describes
   * the edit form. If called with a data item, it will build the `FormGroup` from the data item fields.
   */
  addRow(group2) {
    const isFormGroup = group2 instanceof FormGroup;
    if (!isFormGroup) {
      const fields = Object.keys(group2).reduce(createControl(group2), {});
      group2 = new FormGroup(fields);
    }
    this.editService.addRow(group2);
    this.focusEditElement(".k-grid-add-row");
  }
  /**
   * Puts the cell that is specified by the table row and column in edit mode ([see example](slug:editing_incell_grid)).
   *
   * @param {number} rowIndex - The data row index that will be switched in the edit mode.
   * @param {number|string|any} column - The leaf column index, or the field name or the column instance that should be edited.
   * @param {FormGroup} group - The [FormGroup](link:site.data.urls.angular['formgroupapi'])
   * that describes the edit form.
   */
  editCell(rowIndex, column, group2) {
    const instance = this.columnInstance(column);
    this.editService.editCell(rowIndex, instance, group2);
    this.focusEditElement(".k-grid-edit-cell");
  }
  /**
   * Closes the current cell in edit mode and fires
   * the [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event.
   *
   * @return {boolean} Indicates whether the edited cell was closed.
   * A `false` value indicates that the
   * [cellClose]({% slug api_grid_gridcomponent %}#toc-cellclose) event was prevented.
   */
  closeCell() {
    return !this.editService.closeCell();
  }
  /**
   * Closes the current cell in edit mode.
   */
  cancelCell() {
    this.editService.cancelCell();
  }
  /**
   * Returns a flag which indicates if a row or a cell is currently edited.
   *
   * @return {boolean} A flag which indicates if a row or a cell is currently edited.
   */
  isEditing() {
    return this.editService.isEditing();
  }
  /**
   * Returns a flag which indicates if a cell is currently edited.
   *
   * @return {boolean} A flag which indicates if a cell is currently being edited.
   */
  isEditingCell() {
    return this.editService.isEditingCell();
  }
  /**
   * Initiates the PDF export ([see example]({% slug pdfexport_grid %})).
   */
  saveAsPDF() {
    this.pdfService.save(this);
  }
  /**
   * Exports the Grid element to a Drawing [Group]({% slug api_kendo-drawing_group %}) by using the `kendo-grid-pdf` component options.
   * ([see example]({% slug pdfexport_grid %}#toc-exporting-multiple-grids-to-the-same-pdf)).
   *
   * @return {Promise} A promise that will be resolved with the Drawing `Group`.
   */
  drawPDF() {
    const promise = createPromise();
    this.pdfService.draw(this, promise);
    return promise;
  }
  /**
   * Initiates the Excel export ([see example]({% slug excelexport_grid %})).
   */
  saveAsExcel() {
    this.excelService.save(this);
  }
  /**
   * Applies the minimum possible width for the specified column,
   * so that the whole text fits without wrapping. This method expects the Grid
   * to be [resizable](slug:resizing_columns_grid). The method must be executed
   * after the Grid is already populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   */
  autoFitColumn(column) {
    this.columnResizingService.autoFit(column);
  }
  /**
   * Adjusts the width of the specified columns to fit the entire content, including headers, without wrapping.
   * If no columns are specified, `autoFitColumns` is applied to all columns.The method must be executed
   * after the Grid is already populated with data.
   * [See example](slug:resizing_columns_grid#toc-auto-fitting-the-content)
   *
   */
  autoFitColumns(columns = this.columns) {
    let cols;
    if (columns instanceof QueryList) {
      cols = columns.toArray();
    } else {
      cols = columns;
    }
    this.columnResizingService.autoFit(...cols);
  }
  /**
   * @hidden
   */
  notifyPageChange(source, event2) {
    if (source === "list" && !this.isVirtual) {
      return;
    }
    this.pageChange.emit(event2);
  }
  /**
   * @hidden
   */
  notifyScrollBottom() {
    if (this.scrollable === "none") {
      return;
    }
    if (hasObservers(this.scrollBottom)) {
      this.ngZone.run(() => this.scrollBottom.emit({
        sender: this
      }));
    }
  }
  /**
   * @hidden
   */
  focusEditElement(containerSelector) {
    if (this.focusElementSubscription) {
      this.focusElementSubscription.unsubscribe();
    }
    this.ngZone.runOutsideAngular(() => {
      this.focusElementSubscription = this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        const wrapper = this.wrapper.nativeElement;
        if (!this.setEditFocus(wrapper.querySelector(containerSelector)) && this.isLocked) {
          this.setEditFocus(wrapper.querySelector(`.k-grid-content ${containerSelector}`));
        }
        this.focusElementSubscription = null;
      });
    });
  }
  /**
   * Focuses the last active or the first cell of the Grid.
   *
   * @returns {NavigationCell} The focused cell.
   */
  focus() {
    this.assertNavigable();
    return this.navigationService.focusCell();
  }
  /**
   * Focuses the cell with the specified row and column index.
   *
   * The row index is based on the logical structure of the Grid and does not correspond to the data item index.
   * Header rows are included, starting at index 0.
   * Group headers and footers are included.
   * The row indexing is absolute and does not change with paging.
   *
   * If the Grid is configured for scrolling, including virtual scrolling, the scroll position will be updated.
   * If the row is not present on the current page, the method will have no effect.
   *
   * @param rowIndex - The logical row index to focus. The top header row has an index 0.
   * @param colIndex - The column index to focus.
   * @returns {NavigationCell} The focused cell.
   *
   */
  focusCell(rowIndex, colIndex) {
    this.assertNavigable();
    return this.navigationService.focusCell(rowIndex, colIndex);
  }
  /**
   * Focuses the next cell, optionally wrapping to the next row.
   *
   * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the last cell, returns `null`.
   */
  focusNextCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusNextCell(wrap);
  }
  /**
   * Focuses the previous cell. Optionally wraps to the previous row.
   *
   * @param wrap - A Boolean value which indicates if the focus will move to the next row. Defaults to `true`.
   * @returns {NavigationCell} The focused cell. If the focus is already on the first cell, returns `null`.
   */
  focusPrevCell(wrap = true) {
    this.assertNavigable();
    return this.navigationService.focusPrevCell(wrap);
  }
  /**
   * Scrolls to the specified row and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-row-and-column)).
   */
  scrollTo(request) {
    this.scrollRequestService.scrollTo(request, false);
  }
  /**
   * Scrolls to the specified data item and column ([see example](slug:scrollmmodes_grid#toc-scrolling-to-a-specific-item)).
   */
  scrollToItem(request) {
    this.scrollRequestService.scrollToItem(request);
  }
  /**
   * Changes the position of the specified column.
   * The reordering of columns operates only on the level
   * which is inferred by the source column.
   * For the `reorderColumn` method to work properly,
   * the `source` column has to be visible.
   *
   * @param {ColumnBase} source - The column whose position will be changed.
   * @param {number} destIndex - The new position of the column.
   * @param {ColumnReorderConfig} options - Additional options.
   *
   */
  reorderColumn(source, destIndex, options = {
    before: false
  }) {
    const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
    let target = columnsForLevel[destIndex];
    if (!target) {
      return;
    }
    const lastNonLocked2 = target.isLocked && !source.isLocked && this.columnsContainer.nonLockedColumns.length === 1;
    if (lastNonLocked2) {
      return;
    }
    if (isSpanColumnComponent(target) && !options.before) {
      target = target.childColumns.last;
    }
    this.reorder({
      before: options.before,
      source,
      target
    });
  }
  /**
   * A function which determines if a specific row is expanded.
   */
  set isDetailExpanded(callback) {
    this.detailsService.userCallback = callback;
  }
  get isDetailExpanded() {
    return this.detailsService.userCallback;
  }
  /**
   * A function which determines if a specific group row is expanded.
   */
  set isGroupExpanded(callback) {
    this.groupsService.userCallback = callback;
    this.groupable = isPresent4(callback);
  }
  get isGroupExpanded() {
    return this.groupsService.userCallback;
  }
  /**
   * @hidden
   */
  handleReorderEvents(ev, evType) {
    this.rowReorderService[evType](ev);
  }
  /**
   * @hidden
   */
  reorder({
    target,
    source,
    before,
    changeContainer
  }) {
    this.ngZone.run(() => {
      const columnsForLevel = sortColumns(this.allColumnsForLevel(source.level));
      let newIndex = columnsForLevel.indexOf(target);
      if (target.parent && target.parent.isSpanColumn) {
        newIndex = columnsForLevel.indexOf(target.parent);
        if (before) {
          target = target.parent;
        }
      }
      const oldIndex = columnsForLevel.indexOf(source);
      if (changeContainer) {
        if (before && 0 < newIndex && oldIndex < newIndex) {
          newIndex--;
        } else if (!before && oldIndex > newIndex) {
          newIndex++;
        }
      }
      const args = new ColumnReorderEvent({
        column: source,
        oldIndex,
        newIndex
      });
      this.columnReorder.emit(args);
      if (args.isDefaultPrevented()) {
        return;
      }
      if (changeContainer) {
        this.columnLockedChange.emit(new ColumnLockedChangeEvent([source]));
      }
      this.updateColumnIndices({
        columnsForLevel,
        source,
        target,
        before
      });
      if (source.locked !== target.locked) {
        source.locked = target.locked;
      }
      this.columnsContainer.refresh();
      this.changeDetectorRef.markForCheck();
    });
  }
  updateColumnIndices({
    columnsForLevel,
    source,
    target,
    before
  }) {
    const expandedColumns = expandColumnsWithSpan(columnsForLevel);
    const sourceColumnIndex = expandedColumns.indexOf(source);
    let nextSourceIndex = 0;
    let nextIndex = 0;
    let toSkip = 1;
    if (source.isSpanColumn) {
      toSkip += source.childColumns.length;
    }
    let i = 0;
    while (i < expandedColumns.length) {
      const column = expandedColumns[i];
      if (column === target) {
        nextSourceIndex = before ? nextIndex : nextIndex + 1;
        nextIndex = before ? nextIndex + toSkip : nextIndex;
        column.orderIndex = nextIndex;
        if (nextSourceIndex === nextIndex + 1) {
          nextIndex += toSkip;
        }
      } else if (column === source) {
        i += toSkip;
        continue;
      } else {
        column.orderIndex = nextIndex;
      }
      nextIndex++;
      i++;
    }
    for (i = sourceColumnIndex; i < sourceColumnIndex + toSkip; i++) {
      expandedColumns[i].orderIndex = nextSourceIndex++;
    }
    this.updateIndicesForLevel(source.level + 1);
  }
  updateIndicesForLevel(level) {
    const colsForParentLevel = this.allColumnsForLevel(level - 1);
    const colsForLevel = [];
    sortColumns(colsForParentLevel).forEach((c) => {
      if (c.isColumnGroup) {
        colsForLevel.push(...c.childrenArray.sort((a, b) => a.orderIndex - b.orderIndex));
      }
    });
    expandColumnsWithSpan(colsForLevel).map((c, i) => c.orderIndex = i);
    if (level < this.columnList.totalColumnLevels()) {
      this.updateIndicesForLevel(level + 1);
    }
  }
  allColumnsForLevel(level) {
    return this.columnList.toArray().filter((column) => column.level === level);
  }
  initSelectionService() {
    if (!this.selectable) {
      this.selectionService.ngOnDestroy();
      this.cellSelectionService.ngOnDestroy();
      return;
    }
    if (!this.selectionDirective && !isPresent4(this.defaultSelection)) {
      this.defaultSelection = new Selection(this.ctx, this.changeDetectorRef);
    }
    const cellSelectionMode = this.selectable["cell"];
    const activeService = cellSelectionMode ? this.cellSelectionService : this.selectionService;
    const inactiveService = cellSelectionMode ? this.selectionService : this.cellSelectionService;
    if (inactiveService.active) {
      inactiveService.ngOnDestroy();
      activeService.addSubscriptions();
      inactiveService.active = false;
    }
    activeService.active = true;
    activeService.init({
      cellSelected: cellSelectionMode ? this.cellSelected : void 0,
      rowSelected: cellSelectionMode ? void 0 : this.rowSelected,
      selectable: this.selectable,
      view: this.view,
      columns: cellSelectionMode ? this.columnList.toArray() : void 0
    });
    if (!this.selectionDirective && !this.selectableSettings.enabled) {
      this.defaultSelection.reset();
    }
    if (this.selectionSubscription) {
      this.selectionSubscription.unsubscribe();
    }
    if (cellSelectionMode) {
      this.selectionSubscription = this.cellSelectionService.changes.subscribe((event2) => {
        this.ngZone.run(() => this.selectionChange.emit(event2));
      });
    } else {
      this.selectionSubscription = this.selectionService.changes.subscribe((event2) => {
        this.ngZone.run(() => this.selectionChange.emit(event2));
      });
    }
  }
  setEditFocus(element) {
    if (element) {
      return this.navigationService.tryFocus(element);
    }
  }
  columnInstance(column) {
    let instance;
    if (typeof column === "number") {
      instance = this.columnsContainer.lockedLeafColumns.toArray().concat(this.columnsContainer.nonLockedLeafColumns.toArray())[column];
    } else if (typeof column === "string") {
      instance = this.columnList.filter((item) => item.field === column)[0];
    } else {
      instance = column;
    }
    if (!instance && isDevMode()) {
      throw new Error(ColumnConfigurationErrorMessages.invalidColumn(column));
    }
    return instance;
  }
  verifySettings() {
    if (isDevMode()) {
      const locked = this.lockedLeafColumns.length || this.columnMenu && this.columnMenu.lock;
      const stickyColumns = this.stickyColumns.length || this.columnMenu && this.columnMenu.stick;
      if (locked && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "locked columns"));
      }
      if (stickyColumns && this.detailTemplate) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("detail template", "sticky columns"));
      }
      if (this.lockedLeafColumns.length && !this.nonLockedLeafColumns.length) {
        console.warn(GridConfigurationErrorMessages.nonLockedColumnPresent);
      }
      if ((locked || this.virtualColumns) && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth(locked ? "Locked" : "Virtual"));
      }
      if (locked && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Locked"));
      }
      if (stickyColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Sticky"));
      }
      if (this.virtualColumns && !this.isScrollable) {
        console.warn(ColumnConfigurationErrorMessages.requiredScroll("Virtual"));
      }
      if (this.columnList.filter(isColumnGroupComponent).filter((x) => !x.hasChildren).length) {
        throw new Error(ColumnConfigurationErrorMessages.groupColumnContent);
      }
      if (this.columnList.filter((x) => x.locked && x.parent && !x.parent.isLocked).length) {
        throw new Error(ColumnConfigurationErrorMessages.lockedParent);
      }
      if ((this.rowHeight || this.detailRowHeight) && !this.isVirtual) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (!this.rowHeight && this.isVirtual) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (!this.detailRowHeight && this.isVirtual && this.detailTemplate) {
        console.warn(GridConfigurationErrorMessages.rowHeightVirtual);
      }
      if (stickyColumns && expandColumns(this.columnList.toArray()).filter((column) => !column.width && !isColumnGroupComponent(column)).length) {
        console.warn(ColumnConfigurationErrorMessages.requiredWidth("Sticky"));
      }
      if (this.rowSticky && this.scrollable === "virtual") {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", 'row virtualization (scrollable="virtual")'));
      }
      if (this.rowSticky && this.groupable) {
        throw new Error(GridConfigurationErrorMessages.incompatibleFeatures("sticky rows", "grouping"));
      }
      validateColumnsField(this.columnList);
    }
  }
  autoGenerateColumns() {
    if (this.shouldGenerateColumns && !this.columns.length && this.view.length) {
      this.columns.reset(Object.keys(this.view.at(0)).map((field) => {
        const column = new ColumnComponent2();
        column.field = field;
        return column;
      }));
    }
  }
  attachStateChangesEmitter() {
    this.stateChangeSubscription = merge(this.pageChange.pipe(map((x) => ({
      filter: this.filter,
      group: this.group,
      skip: x.skip,
      sort: this.sort,
      take: x.take
    }))), this.sortChange.pipe(map((sort2) => ({
      filter: this.filter,
      group: this.group,
      skip: this.skip,
      sort: sort2,
      take: this.pageSize
    }))), this.groupChange.pipe(map((group2) => ({
      filter: this.filter,
      group: group2,
      skip: this.skip,
      sort: this.sort,
      take: this.pageSize
    }))), this.filterChange.pipe(map((filter4) => ({
      filter: filter4,
      group: this.group,
      skip: 0,
      sort: this.sort,
      take: this.pageSize
    })))).subscribe((x) => {
      this.closeCell();
      this.cancelCell();
      this.dataStateChange.emit(x);
    });
  }
  attachEditHandlers() {
    if (!this.editService) {
      return;
    }
    this.editServiceSubscription = this.editService.changes.subscribe(this.emitCRUDEvent.bind(this));
  }
  emitCRUDEvent(args) {
    const {
      action,
      rowIndex,
      formGroup
    } = args;
    let dataItem = this.view.at(rowIndex - this.skip);
    if (action !== "add" && !dataItem) {
      dataItem = formGroup.value;
    }
    this.closeCell();
    Object.assign(args, {
      dataItem,
      sender: this
    });
    switch (action) {
      case "add":
        this.add.emit(args);
        break;
      case "cancel":
        this.cancel.emit(args);
        break;
      case "edit":
        this.edit.emit(args);
        break;
      case "remove":
        this.remove.emit(args);
        break;
      case "save":
        this.save.emit(args);
        break;
      case "cellClose":
        this.cellClose.emit(args);
        break;
      default:
        break;
    }
  }
  attachDomEventHandlers() {
    this.cellClickSubscription = this.domEvents.cellClick.subscribe((args) => {
      this.cellClick.emit(Object.assign({
        sender: this
      }, args));
    });
  }
  attachElementEventHandlers() {
    if (isUniversal()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const ariaRoot = this.ariaRoot.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      const resizeCheck = this.resizeCheck.bind(this);
      const resizeSubscription = this.renderer.listen("window", "resize", resizeCheck);
      const orientationSubscription = this.renderer.listen("window", "orientationchange", resizeCheck);
      const documentClickSubscription = this.renderer.listen("document", "click", (args) => {
        const activeElement = document.activeElement;
        if (this.editService.shouldCloseCell() && !closest2(args.target, matchesClasses("k-animation-container k-grid-ignore-click")) && !(activeElement && (closest2(activeElement, matchesClasses("k-animation-container")) || isInEditedCell(activeElement, this.wrapper.nativeElement)))) {
          this.editService.closeCell(args);
        }
      });
      const windowBlurSubscription = this.renderer.listen("window", "blur", (args) => {
        const activeElement = document.activeElement;
        if (activeElement && !(matchesNodeName("input")(activeElement) && activeElement.type === "file" && isInEditedCell(activeElement, this.wrapper.nativeElement))) {
          this.editService.closeCell(args);
        }
        this.domEvents.windowBlur.emit(args);
      });
      const clickSubscription = this.renderer.listen(wrapper, "click", (args) => {
        this.domEvents.click.emit(args);
      });
      const keydownSubscription = this.renderer.listen(wrapper, "keydown", (args) => {
        this.domEvents.keydown.emit(args);
      });
      let focused = false;
      const focusInSubscription = this.renderer.listen(ariaRoot, "focusin", (args) => {
        this.domEvents.focus.emit(args);
        if (!focused) {
          this.domEvents.focusIn.emit(args);
          focused = true;
        }
      });
      const focusOutSubscription = this.renderer.listen(ariaRoot, "focusout", (args) => {
        const next = args.relatedTarget || document.activeElement;
        const outside = !closest2(next, (node) => node === ariaRoot);
        if (outside) {
          this.domEvents.focusOut.emit(args);
          focused = false;
        }
      });
      this.detachElementEventHandlers = () => {
        resizeSubscription();
        orientationSubscription();
        documentClickSubscription();
        windowBlurSubscription();
        clickSubscription();
        keydownSubscription();
        focusInSubscription();
        focusOutSubscription();
      };
    });
  }
  matchesMedia(c) {
    return this.responsiveService.matchesMedia(c.media);
  }
  resizeCheck() {
    if (window.innerWidth !== this.cachedWindowWidth) {
      this.cachedWindowWidth = window.innerWidth;
      let hasChanges = false;
      this.columnList.filterHierarchy((column) => {
        const matchesMedia = this.matchesMedia(column);
        if (column.matchesMedia !== matchesMedia) {
          hasChanges = true;
          column.matchesMedia = matchesMedia;
        }
        return column.isVisible;
      });
      if (hasChanges) {
        this.ngZone.run(() => {
          this.changeDetectorRef.markForCheck();
        });
      }
    }
  }
  emitPDFExportEvent() {
    const args = new PDFExportEvent();
    this.pdfExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.saveAsPDF();
    }
  }
  syncHeaderHeight(observable) {
    return observable.pipe(filter(() => isPresent4(this.lockedHeader))).subscribe(() => syncRowsHeight(this.lockedHeader.nativeElement.children[0], this.header.nativeElement.children[0]));
  }
  columnsContainerChange() {
    this.columnsContainerChangeSubscription = this.syncHeaderHeight(this.columnsContainer.changes.pipe(filter(() => this.lockedColumns.length > 0), switchMap(() => this.ngZone.onStable.asObservable().pipe(take(1)))));
  }
  handleColumnResize() {
    const resizes = this.columnResizingService.changes;
    this.columnResizingSubscription = resizes.pipe(tap((e) => {
      if (e.type === "start") {
        this.renderer.addClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      } else if (e.type === "end") {
        this.renderer.removeClass(this.wrapper.nativeElement, "k-grid-column-resizing");
      }
    }), filter((e) => e.type === "start"), switchMap(() => resizes.pipe(takeUntil(resizes.pipe(filter((e) => e.type === "triggerAutoFit"))), filter((e) => e.type === "end")))).subscribe(this.notifyResize.bind(this));
  }
  notifyResize(e) {
    const args = e.resizedColumns.filter((item) => isTruthy(item.column.resizable) && !item.column.isColumnGroup).map((item) => ({
      column: item.column,
      newWidth: item.column.width,
      oldWidth: item.oldWidth
    }));
    this.columnResize.emit(args);
  }
  assertNavigable() {
    if (isDevMode() && !this.navigationService.enabled) {
      throw new Error(GridConfigurationErrorMessages.focusNavigable);
    }
  }
  navigationMetadata() {
    const isVirtual = this.isVirtual;
    const pageSize = this.pageSize;
    const dataRows = isVirtual ? this.view.total : pageSize;
    const addRowOffset = this.editService.hasNewItem ? 1 : 0;
    const filterRowOffset = hasFilterRow(this.filterable) ? 1 : 0;
    const headerRows = this.totalColumnLevels + 1 + filterRowOffset + addRowOffset;
    return new NavigationMetadata(dataRows, headerRows, isVirtual, this.hasPager, isPresent4(this.detailTemplate), this.wrapper, this.virtualColumns, this.columnsContainer);
  }
  updateNavigationMetadata() {
    this.navigationService.metadata = this.navigationMetadata();
  }
  applyAutoSize() {
    const cols = this.columns.filter((c) => this.autoSize ? c.autoSize !== false : c.autoSize);
    if (cols.length > 0) {
      this.ngZone.onStable.pipe(take(1)).subscribe((_) => this.autoFitColumns(cols));
    }
  }
  onColumnRangeChange(range) {
    const viewportColumns = this.viewportColumns = [];
    const columnsArray = this.columnsContainer.nonLockedLeafColumns.toArray();
    let leafViewportColumns = columnsArray.slice(range.start, range.end + 1);
    const stickyBeforeStart = columnsArray.slice(0, range.start).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    const stickyAfterEnd = columnsArray.slice(range.end, columnsArray.length).filter((c) => c.sticky && !leafViewportColumns.some((col) => col === c));
    leafViewportColumns = [...stickyBeforeStart, ...leafViewportColumns, ...stickyAfterEnd];
    for (let idx = 0; idx < leafViewportColumns.length; idx++) {
      let column = leafViewportColumns[idx];
      while (column.parent) {
        column = column.parent;
      }
      const toAdd = [column];
      while (toAdd.length) {
        column = toAdd.shift();
        viewportColumns.push(column);
        if (column.isColumnGroup) {
          toAdd.unshift(...column.childrenArray);
        }
      }
      const lastFromGroup = viewportColumns[viewportColumns.length - 1];
      column = leafViewportColumns[idx];
      while (column !== lastFromGroup && idx < leafViewportColumns.length) {
        idx++;
        column = leafViewportColumns[idx];
      }
    }
    if (range.start > 0) {
      const first = leafViewportColumns[0];
      let offset2 = range.offset;
      let current3 = viewportColumns[0];
      let index = 0;
      while (current3 !== first) {
        offset2 -= current3.isColumnGroup ? 0 : current3.width;
        index++;
        current3 = viewportColumns[index];
      }
      if (offset2 > 0) {
        const totalLevels = this.columnsContainer.totalLevels;
        let previous;
        for (let idx = 0; idx <= totalLevels; idx++) {
          const offsetColumn = idx < totalLevels ? new ColumnGroupComponent2(previous) : new ColumnBase2(previous);
          previous = offsetColumn;
          offsetColumn.title = " ";
          offsetColumn.width = offset2;
          viewportColumns.unshift(offsetColumn);
        }
      }
    }
    this.leafViewportColumns = viewportColumns.filter((c) => !c.isColumnGroup);
  }
  toggleDetailRowLegacy(index, expand) {
    const hasCallback = typeof this.isDetailExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandRow", "collapseRow", "kendoGridDetailsExpandBy", "isDetailExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.detailsService.isExpanded(index, null) !== expand) {
      this.detailsService.toggleRow(index, null);
    }
  }
  toggleGroupRowLegacy(index, expand) {
    const hasCallback = typeof this.isGroupExpanded === "function";
    if (isDevMode() && hasCallback) {
      throw new Error(GridConfigurationErrorMessages.expandCollapseMethods("expandGroup", "collapseGroup", "kendoGridExpandGroupBy", "isGroupExpanded"));
    }
    if (!isDevMode() && hasCallback) {
      return;
    }
    if (this.groupsService.isExpanded({
      groupIndex: index
    }) !== expand) {
      this.groupsService.toggleRow({
        index
      }, false);
      if (this.ctx.groupBindingDirective) {
        this.ctx.groupBindingDirective[`group${expand ? "Expand" : "Collapse"}`]({
          groupIndex: index
        });
      }
    }
  }
  shouldResetSelection(selectableChanges) {
    const previousValue = selectableChanges.previousValue;
    if (!previousValue) {
      return false;
    }
    const currentValue = selectableChanges.currentValue;
    if (!currentValue || currentValue.enabled === false) {
      return true;
    }
    return previousValue.cell !== currentValue.cell;
  }
  notifyReorderContainers() {
    this.dragTargetContainer?.notify();
    this.dropTargetContainer?.notify();
  }
  get flatData() {
    return isArray2(this.data) ? this.data : this.data.data;
  }
};
GridComponent.ɵfac = function GridComponent_Factory(t) {
  return new (t || GridComponent)(ɵɵdirectiveInject(BrowserSupportService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(CellSelectionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(GroupInfoService), ɵɵdirectiveInject(GroupsService), ɵɵdirectiveInject(ChangeNotificationService), ɵɵdirectiveInject(DetailsService), ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ResponsiveService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ScrollSyncService), ɵɵdirectiveInject(DomEventsService), ɵɵdirectiveInject(ColumnResizingService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ColumnReorderService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(SortService), ɵɵdirectiveInject(ScrollRequestService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService), ɵɵdirectiveInject(RowReorderService));
};
GridComponent.ɵcmp = ɵɵdefineComponent({
  type: GridComponent,
  selectors: [["kendo-grid"]],
  contentQueries: function GridComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
      ɵɵcontentQuery(dirIndex, DetailTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, CellLoadingTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, LoadingTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, StatusBarTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, NoRecordsTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, PagerTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, ToolbarTemplateDirective, 4);
      ɵɵcontentQuery(dirIndex, ColumnMenuTemplateDirective, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.detailTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellLoadingTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadingTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.statusBarTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noRecordsTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pagerTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toolbarTemplateChildren = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnMenuTemplates = _t);
    }
  },
  viewQuery: function GridComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c46, 5);
      ɵɵviewQuery(_c47, 5);
      ɵɵviewQuery(_c48, 7);
      ɵɵviewQuery(DragTargetContainerDirective, 5);
      ɵɵviewQuery(DropTargetContainerDirective, 5);
      ɵɵviewQuery(_c49, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lockedHeader = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ariaRoot = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragTargetContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropTargetContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footer = _t);
    }
  },
  hostVars: 13,
  hostBindings: function GridComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("dir", ctx.dir);
      ɵɵclassProp("k-grid", ctx.hostClass)("k-grid-sm", ctx.sizeSmallClass)("k-grid-md", ctx.sizeMediumClass)("k-grid-lockedcolumns", ctx.lockedClasses)("k-grid-virtual", ctx.virtualClasses)("k-grid-no-scrollbar", ctx.noScrollbarClass);
    }
  },
  inputs: {
    data: "data",
    pageSize: "pageSize",
    height: "height",
    rowHeight: "rowHeight",
    detailRowHeight: "detailRowHeight",
    skip: "skip",
    scrollable: "scrollable",
    selectable: "selectable",
    sort: "sort",
    size: "size",
    trackBy: "trackBy",
    filter: "filter",
    group: "group",
    virtualColumns: "virtualColumns",
    filterable: "filterable",
    sortable: "sortable",
    pageable: "pageable",
    groupable: "groupable",
    rowReorderable: "rowReorderable",
    navigable: "navigable",
    navigatable: "navigatable",
    autoSize: "autoSize",
    rowClass: "rowClass",
    rowSticky: "rowSticky",
    rowSelected: "rowSelected",
    cellSelected: "cellSelected",
    resizable: "resizable",
    reorderable: "reorderable",
    loading: "loading",
    columnMenu: "columnMenu",
    hideHeader: "hideHeader",
    isDetailExpanded: "isDetailExpanded",
    isGroupExpanded: "isGroupExpanded"
  },
  outputs: {
    filterChange: "filterChange",
    pageChange: "pageChange",
    groupChange: "groupChange",
    sortChange: "sortChange",
    selectionChange: "selectionChange",
    rowReorder: "rowReorder",
    dataStateChange: "dataStateChange",
    groupExpand: "groupExpand",
    groupCollapse: "groupCollapse",
    detailExpand: "detailExpand",
    detailCollapse: "detailCollapse",
    edit: "edit",
    cancel: "cancel",
    save: "save",
    remove: "remove",
    add: "add",
    cellClose: "cellClose",
    cellClick: "cellClick",
    pdfExport: "pdfExport",
    excelExport: "excelExport",
    columnResize: "columnResize",
    columnReorder: "columnReorder",
    columnVisibilityChange: "columnVisibilityChange",
    columnLockedChange: "columnLockedChange",
    columnStickyChange: "columnStickyChange",
    scrollBottom: "scrollBottom",
    contentScroll: "contentScroll"
  },
  exportAs: ["kendoGrid"],
  features: [ɵɵProvidersFeature([BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
    provide: CELL_CONTEXT,
    useValue: EMPTY_CELL_CONTEXT
  }, {
    provide: L10N_PREFIX,
    useValue: "kendo.grid"
  }, FilterService, ResponsiveService, PagerContextService, ExcelService, ScrollSyncService, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService]), ɵɵNgOnChangesFeature],
  decls: 16,
  vars: 22,
  consts: () => {
    let i18n_0;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_0 = goog.getMsg("Drag a column header and drop it here to group by that column");
      i18n_0 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_0;
    } else {
      i18n_0 = $localize`:kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty:Drag a column header and drop it here to group by that column`;
    }
    let i18n_1;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_1 = goog.getMsg("No records available.");
      i18n_1 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_1;
    } else {
      i18n_1 = $localize`:kendo.grid.noRecords|The label visible in the Grid when there are no records:No records available.`;
    }
    let i18n_2;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_2 = goog.getMsg("Go to the first page");
      i18n_2 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_2;
    } else {
      i18n_2 = $localize`:kendo.grid.pagerFirstPage|The label for the first page button in Grid pager:Go to the first page`;
    }
    let i18n_3;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_3 = goog.getMsg("Go to the previous page");
      i18n_3 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_3;
    } else {
      i18n_3 = $localize`:kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager:Go to the previous page`;
    }
    let i18n_4;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_4 = goog.getMsg("Go to the next page");
      i18n_4 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_4;
    } else {
      i18n_4 = $localize`:kendo.grid.pagerNextPage|The label for the next page button in Grid pager:Go to the next page`;
    }
    let i18n_5;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_5 = goog.getMsg("Go to the last page");
      i18n_5 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_5;
    } else {
      i18n_5 = $localize`:kendo.grid.pagerLastPage|The label for the last page button in Grid pager:Go to the last page`;
    }
    let i18n_6;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_6 = goog.getMsg("Page");
      i18n_6 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_6;
    } else {
      i18n_6 = $localize`:kendo.grid.pagerPage|The label before the current page number in the Grid pager:Page`;
    }
    let i18n_7;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_7 = goog.getMsg("of");
      i18n_7 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_7;
    } else {
      i18n_7 = $localize`:kendo.grid.pagerOf|The label before the total pages number in the Grid pager:of`;
    }
    let i18n_8;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_8 = goog.getMsg("items");
      i18n_8 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_8;
    } else {
      i18n_8 = $localize`:kendo.grid.pagerItems|The label after the total pages number in the Grid pager:items`;
    }
    let i18n_9;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_9 = goog.getMsg("Page Number");
      i18n_9 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_9;
    } else {
      i18n_9 = $localize`:kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager:Page Number`;
    }
    let i18n_10;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_10 = goog.getMsg("items per page");
      i18n_10 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_10;
    } else {
      i18n_10 = $localize`:kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager:items per page`;
    }
    let i18n_11;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_11 = goog.getMsg("Filter");
      i18n_11 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_11;
    } else {
      i18n_11 = $localize`:kendo.grid.filter|The label of the filter cell or icon:Filter`;
    }
    let i18n_12;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_12 = goog.getMsg("Is equal to");
      i18n_12 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_12;
    } else {
      i18n_12 = $localize`:kendo.grid.filterEqOperator|The text of the equal filter operator:Is equal to`;
    }
    let i18n_13;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_13 = goog.getMsg("Is not equal to");
      i18n_13 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_13;
    } else {
      i18n_13 = $localize`:kendo.grid.filterNotEqOperator|The text of the not equal filter operator:Is not equal to`;
    }
    let i18n_14;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_14 = goog.getMsg("Is null");
      i18n_14 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_14;
    } else {
      i18n_14 = $localize`:kendo.grid.filterIsNullOperator|The text of the is null filter operator:Is null`;
    }
    let i18n_15;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_15 = goog.getMsg("Is not null");
      i18n_15 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_15;
    } else {
      i18n_15 = $localize`:kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator:Is not null`;
    }
    let i18n_16;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_16 = goog.getMsg("Is empty");
      i18n_16 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_16;
    } else {
      i18n_16 = $localize`:kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator:Is empty`;
    }
    let i18n_17;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_17 = goog.getMsg("Is not empty");
      i18n_17 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_17;
    } else {
      i18n_17 = $localize`:kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator:Is not empty`;
    }
    let i18n_18;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_18 = goog.getMsg("Starts with");
      i18n_18 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_18;
    } else {
      i18n_18 = $localize`:kendo.grid.filterStartsWithOperator|The text of the starts with filter operator:Starts with`;
    }
    let i18n_19;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_19 = goog.getMsg("Contains");
      i18n_19 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_19;
    } else {
      i18n_19 = $localize`:kendo.grid.filterContainsOperator|The text of the contains filter operator:Contains`;
    }
    let i18n_20;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_20 = goog.getMsg("Does not contain");
      i18n_20 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_20;
    } else {
      i18n_20 = $localize`:kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator:Does not contain`;
    }
    let i18n_21;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_21 = goog.getMsg("Ends with");
      i18n_21 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_21;
    } else {
      i18n_21 = $localize`:kendo.grid.filterEndsWithOperator|The text of the ends with filter operator:Ends with`;
    }
    let i18n_22;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_22 = goog.getMsg("Is greater than or equal to");
      i18n_22 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_22;
    } else {
      i18n_22 = $localize`:kendo.grid.filterGteOperator|The text of the greater than or equal filter operator:Is greater than or equal to`;
    }
    let i18n_23;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_23 = goog.getMsg("Is greater than");
      i18n_23 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_23;
    } else {
      i18n_23 = $localize`:kendo.grid.filterGtOperator|The text of the greater than filter operator:Is greater than`;
    }
    let i18n_24;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_24 = goog.getMsg("Is less than or equal to");
      i18n_24 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_24;
    } else {
      i18n_24 = $localize`:kendo.grid.filterLteOperator|The text of the less than or equal filter operator:Is less than or equal to`;
    }
    let i18n_25;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_25 = goog.getMsg("Is less than");
      i18n_25 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_25;
    } else {
      i18n_25 = $localize`:kendo.grid.filterLtOperator|The text of the less than filter operator:Is less than`;
    }
    let i18n_26;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_26 = goog.getMsg("Is True");
      i18n_26 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_26;
    } else {
      i18n_26 = $localize`:kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option:Is True`;
    }
    let i18n_27;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_27 = goog.getMsg("Is False");
      i18n_27 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_27;
    } else {
      i18n_27 = $localize`:kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option:Is False`;
    }
    let i18n_28;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_28 = goog.getMsg("(All)");
      i18n_28 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_28;
    } else {
      i18n_28 = $localize`:kendo.grid.filterBooleanAll|The text of the (All) boolean filter option:(All)`;
    }
    let i18n_29;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_29 = goog.getMsg("Is after or equal to");
      i18n_29 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_29;
    } else {
      i18n_29 = $localize`:kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator:Is after or equal to`;
    }
    let i18n_30;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_30 = goog.getMsg("Is after");
      i18n_30 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_30;
    } else {
      i18n_30 = $localize`:kendo.grid.filterAfterOperator|The text of the after date filter operator:Is after`;
    }
    let i18n_31;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_31 = goog.getMsg("Is before");
      i18n_31 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_31;
    } else {
      i18n_31 = $localize`:kendo.grid.filterBeforeOperator|The text of the before date filter operator:Is before`;
    }
    let i18n_32;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_32 = goog.getMsg("Is before or equal to");
      i18n_32 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_32;
    } else {
      i18n_32 = $localize`:kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator:Is before or equal to`;
    }
    let i18n_33;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_33 = goog.getMsg("Filter");
      i18n_33 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_33;
    } else {
      i18n_33 = $localize`:kendo.grid.filterFilterButton|The text of the filter button:Filter`;
    }
    let i18n_34;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_34 = goog.getMsg("Clear");
      i18n_34 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_34;
    } else {
      i18n_34 = $localize`:kendo.grid.filterClearButton|The text of the clear filter button:Clear`;
    }
    let i18n_35;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_35 = goog.getMsg("And");
      i18n_35 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_35;
    } else {
      i18n_35 = $localize`:kendo.grid.filterAndLogic|The text of the And filter logic:And`;
    }
    let i18n_36;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_36 = goog.getMsg("Or");
      i18n_36 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_36;
    } else {
      i18n_36 = $localize`:kendo.grid.filterOrLogic|The text of the Or filter logic:Or`;
    }
    let i18n_37;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_37 = goog.getMsg("Loading");
      i18n_37 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_37;
    } else {
      i18n_37 = $localize`:kendo.grid.loading|The loading text:Loading`;
    }
    let i18n_38;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_38 = goog.getMsg("Data table");
      i18n_38 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_38;
    } else {
      i18n_38 = $localize`:kendo.grid.gridLabel|The Grid aria-label:Data table`;
    }
    let i18n_39;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_39 = goog.getMsg("Columns");
      i18n_39 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_39;
    } else {
      i18n_39 = $localize`:kendo.grid.columns|The text shown in the column menu for the columns item:Columns`;
    }
    let i18n_40;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_40 = goog.getMsg("Lock");
      i18n_40 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_40;
    } else {
      i18n_40 = $localize`:kendo.grid.lock|The text shown in the column menu for the lock item:Lock`;
    }
    let i18n_41;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_41 = goog.getMsg("Unlock");
      i18n_41 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_41;
    } else {
      i18n_41 = $localize`:kendo.grid.unlock|The text shown in the column menu for the unlock item:Unlock`;
    }
    let i18n_42;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_42 = goog.getMsg("Set Column Position");
      i18n_42 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_42;
    } else {
      i18n_42 = $localize`:kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item:Set Column Position`;
    }
    let i18n_43;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_43 = goog.getMsg("Stick");
      i18n_43 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_43;
    } else {
      i18n_43 = $localize`:kendo.grid.stick|The text shown in the column menu for the stick item:Stick`;
    }
    let i18n_44;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_44 = goog.getMsg("Unstick");
      i18n_44 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_44;
    } else {
      i18n_44 = $localize`:kendo.grid.unstick|The text shown in the column menu for the unstick item:Unstick`;
    }
    let i18n_45;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_45 = goog.getMsg("Sortable");
      i18n_45 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_45;
    } else {
      i18n_45 = $localize`:kendo.grid.sortable|The label of the sort icon:Sortable`;
    }
    let i18n_46;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_46 = goog.getMsg("Sort Ascending");
      i18n_46 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_46;
    } else {
      i18n_46 = $localize`:kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item:Sort Ascending`;
    }
    let i18n_47;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_47 = goog.getMsg("Sort Descending");
      i18n_47 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_47;
    } else {
      i18n_47 = $localize`:kendo.grid.sortDescending|The text shown in the column menu for the sort descending item:Sort Descending`;
    }
    let i18n_48;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_48 = goog.getMsg("Autosize All Columns");
      i18n_48 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_48;
    } else {
      i18n_48 = $localize`:kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item:Autosize All Columns`;
    }
    let i18n_49;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_49 = goog.getMsg("Autosize This Column");
      i18n_49 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_49;
    } else {
      i18n_49 = $localize`:kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item:Autosize This Column`;
    }
    let i18n_50;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_50 = goog.getMsg("Not Sorted");
      i18n_50 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_50;
    } else {
      i18n_50 = $localize`:kendo.grid.sortedDefault|The status announcement when a column is no longer sorted:Not Sorted`;
    }
    let i18n_51;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_51 = goog.getMsg("Sorted Ascending");
      i18n_51 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_51;
    } else {
      i18n_51 = $localize`:kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups:Sorted Ascending`;
    }
    let i18n_52;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_52 = goog.getMsg("Sorted Descending");
      i18n_52 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_52;
    } else {
      i18n_52 = $localize`:kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups:Sorted Descending`;
    }
    let i18n_53;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_53 = goog.getMsg("Apply");
      i18n_53 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_53;
    } else {
      i18n_53 = $localize`:kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button:Apply`;
    }
    let i18n_54;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_54 = goog.getMsg("Reset");
      i18n_54 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_54;
    } else {
      i18n_54 = $localize`:kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button:Reset`;
    }
    let i18n_55;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_55 = goog.getMsg("Expand Details");
      i18n_55 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_55;
    } else {
      i18n_55 = $localize`:kendo.grid.detailExpand|The title of the expand icon of detail rows.:Expand Details`;
    }
    let i18n_56;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_56 = goog.getMsg("Collapse Details");
      i18n_56 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_56;
    } else {
      i18n_56 = $localize`:kendo.grid.detailCollapse|The title of the collapse icon of detail rows.:Collapse Details`;
    }
    let i18n_57;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_57 = goog.getMsg("TODAY");
      i18n_57 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_57;
    } else {
      i18n_57 = $localize`:kendo.grid.filterDateToday|The text of the Today button of the Date filter.:TODAY`;
    }
    let i18n_58;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_58 = goog.getMsg("Toggle Calendar");
      i18n_58 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_58;
    } else {
      i18n_58 = $localize`:kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter.:Toggle Calendar`;
    }
    let i18n_59;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_59 = goog.getMsg("Decrement");
      i18n_59 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_59;
    } else {
      i18n_59 = $localize`:kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter.:Decrement`;
    }
    let i18n_60;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_60 = goog.getMsg("Increment");
      i18n_60 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_60;
    } else {
      i18n_60 = $localize`:kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter.:Increment`;
    }
    let i18n_61;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_61 = goog.getMsg("Select Row");
      i18n_61 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_61;
    } else {
      i18n_61 = $localize`:kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes.:Select Row`;
    }
    let i18n_62;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_62 = goog.getMsg("Select All Rows");
      i18n_62 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_62;
    } else {
      i18n_62 = $localize`:kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox.:Select All Rows`;
    }
    let i18n_63;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_63 = goog.getMsg("Collapse Group");
      i18n_63 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_63;
    } else {
      i18n_63 = $localize`:kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows.:Collapse Group`;
    }
    let i18n_64;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_64 = goog.getMsg("Expand Group");
      i18n_64 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_64;
    } else {
      i18n_64 = $localize`:kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows.:Expand Group`;
    }
    let i18n_65;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_65 = goog.getMsg("Select page");
      i18n_65 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_65;
    } else {
      i18n_65 = $localize`:kendo.grid.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager:Select page`;
    }
    let i18n_66;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_66 = goog.getMsg("Top toolbar");
      i18n_66 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_66;
    } else {
      i18n_66 = $localize`:kendo.grid.topToolbarLabel|The label for the Grid top toolbar:Top toolbar`;
    }
    let i18n_67;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_67 = goog.getMsg("Bottom toolbar");
      i18n_67 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_67;
    } else {
      i18n_67 = $localize`:kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar:Bottom toolbar`;
    }
    let i18n_68;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_68 = goog.getMsg("Group panel");
      i18n_68 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_68;
    } else {
      i18n_68 = $localize`:kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar:Group panel`;
    }
    let i18n_69;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_69 = goog.getMsg("Drag row");
      i18n_69 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_69;
    } else {
      i18n_69 = $localize`:kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle:Drag row`;
    }
    let i18n_70;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_70 = goog.getMsg("Filter");
      i18n_70 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_70;
    } else {
      i18n_70 = $localize`:kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab:Filter`;
    }
    let i18n_71;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_71 = goog.getMsg("General");
      i18n_71 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_71;
    } else {
      i18n_71 = $localize`:kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab:General`;
    }
    let i18n_72;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_72 = goog.getMsg("Columns");
      i18n_72 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_72;
    } else {
      i18n_72 = $localize`:kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab:Columns`;
    }
    let i18n_73;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_73 = goog.getMsg("Move as previous");
      i18n_73 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_73;
    } else {
      i18n_73 = $localize`:kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item:Move as previous`;
    }
    let i18n_74;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_74 = goog.getMsg("Move as next");
      i18n_74 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_74;
    } else {
      i18n_74 = $localize`:kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item:Move as next`;
    }
    let i18n_75;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_75 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ 'Page navigation, page {currentPage} of {totalPages}' }}"
        }
      });
      i18n_75 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_75;
    } else {
      i18n_75 = $localize`:kendo.grid.pagerLabel|The label for the Grid pager:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_76;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_76 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ '{columnName} Filter' }}"
        }
      });
      i18n_76 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_76;
    } else {
      i18n_76 = $localize`:kendo.grid.filterInputLabel|The label of the filter row and menu inputs:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_77;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_77 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ '{columnName} Filter Menu' }}"
        }
      });
      i18n_77 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_77;
    } else {
      i18n_77 = $localize`:kendo.grid.filterMenuTitle|The title of the filter menu icon:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_78;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_78 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ '{columnName} Filter Operators' }}"
        }
      });
      i18n_78 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_78;
    } else {
      i18n_78 = $localize`:kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_79;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_79 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ 'Filter cell operators for {columnName}' }}"
        }
      });
      i18n_79 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_79;
    } else {
      i18n_79 = $localize`:kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_80;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_80 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ 'Boolean filter cell for {columnName}' }}"
        }
      });
      i18n_80 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_80;
    } else {
      i18n_80 = $localize`:kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_81;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_81 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ '{columnName} Filter Logic' }}"
        }
      });
      i18n_81 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_81;
    } else {
      i18n_81 = $localize`:kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown:${"�0�"}:INTERPOLATION:`;
    }
    let i18n_82;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_82 = goog.getMsg("{$interpolation}", {
        "interpolation": "�0�"
      }, {
        original_code: {
          "interpolation": "{{ '{columnName} Column Menu' }}"
        }
      });
      i18n_82 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_GRID_FESM2020_PROGRESS_KENDO_ANGULAR_GRID_MJS_82;
    } else {
      i18n_82 = $localize`:kendo.grid.columnMenu|The title of the column menu icon:${"�0�"}:INTERPOLATION:`;
    }
    return [["ariaRoot", ""], ["defaultHint", ""], ["header", ""], ["lockedHeader", ""], ["footer", ""], ["pagerLabel", i18n_75, "filterInputLabel", i18n_76, "filterMenuTitle", i18n_77, "filterMenuOperatorsDropDownLabel", i18n_78, "filterCellOperatorLabel", i18n_79, "booleanFilterCellLabel", i18n_80, "filterMenuLogicDropDownLabel", i18n_81, "columnMenu", i18n_82], ["kendoGridLocalizedMessages", "", "groupPanelEmpty", i18n_0, "noRecords", i18n_1, "pagerFirstPage", i18n_2, "pagerPreviousPage", i18n_3, "pagerNextPage", i18n_4, "pagerLastPage", i18n_5, "pagerPage", i18n_6, "pagerOf", i18n_7, "pagerItems", i18n_8, "pagerPageNumberInputTitle", i18n_9, "pagerItemsPerPage", i18n_10, "filter", i18n_11, "filterEqOperator", i18n_12, "filterNotEqOperator", i18n_13, "filterIsNullOperator", i18n_14, "filterIsNotNullOperator", i18n_15, "filterIsEmptyOperator", i18n_16, "filterIsNotEmptyOperator", i18n_17, "filterStartsWithOperator", i18n_18, "filterContainsOperator", i18n_19, "filterNotContainsOperator", i18n_20, "filterEndsWithOperator", i18n_21, "filterGteOperator", i18n_22, "filterGtOperator", i18n_23, "filterLteOperator", i18n_24, "filterLtOperator", i18n_25, "filterIsTrue", i18n_26, "filterIsFalse", i18n_27, "filterBooleanAll", i18n_28, "filterAfterOrEqualOperator", i18n_29, "filterAfterOperator", i18n_30, "filterBeforeOperator", i18n_31, "filterBeforeOrEqualOperator", i18n_32, "filterFilterButton", i18n_33, "filterClearButton", i18n_34, "filterAndLogic", i18n_35, "filterOrLogic", i18n_36, "loading", i18n_37, "gridLabel", i18n_38, "columns", i18n_39, "lock", i18n_40, "unlock", i18n_41, "setColumnPosition", i18n_42, "stick", i18n_43, "unstick", i18n_44, "sortable", i18n_45, "sortAscending", i18n_46, "sortDescending", i18n_47, "autosizeAllColumns", i18n_48, "autosizeThisColumn", i18n_49, "sortedDefault", i18n_50, "sortedAscending", i18n_51, "sortedDescending", i18n_52, "columnsApply", i18n_53, "columnsReset", i18n_54, "detailExpand", i18n_55, "detailCollapse", i18n_56, "filterDateToday", i18n_57, "filterDateToggle", i18n_58, "filterNumericDecrement", i18n_59, "filterNumericIncrement", i18n_60, "selectionCheckboxLabel", i18n_61, "selectAllCheckboxLabel", i18n_62, "groupCollapse", i18n_63, "groupExpand", i18n_64, "selectPage", i18n_65, "topToolbarLabel", i18n_66, "bottomToolbarLabel", i18n_67, "groupPanelLabel", i18n_68, "dragRowHandleLabel", i18n_69, "columnMenuFilterTabTitle", i18n_70, "columnMenuGeneralTabTitle", i18n_71, "columnMenuColumnsTabTitle", i18n_72, "groupChipMenuPrevious", i18n_73, "groupChipMenuNext", i18n_74, 6, "pagerLabel", "filterInputLabel", "filterMenuTitle", "filterMenuOperatorsDropDownLabel", "filterCellOperatorLabel", "booleanFilterCellLabel", "filterMenuLogicDropDownLabel", "columnMenu"], ["class", "k-toolbar k-grid-toolbar", "position", "top", 3, "size", "navigable", 4, "ngIf"], ["class", "k-grid-pager-top k-pager", 3, "tabindex", "template", "pageSize", "total", "skip", "size", "options", "pageChange", 4, "ngIf"], ["role", "toolbar", 3, "navigable", "text", "groups", "change", 4, "ngIf"], ["role", "grid", 1, "k-grid-aria-root", 3, "id"], [4, "ngIf"], ["kendoGridLoading", "", 3, "loadingTemplate", 4, "ngIf"], [3, "statusBarTemplate", 4, "ngIf"], ["class", "k-pager", 3, "tabindex", "template", "pageSize", "total", "skip", "size", "options", "pageChange", 4, "ngIf"], ["class", "k-toolbar k-grid-toolbar k-grid-toolbar-bottom", "position", "bottom", 3, "size", "navigable", 4, "ngIf"], ["kendoWatermarkOverlay", "", 4, "ngIf"], ["position", "top", 1, "k-toolbar", "k-grid-toolbar", 3, "size", "navigable"], [1, "k-grid-pager-top", "k-pager", 3, "pageChange", "tabindex", "template", "pageSize", "total", "skip", "size", "options"], ["role", "toolbar", 3, "change", "navigable", "text", "groups"], ["class", "k-grid-header", "role", "presentation", 3, "padding", 4, "ngIf"], ["kendoDragTargetContainer", "", "kendoDropTargetContainer", "", "mode", "manual", "kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "onPress", "onDragStart", "onDrag", "onDragEnter", "onDragLeave", "onDragEnd", "onDrop", "pageChange", "scrollBottom", "contentScroll", "dragDisabled", "dropDisabled", "dragTargetFilter", "dropTargetFilter", "dragHandle", "hint", "dragData", "data", "rowHeight", "detailRowHeight", "total", "take", "groups", "groupable", "skip", "trackBy", "columns", "selectable", "filterable", "detailTemplate", "noRecordsTemplate", "size", "rowClass", "rowSticky", "loading", "isVirtual", "cellLoadingTemplate", "loadingTemplate", "virtualColumns", "enableDrag", "sort"], ["class", "k-grid-footer", 3, "padding", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header"], ["role", "presentation", "class", "k-grid-header-locked", 3, "width", 4, "ngIf"], ["role", "presentation", "data-scrollable", "", 1, "k-grid-header-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridTable", "", 1, "k-grid-header-table", 3, "virtualColumns", "size"], ["kendoGridColGroup", "", 3, "columns", "groups", "detailTemplate"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "filter", "filterable", "groupable", "reorderable", "groups", "sortable", "columnMenu", "columnMenuTemplate", "lockedColumnsCount", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], ["class", "k-width-container", "role", "presentation", 4, "ngIf"], ["role", "presentation", 1, "k-grid-header-locked"], ["role", "presentation", "kendoGridTable", "", 1, "k-grid-header-table", 3, "locked", "size"], ["kendoGridHeader", "", "role", "rowgroup", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "sort", "groups", "filter", "filterable", "groupable", "reorderable", "sortable", "columnMenu", "columnMenuTemplate", "totalColumnsCount", "totalColumns", "detailTemplate", "tabIndex"], ["role", "presentation", 1, "k-width-container"], [1, "k-grid-footer"], ["class", "k-grid-footer-locked", 3, "width", 4, "ngIf"], ["data-scrollable", "", 1, "k-grid-footer-wrap", 3, "kendoGridResizableContainer", "lockedWidth"], ["role", "presentation", "kendoGridTable", "", 1, "k-grid-footer-table", 3, "size"], ["kendoGridFooter", "", 3, "logicalRowIndex", "scrollable", "groups", "columns", "lockedColumnsCount", "detailTemplate", "totalColumns"], [1, "k-grid-footer-locked"], ["role", "presentation", "kendoGridTable", "", 1, "k-grid-footer-table", 3, "locked", "size"], ["kendoGridFooter", "", 3, "scrollable", "groups", "columns", "detailTemplate", "logicalRowIndex", "totalColumns"], ["kendoGridTable", "", "role", "presentation", 3, "size"], ["kendoGridHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex", 4, "ngIf"], ["kendoGridTableBody", "", "kendoDraggable", "", "kendoGridSelectionMarquee", "", 3, "isLoading", "groups", "data", "skip", "columns", "selectable", "filterable", "noRecordsTemplate", "detailTemplate", "showGroupFooters", "trackBy", "rowClass", "enableDrag"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", "totalColumns", 4, "ngIf"], ["kendoGridHeader", "", 3, "resizable", "scrollable", "columns", "totalColumnLevels", "totalColumns", "groups", "groupable", "reorderable", "sort", "sortable", "filter", "filterable", "columnMenu", "columnMenuTemplate", "detailTemplate", "tabIndex"], ["kendoGridFooter", "", 3, "scrollable", "logicalRowIndex", "groups", "columns", "detailTemplate", "totalColumns"], ["kendoGridLoading", "", 3, "loadingTemplate"], [3, "statusBarTemplate"], [1, "k-pager", 3, "pageChange", "tabindex", "template", "pageSize", "total", "skip", "size", "options"], ["position", "bottom", 1, "k-toolbar", "k-grid-toolbar", "k-grid-toolbar-bottom", 3, "size", "navigable"], ["innerCssClass", "k-drag-status", 3, "name", "svgIcon"], ["kendoWatermarkOverlay", ""]];
  },
  template: function GridComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 6);
      ɵɵi18nAttributes(1, 5);
      ɵɵelementContainerEnd();
      ɵɵtemplate(2, GridComponent_kendo_grid_toolbar_2_Template, 1, 4, "kendo-grid-toolbar", 7)(3, GridComponent_kendo_pager_3_Template, 1, 8, "kendo-pager", 8)(4, GridComponent_kendo_grid_group_panel_4_Template, 1, 5, "kendo-grid-group-panel", 9);
      ɵɵelementStart(5, "div", 10, 0);
      ɵɵtemplate(7, GridComponent_ng_container_7_Template, 4, 35, "ng-container", 11)(8, GridComponent_ng_container_8_Template, 6, 21, "ng-container", 11)(9, GridComponent_div_9_Template, 1, 1, "div", 12);
      ɵɵelementEnd();
      ɵɵtemplate(10, GridComponent_kendo_grid_status_bar_10_Template, 1, 1, "kendo-grid-status-bar", 13)(11, GridComponent_kendo_pager_11_Template, 1, 8, "kendo-pager", 14)(12, GridComponent_kendo_grid_toolbar_12_Template, 1, 4, "kendo-grid-toolbar", 15)(13, GridComponent_ng_template_13_Template, 2, 3, "ng-template", null, 1, ɵɵtemplateRefExtractor)(15, GridComponent_div_15_Template, 1, 0, "div", 16);
    }
    if (rf & 2) {
      ɵɵi18nExp("Page navigation, page {currentPage} of {totalPages}")("{columnName} Filter")("{columnName} Filter Menu")("{columnName} Filter Operators")("Filter cell operators for {columnName}")("Boolean filter cell for {columnName}")("{columnName} Filter Logic")("{columnName} Column Menu");
      ɵɵi18nApply(1);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showTopToolbar);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showTopPager);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showGroupPanel);
      ɵɵadvance();
      ɵɵproperty("id", ctx.ariaRootId);
      ɵɵattribute("aria-label", ctx.ariaLabel)("aria-rowcount", ctx.ariaRowCount)("aria-colcount", ctx.ariaColCount);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isScrollable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isScrollable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showStatusBar);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showBottomPager);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showBottomToolbar);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showLicenseWatermark);
    }
  },
  dependencies: [NgIf, GroupPanelComponent, ColGroupComponent, ResizableContainerDirective, TableDirective, LoadingComponent, GridTableDirective, DraggableDirective, IconWrapperComponent, TableBodyComponent, HeaderComponent, FooterComponent, PagerComponent, DragTargetContainerDirective, DropTargetContainerDirective, WatermarkOverlayComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, GridMarqueeDirective, StatusBarComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridComponent, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "kendoGrid",
      providers: [BrowserSupportService, LocalizationService, ColumnInfoService, SelectionService, CellSelectionService, DetailsService, GroupsService, GroupInfoService, ChangeNotificationService, EditService, PDFService, SuspendService, {
        provide: CELL_CONTEXT,
        useValue: EMPTY_CELL_CONTEXT
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.grid"
      }, FilterService, ResponsiveService, PagerContextService, ExcelService, ScrollSyncService, ResizeService, LocalDataChangesService, DomEventsService, ColumnResizingService, SinglePopupService, DragAndDropService, DragHintService, DropCueService, ColumnReorderService, NavigationService, FocusRoot, IdService, CellSelectionAggregateService, ScrollRequestService, SortService, ContextService, SizingOptionsService, RowReorderService, ClipboardService],
      selector: "kendo-grid",
      template: `
        <ng-container kendoGridLocalizedMessages
            i18n-groupPanelEmpty="kendo.grid.groupPanelEmpty|The label visible in the Grid group panel when it is empty"
            groupPanelEmpty="Drag a column header and drop it here to group by that column"

            i18n-noRecords="kendo.grid.noRecords|The label visible in the Grid when there are no records"
            noRecords="No records available."

            i18n-pagerLabel="kendo.grid.pagerLabel|The label for the Grid pager"
            pagerLabel="{{ 'Page navigation, page {currentPage} of {totalPages}' }}"

            i18n-pagerFirstPage="kendo.grid.pagerFirstPage|The label for the first page button in Grid pager"
            pagerFirstPage="Go to the first page"

            i18n-pagerPreviousPage="kendo.grid.pagerPreviousPage|The label for the previous page button in Grid pager"
            pagerPreviousPage="Go to the previous page"

            i18n-pagerNextPage="kendo.grid.pagerNextPage|The label for the next page button in Grid pager"
            pagerNextPage="Go to the next page"

            i18n-pagerLastPage="kendo.grid.pagerLastPage|The label for the last page button in Grid pager"
            pagerLastPage="Go to the last page"

            i18n-pagerPage="kendo.grid.pagerPage|The label before the current page number in the Grid pager"
            pagerPage="Page"

            i18n-pagerOf="kendo.grid.pagerOf|The label before the total pages number in the Grid pager"
            pagerOf="of"

            i18n-pagerItems="kendo.grid.pagerItems|The label after the total pages number in the Grid pager"
            pagerItems="items"

            i18n-pagerPageNumberInputTitle="kendo.grid.pagerPageNumberInputTitle|The label for the pager input in the Grid pager"
            pagerPageNumberInputTitle="Page Number"

            i18n-pagerItemsPerPage="kendo.grid.pagerItemsPerPage|The label for the page size chooser in the Grid pager"
            pagerItemsPerPage="items per page"

            i18n-filter="kendo.grid.filter|The label of the filter cell or icon"
            filter="Filter"

            i18n-filterInputLabel="kendo.grid.filterInputLabel|The label of the filter row and menu inputs"
            filterInputLabel="{{ '{columnName} Filter' }}"

            i18n-filterMenuTitle="kendo.grid.filterMenuTitle|The title of the filter menu icon"
            filterMenuTitle="{{ '{columnName} Filter Menu' }}"

            i18n-filterMenuOperatorsDropDownLabel="kendo.grid.filterMenuOperatorsDropDownLabel|The label of the filter menu operators dropdown"
            filterMenuOperatorsDropDownLabel="{{ '{columnName} Filter Operators' }}"
            
            i18n-filterCellOperatorLabel="kendo.grid.filterCellOperatorLabel|The label of the filter cell operators dropdown"
            filterCellOperatorLabel="{{ 'Filter cell operators for {columnName}' }}"

            i18n-booleanFilterCellLabel="kendo.grid.booleanFilterCellLabel|The label of the boolean filter cell dropdown"
            booleanFilterCellLabel="{{ 'Boolean filter cell for {columnName}' }}"

            i18n-filterMenuLogicDropDownLabel="kendo.grid.filterMenuLogicDropDownLabel|The label of the filter menu logic dropdown"
            filterMenuLogicDropDownLabel="{{ '{columnName} Filter Logic' }}"

            i18n-filterEqOperator="kendo.grid.filterEqOperator|The text of the equal filter operator"
            filterEqOperator="Is equal to"

            i18n-filterNotEqOperator="kendo.grid.filterNotEqOperator|The text of the not equal filter operator"
            filterNotEqOperator="Is not equal to"

            i18n-filterIsNullOperator="kendo.grid.filterIsNullOperator|The text of the is null filter operator"
            filterIsNullOperator="Is null"

            i18n-filterIsNotNullOperator="kendo.grid.filterIsNotNullOperator|The text of the is not null filter operator"
            filterIsNotNullOperator="Is not null"

            i18n-filterIsEmptyOperator="kendo.grid.filterIsEmptyOperator|The text of the is empty filter operator"
            filterIsEmptyOperator="Is empty"

            i18n-filterIsNotEmptyOperator="kendo.grid.filterIsNotEmptyOperator|The text of the is not empty filter operator"
            filterIsNotEmptyOperator="Is not empty"

            i18n-filterStartsWithOperator="kendo.grid.filterStartsWithOperator|The text of the starts with filter operator"
            filterStartsWithOperator="Starts with"

            i18n-filterContainsOperator="kendo.grid.filterContainsOperator|The text of the contains filter operator"
            filterContainsOperator="Contains"

            i18n-filterNotContainsOperator="kendo.grid.filterNotContainsOperator|The text of the does not contain filter operator"
            filterNotContainsOperator="Does not contain"

            i18n-filterEndsWithOperator="kendo.grid.filterEndsWithOperator|The text of the ends with filter operator"
            filterEndsWithOperator="Ends with"

            i18n-filterGteOperator="kendo.grid.filterGteOperator|The text of the greater than or equal filter operator"
            filterGteOperator="Is greater than or equal to"

            i18n-filterGtOperator="kendo.grid.filterGtOperator|The text of the greater than filter operator"
            filterGtOperator="Is greater than"

            i18n-filterLteOperator="kendo.grid.filterLteOperator|The text of the less than or equal filter operator"
            filterLteOperator="Is less than or equal to"

            i18n-filterLtOperator="kendo.grid.filterLtOperator|The text of the less than filter operator"
            filterLtOperator="Is less than"

            i18n-filterIsTrue="kendo.grid.filterIsTrue|The text of the IsTrue boolean filter option"
            filterIsTrue="Is True"

            i18n-filterIsFalse="kendo.grid.filterIsFalse|The text of the IsFalse boolean filter option"
            filterIsFalse="Is False"

            i18n-filterBooleanAll="kendo.grid.filterBooleanAll|The text of the (All) boolean filter option"
            filterBooleanAll="(All)"

            i18n-filterAfterOrEqualOperator="kendo.grid.filterAfterOrEqualOperator|The text of the after or equal date filter operator"
            filterAfterOrEqualOperator="Is after or equal to"

            i18n-filterAfterOperator="kendo.grid.filterAfterOperator|The text of the after date filter operator"
            filterAfterOperator="Is after"

            i18n-filterBeforeOperator="kendo.grid.filterBeforeOperator|The text of the before date filter operator"
            filterBeforeOperator="Is before"

            i18n-filterBeforeOrEqualOperator="kendo.grid.filterBeforeOrEqualOperator|The text of the before or equal date filter operator"
            filterBeforeOrEqualOperator="Is before or equal to"

            i18n-filterFilterButton="kendo.grid.filterFilterButton|The text of the filter button"
            filterFilterButton="Filter"

            i18n-filterClearButton="kendo.grid.filterClearButton|The text of the clear filter button"
            filterClearButton="Clear"

            i18n-filterAndLogic="kendo.grid.filterAndLogic|The text of the And filter logic"
            filterAndLogic="And"

            i18n-filterOrLogic="kendo.grid.filterOrLogic|The text of the Or filter logic"
            filterOrLogic="Or"

            i18n-loading="kendo.grid.loading|The loading text"
            loading="Loading"

            i18n-gridLabel="kendo.grid.gridLabel|The Grid aria-label"
            gridLabel="Data table"

            i18n-columnMenu="kendo.grid.columnMenu|The title of the column menu icon"
            columnMenu="{{ '{columnName} Column Menu' }}"

            i18n-columns="kendo.grid.columns|The text shown in the column menu for the columns item"
            columns="Columns"

            i18n-lock="kendo.grid.lock|The text shown in the column menu for the lock item"
            lock="Lock"

            i18n-unlock="kendo.grid.unlock|The text shown in the column menu for the unlock item"
            unlock="Unlock"

            i18n-setColumnPosition="kendo.grid.setColumnPosition|The text shown in the column menu for the set column position item"
            setColumnPosition="Set Column Position"

            i18n-stick="kendo.grid.stick|The text shown in the column menu for the stick item"
            stick="Stick"

            i18n-unstick="kendo.grid.unstick|The text shown in the column menu for the unstick item"
            unstick="Unstick"

            i18n-sortable="kendo.grid.sortable|The label of the sort icon"
            sortable="Sortable"

            i18n-sortAscending="kendo.grid.sortAscending|The text shown in the column menu for the sort ascending item"
            sortAscending="Sort Ascending"

            i18n-sortDescending="kendo.grid.sortDescending|The text shown in the column menu for the sort descending item"
            sortDescending="Sort Descending"

            i18n-autosizeAllColumns="kendo.grid.autosizeAllColumns|The text shown in the column menu for the autosize all columns item"
            autosizeAllColumns="Autosize All Columns"

            i18n-autosizeThisColumn="kendo.grid.autosizeThisColumn|The text shown in the column menu for the autosize this column item"
            autosizeThisColumn="Autosize This Column"

            i18n-sortedDefault="kendo.grid.sortedDefault|The status announcement when a column is no longer sorted"
            sortedDefault="Not Sorted"

            i18n-sortedAscending="kendo.grid.sortedAscending|The title of the Group Chip indicating the ascending sorting order of the groups"
            sortedAscending="Sorted Ascending"
            
            i18n-sortedDescending="kendo.grid.sortedDescending|The title of the Group Chip indicating the descending sorting order of the groups"
            sortedDescending="Sorted Descending"

            i18n-columnsApply="kendo.grid.columnsApply|The text shown in the column menu or column chooser for the columns apply button"
            columnsApply="Apply"

            i18n-columnsReset="kendo.grid.columnsReset|The text shown in the column menu or column chooser for the columns reset button"
            columnsReset="Reset"

            i18n-detailExpand="kendo.grid.detailExpand|The title of the expand icon of detail rows."
            detailExpand="Expand Details"

            i18n-detailCollapse="kendo.grid.detailCollapse|The title of the collapse icon of detail rows."
            detailCollapse="Collapse Details"

            i18n-filterDateToday="kendo.grid.filterDateToday|The text of the Today button of the Date filter."
            filterDateToday="TODAY"

            i18n-filterDateToggle="kendo.grid.filterDateToggle|The title of the Toggle button of the Date filter."
            filterDateToggle="Toggle Calendar"

            i18n-filterNumericDecrement="kendo.grid.filterNumericDecrement|The title of the Decrement button of the Numeric filter."
            filterNumericDecrement="Decrement"

            i18n-filterNumericIncrement="kendo.grid.filterNumericIncrement|The title of the Increment button of the Numeric filter."
            filterNumericIncrement="Increment"

            i18n-selectionCheckboxLabel="kendo.grid.selectionCheckboxLabel|The labels of the checkbox column checkboxes."
            selectionCheckboxLabel="Select Row"

            i18n-selectAllCheckboxLabel="kendo.grid.selectAllCheckboxLabel|The label of the checkbox column select all checkbox."
            selectAllCheckboxLabel="Select All Rows"

            i18n-groupCollapse="kendo.grid.groupCollapse|The text of the title and aria-label attributes applied to the collapse icon of group rows."
            groupCollapse="Collapse Group"

            i18n-groupExpand="kendo.grid.groupExpand|The text of the title and aria-label attributes applied to the expand icon of group rows."
            groupExpand="Expand Group"

            i18n-selectPage="kendo.grid.selectPage|The text of the title and aria-label attributes applied to the page chooser in the Grid Pager"
            selectPage="Select page"

            i18n-topToolbarLabel="kendo.grid.topToolbarLabel|The label for the Grid top toolbar"
            topToolbarLabel="Top toolbar"

            i18n-bottomToolbarLabel="kendo.grid.bottomToolbarLabel|The label for the Grid bottom toolbar"
            bottomToolbarLabel="Bottom toolbar"

            i18n-groupPanelLabel="kendo.grid.groupPanelLabel|The label for the Grid group panel toolbar"
            groupPanelLabel="Group panel"

            i18n-dragRowHandleLabel="kendo.grid.dragRowHandleLabel|The label for the Grid drag row handle"
            dragRowHandleLabel="Drag row"

            i18n-columnMenuFilterTabTitle="kendo.grid.columnMenuFilterTabTitle|The title for the column menu Filter tab"
            columnMenuFilterTabTitle="Filter"

            i18n-columnMenuGeneralTabTitle="kendo.grid.columnMenuGeneralTabTitle|The title for the column menu General tab"
            columnMenuGeneralTabTitle="General"

            i18n-columnMenuColumnsTabTitle="kendo.grid.columnMenuColumnsTabTitle|The title for the column menu Columns tab"
            columnMenuColumnsTabTitle="Columns"

            i18n-groupChipMenuPrevious="kendo.grid.groupChipMenuPrevious|The text for the Group pane Chip Menu Move as previous item"
            groupChipMenuPrevious="Move as previous"

            i18n-groupChipMenuNext="kendo.grid.groupChipMenuNext|The text for the Group pane Chip Menu Move as next item"
            groupChipMenuNext="Move as next"
        >
        </ng-container>
        <kendo-grid-toolbar
            class="k-toolbar k-grid-toolbar"
            *ngIf="showTopToolbar"
            [size]="size"
            [attr.aria-label]="messageFor('topToolbarLabel')"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-controls]="ariaRootId"
            position="top"></kendo-grid-toolbar>
            <kendo-pager
                *ngIf="showTopPager"
                [tabindex]="navigation.pagerEnabled ? '0' : '-1'"
                [attr.role]="navigation.pagerEnabled ? 'application' : undefined"
                class="k-grid-pager-top k-pager"
                [template]="pagerTemplate"
                [pageSize]="pageSize"
                [total]="view.total"
                [skip]="skip"
                [size]="size"
                [options]="pageable"
                (pageChange)="notifyPageChange('pager', $event)">
            </kendo-pager>
            <kendo-grid-group-panel
                *ngIf="showGroupPanel"
                [navigable]="navigation.toolbarEnabled"
                [text]="groupableEmptyText"
                [groups]="group"
                role="toolbar"
                [attr.aria-label]="messageFor('groupPanelLabel')"
                [attr.aria-controls]="ariaRootId"
                (change)="groupChange.emit($event)">
            </kendo-grid-group-panel>
            <div #ariaRoot
                class="k-grid-aria-root"
                role="grid"
                [id]="ariaRootId"
                [attr.aria-label]="ariaLabel"
                [attr.aria-rowcount]="ariaRowCount"
                [attr.aria-colcount]="ariaColCount">
            <ng-container *ngIf="isScrollable">
                <div *ngIf="!hideHeader"
                    class="k-grid-header"
                    role="presentation"
                    [style.padding]="headerPadding">
                    <div *ngIf="isLocked"
                        #lockedHeader
                        role="presentation"
                        class="k-grid-header-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            [locked]="true"
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                role="rowgroup"
                                [resizable]="resizable"
                                [scrollable]="true"
                                [columns]="$any(lockedColumns)"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [groups]="group"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                    </div>
                    <div #header class="k-grid-header-wrap" role="presentation" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 2">
                        <table
                            role="presentation"
                            class="k-grid-header-table"
                            [style.width.px]="nonLockedWidth"
                            [virtualColumns]="virtualColumns"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="headerLeafColumns"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <thead kendoGridHeader
                                [resizable]="resizable"
                                role="rowgroup"
                                [scrollable]="true"
                                [columns]="headerColumns"
                                [totalColumnLevels]="totalColumnLevels"
                                [sort]="sort"
                                [filter]="filter"
                                [filterable]="filterable"
                                [groupable]="showGroupPanel"
                                [reorderable]="reorderable"
                                [groups]="isLocked ? [] : group"
                                [sortable]="sortable"
                                [columnMenu]="columnMenuOptions"
                                [columnMenuTemplate]="columnMenuTemplate"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [totalColumnsCount]="leafColumns.length"
                                [totalColumns]="columnsContainer"
                                [detailTemplate]="detailTemplate"
                                [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                            </thead>
                        </table>
                        <div *ngIf="virtualColumns" class="k-width-container" role="presentation">
                            <div [style.width.px]="columnsContainer.unlockedWidth"></div>
                        </div>
                    </div>
                </div>
                <kendo-grid-list
                    kendoDragTargetContainer
                    kendoDropTargetContainer
                    mode="manual"
                    [dragDisabled]="!rowReorderable"
                    [dropDisabled]="!rowReorderable"
                    [dragTargetFilter]="getDefaultSelectors('dragTarget')"
                    [dropTargetFilter]="getDefaultSelectors('dropTarget')"
                    [dragHandle]="getDefaultSelectors('handle')"
                    [hint]="{hintTemplate: defaultHint}"
                    (onPress)="handleReorderEvents($event, 'press')"
                    (onDragStart)="handleReorderEvents($event, 'dragStart')"
                    (onDrag)="handleReorderEvents($event, 'drag')"
                    (onDragEnter)="handleReorderEvents($event, 'dragEnter')"
                    (onDragLeave)="handleReorderEvents($event, 'dragLeave')"
                    (onDragEnd)="handleReorderEvents($event, 'dragEnd')"
                    (onDrop)="handleReorderEvents($event, 'drop')"
                    [dragData]="gridData"
                    [data]="$any(view)"
                    [rowHeight]="rowHeight"
                    [detailRowHeight]="detailRowHeight"
                    [total]="totalCount"
                    [take]="pageSize"
                    [groups]="group"
                    [groupable]="groupable"
                    [skip]="skip"
                    [trackBy]="trackBy"
                    [columns]="columnsContainer"
                    [selectable]="selectable"
                    [filterable]="filterable"
                    [detailTemplate]="detailTemplate"
                    [noRecordsTemplate]="noRecordsTemplate"
                    [size]="size"
                    (pageChange)="notifyPageChange('list', $event)"
                    [rowClass]="rowClass"
                    [rowSticky]="rowSticky"
                    [loading]="loading"
                    [isVirtual]="isVirtual"
                    [cellLoadingTemplate]="cellLoadingTemplate?.templateRef"
                    [loadingTemplate]="loadingTemplate?.templateRef"
                    [virtualColumns]="virtualColumns"
                    (scrollBottom)="notifyScrollBottom()"
                    (contentScroll)="contentScroll.emit($event)"
                    kendoDraggable
                    kendoGridSelectionMarquee
                    [enableDrag]="marqueeSelection"
                    [sort]="sort">
                </kendo-grid-list>
                <div
                    *ngIf="showFooter"
                    class="k-grid-footer"
                    [style.padding]="headerPadding">
                    <div
                        *ngIf="lockedLeafColumns.length"
                        class="k-grid-footer-locked"
                        [style.width.px]="lockedWidth">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            [locked]="true"
                            [style.width.px]="lockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(lockedLeafColumns)"
                                [groups]="group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [scrollable]="true"
                                [groups]="group"
                                [columns]="$any(lockedLeafColumns)"
                                [detailTemplate]="detailTemplate"
                                [logicalRowIndex]="ariaRowCount"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                    <div #footer
                        class="k-grid-footer-wrap" data-scrollable
                        [kendoGridResizableContainer]="lockedLeafColumns.length > 0"
                        [lockedWidth]="lockedWidth + scrollbarWidth + 3">
                        <table
                            role="presentation"
                            class="k-grid-footer-table"
                            [style.width.px]="nonLockedWidth"
                            kendoGridTable
                            [size]="size">
                            <colgroup kendoGridColGroup
                                [columns]="$any(headerLeafColumns)"
                                [groups]="isLocked ? [] : group"
                                [detailTemplate]="detailTemplate">
                            </colgroup>
                            <tfoot kendoGridFooter
                                [logicalRowIndex]="ariaRowCount"
                                [scrollable]="true"
                                [groups]="isLocked ? [] : group"
                                [columns]="$any(headerColumns)"
                                [lockedColumnsCount]="lockedLeafColumns.length"
                                [detailTemplate]="detailTemplate"
                                [totalColumns]="columnsContainer">
                            </tfoot>
                        </table>
                    </div>
                </div>
            </ng-container>
            <ng-container *ngIf="!isScrollable">
                <table
                    [style.table-layout]="resizable ? 'fixed' : null"
                    kendoGridTable
                    role="presentation"
                    [size]="size">
                    <colgroup kendoGridColGroup
                        [columns]="$any(leafColumns)"
                        [groups]="group"
                        [detailTemplate]="detailTemplate">
                    </colgroup>
                    <thead kendoGridHeader
                        *ngIf="!hideHeader"
                        [resizable]="resizable"
                        [scrollable]="false"
                        [columns]="$any(visibleColumns)"
                        [totalColumnLevels]="totalColumnLevels"
                        [totalColumns]="columnsContainer"
                        [groups]="group"
                        [groupable]="showGroupPanel"
                        [reorderable]="reorderable"
                        [sort]="sort"
                        [sortable]="sortable"
                        [filter]="filter"
                        [filterable]="filterable"
                        [columnMenu]="columnMenuOptions"
                        [columnMenuTemplate]="columnMenuTemplate"
                        [detailTemplate]="detailTemplate"
                        [tabIndex]="navigation.tableEnabled ? '-1' : '0'">
                    </thead>
                    <tbody kendoGridTableBody
                        [isLoading]="loading"
                        [groups]="group"
                        [data]="$any(view)"
                        [skip]="skip"
                        [columns]="$any(leafColumns)"
                        [selectable]="selectable"
                        [filterable]="filterable"
                        [noRecordsTemplate]="noRecordsTemplate"
                        [detailTemplate]="detailTemplate"
                        [showGroupFooters]="showGroupFooters"
                        [trackBy]="trackBy"
                        [rowClass]="rowClass"
                        kendoDraggable
                        kendoGridSelectionMarquee
                        [enableDrag]="marqueeSelection">
                    </tbody>
                    <tfoot kendoGridFooter
                        *ngIf="showFooter"
                        [scrollable]="false"
                        [logicalRowIndex]="ariaRowCount"
                        [groups]="group"
                        [columns]="$any(leafColumns)"
                        [detailTemplate]="detailTemplate"
                        [totalColumns]="columnsContainer">
                    </tfoot>
                </table>
            </ng-container>
            <div [loadingTemplate]="loadingTemplate" *ngIf="loading" kendoGridLoading></div>
        </div>
        <kendo-grid-status-bar
            *ngIf="showStatusBar"
            [statusBarTemplate]="statusBarTemplate">
        </kendo-grid-status-bar>
        <kendo-pager
            *ngIf="showBottomPager"
            [tabindex]="navigation.pagerEnabled ? '0' : '-1'"
            [attr.role]="navigation.pagerEnabled ? 'application' : undefined"
            [template]="pagerTemplate"
            [pageSize]="pageSize"
            [total]="view.total"
            [skip]="skip"
            [size]="size"
            [options]="pageable"
            class="k-pager"
            (pageChange)="notifyPageChange('pager', $event)">
        </kendo-pager>
        <kendo-grid-toolbar
            class="k-toolbar k-grid-toolbar k-grid-toolbar-bottom"
            *ngIf="showBottomToolbar"
            [size]="size"
            [navigable]="navigation.toolbarEnabled"
            [attr.aria-label]="messageFor('bottomToolbarLabel')"
            [attr.aria-controls]="ariaRootId"
            position="bottom">
        </kendo-grid-toolbar>

        <ng-template #defaultHint>
            <kendo-icon-wrapper
                [name]="getHintSettings('hintIcon')"
                [svgIcon]="getHintSettings('hintSVGIcon')"
                innerCssClass="k-drag-status">
            </kendo-icon-wrapper>
            {{hintText}}
        </ng-template>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `
    }]
  }], function() {
    return [{
      type: BrowserSupportService
    }, {
      type: SelectionService
    }, {
      type: CellSelectionService
    }, {
      type: ElementRef
    }, {
      type: GroupInfoService
    }, {
      type: GroupsService
    }, {
      type: ChangeNotificationService
    }, {
      type: DetailsService
    }, {
      type: EditService
    }, {
      type: FilterService
    }, {
      type: PDFService
    }, {
      type: ResponsiveService
    }, {
      type: Renderer2
    }, {
      type: ExcelService
    }, {
      type: NgZone
    }, {
      type: ScrollSyncService
    }, {
      type: DomEventsService
    }, {
      type: ColumnResizingService
    }, {
      type: ChangeDetectorRef
    }, {
      type: ColumnReorderService
    }, {
      type: ColumnInfoService
    }, {
      type: NavigationService
    }, {
      type: SortService
    }, {
      type: ScrollRequestService
    }, {
      type: LocalizationService
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }, {
      type: RowReorderService
    }];
  }, {
    data: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    detailRowHeight: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    scrollable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    virtualColumns: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    sortable: [{
      type: Input
    }],
    pageable: [{
      type: Input
    }],
    groupable: [{
      type: Input
    }],
    rowReorderable: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    navigatable: [{
      type: Input
    }],
    autoSize: [{
      type: Input
    }],
    rowClass: [{
      type: Input
    }],
    rowSticky: [{
      type: Input
    }],
    rowSelected: [{
      type: Input
    }],
    cellSelected: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    reorderable: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    columnMenu: [{
      type: Input
    }],
    hideHeader: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    groupChange: [{
      type: Output
    }],
    sortChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    rowReorder: [{
      type: Output
    }],
    dataStateChange: [{
      type: Output
    }],
    groupExpand: [{
      type: Output
    }],
    groupCollapse: [{
      type: Output
    }],
    detailExpand: [{
      type: Output
    }],
    detailCollapse: [{
      type: Output
    }],
    edit: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    save: [{
      type: Output
    }],
    remove: [{
      type: Output
    }],
    add: [{
      type: Output
    }],
    cellClose: [{
      type: Output
    }],
    cellClick: [{
      type: Output
    }],
    pdfExport: [{
      type: Output
    }],
    excelExport: [{
      type: Output
    }],
    columnResize: [{
      type: Output
    }],
    columnReorder: [{
      type: Output
    }],
    columnVisibilityChange: [{
      type: Output
    }],
    columnLockedChange: [{
      type: Output
    }],
    columnStickyChange: [{
      type: Output
    }],
    scrollBottom: [{
      type: Output
    }],
    contentScroll: [{
      type: Output
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-grid"]
    }],
    sizeSmallClass: [{
      type: HostBinding,
      args: ["class.k-grid-sm"]
    }],
    sizeMediumClass: [{
      type: HostBinding,
      args: ["class.k-grid-md"]
    }],
    lockedClasses: [{
      type: HostBinding,
      args: ["class.k-grid-lockedcolumns"]
    }],
    virtualClasses: [{
      type: HostBinding,
      args: ["class.k-grid-virtual"]
    }],
    noScrollbarClass: [{
      type: HostBinding,
      args: ["class.k-grid-no-scrollbar"]
    }],
    detailTemplateChildren: [{
      type: ContentChildren,
      args: [DetailTemplateDirective]
    }],
    cellLoadingTemplateChildren: [{
      type: ContentChildren,
      args: [CellLoadingTemplateDirective]
    }],
    loadingTemplateChildren: [{
      type: ContentChildren,
      args: [LoadingTemplateDirective]
    }],
    statusBarTemplateChildren: [{
      type: ContentChildren,
      args: [StatusBarTemplateDirective]
    }],
    noRecordsTemplateChildren: [{
      type: ContentChildren,
      args: [NoRecordsTemplateDirective]
    }],
    pagerTemplateChildren: [{
      type: ContentChildren,
      args: [PagerTemplateDirective]
    }],
    toolbarTemplateChildren: [{
      type: ContentChildren,
      args: [ToolbarTemplateDirective]
    }],
    columnMenuTemplates: [{
      type: ContentChildren,
      args: [ColumnMenuTemplateDirective]
    }],
    lockedHeader: [{
      type: ViewChild,
      args: ["lockedHeader", {
        static: false
      }]
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: false
      }]
    }],
    footer: [{
      type: ViewChildren,
      args: ["footer"]
    }],
    ariaRoot: [{
      type: ViewChild,
      args: ["ariaRoot", {
        static: true
      }]
    }],
    dragTargetContainer: [{
      type: ViewChild,
      args: [DragTargetContainerDirective]
    }],
    dropTargetContainer: [{
      type: ViewChild,
      args: [DropTargetContainerDirective]
    }],
    isDetailExpanded: [{
      type: Input
    }],
    isGroupExpanded: [{
      type: Input
    }]
  });
})();
var DataBindingDirective = class {
  constructor(grid, changeDetector, localDataChangesService, rowReorderService) {
    this.grid = grid;
    this.changeDetector = changeDetector;
    this.localDataChangesService = localDataChangesService;
    this.rowReorderService = rowReorderService;
    this.state = {
      skip: 0
    };
    this.originalData = [];
    if (localDataChangesService) {
      this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
    }
  }
  /**
   * Defines the number of records that will be skipped by the pager.
   * @default 0
   */
  set skip(value2) {
    if (!isPresent4(value2)) {
      value2 = 0;
    }
    this.grid.skip = this.state.skip = value2;
    if (this.rowReorderService) {
      this.rowReorderService.skip = value2;
    }
  }
  /**
   * Defines the descriptors by which the data will be sorted.
   */
  set sort(value2) {
    this.grid.sort = this.state.sort = value2;
  }
  /**
   * Defines the descriptor by which the data will be filtered.
   */
  set filter(value2) {
    this.grid.filter = this.state.filter = value2;
  }
  /**
   * Defines the page size used by the Grid pager.
   */
  set pageSize(value2) {
    this.grid.pageSize = this.state.take = value2;
  }
  /**
   * The descriptors by which the data will be grouped.
   */
  set group(value2) {
    this.grid.group = this.state.group = value2;
  }
  /**
   * The array of data which will be used to populate the Grid.
   */
  set data(value2) {
    this.originalData = value2 || [];
    if (this.localDataChangesService) {
      this.localDataChangesService.data = value2;
    }
    this.dataChanged = true;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.applyState(this.state);
    this.stateChangeSubscription = this.grid.dataStateChange.subscribe(this.onStateChange.bind(this));
    if (this.rowReorderService) {
      this.rowReorderSubscription = this.grid.rowReorder.subscribe(this.onRowReorder.bind(this));
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.stateChangeSubscription) {
      this.stateChangeSubscription.unsubscribe();
    }
    if (this.dataChangedSubscription) {
      this.dataChangedSubscription.unsubscribe();
    }
    if (this.rowReorderSubscription) {
      this.rowReorderSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["pageSize", "skip", "sort", "group", "filter"], changes)) {
      this.rebind();
    }
  }
  ngDoCheck() {
    if (this.dataChanged) {
      this.updateGridData();
    }
  }
  /**
   * @hidden
   */
  onStateChange(state2) {
    this.applyState(state2);
    this.rebind();
  }
  /**
   * @hidden
   */
  onRowReorder(ev) {
    this.rowReorderService.reorderRows(ev, this.originalData);
    this.rebind();
  }
  /**
   * @hidden
   */
  rebind() {
    this.data = this.originalData;
    this.updateGridData();
    this.notifyDataChange();
  }
  /**
   * Notifies the Grid that its data has changed.
   */
  notifyDataChange() {
    this.grid.onDataChange();
    if (this.changeDetector) {
      this.changeDetector.markForCheck();
    }
  }
  process(state2) {
    return process(this.originalData, state2);
  }
  applyState({
    skip: skip4,
    take: take4,
    sort: sort2,
    group: group2,
    filter: filter4
  }) {
    this.skip = skip4;
    this.pageSize = take4;
    this.sort = sort2;
    this.group = group2;
    this.filter = filter4;
  }
  updateGridData() {
    this.grid.data = this.process(this.state);
    this.dataChanged = false;
  }
};
DataBindingDirective.ɵfac = function DataBindingDirective_Factory(t) {
  return new (t || DataBindingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(RowReorderService));
};
DataBindingDirective.ɵdir = ɵɵdefineDirective({
  type: DataBindingDirective,
  selectors: [["", "kendoGridBinding", ""]],
  inputs: {
    skip: "skip",
    sort: "sort",
    filter: "filter",
    pageSize: "pageSize",
    group: "group",
    data: [0, "kendoGridBinding", "data"]
  },
  exportAs: ["kendoGridBinding"],
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridBinding]",
      exportAs: "kendoGridBinding"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalDataChangesService
    }, {
      type: RowReorderService
    }];
  }, {
    skip: [{
      type: Input
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    data: [{
      type: Input,
      args: ["kendoGridBinding"]
    }]
  });
})();
var SelectionDirective = class extends Selection {
  constructor(ctx, cd) {
    super(ctx, cd);
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (this.ctx.grid.selectable === false) {
      this.ctx.grid.selectable = true;
    }
    this.ctx.grid.selectionDirective = this;
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    super.destroy();
  }
};
SelectionDirective.ɵfac = function SelectionDirective_Factory(t) {
  return new (t || SelectionDirective)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ChangeDetectorRef));
};
SelectionDirective.ɵdir = ɵɵdefineDirective({
  type: SelectionDirective,
  selectors: [["", "kendoGridSelectBy", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridSelectBy]"
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var ExpandDetailsDirective = class {
  constructor(grid) {
    this.grid = grid;
    this.expandedDetailKeysChange = new EventEmitter();
    this.expandedDetailKeys = [];
    this.initiallyExpanded = false;
    this.expandedState = /* @__PURE__ */ new Set();
    this.subscriptions = new Subscription();
    this.grid.isDetailExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.detailExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.detailCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  /**
   * Defines the item key that will be stored in the `expandedDetailKeys` collection ([see example]({% slug master_detail_expanded_state_grid %}#toc-built-in-directive)).
   */
  get expandDetailsKey() {
    return this._expandBy;
  }
  set expandDetailsKey(key) {
    if (isString2(key)) {
      this._expandBy = getter(key);
    } else {
      this._expandBy = key;
    }
  }
  /**
   *
   * @hidden
   * A deprecated alias for setting the `expandDetailsKey` property.
   */
  get expandDetailBy() {
    return this.expandDetailsKey;
  }
  set expandDetailBy(key) {
    this.expandDetailsKey = key;
  }
  ngOnChanges(changes) {
    if (isPresent4(changes["expandedDetailKeys"]) && this.lastExpandedState !== this.expandedDetailKeys) {
      this.expandedState = new Set(this.expandedDetailKeys);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this._expandBy || getter(void 0);
  }
  /**
   * @hidden
   */
  isExpanded(args) {
    const key = this.keyGetter(args.dataItem);
    const hasKey = this.expandedState.has(key);
    return this.initiallyExpanded ? !hasKey : hasKey;
  }
  toggleState(args) {
    const key = this.keyGetter(args.dataItem);
    if (Boolean(this.initiallyExpanded) !== args.expand) {
      this.expandedState.add(key);
    } else {
      this.expandedState.delete(key);
    }
    this.notifyChange();
  }
  notifyChange() {
    this.lastExpandedState = Array.from(this.expandedState);
    this.expandedDetailKeysChange.emit(this.lastExpandedState);
  }
};
ExpandDetailsDirective.ɵfac = function ExpandDetailsDirective_Factory(t) {
  return new (t || ExpandDetailsDirective)(ɵɵdirectiveInject(GridComponent));
};
ExpandDetailsDirective.ɵdir = ɵɵdefineDirective({
  type: ExpandDetailsDirective,
  selectors: [["", "kendoGridExpandDetailsBy", ""]],
  inputs: {
    expandDetailsKey: [0, "kendoGridExpandDetailsBy", "expandDetailsKey"],
    expandDetailBy: "expandDetailBy",
    expandedDetailKeys: "expandedDetailKeys",
    initiallyExpanded: "initiallyExpanded"
  },
  outputs: {
    expandedDetailKeysChange: "expandedDetailKeysChange"
  },
  exportAs: ["kendoGridExpandDetailsBy"],
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandDetailsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandDetailsBy]",
      exportAs: "kendoGridExpandDetailsBy"
    }]
  }], function() {
    return [{
      type: GridComponent
    }];
  }, {
    expandedDetailKeysChange: [{
      type: Output
    }],
    expandDetailsKey: [{
      type: Input,
      args: ["kendoGridExpandDetailsBy"]
    }],
    expandDetailBy: [{
      type: Input
    }],
    expandedDetailKeys: [{
      type: Input
    }],
    initiallyExpanded: [{
      type: Input
    }]
  });
})();
var mapParentGroup = (parentGroup) => {
  const parentGroupKeys = [];
  while (parentGroup) {
    parentGroupKeys.push({
      field: parentGroup.group.field,
      value: parentGroup.group.value
    });
    parentGroup = parentGroup.parentGroup;
  }
  return parentGroupKeys;
};
var DEFAULT_KEY_GETTER = (groupRowArgs) => ({
  field: groupRowArgs.group.field,
  value: groupRowArgs.group.value,
  parentGroupKeys: mapParentGroup(groupRowArgs.parentGroup)
});
var ExpandGroupDirective = class {
  constructor(grid) {
    this.grid = grid;
    this.expandedGroupKeysChange = new EventEmitter();
    this.groupsInitiallyExpanded = false;
    this.subscriptions = new Subscription();
    this.grid.isGroupExpanded = this.isExpanded.bind(this);
    this.subscriptions.add(merge(this.grid.groupExpand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.grid.groupCollapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleState.bind(this)));
  }
  /**
   * Defines the item format that will be stored in the `expandedGroupKeys`
   * ([see example]({% slug groups_expanded_state_grid %}#toc-custom-group-key-format)).
   */
  get expandGroupBy() {
    return this._expandGroupBy;
  }
  set expandGroupBy(key) {
    if (typeof key === "function") {
      this._expandGroupBy = key;
    }
  }
  /**
   * Defines the collection that will store the expanded group keys.
   */
  get expandedGroupKeys() {
    return this._expandedGroupKeys;
  }
  set expandedGroupKeys(expandedGroups) {
    this._expandedGroupKeys = (expandedGroups || []).slice();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  get keyGetter() {
    return this.expandGroupBy || DEFAULT_KEY_GETTER;
  }
  /**
   * @hidden
   */
  isExpanded(groupArgs) {
    const itemIndex = this.getItemIndex(groupArgs);
    return itemIndex > -1 ? !this.groupsInitiallyExpanded : this.groupsInitiallyExpanded;
  }
  getItemIndex(groupArgs) {
    if (this.expandGroupBy) {
      return this.expandedGroupKeys.indexOf(this.keyGetter(groupArgs));
    }
    return this.expandedGroupKeys.findIndex((item) => {
      let index = 0;
      let parentGroup = groupArgs.parentGroup;
      while (isPresent4(parentGroup)) {
        if (!isPresent4(item.parentGroupKeys) || !isPresent4(item.parentGroupKeys[index]) || parentGroup.group.value !== item.parentGroupKeys[index].value || parentGroup.group.field !== item.parentGroupKeys[index].field) {
          return false;
        }
        parentGroup = parentGroup.parentGroup;
        index++;
      }
      return item.value === groupArgs.group.value && item.field === groupArgs.group.field;
    });
  }
  toggleState(groupArgs) {
    const key = this.keyGetter(groupArgs);
    if (Boolean(this.groupsInitiallyExpanded) !== groupArgs.expand) {
      this.expandedGroupKeys.push(key);
    } else {
      const index = this.expandedGroupKeys.findIndex((group2) => {
        if (this.expandGroupBy) {
          return group2 === key;
        } else if (key.parentGroupKeys?.length === 0) {
          return group2.value === key.value;
        }
        return JSON.stringify(group2) === JSON.stringify(key);
      });
      this.expandedGroupKeys.splice(index, 1);
    }
    this.expandedGroupKeysChange.emit(this.expandedGroupKeys.slice());
  }
};
ExpandGroupDirective.ɵfac = function ExpandGroupDirective_Factory(t) {
  return new (t || ExpandGroupDirective)(ɵɵdirectiveInject(GridComponent));
};
ExpandGroupDirective.ɵdir = ɵɵdefineDirective({
  type: ExpandGroupDirective,
  selectors: [["", "kendoGridExpandGroupBy", ""]],
  inputs: {
    expandGroupBy: [0, "kendoGridExpandGroupBy", "expandGroupBy"],
    expandedGroupKeys: "expandedGroupKeys",
    groupsInitiallyExpanded: "groupsInitiallyExpanded"
  },
  outputs: {
    expandedGroupKeysChange: "expandedGroupKeysChange"
  },
  exportAs: ["kendoGridExpandGroupBy"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridExpandGroupBy]",
      exportAs: "kendoGridExpandGroupBy"
    }]
  }], function() {
    return [{
      type: GridComponent
    }];
  }, {
    expandedGroupKeysChange: [{
      type: Output
    }],
    expandGroupBy: [{
      type: Input,
      args: ["kendoGridExpandGroupBy"]
    }],
    expandedGroupKeys: [{
      type: Input
    }],
    groupsInitiallyExpanded: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent = class extends GridMessages {
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
};
CustomMessagesComponent.ɵfac = function CustomMessagesComponent_Factory(t) {
  return new (t || CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
};
CustomMessagesComponent.ɵcmp = ɵɵdefineComponent({
  type: CustomMessagesComponent,
  selectors: [["kendo-grid-messages"]],
  features: [ɵɵProvidersFeature([{
    provide: GridMessages,
    useExisting: forwardRef(() => CustomMessagesComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CustomMessagesComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: GridMessages,
        useExisting: forwardRef(() => CustomMessagesComponent)
      }],
      selector: "kendo-grid-messages",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var stringOperators = localizeOperators({
  "filterContainsOperator": "contains",
  "filterNotContainsOperator": "doesnotcontain",
  "filterEqOperator": "eq",
  "filterNotEqOperator": "neq",
  "filterStartsWithOperator": "startswith",
  "filterEndsWithOperator": "endswith",
  "filterIsNullOperator": "isnull",
  "filterIsNotNullOperator": "isnotnull",
  "filterIsEmptyOperator": "isempty",
  "filterIsNotEmptyOperator": "isnotempty"
});
var AutoCompleteFilterCellComponent = class extends BaseFilterCellComponent {
  constructor(filterService, column, ctx, sizingOptionsService) {
    super(filterService);
    this.ctx = ctx;
    this.showOperators = true;
    this.size = "medium";
    this.defaultOperators = stringOperators(this.ctx.localization);
    this.column = column;
    this.subs = sizingOptionsService.changes.subscribe((size) => this.size = size);
  }
  set valueField(value2) {
    this._valueField = value2;
  }
  get valueField() {
    return this._valueField ? this._valueField : this.column.field;
  }
  get currentFilter() {
    return this.filterByField(this.column.field);
  }
  get currentOperator() {
    return this.currentFilter ? this.currentFilter.operator : "contains";
  }
  ngOnDestroy() {
    if (this.subs) {
      this.subs.unsubscribe();
    }
  }
};
AutoCompleteFilterCellComponent.ɵfac = function AutoCompleteFilterCellComponent_Factory(t) {
  return new (t || AutoCompleteFilterCellComponent)(ɵɵdirectiveInject(FilterService), ɵɵdirectiveInject(ColumnComponent2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(SizingOptionsService));
};
AutoCompleteFilterCellComponent.ɵcmp = ɵɵdefineComponent({
  type: AutoCompleteFilterCellComponent,
  selectors: [["kendo-grid-autocomplete-filter-cell"]],
  inputs: {
    showOperators: "showOperators",
    column: "column",
    filter: "filter",
    data: "data",
    valueField: "valueField"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 8,
  consts: [[3, "column", "filter", "operators", "showOperators"], ["kendoFilterInput", "", 3, "data", "size", "valueField", "value"]],
  template: function AutoCompleteFilterCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-grid-filter-wrapper-cell", 0);
      ɵɵelement(1, "kendo-autocomplete", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("column", ctx.column)("filter", ctx.filter)("operators", ctx.operators)("showOperators", ctx.showOperators);
      ɵɵadvance();
      ɵɵproperty("data", ctx.data)("size", ctx.size)("valueField", ctx.valueField)("value", ctx.currentFilter == null ? null : ctx.currentFilter.value);
    }
  },
  dependencies: [AutoCompleteComponent, FilterInputDirective, FilterCellWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteFilterCellComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-autocomplete-filter-cell",
      template: `
        <kendo-grid-filter-wrapper-cell
            [column]="column"
            [filter]="filter"
            [operators]="operators"
            [showOperators]="showOperators">
            <kendo-autocomplete
                kendoFilterInput
                [data]="data"
                [size]="size"
                [valueField]="valueField"
                [value]="currentFilter?.value">
            </kendo-autocomplete>
        </kendo-grid-filter-wrapper-cell>
    `
    }]
  }], function() {
    return [{
      type: FilterService
    }, {
      type: ColumnComponent2
    }, {
      type: ContextService
    }, {
      type: SizingOptionsService
    }];
  }, {
    showOperators: [{
      type: Input
    }],
    column: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }]
  });
})();
var exportedModules$5 = [ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective2, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent, GridTableDirective];
var SharedModule = class {
  static exports() {
    return [ColumnComponent2, SpanColumnComponent, ColumnGroupComponent2, FooterTemplateDirective2, DetailTemplateDirective, FocusableDirective, GridTableDirective];
  }
};
SharedModule.ɵfac = function SharedModule_Factory(t) {
  return new (t || SharedModule)();
};
SharedModule.ɵmod = ɵɵdefineNgModule({
  type: SharedModule,
  declarations: [ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective2, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent, GridTableDirective],
  imports: [CommonModule, IconsModule],
  exports: [ColumnComponent2, ColumnGroupComponent2, LogicalCellDirective, LogicalRowDirective, FocusableDirective, FooterTemplateDirective2, ColGroupComponent, ResizableContainerDirective, TemplateContextDirective, FieldAccessorPipe, DetailTemplateDirective, SpanColumnComponent, TableDirective, LoadingComponent, GridTableDirective, DraggableModule, EventsModule, IconsModule]
});
SharedModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, IconsModule, DraggableModule, EventsModule, IconsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedModule, [{
    type: NgModule,
    args: [{
      declarations: [exportedModules$5],
      exports: [exportedModules$5, DraggableModule, EventsModule, IconsModule],
      imports: [CommonModule, IconsModule]
    }]
  }], null, null);
})();
var ContainsFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("contains", ctx);
  }
};
ContainsFilterOperatorComponent.ɵfac = function ContainsFilterOperatorComponent_Factory(t) {
  return new (t || ContainsFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
ContainsFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: ContainsFilterOperatorComponent,
  selectors: [["kendo-filter-contains-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => ContainsFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ContainsFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainsFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => ContainsFilterOperatorComponent)
      }],
      selector: "kendo-filter-contains-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var DoesNotContainFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("doesnotcontain", ctx);
  }
};
DoesNotContainFilterOperatorComponent.ɵfac = function DoesNotContainFilterOperatorComponent_Factory(t) {
  return new (t || DoesNotContainFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
DoesNotContainFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: DoesNotContainFilterOperatorComponent,
  selectors: [["kendo-filter-not-contains-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function DoesNotContainFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DoesNotContainFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => DoesNotContainFilterOperatorComponent)
      }],
      selector: "kendo-filter-not-contains-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var EndsWithFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("endswith", ctx);
  }
};
EndsWithFilterOperatorComponent.ɵfac = function EndsWithFilterOperatorComponent_Factory(t) {
  return new (t || EndsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
EndsWithFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: EndsWithFilterOperatorComponent,
  selectors: [["kendo-filter-endswith-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function EndsWithFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EndsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EndsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-endswith-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var EqualFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("eq", ctx);
  }
};
EqualFilterOperatorComponent.ɵfac = function EqualFilterOperatorComponent_Factory(t) {
  return new (t || EqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
EqualFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: EqualFilterOperatorComponent,
  selectors: [["kendo-filter-eq-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => EqualFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function EqualFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => EqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-eq-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsEmptyFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("isempty", ctx);
  }
};
IsEmptyFilterOperatorComponent.ɵfac = function IsEmptyFilterOperatorComponent_Factory(t) {
  return new (t || IsEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
IsEmptyFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: IsEmptyFilterOperatorComponent,
  selectors: [["kendo-filter-isempty-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function IsEmptyFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isempty-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNotEmptyFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotempty", ctx);
  }
};
IsNotEmptyFilterOperatorComponent.ɵfac = function IsNotEmptyFilterOperatorComponent_Factory(t) {
  return new (t || IsNotEmptyFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
IsNotEmptyFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: IsNotEmptyFilterOperatorComponent,
  selectors: [["kendo-filter-isnotempty-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function IsNotEmptyFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotEmptyFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotEmptyFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotempty-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNotNullFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("isnotnull", ctx);
  }
};
IsNotNullFilterOperatorComponent.ɵfac = function IsNotNullFilterOperatorComponent_Factory(t) {
  return new (t || IsNotNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
IsNotNullFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: IsNotNullFilterOperatorComponent,
  selectors: [["kendo-filter-isnotnull-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function IsNotNullFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNotNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNotNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnotnull-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var IsNullFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("isnull", ctx);
  }
};
IsNullFilterOperatorComponent.ɵfac = function IsNullFilterOperatorComponent_Factory(t) {
  return new (t || IsNullFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
IsNullFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: IsNullFilterOperatorComponent,
  selectors: [["kendo-filter-isnull-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => IsNullFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function IsNullFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNullFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => IsNullFilterOperatorComponent)
      }],
      selector: "kendo-filter-isnull-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var NotEqualFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("neq", ctx);
  }
};
NotEqualFilterOperatorComponent.ɵfac = function NotEqualFilterOperatorComponent_Factory(t) {
  return new (t || NotEqualFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
NotEqualFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: NotEqualFilterOperatorComponent,
  selectors: [["kendo-filter-neq-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NotEqualFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NotEqualFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => NotEqualFilterOperatorComponent)
      }],
      selector: "kendo-filter-neq-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var StartsWithFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("startswith", ctx);
  }
};
StartsWithFilterOperatorComponent.ɵfac = function StartsWithFilterOperatorComponent_Factory(t) {
  return new (t || StartsWithFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
StartsWithFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: StartsWithFilterOperatorComponent,
  selectors: [["kendo-filter-startswith-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function StartsWithFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StartsWithFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => StartsWithFilterOperatorComponent)
      }],
      selector: "kendo-filter-startswith-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var GreaterFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("gt", ctx);
  }
};
GreaterFilterOperatorComponent.ɵfac = function GreaterFilterOperatorComponent_Factory(t) {
  return new (t || GreaterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
GreaterFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: GreaterFilterOperatorComponent,
  selectors: [["kendo-filter-gt-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => GreaterFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function GreaterFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterFilterOperatorComponent)
      }],
      selector: "kendo-filter-gt-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var GreaterOrEqualToFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("gte", ctx);
  }
};
GreaterOrEqualToFilterOperatorComponent.ɵfac = function GreaterOrEqualToFilterOperatorComponent_Factory(t) {
  return new (t || GreaterOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
GreaterOrEqualToFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: GreaterOrEqualToFilterOperatorComponent,
  selectors: [["kendo-filter-gte-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function GreaterOrEqualToFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GreaterOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => GreaterOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-gte-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var LessFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("lt", ctx);
  }
};
LessFilterOperatorComponent.ɵfac = function LessFilterOperatorComponent_Factory(t) {
  return new (t || LessFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
LessFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: LessFilterOperatorComponent,
  selectors: [["kendo-filter-lt-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => LessFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function LessFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessFilterOperatorComponent)
      }],
      selector: "kendo-filter-lt-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var LessOrEqualToFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("lte", ctx);
  }
};
LessOrEqualToFilterOperatorComponent.ɵfac = function LessOrEqualToFilterOperatorComponent_Factory(t) {
  return new (t || LessOrEqualToFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
LessOrEqualToFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: LessOrEqualToFilterOperatorComponent,
  selectors: [["kendo-filter-lte-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function LessOrEqualToFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LessOrEqualToFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => LessOrEqualToFilterOperatorComponent)
      }],
      selector: "kendo-filter-lte-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var AfterFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("after", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gt"
    };
  }
};
AfterFilterOperatorComponent.ɵfac = function AfterFilterOperatorComponent_Factory(t) {
  return new (t || AfterFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
AfterFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: AfterFilterOperatorComponent,
  selectors: [["kendo-filter-after-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => AfterFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AfterFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var AfterEqFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("after-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "gte"
    };
  }
};
AfterEqFilterOperatorComponent.ɵfac = function AfterEqFilterOperatorComponent_Factory(t) {
  return new (t || AfterEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
AfterEqFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: AfterEqFilterOperatorComponent,
  selectors: [["kendo-filter-after-eq-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AfterEqFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AfterEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => AfterEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-after-eq-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var BeforeEqFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("before-eq", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lte"
    };
  }
};
BeforeEqFilterOperatorComponent.ɵfac = function BeforeEqFilterOperatorComponent_Factory(t) {
  return new (t || BeforeEqFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
BeforeEqFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: BeforeEqFilterOperatorComponent,
  selectors: [["kendo-filter-before-eq-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function BeforeEqFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeEqFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeEqFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-eq-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var BeforeFilterOperatorComponent = class extends FilterOperatorBase {
  constructor(ctx) {
    super("before", ctx);
  }
  /**
   * @hidden
   */
  toJSON() {
    return {
      text: this.text,
      value: "lt"
    };
  }
};
BeforeFilterOperatorComponent.ɵfac = function BeforeFilterOperatorComponent_Factory(t) {
  return new (t || BeforeFilterOperatorComponent)(ɵɵdirectiveInject(ContextService));
};
BeforeFilterOperatorComponent.ɵcmp = ɵɵdefineComponent({
  type: BeforeFilterOperatorComponent,
  selectors: [["kendo-filter-before-operator"]],
  features: [ɵɵProvidersFeature([{
    provide: FilterOperatorBase,
    useExisting: forwardRef(() => BeforeFilterOperatorComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function BeforeFilterOperatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BeforeFilterOperatorComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: FilterOperatorBase,
        useExisting: forwardRef(() => BeforeFilterOperatorComponent)
      }],
      selector: "kendo-filter-before-operator",
      template: ``
    }]
  }], function() {
    return [{
      type: ContextService
    }];
  }, null);
})();
var FILTER_OPERATORS = [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent];
var importedModules$4 = [CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule, ButtonModule];
var COMPONENTS$1 = [FilterInputDirective];
var SharedFilterModule = class {
  static exports() {
    return [...FILTER_OPERATORS];
  }
};
SharedFilterModule.ɵfac = function SharedFilterModule_Factory(t) {
  return new (t || SharedFilterModule)();
};
SharedFilterModule.ɵmod = ɵɵdefineNgModule({
  type: SharedFilterModule,
  declarations: [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, FilterInputDirective],
  imports: [CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule, ButtonModule],
  exports: [FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule, ButtonModule, FilterInputDirective]
});
SharedFilterModule.ɵinj = ɵɵdefineInjector({
  imports: [importedModules$4, CommonModule, ReactiveFormsModule, FormsModule, DropDownListModule, AutoCompleteModule, InputsModule, DatePickerModule, PopupModule, SharedModule, ButtonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedFilterModule, [{
    type: NgModule,
    args: [{
      declarations: [FILTER_OPERATORS, COMPONENTS$1],
      exports: [FILTER_OPERATORS, importedModules$4, COMPONENTS$1],
      imports: [...importedModules$4]
    }]
  }], null, null);
})();
var INTERNAL_COMPONENTS$2 = [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent];
var ENTRY_COMPONENTS$1 = [StringFilterCellComponent, NumericFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent];
var RowFilterModule = class {
  static exports() {
    return [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, FilterCellOperatorsComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent, SharedFilterModule.exports()];
  }
};
RowFilterModule.ɵfac = function RowFilterModule_Factory(t) {
  return new (t || RowFilterModule)();
};
RowFilterModule.ɵmod = ɵɵdefineNgModule({
  type: RowFilterModule,
  declarations: [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent],
  imports: [SharedFilterModule],
  exports: [FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, FilterCellHostDirective, FilterCellWrapperComponent, DateFilterCellComponent, SharedFilterModule]
});
RowFilterModule.ɵinj = ɵɵdefineInjector({
  imports: [SharedFilterModule, SharedFilterModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowFilterModule, [{
    type: NgModule,
    args: [{
      declarations: [INTERNAL_COMPONENTS$2],
      entryComponents: ENTRY_COMPONENTS$1,
      exports: [INTERNAL_COMPONENTS$2, SharedFilterModule],
      imports: [SharedFilterModule]
    }]
  }], null, null);
})();
var importedModules$3 = [CommonModule, InputsModule, LabelModule, ButtonModule, DropDownsModule, ResizeSensorModule, SharedModule];
var INTERNAL_COMPONENTS$1 = [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective];
var PagerModule = class {
  static exports() {
    return [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective];
  }
};
PagerModule.ɵfac = function PagerModule_Factory(t) {
  return new (t || PagerModule)();
};
PagerModule.ɵmod = ɵɵdefineNgModule({
  type: PagerModule,
  declarations: [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective],
  imports: [CommonModule, InputsModule, LabelModule, ButtonModule, DropDownsModule, ResizeSensorModule, SharedModule],
  exports: [PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective]
});
PagerModule.ɵinj = ɵɵdefineInjector({
  imports: [importedModules$3]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PagerModule, [{
    type: NgModule,
    args: [{
      declarations: [INTERNAL_COMPONENTS$1],
      exports: [INTERNAL_COMPONENTS$1],
      imports: [...importedModules$3]
    }]
  }], null, null);
})();
var exported$1 = [DraggableColumnDirective, DropTargetDirective2];
var DragAndDropModule2 = class {
};
DragAndDropModule2.ɵfac = function DragAndDropModule_Factory2(t) {
  return new (t || DragAndDropModule2)();
};
DragAndDropModule2.ɵmod = ɵɵdefineNgModule({
  type: DragAndDropModule2,
  declarations: [DraggableColumnDirective, DropTargetDirective2],
  exports: [DraggableColumnDirective, DropTargetDirective2]
});
DragAndDropModule2.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropModule2, [{
    type: NgModule,
    args: [{
      declarations: [exported$1],
      exports: [exported$1]
    }]
  }], null, null);
})();
var exportedModules$4 = [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent];
var GroupModule = class {
  static exports() {
    return [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2];
  }
};
GroupModule.ɵfac = function GroupModule_Factory(t) {
  return new (t || GroupModule)();
};
GroupModule.ɵmod = ɵɵdefineNgModule({
  type: GroupModule,
  declarations: [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent],
  imports: [CommonModule, SharedModule, DragAndDropModule2, ChipModule, PopupModule],
  exports: [GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, GroupHeaderComponent, GroupPanelComponent]
});
GroupModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, SharedModule, DragAndDropModule2, ChipModule, PopupModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupModule, [{
    type: NgModule,
    args: [{
      declarations: [...exportedModules$4],
      exports: [exportedModules$4],
      imports: [CommonModule, SharedModule, DragAndDropModule2, ChipModule, PopupModule]
    }]
  }], null, null);
})();
var INTERNAL_COMPONENTS = [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective];
var ENTRY_COMPONENTS = [StringFilterMenuComponent, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent];
var FilterMenuModule = class {
  static exports() {
    return [StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, SharedFilterModule.exports()];
  }
};
FilterMenuModule.ɵfac = function FilterMenuModule_Factory(t) {
  return new (t || FilterMenuModule)();
};
FilterMenuModule.ɵmod = ɵɵdefineNgModule({
  type: FilterMenuModule,
  declarations: [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective],
  imports: [SharedFilterModule],
  exports: [FilterMenuComponent, FilterMenuContainerComponent, FilterMenuInputWrapperComponent, StringFilterMenuInputComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, NumericFilterMenuInputComponent, DateFilterMenuInputComponent, DateFilterMenuComponent, FilterMenuHostDirective, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, SharedFilterModule]
});
FilterMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [SharedFilterModule, SharedFilterModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterMenuModule, [{
    type: NgModule,
    args: [{
      declarations: [INTERNAL_COMPONENTS],
      entryComponents: ENTRY_COMPONENTS,
      exports: [INTERNAL_COMPONENTS, SharedFilterModule],
      imports: [SharedFilterModule]
    }]
  }], null, null);
})();
var ColumnChooserComponent = class {
  constructor(ctx, columnInfoService, popupService, ngZone, renderer, changeDetector) {
    this.ctx = ctx;
    this.columnInfoService = columnInfoService;
    this.popupService = popupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.changeDetector = changeDetector;
    this.columnsIcon = columnsIcon;
    this.autoSync = false;
    this.allowHideAll = true;
  }
  get columns() {
    return this.columnInfoService.leafNamedColumns;
  }
  ngOnDestroy() {
    this.close();
  }
  /**
   * @hidden
   */
  toggle(anchor2, template) {
    if (!this.popupRef) {
      const direction = this.ctx.localization.rtl ? "right" : "left";
      this.popupRef = this.popupService.open({
        anchor: anchor2.element,
        content: template,
        positionMode: "absolute",
        anchorAlign: {
          vertical: "bottom",
          horizontal: direction
        },
        popupAlign: {
          vertical: "top",
          horizontal: direction
        }
      });
      const popupElement = this.popupRef?.popupElement;
      if (popupElement) {
        const popupId = `k-${guid()}`;
        const popupAriaElement = popupElement.querySelector(".k-popup");
        this.ngZone.runOutsideAngular(() => {
          this.escapeListener = this.renderer.listen(popupAriaElement, "keydown", (e) => {
            if (e.keyCode === Keys.Escape) {
              this.close(true);
            }
          });
        });
        this.renderer.setAttribute(popupElement, "dir", this.ctx.localization.rtl ? "rtl" : "ltr");
        this.renderer.setAttribute(popupAriaElement, "id", popupId);
        this.renderer.setAttribute(popupAriaElement, "role", "dialog");
        this.popupId = popupId;
      }
      if (!isDocumentAvailable()) {
        return;
      }
      this.ngZone.runOutsideAngular(() => this.closeClick = this.renderer.listen("document", "click", ({
        target
      }) => {
        if (!closest2(target, (node) => node === this.popupRef.popupElement || node === anchor2.element)) {
          this.ngZone.run(() => {
            this.close();
          });
        }
      }));
    } else {
      this.close();
    }
  }
  /**
   * @hidden
   */
  onApply(changed) {
    this.close(true);
    if (changed.length) {
      this.changeDetector.markForCheck();
      this.columnInfoService.changeVisibility(changed);
    }
  }
  /**
   * @hidden
   */
  onChange(changed) {
    this.changeDetector.markForCheck();
    this.columnInfoService.changeVisibility(changed);
  }
  /**
   * @hidden
   */
  onShiftTab(e) {
    if (e.target.matches(".k-column-list-item")) {
      e.preventDefault();
      this.columnList.resetButton.nativeElement.focus();
    }
  }
  close(focusAnchor = false) {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.changeDetector.markForCheck();
      this.escapeListener && this.escapeListener();
    }
    this.detachClose();
    focusAnchor && this.anchor.element.focus();
  }
  detachClose() {
    if (this.closeClick) {
      this.closeClick();
      this.closeClick = null;
    }
  }
};
ColumnChooserComponent.ɵfac = function ColumnChooserComponent_Factory(t) {
  return new (t || ColumnChooserComponent)(ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(ColumnInfoService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
};
ColumnChooserComponent.ɵcmp = ɵɵdefineComponent({
  type: ColumnChooserComponent,
  selectors: [["kendo-grid-column-chooser"]],
  viewQuery: function ColumnChooserComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c19, 5);
      ɵɵviewQuery(_c51, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnList = _t.first);
    }
  },
  inputs: {
    autoSync: "autoSync",
    allowHideAll: "allowHideAll"
  },
  decls: 4,
  vars: 5,
  consts: [["anchor", ""], ["template", ""], ["columnList", ""], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "columns", 3, "click", "svgIcon"], [1, "k-column-chooser-title"], [3, "apply", "columnChange", "keydown.shift.tab", "columns", "ariaLabel", "isLast", "applyText", "resetText", "autoSync", "allowHideAll"]],
  template: function ColumnChooserComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "button", 3, 0);
      ɵɵlistener("click", function ColumnChooserComponent_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        const anchor_r2 = ɵɵreference(1);
        const template_r3 = ɵɵreference(3);
        return ɵɵresetView(ctx.toggle(anchor_r2, template_r3));
      });
      ɵɵelementEnd();
      ɵɵtemplate(2, ColumnChooserComponent_ng_template_2_Template, 4, 8, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("svgIcon", ctx.columnsIcon);
      ɵɵattribute("title", ctx.ctx.localization.get("columns"))("aria-haspopup", "dialog")("aria-expanded", !!ctx.popupRef)("aria-controls", !!ctx.popupRef ? ctx.popupId : void 0);
    }
  },
  dependencies: [ButtonComponent, ColumnListComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnChooserComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-column-chooser",
      template: `
        <button #anchor
            kendoButton
            type="button"
            (click)="toggle(anchor, template)"
            fillMode="flat"
            [attr.title]="ctx.localization.get('columns')"
            icon="columns"
            [svgIcon]="columnsIcon"
            [attr.aria-haspopup]="'dialog'"
            [attr.aria-expanded]="!!(popupRef)"
            [attr.aria-controls]="!!(popupRef) ? popupId : undefined"></button>
        <ng-template #template>
            <span class='k-column-chooser-title'>{{ ctx.localization.get('columns') }}</span>
            <kendo-grid-columnlist
                #columnList
                [columns]="columns"
                [ariaLabel]="ctx.localization.get('columns')"
                [isLast]="true"
                [applyText]="ctx.localization.get('columnsApply')"
                [resetText]="ctx.localization.get('columnsReset')"
                [autoSync]="autoSync"
                [allowHideAll]="allowHideAll"
                (apply)="onApply($event)"
                (columnChange)="onChange($event)"
                (keydown.shift.tab)="onShiftTab($event)">
            </kendo-grid-columnlist>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: ContextService
    }, {
      type: ColumnInfoService
    }, {
      type: PopupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    autoSync: [{
      type: Input
    }],
    allowHideAll: [{
      type: Input
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor"]
    }],
    columnList: [{
      type: ViewChild,
      args: ["columnList"]
    }]
  });
})();
var COMPONENTS = [ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
var ColumnMenuModule = class {
  static exports() {
    return [ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent];
  }
};
ColumnMenuModule.ɵfac = function ColumnMenuModule_Factory(t) {
  return new (t || ColumnMenuModule)();
};
ColumnMenuModule.ɵmod = ɵɵdefineNgModule({
  type: ColumnMenuModule,
  declarations: [ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent],
  imports: [CommonModule, FilterMenuModule, ButtonModule, TabStripModule],
  exports: [ColumnMenuChooserItemCheckedDirective, ColumnListComponent, ColumnChooserComponent, ColumnMenuChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuComponent, ColumnMenuLockComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent]
});
ColumnMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FilterMenuModule, ButtonModule, TabStripModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnMenuModule, [{
    type: NgModule,
    args: [{
      declarations: [COMPONENTS],
      imports: [CommonModule, FilterMenuModule, ButtonModule, TabStripModule],
      exports: [COMPONENTS]
    }]
  }], null, null);
})();
var exportedModules$3 = [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective];
var importedModules$2 = [CommonModule, GroupModule, RowFilterModule, FilterMenuModule, SharedModule, DragAndDropModule2, ColumnMenuModule];
var HeaderModule = class {
  static exports() {
    return [HeaderTemplateDirective, SelectAllCheckboxDirective];
  }
};
HeaderModule.ɵfac = function HeaderModule_Factory(t) {
  return new (t || HeaderModule)();
};
HeaderModule.ɵmod = ɵɵdefineNgModule({
  type: HeaderModule,
  declarations: [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective],
  imports: [CommonModule, GroupModule, RowFilterModule, FilterMenuModule, SharedModule, DragAndDropModule2, ColumnMenuModule],
  exports: [HeaderComponent, HeaderTemplateDirective, ColumnHandleDirective, SelectAllCheckboxDirective]
});
HeaderModule.ɵinj = ɵɵdefineInjector({
  imports: [importedModules$2]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderModule, [{
    type: NgModule,
    args: [{
      declarations: [exportedModules$3],
      exports: [exportedModules$3],
      imports: [...importedModules$2]
    }]
  }], null, null);
})();
var CheckboxColumnComponent = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
    this.isCheckboxColumn = true;
  }
  get templateRef() {
    return this.template ? this.template.templateRef : void 0;
  }
};
CheckboxColumnComponent.ɵfac = function CheckboxColumnComponent_Factory(t) {
  return new (t || CheckboxColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
CheckboxColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: CheckboxColumnComponent,
  selectors: [["kendo-grid-checkbox-column"]],
  contentQueries: function CheckboxColumnComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CellTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
    }
  },
  inputs: {
    showSelectAll: "showSelectAll"
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => CheckboxColumnComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CheckboxColumnComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => CheckboxColumnComponent)
      }],
      selector: "kendo-grid-checkbox-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSelectAll: [{
      type: Input
    }],
    template: [{
      type: ContentChild,
      args: [CellTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var EditCommandDirective = class extends ButtonComponent {
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
    this.commandClass = true;
  }
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginEdit(this.rowIndex);
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
};
EditCommandDirective.ɵfac = function EditCommandDirective_Factory(t) {
  return new (t || EditCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
EditCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: EditCommandDirective,
  selectors: [["", "kendoGridEditCommand", ""]],
  hostVars: 4,
  hostBindings: function EditCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function EditCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.visible);
      ɵɵclassProp("k-grid-edit-command", ctx.commandClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c52,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function EditCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, EditCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, EditCommandDirective_span_1_Template, 2, 1, "span", 1)(2, EditCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridEditCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-edit-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var CancelCommandDirective = class extends ButtonComponent {
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
    this.commandClass = true;
  }
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.endEdit(this.rowIndex);
    }
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
};
CancelCommandDirective.ɵfac = function CancelCommandDirective_Factory(t) {
  return new (t || CancelCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
CancelCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: CancelCommandDirective,
  selectors: [["", "kendoGridCancelCommand", ""]],
  hostVars: 4,
  hostBindings: function CancelCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CancelCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.visible);
      ɵɵclassProp("k-grid-cancel-command", ctx.commandClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c53,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function CancelCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, CancelCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, CancelCommandDirective_span_1_Template, 2, 1, "span", 1)(2, CancelCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CancelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridCancelCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-cancel-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var SaveCommandDirective = class extends ButtonComponent {
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
    this.commandClass = true;
  }
  /**
   * @hidden
   */
  get visible() {
    return !this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    if (this.isEdited) {
      this.editService.save(this.rowIndex);
    }
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
};
SaveCommandDirective.ɵfac = function SaveCommandDirective_Factory(t) {
  return new (t || SaveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
SaveCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: SaveCommandDirective,
  selectors: [["", "kendoGridSaveCommand", ""]],
  hostVars: 4,
  hostBindings: function SaveCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function SaveCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.visible);
      ɵɵclassProp("k-grid-save-command", ctx.commandClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c54,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function SaveCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, SaveCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, SaveCommandDirective_span_1_Template, 2, 1, "span", 1)(2, SaveCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SaveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridSaveCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-save-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var RemoveCommandDirective = class extends ButtonComponent {
  constructor(editService, cellContext, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
    this.cellContext = cellContext;
    this.commandClass = true;
  }
  /**
   * @hidden
   */
  get visible() {
    return this.isEdited ? "none" : "";
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.remove(this.rowIndex);
  }
  ngDoCheck() {
    if (this.cellContext) {
      this.rowIndex = this.cellContext.rowIndex;
      this.isEdited = this.editService.isEdited(this.rowIndex);
    }
  }
};
RemoveCommandDirective.ɵfac = function RemoveCommandDirective_Factory(t) {
  return new (t || RemoveCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(CELL_CONTEXT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
RemoveCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: RemoveCommandDirective,
  selectors: [["", "kendoGridRemoveCommand", ""]],
  hostVars: 4,
  hostBindings: function RemoveCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function RemoveCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("display", ctx.visible);
      ɵɵclassProp("k-grid-remove-command", ctx.commandClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c55,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function RemoveCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, RemoveCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, RemoveCommandDirective_span_1_Template, 2, 1, "span", 1)(2, RemoveCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RemoveCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridRemoveCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CELL_CONTEXT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    visible: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-remove-command"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var AddCommandDirective = class extends ButtonComponent {
  constructor(editService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.editService = editService;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.editService.beginAdd();
  }
  /**
   * @hidden
   */
  get commandClass() {
    return true;
  }
};
AddCommandDirective.ɵfac = function AddCommandDirective_Factory(t) {
  return new (t || AddCommandDirective)(ɵɵdirectiveInject(EditService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
AddCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: AddCommandDirective,
  selectors: [["", "kendoGridAddCommand", ""]],
  hostVars: 2,
  hostBindings: function AddCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function AddCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("k-grid-add-command", ctx.commandClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c56,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function AddCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, AddCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, AddCommandDirective_span_1_Template, 2, 1, "span", 1)(2, AddCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AddCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridAddCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: EditService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    commandClass: [{
      type: HostBinding,
      args: ["class.k-grid-add-command"]
    }]
  });
})();
var RowReorderColumnComponent = class extends ColumnBase2 {
  constructor(parent, idService) {
    super(parent, idService);
    this.parent = parent;
    this.isRowReorderColumn = true;
  }
};
RowReorderColumnComponent.ɵfac = function RowReorderColumnComponent_Factory(t) {
  return new (t || RowReorderColumnComponent)(ɵɵdirectiveInject(ColumnBase2, 13), ɵɵdirectiveInject(IdService, 8));
};
RowReorderColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: RowReorderColumnComponent,
  selectors: [["kendo-grid-rowreorder-column"]],
  inputs: {
    dragHandleIcon: "dragHandleIcon",
    dragHandleSVGIcon: "dragHandleSVGIcon"
  },
  features: [ɵɵProvidersFeature([{
    provide: ColumnBase2,
    useExisting: forwardRef(() => RowReorderColumnComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function RowReorderColumnComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowReorderColumnComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColumnBase2,
        useExisting: forwardRef(() => RowReorderColumnComponent)
      }],
      selector: "kendo-grid-rowreorder-column",
      template: ``
    }]
  }], function() {
    return [{
      type: ColumnBase2,
      decorators: [{
        type: SkipSelf
      }, {
        type: Host
      }, {
        type: Optional
      }]
    }, {
      type: IdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    dragHandleIcon: [{
      type: Input
    }],
    dragHandleSVGIcon: [{
      type: Input
    }]
  });
})();
var exported = [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent];
var importedModules$1 = [CommonModule, ReactiveFormsModule, FormsModule, SharedModule, GroupModule, NumericTextBoxModule, DatePickerModule, ResizeSensorModule];
var BodyModule = class {
  static exports() {
    return [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, NoRecordsTemplateDirective, EditTemplateDirective, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent];
  }
};
BodyModule.ɵfac = function BodyModule_Factory(t) {
  return new (t || BodyModule)();
};
BodyModule.ɵmod = ɵɵdefineNgModule({
  type: BodyModule,
  declarations: [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent],
  imports: [CommonModule, ReactiveFormsModule, FormsModule, SharedModule, GroupModule, NumericTextBoxModule, DatePickerModule, ResizeSensorModule],
  exports: [CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, EditTemplateDirective, TableBodyComponent, NoRecordsTemplateDirective, CellComponent, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent]
});
BodyModule.ɵinj = ɵɵdefineInjector({
  imports: [importedModules$1]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BodyModule, [{
    type: NgModule,
    args: [{
      declarations: [exported],
      exports: [exported],
      imports: [...importedModules$1]
    }]
  }], null, null);
})();
var exportedModules$2 = [FooterComponent];
var importedModules = [CommonModule, SharedModule];
var FooterModule = class {
  static exports() {
    return [];
  }
};
FooterModule.ɵfac = function FooterModule_Factory(t) {
  return new (t || FooterModule)();
};
FooterModule.ɵmod = ɵɵdefineNgModule({
  type: FooterModule,
  declarations: [FooterComponent],
  imports: [CommonModule, SharedModule],
  exports: [FooterComponent]
});
FooterModule.ɵinj = ɵɵdefineInjector({
  imports: [importedModules]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterModule, [{
    type: NgModule,
    args: [{
      declarations: [exportedModules$2],
      exports: [exportedModules$2],
      imports: [...importedModules]
    }]
  }], null, null);
})();
var LocalEditService = class {
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  create(item) {
    if (this.hasLocalData && this.grid.skip) {
      this.localDataChangesService.data.splice(this.grid.skip, 0, item);
    } else {
      this.data.unshift(item);
    }
    this.dataChanged();
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  update(_item) {
  }
  remove(item) {
    const data = this.data;
    for (let idx = 0; idx < data.length; idx++) {
      if (item === data[idx]) {
        data.splice(idx, 1);
        this.dataChanged({
          action: "remove",
          item
        });
        break;
      }
    }
  }
  assignValues(target, source) {
    Object.assign(target, source);
  }
  dataChanged(args = {}) {
    if (this.hasLocalData) {
      this.localDataChangesService.changes.emit(args);
    }
  }
  get hasLocalData() {
    return Array.isArray(this.localDataChangesService.data);
  }
  get data() {
    if (this.hasLocalData) {
      return this.localDataChangesService.data;
    }
    const data = this.grid.data;
    if (Array.isArray(data)) {
      return data;
    }
    if (isDevMode()) {
      throw new Error(GridConfigurationErrorMessages.requiredEditService);
    }
    return [];
  }
};
var EditingDirectiveBase = class {
  constructor(grid, localDataChangesService) {
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.subscriptions = new Subscription();
    this.defaultEditService = this.createDefaultService();
  }
  // Consider adding support for the dependency injection of the service to allow for specifying a generic service without code.
  // The Input should still be kept.
  /**
   * The edit service that will handle the operations.
   */
  set editService(value2) {
    this.userEditService = value2;
  }
  get editService() {
    return this.userEditService || this.defaultEditService;
  }
  /**
   * @hidden
   */
  ngOnInit() {
    this.subscriptions.add(this.grid.add.subscribe(this.addHandler.bind(this)));
    this.subscriptions.add(this.grid.remove.subscribe(this.removeHandler.bind(this)));
    this.subscriptions.add(this.grid.cancel.subscribe(this.cancelHandler.bind(this)));
    this.subscriptions.add(this.grid.save.subscribe(this.saveHandler.bind(this)));
    this.subscriptions.add(this.grid.dataStateChange.subscribe(this.onStateChange.bind(this)));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  createDefaultService() {
    return new LocalEditService(this.grid, this.localDataChangesService);
  }
  addHandler() {
    this.grid.addRow(this.createModel({
      isNew: true
    }));
  }
  saveHandler(args) {
    const item = this.saveModel(args);
    if (item) {
      if (args.isNew) {
        this.editService.create(item);
      } else {
        this.editService.update(item);
      }
    }
    this.grid.closeRow(args.rowIndex);
  }
  cancelHandler({
    rowIndex
  }) {
    this.closeEditor(rowIndex);
  }
  removeHandler({
    dataItem
  }) {
    const removeItem = (shouldRemove) => {
      if (shouldRemove) {
        this.editService.remove(dataItem);
      }
    };
    if (this.removeConfirmation) {
      const result = this.removeConfirmation(dataItem);
      if (result instanceof Promise) {
        result.then(removeItem);
      } else if (result instanceof Observable) {
        result.pipe(take(1)).subscribe(removeItem);
      } else {
        removeItem(result);
      }
    } else {
      removeItem(true);
    }
  }
  onStateChange() {
    this.closeEditor();
  }
  closeEditor(rowIndex) {
    this.grid.closeRow(rowIndex);
  }
};
EditingDirectiveBase.ɵfac = function EditingDirectiveBase_Factory(t) {
  return new (t || EditingDirectiveBase)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
};
EditingDirectiveBase.ɵdir = ɵɵdefineDirective({
  type: EditingDirectiveBase,
  selectors: [["", "kendoGridEditingDirectiveBase", ""]],
  inputs: {
    editService: "editService",
    removeConfirmation: "removeConfirmation"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridEditingDirectiveBase]"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    editService: [{
      type: Input
    }],
    removeConfirmation: [{
      type: Input
    }]
  });
})();
var LocalRowEditService = class extends LocalEditService {
  update(_item) {
    this.dataChanged();
  }
};
var RowEditingDirectiveBase = class extends EditingDirectiveBase {
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.edit.subscribe(this.editHandler.bind(this)));
  }
  createDefaultService() {
    return new LocalRowEditService(this.grid, this.localDataChangesService);
  }
  addHandler() {
    this.closeEditor();
    super.addHandler();
  }
  editHandler(args) {
    this.closeEditor();
    this.rowIndex = args.rowIndex;
    this.grid.editRow(args.rowIndex, this.createModel(args));
  }
  saveHandler(args) {
    super.saveHandler(args);
    this.clean();
  }
  closeEditor(rowIndex = this.rowIndex) {
    super.closeEditor(rowIndex);
    this.clean();
  }
  clean() {
    delete this.rowIndex;
  }
};
RowEditingDirectiveBase.ɵfac = /* @__PURE__ */ (() => {
  let ɵRowEditingDirectiveBase_BaseFactory;
  return function RowEditingDirectiveBase_Factory(t) {
    return (ɵRowEditingDirectiveBase_BaseFactory || (ɵRowEditingDirectiveBase_BaseFactory = ɵɵgetInheritedFactory(RowEditingDirectiveBase)))(t || RowEditingDirectiveBase);
  };
})();
RowEditingDirectiveBase.ɵdir = ɵɵdefineDirective({
  type: RowEditingDirectiveBase,
  selectors: [["", "kendoGridRowEditingDirectiveBase", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowEditingDirectiveBase, [{
    type: Directive,
    args: [{
      selector: "[kendoGridRowEditingDirectiveBase]"
    }]
  }], null, null);
})();
var TemplateEditingDirective = class extends RowEditingDirectiveBase {
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  editHandler(args) {
    super.editHandler(args);
    this.dataItem = args.dataItem;
    this.originalValues = {};
    this.editService.assignValues(this.originalValues, this.dataItem);
  }
  closeEditor(rowIndex) {
    if (this.dataItem) {
      this.editService.assignValues(this.dataItem, this.originalValues);
    }
    super.closeEditor(rowIndex);
  }
  createModel(args) {
    if (args.isNew) {
      return this.createNewItem();
    }
  }
  saveModel(args) {
    return args.dataItem;
  }
  clean() {
    super.clean();
    delete this.dataItem;
  }
};
TemplateEditingDirective.ɵfac = function TemplateEditingDirective_Factory(t) {
  return new (t || TemplateEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
};
TemplateEditingDirective.ɵdir = ɵɵdefineDirective({
  type: TemplateEditingDirective,
  selectors: [["", "kendoGridTemplateEditing", ""]],
  inputs: {
    createNewItem: [0, "kendoGridTemplateEditing", "createNewItem"]
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridTemplateEditing]"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    createNewItem: [{
      type: Input,
      args: ["kendoGridTemplateEditing"]
    }]
  });
})();
var markAllAsTouched = (control) => {
  control.markAsTouched();
  if (control.hasOwnProperty("controls")) {
    const controls = control.controls;
    for (const inner in controls) {
      if (controls.hasOwnProperty(inner)) {
        markAllAsTouched(controls[inner]);
      }
    }
  }
};
var ReactiveEditingDirective = class extends RowEditingDirectiveBase {
  constructor(grid, localDataChangesService) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
  }
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
};
ReactiveEditingDirective.ɵfac = function ReactiveEditingDirective_Factory(t) {
  return new (t || ReactiveEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService));
};
ReactiveEditingDirective.ɵdir = ɵɵdefineDirective({
  type: ReactiveEditingDirective,
  selectors: [["", "kendoGridReactiveEditing", ""]],
  inputs: {
    createFormGroup: [0, "kendoGridReactiveEditing", "createFormGroup"]
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridReactiveEditing]"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridReactiveEditing"]
    }]
  });
})();
var InCellEditingDirective = class extends EditingDirectiveBase {
  constructor(grid, localDataChangesService, cdr) {
    super(grid, localDataChangesService);
    this.grid = grid;
    this.localDataChangesService = localDataChangesService;
    this.cdr = cdr;
  }
  // Need mixin
  createModel(args) {
    return this.createFormGroup(args);
  }
  saveModel({
    dataItem,
    formGroup,
    isNew
  }) {
    if (!formGroup.dirty && !isNew) {
      return;
    }
    if (formGroup.valid) {
      this.editService.assignValues(dataItem, formGroup.value);
      return dataItem;
    }
    markAllAsTouched(formGroup);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    super.ngOnInit();
    this.subscriptions.add(this.grid.cellClick.subscribe(this.cellClickHandler.bind(this)));
    this.subscriptions.add(this.grid.cellClose.subscribe(this.cellCloseHandler.bind(this)));
  }
  removeHandler(args) {
    super.removeHandler(args);
    this.grid.cancelCell();
  }
  cellClickHandler(args) {
    if (!args.isEdited && args.type !== "contextmenu") {
      this.grid.editCell(args.rowIndex, args.columnIndex, this.createFormGroup(args));
      this.cdr.markForCheck();
    }
  }
  cellCloseHandler(args) {
    const {
      formGroup,
      dataItem
    } = args;
    if (!formGroup.valid) {
      args.preventDefault();
    } else if (formGroup.dirty) {
      if (args.originalEvent && args.originalEvent.keyCode === Keys.Escape) {
        return;
      }
      this.editService.assignValues(dataItem, formGroup.value);
      this.editService.update(dataItem);
    }
  }
};
InCellEditingDirective.ɵfac = function InCellEditingDirective_Factory(t) {
  return new (t || InCellEditingDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(ChangeDetectorRef));
};
InCellEditingDirective.ɵdir = ɵɵdefineDirective({
  type: InCellEditingDirective,
  selectors: [["", "kendoGridInCellEditing", ""]],
  inputs: {
    createFormGroup: [0, "kendoGridInCellEditing", "createFormGroup"]
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InCellEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridInCellEditing]"
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: LocalDataChangesService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    createFormGroup: [{
      type: Input,
      args: ["kendoGridInCellEditing"]
    }]
  });
})();
var hasGroups = (items) => items && items.length && items[0].field && items[0].items;
var groupDescriptorsPresent = (descriptors) => isPresent4(descriptors) && descriptors.length > 0;
var processGroups = (data, state2) => process(data, state2).data;
var removeParentDescriptors = (parents, owner) => (g) => g.field !== owner.field && !parents.some((y) => y.field === g.field);
var findGroup = (groupIndex, groups) => {
  const parents = [];
  return {
    group: groupIndex.split("_").reduce((acc, x) => {
      const idx = parseInt(x, 10);
      if (acc.items) {
        parents.push(acc);
        return acc.items[idx];
      }
      return isArray2(acc) ? acc[idx] : acc;
    }, groups),
    parents
  };
};
var findChildren = (data, parents) => {
  const filters = parents.map((p) => ({
    field: p.field,
    operator: "eq",
    value: p.value
  }));
  return filterBy(data, {
    filters,
    logic: "and"
  });
};
var count2 = (groups, includeFooters = false) => groups.reduce((acc, group2) => {
  if (!group2.skipHeader) {
    acc++;
  }
  if (group2.items) {
    const children2 = count2(group2.items, includeFooters);
    if (includeFooters && children2 && !group2.hideFooter) {
      acc++;
    }
    acc += children2;
  }
  return acc;
}, 0);
var noDescriptors = (descriptors) => !isPresent4(descriptors) || !descriptors.length;
var slice = (groups, skip4, take4, includeFooters = false) => {
  if (!isPresent4(take4)) {
    return groups;
  }
  const result = [];
  for (let idx = 0, length = groups.length; idx < length; idx++) {
    if (take4 <= 0) {
      break;
    }
    const group2 = groups[idx];
    const groupItems = group2.items;
    let itemCount = count2(groupItems, includeFooters);
    if (includeFooters && groupItems.length) {
      itemCount++;
    }
    const skipHeader = skip4 > 0;
    if (skip4) {
      skip4--;
      if (itemCount && skip4 >= itemCount) {
        skip4 -= itemCount;
        continue;
      }
    }
    if (!skipHeader || itemCount) {
      const items = [];
      let hideFooter = true;
      if (!skipHeader) {
        take4--;
      }
      if (take4) {
        if (hasGroups(groupItems)) {
          const children2 = slice(groupItems, skip4, take4, includeFooters);
          items.push(...children2);
          take4 -= count2(children2, includeFooters);
        } else {
          items.push(...groupItems.slice(skip4, Math.min(skip4 + take4, groupItems.length)));
          take4 -= items.length;
        }
        if (take4 && includeFooters) {
          hideFooter = false;
          take4--;
        }
        skip4 = 0;
      }
      result.push({
        aggregates: group2.aggregates,
        field: group2.field,
        hideFooter,
        items,
        offset: idx,
        skipHeader,
        value: group2.value
      });
    }
  }
  return result;
};
var skippedHeaders = (groupItem) => {
  let total = 0;
  while (groupItem) {
    if (groupItem.skipHeader) {
      total++;
    }
    groupItem = groupItem.items && groupItem.items[0] || null;
  }
  return total;
};
var GroupBindingDirective = class extends DataBindingDirective {
  constructor(changeDetector, localDataChangesService, ctxService, groupsService) {
    super(ctxService.grid, changeDetector, localDataChangesService);
    this.groupsService = groupsService;
    this.gridSubs = new Subscription();
    ctxService.groupBindingDirective = this;
  }
  /**
   * The array of data which will be used to populate the Grid.
   */
  set kendoGridGroupBinding(value2) {
    this.groups = null;
    this.grid.resetGroupsState();
    this.data = value2;
  }
  /**
   * @hidden
   */
  set data(value2) {
    this.originalData = value2 || [];
    this.dataChanged = true;
  }
  /**
   * Defines the descriptors by which the data will be sorted.
   */
  set sort(value2) {
    const noCurrentDescriptors = noDescriptors(this.state.sort);
    const noIncomingDescriptors = noDescriptors(value2);
    const clear = this.state.sort !== value2 && !(noCurrentDescriptors && noIncomingDescriptors);
    this.grid.sort = this.state.sort = value2;
    if (clear) {
      this.groups = null;
      this.grid.resetGroupsState();
    }
  }
  /**
   * Defines the descriptor by which the data will be filtered.
   */
  set filter(value2) {
    const clear = diffFilters(this.state.filter, value2);
    if (clear) {
      this.state.filter = value2;
      this.grid.filter = cloneFilters(value2);
      this.groups = null;
      this.grid.resetGroupsState();
    }
  }
  /**
   * Defines the descriptors by which the data will be grouped.
   */
  set group(value2) {
    const groupsPresent = groupDescriptorsPresent(this.state.group) || groupDescriptorsPresent(value2);
    const clear = this.state.group !== value2 && groupsPresent;
    this.grid.group = this.state.group = value2;
    if (clear) {
      this.groups = null;
      this.grid.resetGroupsState();
      this.skip = 0;
    }
  }
  ngOnInit() {
    super.ngOnInit();
    this.gridSubs.add(this.grid.groupExpand.subscribe(this.groupExpand.bind(this)));
    this.gridSubs.add(this.grid.groupCollapse.subscribe(this.groupCollapse.bind(this)));
  }
  ngAfterContentInit() {
    if (isDevMode() && this.grid.isGroupExpanded) {
      throw new Error(GridConfigurationErrorMessages.groupBindingDirectives);
    }
  }
  ngOnDestroy() {
    this.gridSubs.unsubscribe();
  }
  /**
   * @hidden
   */
  toggleAll(expand) {
    this.skip = 0;
    this.grid.scrollTo({
      row: 0,
      column: 0
    });
    this.groups.forEach((gr, idx) => {
      const expanded = this.groupsService.isExpanded({
        group: gr,
        groupIndex: idx.toString(),
        parentGroup: void 0
      });
      const performToggle = expand && !expanded || !expand && expanded;
      if (performToggle) {
        this.grid.groupsService.toggleRow({
          type: "group",
          data: gr,
          index: idx.toString(),
          level: 0,
          parentGroup: void 0
        });
        this[expand ? "groupExpand" : "groupCollapse"]({
          groupIndex: idx.toString()
        });
      }
    });
  }
  /**
   * Collapses all expanded root level groups.
   */
  collapseAll() {
    this.toggleAll(false);
  }
  /**
   * Expands all expanded root level groups.
   */
  expandAll() {
    this.toggleAll(true);
  }
  /**
   * @hidden
   */
  groupExpand({
    groupIndex
  }) {
    const {
      group: group2,
      parents
    } = findGroup(groupIndex, this.groups);
    if (!group2) {
      return;
    }
    this.groupsService.expandChildren(groupIndex);
    if (!group2.items.length) {
      const descriptors = this.state.group.filter(removeParentDescriptors(parents, group2));
      const children2 = findChildren(this.originalData, parents.concat(group2));
      group2.items = processGroups(children2, {
        filter: this.state.filter,
        group: descriptors,
        sort: this.state.sort
      });
    }
    this.grid.data = this.dataResult(this.state.skip, this.state.take);
  }
  /**
   * @hidden
   */
  groupCollapse({
    groupIndex
  }) {
    const {
      group: group2
    } = findGroup(groupIndex, this.groups);
    if (group2) {
      group2.items = [];
    } else {
      return;
    }
    this.grid.data = this.dataResult(this.state.skip, this.state.take);
  }
  process(state2) {
    if (state2.group && state2.group.length) {
      const groups = this.processGroups(state2);
      this.grid.skip -= skippedHeaders(groups.data[0]);
      return groups;
    } else {
      this.groups = null;
    }
    return super.process(state2);
  }
  processGroups(state2) {
    if (!this.groups || !this.groups.length) {
      this.groups = processGroups(this.originalData, {
        filter: state2.filter,
        group: state2.group,
        sort: state2.sort
      });
    }
    return this.dataResult(state2.skip, state2.take);
  }
  dataResult(skip4, take4) {
    const includeFooters = this.grid.showGroupFooters;
    return {
      data: slice(this.groups, skip4, take4, includeFooters),
      total: count2(this.groups, includeFooters)
    };
  }
  applyState({
    skip: skip4,
    take: take4,
    sort: sort2,
    group: group2,
    filter: filter4
  }) {
    this.skip = skip4;
    this.state.take = take4;
    this.sort = sort2;
    this.group = group2;
    this.filter = filter4;
  }
};
GroupBindingDirective.ɵfac = function GroupBindingDirective_Factory(t) {
  return new (t || GroupBindingDirective)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalDataChangesService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(GroupsService));
};
GroupBindingDirective.ɵdir = ɵɵdefineDirective({
  type: GroupBindingDirective,
  selectors: [["", "kendoGridGroupBinding", ""]],
  inputs: {
    kendoGridGroupBinding: "kendoGridGroupBinding",
    sort: "sort",
    filter: "filter",
    group: "group"
  },
  exportAs: ["kendoGridGroupBinding"],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridGroupBinding]",
      exportAs: "kendoGridGroupBinding"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: LocalDataChangesService
    }, {
      type: ContextService
    }, {
      type: GroupsService
    }];
  }, {
    kendoGridGroupBinding: [{
      type: Input,
      args: ["kendoGridGroupBinding"]
    }],
    sort: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    group: [{
      type: Input
    }]
  });
})();
var GridToolbarFocusableDirective = class {
  constructor(host, ctx) {
    this.host = host;
    this.ctx = ctx;
  }
  /**
   * @hidden
   */
  get element() {
    return this.host.nativeElement;
  }
  /**
   * @hidden
   */
  get toolbarPosition() {
    return isDocumentAvailable() && this.host.nativeElement.closest(".k-toolbar")?.getAttribute("position");
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable() || !this.toolbarPosition) {
      return;
    }
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.navigableElements.push(this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`]?.notify();
  }
  ngOnDestroy() {
    if (!isDocumentAvailable() || !this.toolbarPosition) {
      return;
    }
    const elements = this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements;
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].navigableElements = elements.filter((el) => el !== this.element);
    this.ctx[`${this.toolbarPosition}ToolbarNavigation`].notify();
  }
};
GridToolbarFocusableDirective.ɵfac = function GridToolbarFocusableDirective_Factory(t) {
  return new (t || GridToolbarFocusableDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService));
};
GridToolbarFocusableDirective.ɵdir = ɵɵdefineDirective({
  type: GridToolbarFocusableDirective,
  selectors: [["", "kendoGridToolbarFocusable", ""], ["", "kendoGridAddCommand", ""], ["", "kendoGridCancelCommand", ""], ["", "kendoGridEditCommand", ""], ["", "kendoGridRemoveCommand", ""], ["", "kendoGridSaveCommand", ""], ["", "kendoGridExcelCommand", ""], ["", "kendoGridPDFCommand", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridToolbarFocusableDirective, [{
    type: Directive,
    args: [{
      selector: `
        [kendoGridToolbarFocusable],
        [kendoGridAddCommand],
        [kendoGridCancelCommand],
        [kendoGridEditCommand],
        [kendoGridRemoveCommand],
        [kendoGridSaveCommand],
        [kendoGridExcelCommand],
        [kendoGridPDFCommand]
    `
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ContextService
    }];
  }, null);
})();
var GridClipboardDirective = class {
  constructor(host, clipboardService, renderer, zone) {
    this.host = host;
    this.clipboardService = clipboardService;
    this.renderer = renderer;
    this.zone = zone;
    this.clipboard = new EventEmitter();
    this._target = "selection";
    this._clipboardSettings = {
      wholeRow: false,
      copyHeaders: false,
      copy: true,
      cut: true,
      paste: true
    };
    this.subs = new Subscription();
    this.onClipboard = (operationType, args) => {
      if (!this.clipboardSettings[operationType] || !this.inGrid(args)) {
        return;
      }
      const gridData = Array.isArray(this.host.data) ? this.host.data : this.host.data.data;
      const gridDataItems = gridData.flatMap(recursiveFlatMap);
      const selection = this.host.selection;
      const selectionDirective = this.host.selectionDirective;
      const targetType = this.clipboardTarget;
      const isCellSelection = this.host.selectable?.cell || selectionDirective.isCellSelectionMode;
      let clipboardData = [];
      switch (targetType) {
        case "activeCell":
          {
            const targetCell2 = __spreadValues({}, this.host.activeCell);
            clipboardData = targetCell2 && [{
              dataItem: targetCell2.dataItem,
              dataRowIndex: targetCell2.dataRowIndex,
              colIndex: targetCell2.colIndex
            }];
          }
          break;
        case "selection":
          {
            const identifier = selectionDirective.selectionKey;
            clipboardData = gridDataItems.flatMap((item, index) => {
              if (identifier) {
                const key = typeof identifier === "string" ? item[identifier] : identifier({
                  index: index + this.host.skip,
                  dataItem: item
                });
                return isCellSelection ? selection.some((s) => s.itemKey === key) ? [{
                  dataItem: item,
                  dataRowIndex: index + this.host.skip
                }] : [] : selection.indexOf(key) > -1 ? [{
                  dataItem: item,
                  dataRowIndex: index + this.host.skip
                }] : [];
              }
              return isCellSelection ? selection.some((s) => s.itemKey === index + this.host.skip) ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [] : selection.indexOf(index + this.host.skip) > -1 ? [{
                dataItem: item,
                dataRowIndex: index + this.host.skip
              }] : [];
            });
          }
          break;
      }
      const isPaste = operationType === "paste";
      const pastedData = args.clipboardData.getData("text");
      const visibleCols = this.host.columns.toArray().filter((c) => c.isVisible);
      const data = isPaste ? {
        dataString: pastedData,
        gridItems: this.clipboardService.getGridData(pastedData, visibleCols, this.clipboardTarget, clipboardData[0]?.dataRowIndex, {
          wholeRow: this.clipboardSettings.wholeRow,
          isCellSelection
        })
      } : this.clipboardService.createClipboardData(clipboardData || [], visibleCols, {
        wholeRow: this.clipboardSettings.wholeRow || this.clipboardTarget === "selection" && !isCellSelection,
        target: this.clipboardTarget,
        copyHeaders: this.clipboardSettings.copyHeaders,
        operationType
      });
      !isPaste && navigator.clipboard.writeText(data.dataString);
      if (hasObservers(this.clipboard)) {
        this.zone.run(() => {
          this.clipboard.emit({
            type: operationType,
            originalEvent: args,
            clipboardData: data.dataString,
            gridData: data.gridItems,
            target: {
              dataRowIndex: this.clipboardService.targetRowIndex,
              colField: this.clipboardService.targetColField,
              dataItem: clipboardData.find((item) => item.dataRowIndex === this.clipboardService.targetRowIndex)?.dataItem
            }
          });
        });
      }
      this.clipboardService.targetColField = this.clipboardService.targetRowIndex = null;
    };
    this.inGrid = (args) => {
      const target = document.activeElement.matches(".k-table-td") ? document.activeElement : args.target;
      const inContentArea = closest2(target, (node) => node.parentElement?.classList.contains("k-grid-container"));
      const inHost = contains$2(this.host.wrapper.nativeElement, target);
      return target && inHost && inContentArea;
    };
  }
  /**
   * Determines the target of the clipboard operation ([see example]({% slug clipboard_grid %}#toc-clipboard-target)). The possible options are:
   * - `activeCell`
   * - `selection`
   *
   * @default 'selection'
   */
  set clipboardTarget(value2) {
    if (isDevMode()) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        if (value2 === "activeCell" && !this.host.navigable.length) {
          console.warn(ClipboardErrorMessages.clipboardTarget.activeCellNavigable);
        } else if (value2 === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
          console.warn(ClipboardErrorMessages.selectionSelectable);
        }
      });
    }
    this._target = value2;
  }
  get clipboardTarget() {
    return this._target;
  }
  /**
   * The `GridClipboardDirective` settings.
   *
   * @default { wholeRow: false, copyHeaders: false copy: true, cut: true, paste: true }
   */
  set clipboardSettings(value2) {
    this._clipboardSettings = Object.assign({}, this._clipboardSettings, value2);
  }
  get clipboardSettings() {
    return this._clipboardSettings;
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.clipboardTarget === "selection" && !(this.host.selectable || this.host.selectionDirective)) {
      console.warn(ClipboardErrorMessages.selectionSelectable);
    }
    this.zone.runOutsideAngular(() => {
      this.subs.add(this.renderer.listen(document, "copy", (args) => this.onClipboard("copy", args)));
      this.subs.add(this.renderer.listen(document, "cut", (args) => this.onClipboard("cut", args)));
      this.subs.add(this.renderer.listen(document, "paste", (args) => this.onClipboard("paste", args)));
    });
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
};
GridClipboardDirective.ɵfac = function GridClipboardDirective_Factory(t) {
  return new (t || GridClipboardDirective)(ɵɵdirectiveInject(GridComponent), ɵɵdirectiveInject(ClipboardService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
GridClipboardDirective.ɵdir = ɵɵdefineDirective({
  type: GridClipboardDirective,
  selectors: [["", "kendoGridClipboard", ""]],
  inputs: {
    clipboardTarget: "clipboardTarget",
    clipboardSettings: "clipboardSettings"
  },
  outputs: {
    clipboard: "clipboard"
  },
  exportAs: ["kendoGridClipboard"],
  features: [ɵɵProvidersFeature([ClipboardService])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridClipboardDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridClipboard]",
      exportAs: "kendoGridClipboard",
      providers: [ClipboardService]
    }]
  }], function() {
    return [{
      type: GridComponent
    }, {
      type: ClipboardService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    clipboardTarget: [{
      type: Input
    }],
    clipboardSettings: [{
      type: Input
    }],
    clipboard: [{
      type: Output
    }]
  });
})();
var exportedModules$1 = [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, ...GroupModule.exports(), ...SharedModule.exports(), ...BodyModule.exports(), ...HeaderModule.exports(), ...FooterModule.exports(), ...PagerModule.exports(), ...RowFilterModule.exports(), ...FilterMenuModule.exports(), ...ColumnMenuModule.exports(), GridClipboardDirective];
var declarations$2 = [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective];
var GridModule = class {
};
GridModule.ɵfac = function GridModule_Factory(t) {
  return new (t || GridModule)();
};
GridModule.ɵmod = ɵɵdefineNgModule({
  type: GridModule,
  declarations: [GridComponent, ListComponent, ToolbarComponent, LocalizedMessagesDirective, CustomMessagesComponent, DataBindingDirective, ToolbarTemplateDirective, SelectionDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GroupBindingDirective, GridMarqueeDirective, GridSpacerComponent, GridToolbarFocusableDirective, StatusBarComponent, StatusBarTemplateDirective, GridClipboardDirective],
  imports: [CommonModule, GroupModule, SharedModule, BodyModule, HeaderModule, FooterModule, PagerModule, RowFilterModule, FilterMenuModule, ResizeSensorModule, ColumnMenuModule, DragAndDropModule, WatermarkModule],
  exports: [GridComponent, ToolbarTemplateDirective, ToolbarComponent, GridSpacerComponent, StatusBarTemplateDirective, DataBindingDirective, SelectionDirective, CustomMessagesComponent, GroupBindingDirective, TemplateEditingDirective, ReactiveEditingDirective, InCellEditingDirective, ExpandDetailsDirective, ExpandGroupDirective, GridToolbarFocusableDirective, GroupHeaderTemplateDirective2, GroupHeaderColumnTemplateDirective2, GroupFooterTemplateDirective2, ColumnComponent2, SpanColumnComponent, ColumnGroupComponent2, FooterTemplateDirective2, DetailTemplateDirective, FocusableDirective, GridTableDirective, CommandColumnComponent, CheckboxColumnComponent, SelectionCheckboxDirective, CellTemplateDirective, NoRecordsTemplateDirective, EditTemplateDirective, EditCommandDirective, CancelCommandDirective, SaveCommandDirective, RemoveCommandDirective, AddCommandDirective, CellLoadingTemplateDirective, LoadingTemplateDirective, RowReorderColumnComponent, HeaderTemplateDirective, SelectAllCheckboxDirective, PagerComponent, PagerPrevButtonsComponent, PagerNextButtonsComponent, PagerNumericButtonsComponent, PagerInputComponent, PagerInfoComponent, PagerPageSizesComponent, PagerTemplateDirective, PagerDropDownListDirective, PagerInputDirective, FilterRowComponent, FilterCellComponent, FilterCellTemplateDirective, FilterCellOperatorsComponent, StringFilterCellComponent, NumericFilterCellComponent, AutoCompleteFilterCellComponent, BooleanFilterCellComponent, DateFilterCellComponent, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, StringFilterMenuComponent, FilterMenuTemplateDirective, NumericFilterMenuComponent, DateFilterMenuComponent, BooleanFilterMenuComponent, FilterMenuDropDownListDirective, BooleanFilterRadioButtonDirective, FilterCellOperatorsComponent, ContainsFilterOperatorComponent, DoesNotContainFilterOperatorComponent, EndsWithFilterOperatorComponent, EqualFilterOperatorComponent, IsEmptyFilterOperatorComponent, IsNotEmptyFilterOperatorComponent, IsNotNullFilterOperatorComponent, IsNullFilterOperatorComponent, NotEqualFilterOperatorComponent, StartsWithFilterOperatorComponent, GreaterFilterOperatorComponent, GreaterOrEqualToFilterOperatorComponent, LessFilterOperatorComponent, LessOrEqualToFilterOperatorComponent, AfterFilterOperatorComponent, AfterEqFilterOperatorComponent, BeforeEqFilterOperatorComponent, BeforeFilterOperatorComponent, ColumnChooserComponent, ColumnMenuFilterComponent, ColumnMenuItemComponent, ColumnMenuItemContentTemplateDirective, ColumnMenuSortComponent, ColumnMenuLockComponent, ColumnMenuStickComponent, ColumnMenuPositionComponent, ColumnMenuChooserComponent, ColumnMenuTemplateDirective, ColumnMenuContainerComponent, ColumnMenuItemDirective, ColumnMenuComponent, ColumnMenuAutoSizeColumnComponent, ColumnMenuAutoSizeAllColumnsComponent, GridClipboardDirective]
});
GridModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, GroupModule, SharedModule, BodyModule, HeaderModule, FooterModule, PagerModule, RowFilterModule, FilterMenuModule, ResizeSensorModule, ColumnMenuModule, DragAndDropModule, WatermarkModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GridModule, [{
    type: NgModule,
    args: [{
      declarations: [declarations$2],
      exports: [exportedModules$1],
      imports: [CommonModule, GroupModule, SharedModule, BodyModule, HeaderModule, FooterModule, PagerModule, RowFilterModule, FilterMenuModule, ResizeSensorModule, ColumnMenuModule, DragAndDropModule, WatermarkModule]
    }]
  }], null, null);
})();
var PDFMarginComponent = class extends PDFExportMarginComponent {
};
PDFMarginComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵPDFMarginComponent_BaseFactory;
  return function PDFMarginComponent_Factory(t) {
    return (ɵPDFMarginComponent_BaseFactory || (ɵPDFMarginComponent_BaseFactory = ɵɵgetInheritedFactory(PDFMarginComponent)))(t || PDFMarginComponent);
  };
})();
PDFMarginComponent.ɵcmp = ɵɵdefineComponent({
  type: PDFMarginComponent,
  selectors: [["kendo-grid-pdf-margin"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PDFMarginComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFMarginComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf-margin",
      template: ""
    }]
  }], null, null);
})();
var PDFTemplateDirective = class extends PDFExportTemplateDirective {
  constructor(templateRef) {
    super(templateRef);
  }
};
PDFTemplateDirective.ɵfac = function PDFTemplateDirective_Factory(t) {
  return new (t || PDFTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
PDFTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: PDFTemplateDirective,
  selectors: [["", "kendoGridPDFTemplate", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoGridPDFTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var HEADER_CLASS = "k-grid-header";
var FOOTER_CLASS = "k-grid-footer";
var GRID_LIST = "KENDO-GRID-LIST";
var TABLE = "TABLE";
var matchesList = matchesNodeName(GRID_LIST);
var matchesTable = matchesNodeName(TABLE);
var suffix = (locked) => locked ? "locked" : "wrap";
var GridQuery = class {
  constructor(element) {
    this.element = element;
    this.list = findElement(element, matchesList);
  }
  content(locked) {
    return findElement(this.list, matchesClasses(`k-grid-content${locked ? "-locked" : ""}`));
  }
  header(locked) {
    this.headerWrap = this.headerWrap || findElement(this.element, matchesClasses(HEADER_CLASS));
    return findElement(this.headerWrap, matchesClasses(`${HEADER_CLASS}-${suffix(locked)}`));
  }
  footer(locked) {
    this.footerWrap = this.footerWrap || findElement(this.element, matchesClasses(FOOTER_CLASS));
    return findElement(this.footerWrap, matchesClasses(`${FOOTER_CLASS}-${suffix(locked)}`));
  }
  table() {
    return findElement(this.element, matchesTable);
  }
};
var FIRST_CLASS = "k-first";
var INPUTS = ["input", "select", "textarea", "option"];
var cloneNode = (node) => {
  const clone = node.cloneNode(false);
  if (node._kendoExportVisual) {
    clone._kendoExportVisual = node._kendoExportVisual;
  }
  if (INPUTS.indexOf(String(node.nodeName).toLowerCase()) >= 0) {
    clone.removeAttribute("id");
    clone.removeAttribute("name");
    clone.value = node.value;
    clone.checked = node.checked;
    clone.selected = node.selected;
  }
  let child = node.firstChild;
  while (child) {
    clone.appendChild(cloneNode(child));
    child = child.nextSibling;
  }
  return clone;
};
var appendNodes = (element, nodes) => {
  const length = nodes.length;
  for (let idx = 0; idx < length; idx++) {
    element.appendChild(cloneNode(nodes[idx]));
  }
};
var wrapTable = (table, size) => {
  if (!isDocumentAvailable()) {
    return;
  }
  const wrapper = document.createElement("div");
  const classes = ["k-grid"];
  if (size && size !== "none") {
    classes.push(`k-grid-${size === "medium" ? "md" : "sm"}`);
  }
  wrapper.classList.add(...classes);
  wrapper.appendChild(table);
  return wrapper;
};
var createTableElement = (sources) => {
  const sourceCount = sources.length;
  const element = cloneNode(sources[0]);
  const rowsCount = element.rows.length;
  if (sourceCount > 1) {
    for (let rowIdx = 0; rowIdx < rowsCount; rowIdx++) {
      for (let sourceIdx = 1; sourceIdx < sourceCount; sourceIdx++) {
        appendNodes(element.rows[rowIdx], sources[sourceIdx].rows[rowIdx].cells);
      }
    }
  }
  return element;
};
var setFirstCellClass = (header, headers) => {
  if (headers.length > 1 && header.rows.length > 1) {
    for (let idx = 1; idx < header.rows.length; idx++) {
      const firstCellIndex = headers[0].rows[idx].cells.length;
      const cell2 = header.rows[idx].cells[firstCellIndex];
      if (String(cell2.className).indexOf(FIRST_CLASS) === -1) {
        cell2.className += ` ${FIRST_CLASS}`;
      }
    }
  }
};
var createTable = (colGroups, headers, bodies, footers, size) => {
  const table = document.createElement("table");
  const classes = ["k-table"];
  if (size && size !== "none") {
    classes.push(`k-table-${size === "medium" ? "md" : "sm"}`);
  }
  table.classList.add(...classes);
  const colGroup = colGroups[0].cloneNode(true);
  for (let idx = 1; idx < colGroups.length; idx++) {
    appendNodes(colGroup, colGroups[idx].querySelectorAll("col"));
  }
  const header = createTableElement(headers);
  const body = createTableElement(bodies);
  setFirstCellClass(header, headers);
  table.appendChild(colGroup);
  table.appendChild(header);
  table.appendChild(body);
  if (footers.length) {
    const footer = createTableElement(footers);
    table.appendChild(footer);
  }
  return wrapTable(table, size);
};
var exportElement = (wrapper, size) => {
  const query = new GridQuery(wrapper);
  const content = query.content();
  let result;
  if (content) {
    const colGroups = [content.querySelector("colgroup")];
    const headers = [query.header().querySelector("thead")];
    const bodies = [content.querySelector("tbody")];
    const footer = query.footer();
    const footers = [];
    if (footer) {
      footers.push(footer.querySelector("tfoot"));
    }
    const lockedContent = query.content(true);
    if (lockedContent) {
      colGroups.unshift(lockedContent.querySelector("colgroup"));
      headers.unshift(query.header(true).querySelector("thead"));
      bodies.unshift(lockedContent.querySelector("tbody"));
      if (footer) {
        footers.unshift(query.footer(true).querySelector("tfoot"));
      }
    }
    result = createTable(colGroups, headers, bodies, footers, size);
  } else {
    result = wrapTable(query.table().cloneNode(true), size);
  }
  return result;
};
var createElement = (tagName, className) => {
  const element = document.createElement(tagName);
  if (className) {
    element.className = className;
  }
  return element;
};
var createDiv = (className) => {
  return createElement("div", className);
};
var PDFComponent = class extends PDFExportComponent {
  constructor(pdfService, suspendService, ngZone, element, ctx) {
    super(element);
    this.pdfService = pdfService;
    this.suspendService = suspendService;
    this.ngZone = ngZone;
    this.ctx = ctx;
    this.delay = 0;
    this.columns = new QueryList();
    this.saveSubscription = pdfService.savePDF.subscribe(this.savePDF.bind(this));
    this.drawSubscription = pdfService.drawPDF.subscribe(this.drawPDF.bind(this));
    this.reset = this.reset.bind(this);
    this.draw = this.draw.bind(this);
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    this.drawSubscription.unsubscribe();
    this.reset();
  }
  /**
   * @hidden
   */
  saveAs(_) {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("saveAs", "GridComponent.saveAsPDF"));
  }
  /**
   * @hidden
   */
  export() {
    throw new Error(GridConfigurationErrorMessages.unsupportedMethod("export", "GridComponent.drawPDF"));
  }
  savePDF(component) {
    this.createPDF(component, this.draw);
  }
  drawPDF({
    component,
    promise
  }) {
    this.createPDF(component, () => {
      this.createExportGroup(promise);
    });
  }
  createPDF(component, callback) {
    const pageSize = component.pageSize;
    const total = component.view.total;
    const columns = this.columns.toArray();
    if (columns.length) {
      this.originalColumns = component.columns.toArray();
    }
    this.component = component;
    this.suspendService.scroll = true;
    this.pdfService.exporting = true;
    this.initProgress();
    this.renderAllPages = this.allPages && pageSize < total;
    if (this.renderAllPages) {
      this.skip = component.skip;
      this.pageSize = pageSize;
      this.changePage(0, total, callback, columns);
    } else if (columns.length || component.virtualColumns) {
      this.changeColumns(columns, callback);
    } else {
      callback();
    }
  }
  initProgress() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    const progress = this.progress = createDiv("k-loading-pdf-mask");
    const overlay = cloneNode(wrapperElement);
    progress.appendChild(overlay);
    progress.appendChild(createDiv("k-loading-color"));
    progress.appendChild(createElement("span", "k-i-loading k-icon"));
    this.originalHeight = wrapperElement.style.height;
    this.originalOverflow = wrapperElement.style.overflow;
    wrapperElement.style.height = wrapperElement.offsetHeight + "px";
    wrapperElement.style.overflow = "hidden";
    wrapperElement.appendChild(progress);
    this.applyScroll(overlay);
  }
  applyScroll(overlay) {
    const query = new GridQuery(this.component.wrapper.nativeElement);
    const content = query.content();
    if (content) {
      const overlayQuery = new GridQuery(overlay);
      const overlayContent = overlayQuery.content();
      overlayContent.scrollTop = content.scrollTop;
      overlayContent.scrollLeft = content.scrollLeft;
      overlayQuery.header().scrollLeft = query.header().scrollLeft;
      const footer = query.footer();
      if (footer) {
        overlayQuery.footer().scrollLeft = footer.scrollLeft;
      }
      const lockedContent = query.content(true);
      if (lockedContent) {
        const overlayLockedContent = overlayQuery.content(true);
        overlayLockedContent.scrollTop = lockedContent.scrollTop;
        overlayLockedContent.scrollLeft = lockedContent.scrollLeft;
      }
    }
  }
  draw() {
    this.createExportElement((element) => {
      this.save(element, this.fileName);
    });
  }
  createExportGroup(promise) {
    this.createExportElement((element) => {
      this.exportElement(element).then((group2) => promise.resolve(group2));
    });
  }
  createExportElement(callback) {
    this.ngZone.runOutsideAngular(() => {
      const container = this.container = createDiv("k-grid-pdf-export-element");
      const element = exportElement(this.component.wrapper.nativeElement, this.ctx?.grid.size || "medium");
      container.appendChild(element);
      document.body.appendChild(container);
      callback(element);
    });
  }
  drawOptions() {
    const options = super.drawOptions();
    options._destructive = true;
    return options;
  }
  cleanup() {
    super.cleanup();
    this.pdfService.exporting = false;
    if (this.component) {
      const originalColumns = this.originalColumns;
      delete this.originalColumns;
      if (this.renderAllPages) {
        this.changePage(this.skip, this.pageSize, this.reset, originalColumns);
      } else if (originalColumns || this.component.virtualColumns) {
        this.changeColumns(originalColumns, this.reset);
      } else {
        this.reset();
      }
    } else {
      this.reset();
    }
    this.removeContainer();
  }
  removeContainer() {
    if (this.container) {
      document.body.removeChild(this.container);
      delete this.container;
    }
  }
  changePage(skip4, _take, callback, columns) {
    this.ngZone.run(() => {
      this.pdfService.dataChanged.pipe(take(1)).subscribe(() => {
        if (columns && columns.length || this.component.virtualColumns) {
          this.changeColumns(columns, callback);
        } else {
          this.onStable(callback);
        }
      });
      this.component.notifyPageChange("pdf", {
        skip: skip4,
        take: _take
      });
    });
  }
  changeColumns(columns, callback) {
    this.ngZone.run(() => {
      this.onStable(callback);
      if (columns && columns.length) {
        this.component.columns.reset(columns);
      }
    });
  }
  reset() {
    this.suspendService.scroll = false;
    this.renderAllPages = false;
    if (!this.component) {
      return;
    }
    const wrapperElement = this.component.wrapper.nativeElement;
    wrapperElement.removeChild(this.progress);
    wrapperElement.style.height = this.originalHeight;
    wrapperElement.style.overflow = this.originalOverflow;
    delete this.progress;
    delete this.component;
  }
  onStable(callback) {
    setTimeout(() => {
      let onStable = this.ngZone.onStable.asObservable().pipe(take(1));
      if (this.delay > 0) {
        onStable = onStable.pipe(delay(this.delay));
      }
      onStable.subscribe(callback);
    }, 0);
  }
};
PDFComponent.ɵfac = function PDFComponent_Factory(t) {
  return new (t || PDFComponent)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(SuspendService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ContextService, 8));
};
PDFComponent.ɵcmp = ɵɵdefineComponent({
  type: PDFComponent,
  selectors: [["kendo-grid-pdf"]],
  contentQueries: function PDFComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PDFMarginComponent, 5);
      ɵɵcontentQuery(dirIndex, PDFTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, ColumnBase2, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.marginComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTemplateDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
    }
  },
  inputs: {
    allPages: "allPages",
    delay: "delay"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PDFComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-pdf",
      template: ""
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: SuspendService
    }, {
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: ContextService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    allPages: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase2]
    }],
    marginComponent: [{
      type: ContentChild,
      args: [PDFMarginComponent, {
        static: false
      }]
    }],
    pageTemplateDirective: [{
      type: ContentChild,
      args: [PDFTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var PDFCommandDirective = class extends ButtonComponent {
  constructor(pdfService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.pdfService = pdfService;
    this.ngZone = ngZone;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.pdfService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get pdfClass() {
    return true;
  }
};
PDFCommandDirective.ɵfac = function PDFCommandDirective_Factory(t) {
  return new (t || PDFCommandDirective)(ɵɵdirectiveInject(PDFService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
PDFCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: PDFCommandDirective,
  selectors: [["", "kendoGridPDFCommand", ""]],
  hostVars: 2,
  hostBindings: function PDFCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function PDFCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("k-grid-pdf", ctx.pdfClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c57,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function PDFCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, PDFCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, PDFCommandDirective_span_1_Template, 2, 1, "span", 1)(2, PDFCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridPDFCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: PDFService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    pdfClass: [{
      type: HostBinding,
      args: ["class.k-grid-pdf"]
    }]
  });
})();
var exportedModules = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective];
var declarations$1 = [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective];
var PDFModule = class {
};
PDFModule.ɵfac = function PDFModule_Factory(t) {
  return new (t || PDFModule)();
};
PDFModule.ɵmod = ɵɵdefineNgModule({
  type: PDFModule,
  declarations: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective],
  imports: [IconsModule],
  exports: [PDFComponent, PDFMarginComponent, PDFCommandDirective, PDFTemplateDirective]
});
PDFModule.ɵinj = ɵɵdefineInjector({
  imports: [IconsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PDFModule, [{
    type: NgModule,
    args: [{
      declarations: [declarations$1],
      imports: [IconsModule],
      exports: [exportedModules]
    }]
  }], null, null);
})();
var ExcelExportEvent = class extends PreventableEvent2 {
  constructor(workbook2) {
    super();
    this.workbook = workbook2;
  }
};
var fetchComponentData = (component) => {
  return {
    data: component.view.map((item) => item),
    group: component.group
  };
};
var toExcelColumn = (column) => {
  return {
    title: column.title,
    field: column.field,
    locked: Boolean(column.locked),
    width: column.width,
    level: column.level,
    hidden: !column.isVisible,
    groupHeaderTemplate: column.groupHeaderTemplate,
    groupHeaderColumnTemplate: column.groupHeaderColumnTemplate,
    groupFooterTemplate: column.groupFooterTemplate,
    footerTemplate: column.footerTemplate
  };
};
var toExcelColumns = (columns) => {
  const result = [];
  sortColumns(columns).forEach((column) => {
    if (column.isSpanColumn) {
      result.push(...toExcelColumns(column.childrenArray));
    } else {
      const excelColumn = toExcelColumn(column);
      if (column.isColumnGroup) {
        excelColumn.children = [excelColumn].concat(toExcelColumns(column.childrenArray));
      }
      result.push(excelColumn);
    }
  });
  return result;
};
var componentColumns = (component) => {
  const columns = toExcelColumns(component.columns.toArray());
  return orderBy(columns, [{
    field: "locked",
    dir: "desc"
  }]);
};
var ExcelComponent = class {
  constructor(excelService, ctx, zone) {
    this.ctx = ctx;
    this.zone = zone;
    this.fileName = "Export.xlsx";
    this.columns = new QueryList();
    this.saveSubscription = excelService.saveToExcel.subscribe(this.save.bind(this));
  }
  ngOnDestroy() {
    this.saveSubscription.unsubscribe();
    if (this.dataSubscription) {
      this.dataSubscription.unsubscribe();
    }
  }
  save(component) {
    const data = (this.fetchData || fetchComponentData)(component);
    const exportData = (result) => {
      delete this.dataSubscription;
      this.exportData(component, result);
    };
    if (data instanceof Promise) {
      data.then(exportData);
    } else if (data instanceof Observable) {
      this.dataSubscription = data.pipe(take(1)).subscribe(exportData);
    } else {
      exportData(data);
    }
  }
  exportData(component, result) {
    const options = workbookOptions({
      columns: this.columns.length ? this.columns : componentColumns(component),
      data: result.data,
      group: result.group,
      filterable: this.filterable,
      creator: this.creator,
      date: this.date,
      paddingCellOptions: this.paddingCellOptions,
      headerPaddingCellOptions: this.headerPaddingCellOptions,
      rtl: this.ctx.localization.rtl,
      collapsible: this.collapsible
    });
    const args = new ExcelExportEvent(options);
    component.excelExport.emit(args);
    if (!args.isDefaultPrevented()) {
      this.zone.runOutsideAngular(() => this.saveFile(options));
    }
  }
  saveFile(options) {
    toDataURL2(options).then((dataURL) => {
      saveAs(dataURL, this.fileName, {
        forceProxy: this.forceProxy,
        proxyURL: this.proxyURL
      });
    });
  }
};
ExcelComponent.ɵfac = function ExcelComponent_Factory(t) {
  return new (t || ExcelComponent)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
ExcelComponent.ɵcmp = ɵɵdefineComponent({
  type: ExcelComponent,
  selectors: [["kendo-grid-excel"]],
  contentQueries: function ExcelComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ColumnBase, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
    }
  },
  inputs: {
    fileName: "fileName",
    filterable: "filterable",
    creator: "creator",
    date: "date",
    forceProxy: "forceProxy",
    proxyURL: "proxyURL",
    fetchData: "fetchData",
    paddingCellOptions: "paddingCellOptions",
    headerPaddingCellOptions: "headerPaddingCellOptions",
    collapsible: "collapsible"
  },
  decls: 0,
  vars: 0,
  template: function ExcelComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelComponent, [{
    type: Component,
    args: [{
      selector: "kendo-grid-excel",
      template: ``
    }]
  }], function() {
    return [{
      type: ExcelService
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    fileName: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    creator: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    forceProxy: [{
      type: Input
    }],
    proxyURL: [{
      type: Input
    }],
    fetchData: [{
      type: Input
    }],
    paddingCellOptions: [{
      type: Input
    }],
    headerPaddingCellOptions: [{
      type: Input
    }],
    collapsible: [{
      type: Input
    }],
    columns: [{
      type: ContentChildren,
      args: [ColumnBase, {
        descendants: true
      }]
    }]
  });
})();
var ExcelCommandDirective = class extends ButtonComponent {
  constructor(excelService, element, renderer, ctx, ngZone) {
    super(element, renderer, null, ctx.localization, ngZone);
    this.excelService = excelService;
    this.ngZone = ngZone;
  }
  /**
   * @hidden
   */
  onClick(e) {
    e.preventDefault();
    this.excelService.exportClick.emit();
  }
  /**
   * @hidden
   */
  get excelClass() {
    return true;
  }
};
ExcelCommandDirective.ɵfac = function ExcelCommandDirective_Factory(t) {
  return new (t || ExcelCommandDirective)(ɵɵdirectiveInject(ExcelService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ContextService), ɵɵdirectiveInject(NgZone));
};
ExcelCommandDirective.ɵcmp = ɵɵdefineComponent({
  type: ExcelCommandDirective,
  selectors: [["", "kendoGridExcelCommand", ""]],
  hostVars: 2,
  hostBindings: function ExcelCommandDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ExcelCommandDirective_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("k-grid-excel", ctx.excelClass);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c58,
  ngContentSelectors: _c16,
  decls: 5,
  vars: 3,
  consts: [["innerCssClass", "k-button-icon", 3, "name", "svgIcon", 4, "ngIf"], ["class", "k-button-icon k-icon", 4, "ngIf"], ["class", "k-button-icon", 3, "ngClass", 4, "ngIf"], [1, "k-button-text"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [1, "k-button-icon", "k-icon"], ["role", "presentation", 1, "k-image", 3, "src"], [1, "k-button-icon", 3, "ngClass"]],
  template: function ExcelCommandDirective_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ExcelCommandDirective_kendo_icon_wrapper_0_Template, 1, 2, "kendo-icon-wrapper", 0)(1, ExcelCommandDirective_span_1_Template, 2, 1, "span", 1)(2, ExcelCommandDirective_span_2_Template, 1, 1, "span", 2);
      ɵɵelementStart(3, "span", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.icon || ctx.svgIcon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageUrl);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconClass);
    }
  },
  dependencies: [NgClass, NgIf, IconWrapperComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelCommandDirective, [{
    type: Component,
    args: [{
      selector: "[kendoGridExcelCommand]",
      template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `
    }]
  }], function() {
    return [{
      type: ExcelService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ContextService
    }, {
      type: NgZone
    }];
  }, {
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }],
    excelClass: [{
      type: HostBinding,
      args: ["class.k-grid-excel"]
    }]
  });
})();
var declarations2 = [ExcelComponent, ExcelCommandDirective];
var ExcelModule = class {
};
ExcelModule.ɵfac = function ExcelModule_Factory(t) {
  return new (t || ExcelModule)();
};
ExcelModule.ɵmod = ɵɵdefineNgModule({
  type: ExcelModule,
  declarations: [ExcelComponent, ExcelCommandDirective],
  imports: [IconsModule],
  exports: [ExcelComponent, ExcelCommandDirective, ExcelExportModule]
});
ExcelModule.ɵinj = ɵɵdefineInjector({
  imports: [IconsModule, ExcelExportModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExcelModule, [{
    type: NgModule,
    args: [{
      declarations: [declarations2],
      imports: [IconsModule],
      exports: [declarations2, ExcelExportModule]
    }]
  }], null, null);
})();
export {
  AddCommandDirective,
  AfterEqFilterOperatorComponent,
  AfterFilterOperatorComponent,
  AutoCompleteFilterCellComponent,
  BaseFilterCellComponent,
  BeforeEqFilterOperatorComponent,
  BeforeFilterOperatorComponent,
  BodyModule,
  BooleanFilterCellComponent,
  BooleanFilterComponent,
  BooleanFilterMenuComponent,
  BooleanFilterRadioButtonDirective,
  BrowserSupportService,
  CELL_CONTEXT,
  CancelCommandDirective,
  CellCloseEvent,
  CellComponent,
  CellLoadingTemplateDirective,
  CellSelectionAggregateService,
  CellSelectionService,
  CellTemplateDirective,
  ChangeNotificationService,
  CheckboxColumnComponent,
  ColGroupComponent,
  ColumnBase2 as ColumnBase,
  ColumnChooserComponent,
  ColumnComponent2 as ColumnComponent,
  ColumnGroupComponent2 as ColumnGroupComponent,
  ColumnHandleDirective,
  ColumnInfoService,
  ColumnListComponent,
  ColumnLockedChangeEvent,
  ColumnMenuAutoSizeAllColumnsComponent,
  ColumnMenuAutoSizeColumnComponent,
  ColumnMenuChooserComponent,
  ColumnMenuComponent,
  ColumnMenuContainerComponent,
  ColumnMenuFilterComponent,
  ColumnMenuItemComponent,
  ColumnMenuItemContentTemplateDirective,
  ColumnMenuItemDirective,
  ColumnMenuLockComponent,
  ColumnMenuPositionComponent,
  ColumnMenuService,
  ColumnMenuSortComponent,
  ColumnMenuStickComponent,
  ColumnMenuTemplateDirective,
  ColumnReorderEvent,
  ColumnReorderService,
  ColumnResizingService,
  ColumnStickyChangeEvent,
  ColumnVisibilityChangeEvent,
  ColumnsContainer,
  CommandColumnComponent,
  ContainsFilterOperatorComponent,
  ContextService,
  CustomMessagesComponent,
  DEFAULT_SCROLLER_FACTORY,
  DataBindingDirective,
  DateFilterCellComponent,
  DateFilterComponent,
  DateFilterMenuComponent,
  DateFilterMenuInputComponent,
  DetailCollapseEvent,
  DetailExpandEvent,
  DetailTemplateDirective,
  DetailsService,
  DoesNotContainFilterOperatorComponent,
  DomEventsService,
  DragAndDropService,
  DragHintService,
  DropCueService,
  EditCommandDirective,
  EditService,
  EditTemplateDirective,
  EditingDirectiveBase,
  EndsWithFilterOperatorComponent,
  EqualFilterOperatorComponent,
  ExcelCommandDirective,
  ExcelComponent,
  ExcelExportEvent,
  ExcelModule,
  ExcelService,
  ExpandDetailsDirective,
  ExpandGroupDirective,
  FieldAccessorPipe,
  FilterCellComponent,
  FilterCellHostDirective,
  FilterCellOperatorsComponent,
  FilterCellTemplateDirective,
  FilterCellWrapperComponent,
  FilterInputDirective,
  FilterMenuComponent,
  FilterMenuContainerComponent,
  FilterMenuDropDownListDirective,
  FilterMenuHostDirective,
  FilterMenuInputWrapperComponent,
  FilterMenuModule,
  FilterMenuTemplateDirective,
  FilterRowComponent,
  FilterService,
  FocusRoot,
  FocusableDirective,
  FooterComponent,
  FooterModule,
  FooterTemplateDirective2 as FooterTemplateDirective,
  GreaterFilterOperatorComponent,
  GreaterOrEqualToFilterOperatorComponent,
  GridClipboardDirective,
  GridComponent,
  GridModule,
  GridSpacerComponent,
  GridTableDirective,
  GridToolbarFocusableDirective,
  GridToolbarNavigationService,
  GroupBindingDirective,
  GroupFooterTemplateDirective2 as GroupFooterTemplateDirective,
  GroupHeaderColumnTemplateDirective2 as GroupHeaderColumnTemplateDirective,
  GroupHeaderComponent,
  GroupHeaderTemplateDirective2 as GroupHeaderTemplateDirective,
  GroupInfoService,
  GroupModule,
  GroupPanelComponent,
  GroupsService,
  HeaderComponent,
  HeaderModule,
  HeaderTemplateDirective,
  IdService,
  InCellEditingDirective,
  IsEmptyFilterOperatorComponent,
  IsNotEmptyFilterOperatorComponent,
  IsNotNullFilterOperatorComponent,
  IsNullFilterOperatorComponent,
  LessFilterOperatorComponent,
  LessOrEqualToFilterOperatorComponent,
  ListComponent,
  LoadingComponent,
  LoadingTemplateDirective,
  LocalDataChangesService,
  LogicalCellDirective,
  LogicalRowDirective,
  MenuTabbingService,
  NavigationService,
  NoRecordsTemplateDirective,
  NotEqualFilterOperatorComponent,
  NumericFilterCellComponent,
  NumericFilterComponent,
  NumericFilterMenuComponent,
  NumericFilterMenuInputComponent,
  PDFCommandDirective,
  PDFComponent,
  PDFMarginComponent,
  PDFModule,
  PDFService,
  PDFTemplateDirective,
  PagerComponent,
  PagerContextService,
  PagerDropDownListDirective,
  PagerInfoComponent,
  PagerInputComponent,
  PagerInputDirective,
  PagerModule,
  PagerNextButtonsComponent,
  PagerNumericButtonsComponent,
  PagerPageSizesComponent,
  PagerPrevButtonsComponent,
  PagerTemplateDirective,
  PopupCloseEvent,
  ReactiveEditingDirective,
  RemoveCommandDirective,
  ResizableContainerDirective,
  ResizeService,
  ResponsiveService,
  RowEditingDirectiveBase,
  RowFilterModule,
  RowReorderColumnComponent,
  RowReorderService,
  SaveCommandDirective,
  ScrollRequestService,
  ScrollSyncService,
  SelectAllCheckboxDirective,
  SelectionCheckboxDirective,
  SelectionDirective,
  SelectionService,
  SharedFilterModule,
  SharedModule,
  SinglePopupService,
  SizingOptionsService,
  Skip,
  SortService,
  SpanColumnComponent,
  StartsWithFilterOperatorComponent,
  StatusBarTemplateDirective,
  StringFilterCellComponent,
  StringFilterComponent,
  StringFilterMenuComponent,
  StringFilterMenuInputComponent,
  SuspendService,
  TableBodyComponent,
  TableDirective,
  TemplateContextDirective,
  TemplateEditingDirective,
  ToolbarComponent,
  ToolbarTemplateDirective,
  count2 as count,
  defaultTrackBy,
  hasFilterMenu,
  hasFilterRow,
  isFilterable,
  slice
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@progress_kendo-angular-grid.js.map
