import { createRequire } from 'module';const require = createRequire(import.meta.url);
import {
  class_default,
  color_default,
  drawing_exports,
  exportImage,
  exportSVG,
  geometry_exports,
  logToConsole,
  parseColor,
  support_default,
  throttle
} from "./chunk-OWBWA4Z6.js";
import {
  BreadCrumbComponent,
  BreadCrumbModule
} from "./chunk-HXU7MQLH.js";
import {
  IntlService
} from "./chunk-PJ5CPNHZ.js";
import {
  POPUP_CONTAINER,
  PopupModule,
  PopupService
} from "./chunk-JIDDKRYE.js";
import {
  ComponentMessages,
  L10N_PREFIX,
  LocalizationService
} from "./chunk-R34FYGCB.js";
import "./chunk-UVFYPAVO.js";
import {
  IconWrapperComponent,
  IconsModule
} from "./chunk-2GY5W5UB.js";
import {
  PreventableEvent,
  ResizeSensorComponent,
  ResizeSensorModule,
  WatermarkModule,
  WatermarkOverlayComponent,
  getter,
  isChanged,
  isDocumentAvailable,
  shouldShowValidationUI
} from "./chunk-UVZZJR6W.js";
import {
  validatePackage
} from "./chunk-6FRD3SAH.js";
import "./chunk-EOXLKPHL.js";
import {
  CommonModule,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgTemplateOutlet
} from "./chunk-DLGLBJGM.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  HostBinding,
  Inject,
  Injectable,
  InjectionToken,
  Input,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  Renderer2,
  SimpleChange,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  forwardRef,
  isDevMode,
  require_cjs,
  require_operators,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵproperty,
  ɵɵqueryRefresh,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery
} from "./chunk-DFLAVSOJ.js";
import {
  __toESM
} from "./chunk-LDODSSGN.js";

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var TAB = "Tab";
var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var ENTER = "Enter";
var ESCAPE = "Escape";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var INHERIT = "inherit";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var SQUARE = "square";
var RECT = "rect";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;
var POINTER = "pointer";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element, classes) {
  var classArray = isArray(classes) ? classes : [classes];
  for (var idx = 0; idx < classArray.length; idx++) {
    var className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  var offset = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset = 0;
    }
  }
  for (var i = 0; i < path.segments.length; i++) {
    path.segments[i].anchor().round(0).translate(offset, offset);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString(value2) {
  return typeof value2 === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value2) {
  return isNumber(value2) || isString(value2) && isFinite(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleUp.js
function cycleUp(index, count) {
  return (index + 1) % count;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleDown.js
function cycleDown(index, count) {
  var result = index - 1;
  return result < 0 ? count - 1 : result;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleIndex.js
function cycleIndex(index, length) {
  if (length === 1 || index % length === 0) {
    return 0;
  }
  if (index < 0) {
    return length + index % length;
  } else if (index >= length) {
    return index % length;
  }
  return index;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT2 = "object";
var UNDEFINED = "undefined";
function deepExtendOne(destination, source) {
  for (var property in source) {
    if (property === "__proto__" || property === "constructor") {
      continue;
    }
    var propValue = source[property];
    var propType = typeof propValue;
    var propInit = void 0;
    if (propType === OBJECT2 && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        var destProp = destination[property];
        if (typeof destProp === OBJECT2) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var i = 1; i < length; i++) {
    deepExtendOne(destination, arguments$1[i]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value2) {
  return typeof value2 === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value2) {
  if (isNumber(value2)) {
    return value2 + "px";
  }
  return value2;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles(element, styles) {
  var stylesArray = isString(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    var result = {};
    var style = window.getComputedStyle(element);
    for (var idx = 0; idx < stylesArray.length; idx++) {
      var field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (var field$1 in styles) {
      element.style[field$1] = styleValue(styles[field$1]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value2, defaultSpacing) {
  if (defaultSpacing === void 0) defaultSpacing = 0;
  var spacing = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  if (typeof value2 === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value2;
  } else {
    spacing[TOP] = value2[TOP] || defaultSpacing;
    spacing[RIGHT] = value2[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value2[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value2[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template2) {
    return template2;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template2, options) {
  return current.compile(template2, options);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options) {
  if (options === void 0) options = {};
  var template2;
  if (options.template) {
    options.template = template2 = template_service_default.compile(options.template);
  } else if (isFunction(options.content)) {
    template2 = options.content;
  }
  return template2;
}

// node_modules/@progress/kendo-charts/dist/es/common/get-aria-template.js
function getTemplate2(options) {
  if (options === void 0) options = {};
  var ariaTemplate;
  if (options.ariaTemplate) {
    options.ariaTemplate = ariaTemplate = template_service_default.compile(options.ariaTemplate);
  } else if (isFunction(options.ariaContent)) {
    ariaTemplate = options.ariaContent;
  }
  return ariaTemplate;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter2(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(drawing_exports.util.defined(index) ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
function grep(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element, classNames) {
  if (element.className) {
    var names = classNames.split(" ");
    for (var idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = function HashMap2() {
  this._map = /* @__PURE__ */ new Map();
};
HashMap.prototype.get = function get(key) {
  return this._map.get(key);
};
HashMap.prototype.set = function set(key, value2) {
  this._map.set(key, value2);
};
var hash_map_default = HashMap;

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value2, array) {
  if (array) {
    return array.indexOf(value2) !== -1;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = function InstanceObserver2(observer, handlers) {
  this.observer = observer;
  this.handlerMap = deepExtend({}, this.handlerMap, handlers);
};
InstanceObserver.prototype.trigger = function trigger(name2, args) {
  var ref2 = this;
  var observer = ref2.observer;
  var handlerMap = ref2.handlerMap;
  var isDefaultPrevented2;
  if (handlerMap[name2]) {
    isDefaultPrevented2 = this.callObserver(handlerMap[name2], args);
  } else if (observer[TRIGGER]) {
    isDefaultPrevented2 = this.callObserver(TRIGGER, name2, args);
  }
  return isDefaultPrevented2;
};
InstanceObserver.prototype.callObserver = function callObserver(fnName) {
  var args = [], len = arguments.length - 1;
  while (len-- > 0) args[len] = arguments[len + 1];
  return this.observer[fnName].apply(this.observer, args);
};
InstanceObserver.prototype.requiresHandlers = function requiresHandlers(names) {
  var this$1 = this;
  if (this.observer.requiresHandlers) {
    return this.observer.requiresHandlers(names);
  }
  for (var idx = 0; idx < names.length; idx++) {
    if (this$1.handlerMap[names[idx]]) {
      return true;
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/is-plain-object.js
function isPlainObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    var value2 = callback(array[idx]);
    if (drawing_exports.util.defined(value2)) {
      result.push(value2);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser = support_default.browser || {};
function mousewheelDelta(e) {
  var delta = 0;
  if (e.wheelDelta) {
    delta = -e.wheelDelta / 120;
    if (browser.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e.detail) {
    delta = e.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var ref = drawing_exports.util;
var append = ref.append;
var bindEvents = ref.bindEvents;
var defined = ref.defined;
var deg = ref.deg;
var elementOffset = ref.elementOffset;
var elementSize = ref.elementSize;
var eventCoordinates = ref.eventCoordinates;
var eventElement = ref.eventElement;
var hashKey = ref.hashKey;
var last = ref.last;
var limitValue = ref.limitValue;
var objectKey = ref.objectKey;
var rad = ref.rad;
var round = ref.round;
var unbindEvents = ref.unbindEvents;
var valueOrDefault = ref.valueOrDefault;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = function FontLoader2() {
};
FontLoader.fetchFonts = function fetchFonts(options, fonts, state) {
  if (state === void 0) state = {
    depth: 0
  };
  var MAX_DEPTH = 5;
  if (!options || state.depth > MAX_DEPTH || !document.fonts) {
    return;
  }
  Object.keys(options).forEach(function(key) {
    var value2 = options[key];
    if (key === "dataSource" || key[0] === "$" || !value2) {
      return;
    }
    if (key === "font") {
      fonts.push(value2);
    } else if (typeof value2 === "object") {
      state.depth++;
      FontLoader.fetchFonts(value2, fonts, state);
      state.depth--;
    }
  });
};
FontLoader.loadFonts = function loadFonts(fonts, callback) {
  var promises = [];
  if (fonts.length > 0 && document.fonts) {
    try {
      promises = fonts.map(function(font2) {
        return document.fonts.load(font2);
      });
    } catch (e) {
      logToConsole(e);
    }
    Promise.all(promises).then(callback, callback);
  } else {
    callback();
  }
};
FontLoader.preloadFonts = function preloadFonts(options, callback) {
  var fonts = [];
  FontLoader.fetchFonts(options, fonts);
  FontLoader.loadFonts(fonts, callback);
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options) {
  var proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options);
  } else {
    proto.options = options;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/render-icon.js
var KICON = "k-icon";
var KI_PREFFIX = "k-i-";
var KFONTICON = "k-font-icon";
var KSVGICON = "k-svg-icon";
var KSVG_PREFFIX = "k-svg-i-";
var HTMLBaseIcon = function HTMLBaseIcon2(element, options) {
  this.element = element;
  this.options = deepExtend({}, this.options, options);
  this.wrapper();
};
HTMLBaseIcon.prototype.wrapper = function wrapper() {
  this.addClasses();
};
HTMLBaseIcon.prototype.addClasses = function addClasses() {
};
HTMLBaseIcon.prototype.html = function html() {
  return this.element.outerHTML;
};
setDefaultOptions(HTMLBaseIcon, {
  name: "",
  size: "none",
  themeColor: "none",
  flip: "default",
  iconClass: "",
  stylingOptions: ["size", "themeColor", "fill"]
});
var HTMLFontIcon = function(HTMLBaseIcon3) {
  function HTMLFontIcon2(element, options) {
    HTMLBaseIcon3.call(this, element, options);
  }
  if (HTMLBaseIcon3) HTMLFontIcon2.__proto__ = HTMLBaseIcon3;
  HTMLFontIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLFontIcon2.prototype.constructor = HTMLFontIcon2;
  HTMLFontIcon2.prototype.wrapper = function wrapper2() {
    var currentIconClass = this.element.className.split(" ").find(function(x) {
      return x.startsWith(KI_PREFFIX);
    });
    var className = this.options.icon ? "" + (this.options.icon.startsWith(KI_PREFFIX) ? "" : KI_PREFFIX) + this.options.icon : "";
    this._className = className;
    addClass(this.element, KICON);
    addClass(this.element, KFONTICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, this.options.iconClass || "");
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLFontIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLFontIcon, {
  name: "HTMLFontIcon",
  icon: null
});
var HTMLSvgIcon = function(HTMLBaseIcon3) {
  function HTMLSvgIcon2(element, options) {
    element.innerHTML = "";
    HTMLBaseIcon3.call(this, element, options);
  }
  if (HTMLBaseIcon3) HTMLSvgIcon2.__proto__ = HTMLBaseIcon3;
  HTMLSvgIcon2.prototype = Object.create(HTMLBaseIcon3 && HTMLBaseIcon3.prototype);
  HTMLSvgIcon2.prototype.constructor = HTMLSvgIcon2;
  HTMLSvgIcon2.prototype.wrapper = function wrapper2() {
    var icon = this.options.icon;
    var iconClass = this.options.iconClass;
    var currentIconClass = this.element.className.split(" ").find(function(x) {
      return x.startsWith(KSVG_PREFFIX);
    });
    if (!icon && iconClass) {
      var regex = /k-i-(\w+(?:-\w+)*)/;
      var iconNameMatch = iconClass.match(regex);
      if (iconNameMatch) {
        icon = iconNameMatch[1];
        iconClass = iconClass.replace(iconNameMatch[0], "");
      }
    }
    if (isString(icon)) {
      icon = icon.replace("k-i-", "").replace(/-./g, function(x) {
        return x[1].toUpperCase();
      });
      icon = this.options.svgIcons[icon] || this.options.svgIcons[icon + "Icon"];
    }
    var className = icon && icon.name ? "" + KSVG_PREFFIX + icon.name : "";
    this._className = className;
    addClass(this.element, KSVGICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, iconClass || "");
    this.element.setAttribute("aria-hidden", "true");
    if (icon && isPlainObject(icon)) {
      var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgElement.setAttribute("viewBox", icon.viewBox || "");
      svgElement.setAttribute("focusable", "false");
      svgElement.innerHTML = icon.content || "";
      this.element.appendChild(svgElement);
    }
    HTMLBaseIcon3.prototype.wrapper.call(this);
  };
  return HTMLSvgIcon2;
}(HTMLBaseIcon);
setDefaultOptions(HTMLSvgIcon, {
  name: "HTMLSvgIcon",
  icon: null,
  svgIcons: {}
});
var ICON_TYPES = {
  "svg": HTMLSvgIcon,
  "font": HTMLFontIcon
};
function renderIcon(iconElement, iconOptions) {
  var element = iconElement;
  var options = iconOptions;
  if (!element || isObject(element) && !(element instanceof HTMLElement) || isString(element)) {
    options = element;
    element = document.createElement("span");
  }
  if (isString(options)) {
    options = {
      icon: options
    };
  }
  if (!options.type) {
    options.type = "svg";
  }
  if (!ICON_TYPES[options.type]) {
    return null;
  }
  return new ICON_TYPES[options.type](element, options).html();
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  var min4 = MAX_VALUE;
  var max3 = MIN_VALUE;
  for (var idx = 0, length = arr.length; idx < length; idx++) {
    var value2 = arr[idx];
    if (value2 !== null && isFinite(value2)) {
      min4 = Math.min(min4, value2);
      max3 = Math.max(max3, value2);
    }
  }
  return {
    min: min4 === MAX_VALUE ? void 0 : min4,
    max: max3 === MIN_VALUE ? void 0 : max3
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix = geometry_exports.Matrix;
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return Matrix.unit();
  }
  var members = match[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(Matrix, [null].concat(members)))();
}
function transformMatrix(element) {
  var transform = getComputedStyle(element).transform;
  if (transform === "none") {
    return Matrix.unit();
  }
  return parseMatrix(transform);
}
function elementScale(element) {
  if (!element) {
    return Matrix.unit();
  }
  var matrix = transformMatrix(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  var isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = function LegacySet2(values5) {
  var this$1 = this;
  this._index = {};
  this._values = values5 ? values5.slice(0) : [];
  for (var i = 0; i < this._values.length; i++) {
    this$1._index[this$1._values[i]] = i;
  }
};
var prototypeAccessors = {
  size: {
    configurable: true
  }
};
LegacySet.prototype.values = function values() {
  return this._values.filter(function(item) {
    return item !== DELETED;
  });
};
LegacySet.prototype.has = function has(value2) {
  return this._index[value2] !== void 0;
};
LegacySet.prototype.add = function add(value2) {
  if (!this.has(value2)) {
    this._index[value2] = this._values.length;
    this._values.push(value2);
  }
};
LegacySet.prototype.delete = function delete$1(value2) {
  var index = this._index[value2];
  if (index !== void 0) {
    this._values[index] = DELETED;
    delete this._index[value2];
  }
};
LegacySet.prototype.clear = function clear() {
  this._index = {};
  this._values = [];
};
prototypeAccessors.size.get = function() {
  return this._values.length;
};
Object.defineProperties(LegacySet.prototype, prototypeAccessors);
var SetWrapper = function SetWrapper2(values5) {
  this._set = new Set(values5);
};
var prototypeAccessors$1 = {
  size: {
    configurable: true
  }
};
SetWrapper.prototype.values = function values2() {
  return Array.from(this._set);
};
SetWrapper.prototype.has = function has2(value2) {
  return this._set.has(value2);
};
SetWrapper.prototype.add = function add2(value2) {
  this._set.add(value2);
};
SetWrapper.prototype.delete = function delete$2(value2) {
  this._set.delete(value2);
};
SetWrapper.prototype.clear = function clear2() {
  this._set.clear();
};
prototypeAccessors$1.size.get = function() {
  return this._set.size;
};
Object.defineProperties(SetWrapper.prototype, prototypeAccessors$1);
var supportsSet = function() {
  var supported = false;
  if (typeof Set === "function") {
    var set3 = /* @__PURE__ */ new Set([1]);
    supported = set3.has(1);
  }
  return supported;
};
function createHashSet(values5) {
  if (supportsSet()) {
    return new SetWrapper(values5);
  }
  return new LegacySet(values5);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error) {
  throw error;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/common/has-own-property.js
function hasOwnProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

// node_modules/@progress/kendo-charts/dist/es/common/matrix.js
var Matrix2 = function Matrix3() {
  this.height = 0;
  this.width = 0;
  this.data = [];
};
Matrix2.prototype.clone = function clone() {
  var m = new Matrix2();
  m.height = this.height;
  m.width = this.width;
  m.data = this.data.map(function(row) {
    return row.slice();
  });
  return m;
};
Matrix2.prototype.get = function get2(row, col) {
  var line = this.data[row];
  var val = line ? line[col] : null;
  return val;
};
Matrix2.prototype.set = function set2(row, col, data) {
  var line = this.data[row];
  if (line == null) {
    line = this.data[row] = [];
  }
  line[col] = data;
  if (row >= this.height) {
    this.height = row + 1;
  }
  if (col >= this.width) {
    this.width = col + 1;
  }
};
Matrix2.prototype.each = function each(f, includeEmpty) {
  var this$1 = this;
  for (var row = 0; row < this.height; ++row) {
    for (var col = 0; col < this.width; ++col) {
      var val = this$1.get(row, col);
      if (includeEmpty || val != null) {
        val = f(val, row, col);
        if (val !== void 0) {
          return val;
        }
      }
    }
  }
};
Matrix2.prototype.map = function map2(f, includeEmpty) {
  var m = new Matrix2();
  this.each(function(el, row, col) {
    m.set(row, col, f(el, row, col));
  }, includeEmpty);
  return m;
};
Matrix2.prototype.transpose = function transpose() {
  var m = new Matrix2();
  this.each(function(el, row, col) {
    m.set(col, row, el);
  });
  return m;
};
Matrix2.prototype.unit = function unit(n) {
  this.width = this.height = n;
  var a = this.data = new Array(n);
  for (var i = n; --i >= 0; ) {
    var row = a[i] = new Array(n);
    for (var j = n; --j >= 0; ) {
      row[j] = i === j ? 1 : 0;
    }
  }
  return this;
};
Matrix2.prototype.multiply = function multiply(b) {
  var a = this;
  var m = new Matrix2();
  for (var row = 0; row < a.height; ++row) {
    for (var col = 0; col < b.width; ++col) {
      var s = 0;
      for (var i = 0; i < a.width; ++i) {
        var va = a.get(row, i);
        var vb = b.get(i, col);
        if (typeof va === "number" && typeof vb === "number") {
          s += va * vb;
        }
      }
      m.set(row, col, s);
    }
  }
  return m;
};
Matrix2.prototype.inverse = function inverse() {
  var n = this.width;
  var m = this.augment(new Matrix2().unit(n));
  var a = m.data;
  var loop = function(k2) {
    var imax = argmax(k2, n, function(i2) {
      return a[i2][k2];
    });
    if (!a[imax][k2]) {
      return {
        v: null
      };
    }
    if (k2 !== imax) {
      var tmp = a[k2];
      a[k2] = a[imax];
      a[imax] = tmp;
    }
    for (var i = k2 + 1; i < n; ++i) {
      for (var j = k2 + 1; j < 2 * n; ++j) {
        a[i][j] -= a[k2][j] * a[i][k2] / a[k2][k2];
      }
      a[i][k2] = 0;
    }
  };
  for (var k = 0; k < n; ++k) {
    var returned = loop(k);
    if (returned) return returned.v;
  }
  for (var i$1 = 0; i$1 < n; ++i$1) {
    for (var f = a[i$1][i$1], j$1 = 0; j$1 < 2 * n; ++j$1) {
      a[i$1][j$1] /= f;
    }
  }
  for (var k$1 = n; --k$1 >= 0; ) {
    for (var i$2 = k$1; --i$2 >= 0; ) {
      if (a[i$2][k$1]) {
        for (var j$2 = 2 * n; --j$2 >= n; ) {
          a[i$2][j$2] -= a[k$1][j$2] * a[i$2][k$1];
        }
      }
    }
  }
  return m.slice(0, n, n, n);
};
Matrix2.prototype.augment = function augment(m) {
  var ret = this.clone();
  var n = ret.width;
  m.each(function(val, row, col) {
    ret.set(row, col + n, val);
  });
  return ret;
};
Matrix2.prototype.slice = function slice(row, col, height, width) {
  var this$1 = this;
  var m = new Matrix2();
  for (var i = 0; i < height; ++i) {
    for (var j = 0; j < width; ++j) {
      m.set(i, j, this$1.get(row + i, col + j));
    }
  }
  return m;
};
function argmax(start, end, f) {
  var max3 = f(start), pos = start;
  for (var i = start + 1; i < end; i++) {
    var v = f(start);
    if (v > max3) {
      max3 = v;
      pos = start;
    }
  }
  return pos;
}
var matrix_default = Matrix2;

// node_modules/@progress/kendo-charts/dist/es/common/event-map.js
var eventMap = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup",
  cancel: "pointercancel pointerleave"
};
function queryEventMap(e) {
  return eventMap[e] || e;
}
var applyEventMap = function(events) {
  var eventRegEx = /([^ ]+)/g;
  var appliedEvents = events.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};

// node_modules/@progress/kendo-charts/dist/es/core/utils/guid.js
function guid() {
  var id = "";
  var i;
  var random;
  for (i = 0; i < 32; i++) {
    random = Math.random() * 16 | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) {
      id += "-";
    }
    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id;
}

// node_modules/@progress/kendo-charts/dist/es/common/event-utils.js
var elementEventHandlers = /* @__PURE__ */ new WeakMap();
var ID = Symbol("id");
function on(element, events, filter, handler, useCapture) {
  addEventListeners(element, events, filter, handler, useCapture);
}
function off(element, events, filter, handler, useCapture) {
  removeEventListeners(element, events, filter, handler, useCapture);
}
function isString2(value2) {
  return typeof value2 === "string";
}
function addEventListeners(element, events, filter, handler, useCapture) {
  var eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
}
function addEventListener(element, event, filter, handler, useCapture) {
  var eventHandler = handler;
  var eventFilter;
  if (filter && isFunction(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString2(filter) && isFunction(eventHandler)) {
    eventFilter = filter;
  }
  var attachedHandler = function(e) {
    var closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e.target && closestMatchingTarget) {
      var currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;
      Object.defineProperty(e, "currentTarget", {
        value: currentTarget
      });
      Object.defineProperty(e, "delegateTarget", {
        value: element
      });
      eventHandler(e);
    }
  };
  eventHandler[ID] = guid();
  var eventHandlers = elementEventHandlers.get(element);
  if (!eventHandlers) {
    eventHandlers = /* @__PURE__ */ new Map();
    elementEventHandlers.set(element, eventHandlers);
  }
  eventHandlers.set(eventHandler[ID], attachedHandler);
  element.addEventListener(event, attachedHandler, Boolean(useCapture));
}
function removeEventListeners(element, events, handler, useCapture) {
  var eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
}
function removeEventListener(element, event, handler, useCapture) {
  var eventHandlers = elementEventHandlers.get(element);
  if (eventHandlers && handler && handler[ID]) {
    var handlerId = handler[ID];
    var attachedHandler = eventHandlers.get(handlerId);
    eventHandlers.delete(handlerId);
    if (attachedHandler) {
      element.removeEventListener(event, attachedHandler, Boolean(useCapture));
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-supported-features.js
function getSupportedFeatures() {
  var os = detectOS(navigator.userAgent);
  var support = {};
  support.mobileOS = os;
  return support;
}
function detectOS(ua) {
  var os = false;
  var agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i
  };
  for (var agent in agentRxs) {
    var match = ua.match(agentRxs[agent]);
    if (match) {
      if (agent === "windows" && "plugins" in navigator) {
        return false;
      }
      os = {};
      os.device = agent;
      os.name = testRegex(agent, osRxs);
      os[os.name] = true;
      break;
    }
  }
  return os;
}
function testRegex(agent, regexes, dflt) {
  for (var regex in regexes) {
    if (regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}

// node_modules/@progress/kendo-charts/dist/es/common/noop.js
function noop() {
}

// node_modules/@progress/kendo-charts/dist/es/common/now.js
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}

// node_modules/@progress/kendo-charts/dist/es/common/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented = function() {
  return this._defaultPrevented === true;
};
var Observable = function(Class) {
  function Observable2() {
    Class.call(this);
    this._events = {};
  }
  if (Class) Observable2.__proto__ = Class;
  Observable2.prototype = Object.create(Class && Class.prototype);
  Observable2.prototype.constructor = Observable2;
  Observable2.prototype.destroy = function destroy() {
    this.unbind();
  };
  Observable2.prototype.bind = function bind(event, handlers, one) {
    var that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    var loop = function() {
      var eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events = that._events[eventName] = that._events[eventName] || [];
        events.push(handler);
      }
    };
    for (idx = 0, length = eventNames.length; idx < length; idx++) loop();
    return that;
  };
  Observable2.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable2.prototype.first = function first(eventName, handlers) {
    var that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        events = that._events[eventName$1] = that._events[eventName$1] || [];
        events.unshift(handler);
      }
    }
    return that;
  };
  Observable2.prototype.trigger = function trigger2(eventName, eventArgs) {
    var that = this, events = that._events[eventName], idx, length;
    if (events) {
      var e = eventArgs || {};
      e.sender = that;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events = events.slice();
      for (idx = 0, length = events.length; idx < length; idx++) {
        events[idx].call(that, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable2.prototype.unbind = function unbind(eventName, handler) {
    var that = this, events = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events) {
      if (handler) {
        for (idx = events.length - 1; idx >= 0; idx--) {
          if (events[idx] === handler || events[idx].original === handler) {
            events.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  };
  Observable2.prototype._setEvents = function _setEvents(options) {
    var this$1 = this;
    var length = (this.events || []).length;
    for (var idx = 0; idx < length; idx++) {
      var e = this$1.events[idx];
      if (this$1.options[e] && options[e]) {
        this$1.unbind(e, this$1.options[e]);
        if (this$1._events && this$1._events[e]) {
          delete this$1._events[e];
        }
      }
    }
    this.bind(this.events, options);
  };
  return Observable2;
}(class_default);
var observable_default = Observable;

// node_modules/@progress/kendo-charts/dist/es/common/user-events.js
var extend = Object.assign;
var preventDefault2 = function(e) {
  e.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT = "select";
var START2 = "start";
var MOVE = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  var x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e) {
  var touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget;
  if (e.api) {
    touches.push({
      id: 2,
      // hardcoded ID for API call
      event: e,
      target: e.target,
      currentTarget: e.target,
      location: e,
      type: "api"
    });
  } else {
    touches.push({
      location: originalEvent,
      event: e,
      target: e.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  }
  return touches;
}
var TouchAxis = function(Class) {
  function TouchAxis2(axis, location) {
    Class.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now();
  }
  if (Class) TouchAxis2.__proto__ = Class;
  TouchAxis2.prototype = Object.create(Class && Class.prototype);
  TouchAxis2.prototype.constructor = TouchAxis2;
  TouchAxis2.prototype.move = function move(location) {
    var that = this, offset = location["page" + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  };
  TouchAxis2.prototype._updateLocationData = function _updateLocationData(location) {
    var that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  };
  return TouchAxis2;
}(class_default);
var Touch = function(Class) {
  function Touch2(userEvents, target, touchInfo) {
    Class.call(this);
    extend(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  if (Class) Touch2.__proto__ = Class;
  Touch2.prototype = Object.create(Class && Class.prototype);
  Touch2.prototype.constructor = Touch2;
  Touch2.prototype.press = function press() {
    var this$1 = this;
    this._holdTimeout = setTimeout(function() {
      return this$1._hold();
    }, this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  };
  Touch2.prototype._tap = function _tap(touchInfo) {
    var that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  };
  Touch2.prototype._hold = function _hold() {
    this._trigger(HOLD, this.pressEvent);
  };
  Touch2.prototype.move = function move(touchInfo) {
    var that = this;
    var preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE, touchInfo);
    }
  };
  Touch2.prototype.end = function end(touchInfo) {
    this.endTime = now();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (this.supportDoubleTap) {
        this._tap(touchInfo);
      } else {
        this._trigger(TAP, touchInfo);
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  };
  Touch2.prototype.dispose = function dispose() {
    var userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    var activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  };
  Touch2.prototype.skip = function skip() {
    this.dispose();
  };
  Touch2.prototype.cancel = function cancel() {
    this.dispose();
  };
  Touch2.prototype.isMoved = function isMoved() {
    return this._moved;
  };
  Touch2.prototype._start = function _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now();
    this._moved = true;
    this._trigger(START2, touchInfo);
  };
  Touch2.prototype._trigger = function _trigger(name2, touchInfo) {
    var e = touchInfo.event;
    var data = {
      touch: this,
      x: this.x,
      y: this.y,
      target: this.target,
      event: e
    };
    if (this.userEvents.notify(name2, data)) {
      e.preventDefault();
    }
  };
  Touch2.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {
    var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  };
  return Touch2;
}(class_default);
function withEachUpEvent(callback) {
  var downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = function(Observable2) {
  function UserEvents2(element, options) {
    Observable2.call(this);
    var that = this;
    var filter;
    var support = getSupportedFeatures();
    this.support = support;
    options = options || {};
    this.options = options;
    filter = that.filter = options.filter;
    that.threshold = options.threshold || DEFAULT_THRESHOLD;
    that.minHold = options.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options.multiTouch ? 2 : 1;
    that.allowSelection = options.allowSelection;
    that.captureUpIfMoved = options.captureUpIfMoved;
    that._clicks = 0;
    that.supportDoubleTap = options.supportDoubleTap;
    extend(that, {
      element,
      surface: options.surface || element,
      stopPropagation: options.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = this._move.bind(this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = this._end.bind(this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = this._start.bind(this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    element.style["touch-action"] = options.touchAction || "none";
    if (options.preventDragEvent) {
      this._elementDragStartHandler = preventDefault2;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = this._select.bind(this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface, preventIfMovingProxy = that.preventIfMoving.bind(that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
      });
    }
    that.bind([PRESS, HOLD, TAP, DOUBLETAP, START2, MOVE, END2, RELEASE, CANCEL, GESTURESTART, GESTURECHANGE, GESTUREEND, GESTURETAP, SELECT], options);
  }
  if (Observable2) UserEvents2.__proto__ = Observable2;
  UserEvents2.prototype = Object.create(Observable2 && Observable2.prototype);
  UserEvents2.prototype.constructor = UserEvents2;
  UserEvents2.prototype.preventIfMoving = function preventIfMoving(e) {
    if (this._isMoved()) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype.destroy = function destroy() {
    var that = this;
    var options = this.options;
    var element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved) {
      var surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (options.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  };
  UserEvents2.prototype.capture = function capture() {
    UserEvents2.current = this;
  };
  UserEvents2.prototype.cancel = function cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  };
  UserEvents2.prototype.notify = function notify3(event, data) {
    var that = this, touches = that.touches;
    var eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend(data, {
      type: eventName
    }));
  };
  UserEvents2.prototype.press = function press(x, y, target) {
    this._apiCall("_start", x, y, target);
  };
  UserEvents2.prototype.move = function move(x, y) {
    this._apiCall("_move", x, y);
  };
  UserEvents2.prototype.end = function end(x, y) {
    this._apiCall("_end", x, y);
  };
  UserEvents2.prototype._isMultiTouch = function _isMultiTouch() {
    return this.touches.length > 1;
  };
  UserEvents2.prototype._maxTouchesReached = function _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  };
  UserEvents2.prototype._disposeAll = function _disposeAll() {
    var touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  };
  UserEvents2.prototype._isMoved = function _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  };
  UserEvents2.prototype._select = function _select(e) {
    if (!this.allowSelection || this.trigger(SELECT, {
      event: e
    })) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype._start = function _start(e) {
    var that = this, idx = 0, filter = that.filter, target, touches = getTouches(e), length = touches.length, touch, which = e.which;
    if (which && which > 1 || that._maxTouchesReached()) {
      return;
    }
    UserEvents2.current = null;
    that.currentTarget = e.currentTarget;
    if (that.stopPropagation) {
      e.stopPropagation();
    }
    for (; idx < length; idx++) {
      if (that._maxTouchesReached()) {
        break;
      }
      touch = touches[idx];
      if (filter) {
        target = touch.currentTarget;
      } else {
        target = that.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      touch = new Touch(that, target, touch);
      that.touches.push(touch);
      touch.press();
      if (that._isMultiTouch()) {
        that.notify("gesturestart", {});
      }
    }
  };
  UserEvents2.prototype._move = function _move(e) {
    this._eachTouch("move", e);
  };
  UserEvents2.prototype._end = function _end(e) {
    this._eachTouch("end", e);
  };
  UserEvents2.prototype._eachTouch = function _eachTouch(methodName, e) {
    var that = this, dict = {}, touches = getTouches(e), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        matchingTouch[methodName](touchInfo);
      }
    }
  };
  UserEvents2.prototype._apiCall = function _apiCall(type, x, y, target) {
    this[type]({
      api: true,
      pageX: x,
      pageY: y,
      clientX: x,
      clientY: y,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  };
  UserEvents2.defaultThreshold = function defaultThreshold(value2) {
    DEFAULT_THRESHOLD = value2;
  };
  UserEvents2.minHold = function minHold(value2) {
    DEFAULT_MIN_HOLD = value2;
  };
  return UserEvents2;
}(observable_default);
var user_events_default = UserEvents;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min4, max3) {
  var diff = round(max3 - min4, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max3 === 0) {
      return 0.1;
    }
    diff = Math.abs(max3);
  }
  var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  var relativeValue = round(diff / scale, DEFAULT_PRECISION);
  var scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point = function(Class) {
  function Point7(x, y) {
    Class.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (Class) Point7.__proto__ = Class;
  Point7.prototype = Object.create(Class && Class.prototype);
  Point7.prototype.constructor = Point7;
  Point7.prototype.clone = function clone3() {
    return new Point7(this.x, this.y);
  };
  Point7.prototype.equals = function equals(point) {
    return point && this.x === point.x && this.y === point.y;
  };
  Point7.prototype.rotate = function rotate(center, degrees) {
    var theta = rad(degrees);
    var cosT = Math.cos(theta);
    var sinT = Math.sin(theta);
    var cx = center.x;
    var cy = center.y;
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    this.x = round(cx + (x - cx) * cosT + (y - cy) * sinT, COORD_PRECISION);
    this.y = round(cy + (y - cy) * cosT - (x - cx) * sinT, COORD_PRECISION);
    return this;
  };
  Point7.prototype.multiply = function multiply2(a) {
    this.x *= a;
    this.y *= a;
    return this;
  };
  Point7.prototype.distanceTo = function distanceTo(point) {
    var dx = this.x - point.x;
    var dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point7.onCircle = function onCircle(center, angle, radius) {
    var radians = rad(angle);
    return new Point7(center.x - radius * Math.cos(radians), center.y - radius * Math.sin(radians));
  };
  return Point7;
}(class_default);
var point_default = Point;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = function(Class) {
  function Box2(x1, y1, x2, y2) {
    Class.call(this);
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x2 || 0;
    this.y2 = y2 || 0;
  }
  if (Class) Box2.__proto__ = Class;
  Box2.prototype = Object.create(Class && Class.prototype);
  Box2.prototype.constructor = Box2;
  Box2.prototype.equals = function equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  };
  Box2.prototype.width = function width() {
    return this.x2 - this.x1;
  };
  Box2.prototype.height = function height() {
    return this.y2 - this.y1;
  };
  Box2.prototype.translate = function translate2(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  };
  Box2.prototype.move = function move(x, y) {
    var height = this.height();
    var width = this.width();
    if (defined(x)) {
      this.x1 = x;
      this.x2 = this.x1 + width;
    }
    if (defined(y)) {
      this.y1 = y;
      this.y2 = this.y1 + height;
    }
    return this;
  };
  Box2.prototype.wrap = function wrap(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  };
  Box2.prototype.wrapPoint = function wrapPoint(point) {
    var arrayPoint = isArray(point);
    var x = arrayPoint ? point[0] : point.x;
    var y = arrayPoint ? point[1] : point.y;
    this.wrap(new Box2(x, y, x, y));
    return this;
  };
  Box2.prototype.snapTo = function snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  };
  Box2.prototype.alignTo = function alignTo(targetBox, anchor) {
    var height = this.height();
    var width = this.width();
    var axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    var offset = axis === Y ? height : width;
    if (anchor === CENTER) {
      var targetCenter = targetBox.center();
      var center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.shrink = function shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  };
  Box2.prototype.expand = function expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  };
  Box2.prototype.pad = function pad2(padding) {
    var spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  };
  Box2.prototype.unpad = function unpad2(padding) {
    var spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  };
  Box2.prototype.clone = function clone3() {
    return new Box2(this.x1, this.y1, this.x2, this.y2);
  };
  Box2.prototype.center = function center() {
    return new point_default(this.x1 + this.width() / 2, this.y1 + this.height() / 2);
  };
  Box2.prototype.containsPoint = function containsPoint(point) {
    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;
  };
  Box2.prototype.points = function points() {
    return [new point_default(this.x1, this.y1), new point_default(this.x2, this.y1), new point_default(this.x2, this.y2), new point_default(this.x1, this.y2)];
  };
  Box2.prototype.getHash = function getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  };
  Box2.prototype.overlaps = function overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  };
  Box2.prototype.rotate = function rotate(rotation) {
    var width = this.width();
    var height = this.height();
    var ref2 = this.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var r1 = rotatePoint(0, 0, cx, cy, rotation);
    var r2 = rotatePoint(width, 0, cx, cy, rotation);
    var r3 = rotatePoint(width, height, cx, cy, rotation);
    var r4 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);
    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.toRect = function toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  };
  Box2.prototype.hasSize = function hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  };
  Box2.prototype.align = function align(targetBox, axis, alignment) {
    var c1 = axis + 1;
    var c2 = axis + 2;
    var sizeFunc = axis === X ? WIDTH : HEIGHT;
    var size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c2] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c2] = targetBox[c2];
      this[c1] = this[c2] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c2] = this[c1] + size;
    }
  };
  return Box2;
}(class_default);
function rotatePoint(x, y, cx, cy, angle) {
  var theta = rad(angle);
  return new point_default(cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta), cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta));
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = function(Class) {
  function Ring2(center, innerRadius, radius, startAngle, angle) {
    Class.call(this);
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  if (Class) Ring2.__proto__ = Class;
  Ring2.prototype = Object.create(Class && Class.prototype);
  Ring2.prototype.constructor = Ring2;
  Ring2.prototype.clone = function clone3() {
    return new Ring2(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  };
  Ring2.prototype.middle = function middle() {
    return this.startAngle + this.angle / 2;
  };
  Ring2.prototype.setRadius = function setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  };
  Ring2.prototype.point = function point(angle, innerRadius) {
    var radianAngle = rad(angle);
    var ax = Math.cos(radianAngle);
    var ay = Math.sin(radianAngle);
    var radius = innerRadius ? this.innerRadius : this.radius;
    var x = round(this.center.x - ax * radius, COORD_PRECISION);
    var y = round(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default(x, y);
  };
  Ring2.prototype.adjacentBox = function adjacentBox(distance, width, height) {
    var sector = this.clone().expand(distance);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    var hw = width / 2;
    var hh = height / 2;
    var sa = Math.sin(rad(midAndle));
    var ca = Math.cos(rad(midAndle));
    var x = midPoint.x - hw;
    var y = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y += hh * -sa / Math.abs(sa);
    }
    return new box_default(x, y, x + width, y + height);
  };
  Ring2.prototype.containsPoint = function containsPoint(p) {
    var center = this.center;
    var innerRadius = this.innerRadius;
    var radius = this.radius;
    var startAngle = this.startAngle;
    var endAngle = this.startAngle + this.angle;
    var dx = p.x - center.x;
    var dy = p.y - center.y;
    var vector = new point_default(dx, dy);
    var startPoint = this.point(startAngle);
    var startVector = new point_default(startPoint.x - center.x, startPoint.y - center.y);
    var endPoint = this.point(endAngle);
    var endVector = new point_default(endPoint.x - center.x, endPoint.y - center.y);
    var dist = round(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  };
  Ring2.prototype.getBBox = function getBBox() {
    var this$1 = this;
    var box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    var startAngle = round(this.startAngle % 360);
    var endAngle = round((startAngle + this.angle) % 360);
    var innerRadius = this.innerRadius;
    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    var startAngleIndex = allAngles.indexOf(startAngle);
    var endAngleIndex = allAngles.indexOf(endAngle);
    var angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));
      }
    }
    for (var i = 0; i < angles.length; i++) {
      var point = this$1.point(angles[i]);
      box.wrapPoint(point);
      box.wrapPoint(point, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  };
  Ring2.prototype.expand = function expand(value2) {
    this.radius += value2;
    return this;
  };
  return Ring2;
}(class_default);
function numericComparer(a, b) {
  return a - b;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/sector.js
var Sector = function(Ring2) {
  function Sector2(center, radius, startAngle, angle) {
    Ring2.call(this, center, 0, radius, startAngle, angle);
  }
  if (Ring2) Sector2.__proto__ = Ring2;
  Sector2.prototype = Object.create(Ring2 && Ring2.prototype);
  Sector2.prototype.constructor = Sector2;
  Sector2.prototype.expand = function expand(value2) {
    return Ring2.prototype.expand.call(this, value2);
  };
  Sector2.prototype.clone = function clone3() {
    return new Sector2(this.center, this.radius, this.startAngle, this.angle);
  };
  Sector2.prototype.setRadius = function setRadius(newRadius) {
    this.radius = newRadius;
    return this;
  };
  return Sector2;
}(ring_default);

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = function(Class) {
  function ShapeBuilder2() {
    Class.apply(this, arguments);
  }
  if (Class) ShapeBuilder2.__proto__ = Class;
  ShapeBuilder2.prototype = Object.create(Class && Class.prototype);
  ShapeBuilder2.prototype.constructor = ShapeBuilder2;
  ShapeBuilder2.prototype.createRing = function createRing(sector, options) {
    var startAngle = sector.startAngle + 180;
    var endAngle = sector.angle + startAngle;
    if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    var center = new geometry_exports.Point(sector.center.x, sector.center.y);
    var radius = Math.max(sector.radius, 0);
    var innerRadius = Math.max(sector.innerRadius, 0);
    var arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    var path = drawing_exports.Path.fromArc(arc, options).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      var innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  };
  return ShapeBuilder2;
}(class_default);
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = function(Class) {
  function ChartElement2(options) {
    Class.call(this);
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options));
  }
  if (Class) ChartElement2.__proto__ = Class;
  ChartElement2.prototype = Object.create(Class && Class.prototype);
  ChartElement2.prototype.constructor = ChartElement2;
  ChartElement2.prototype.initUserOptions = function initUserOptions(options) {
    return options;
  };
  ChartElement2.prototype.reflow = function reflow(targetBox) {
    var children = this.children;
    var box;
    for (var i = 0; i < children.length; i++) {
      var currentChild = children[i];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  };
  ChartElement2.prototype.destroy = function destroy() {
    var children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
  };
  ChartElement2.prototype.getRoot = function getRoot() {
    var parent = this.parent;
    return parent ? parent.getRoot() : null;
  };
  ChartElement2.prototype.getSender = function getSender() {
    var service = this.getService();
    if (service) {
      return service.sender;
    }
  };
  ChartElement2.prototype.getService = function getService() {
    var element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  };
  ChartElement2.prototype.translateChildren = function translateChildren(dx, dy) {
    var children = this.children;
    var childrenCount = children.length;
    for (var i = 0; i < childrenCount; i++) {
      children[i].box.translate(dx, dy);
    }
  };
  ChartElement2.prototype.append = function append2() {
    var arguments$1 = arguments;
    var this$1 = this;
    for (var i = 0; i < arguments.length; i++) {
      var item = arguments$1[i];
      this$1.children.push(item);
      item.parent = this$1;
    }
  };
  ChartElement2.prototype.renderVisual = function renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  };
  ChartElement2.prototype.addVisual = function addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  };
  ChartElement2.prototype.renderChildren = function renderChildren() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      children[i].renderVisual();
    }
  };
  ChartElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault(this.options.visible, true)
    });
  };
  ChartElement2.prototype.createAnimation = function createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(this.visual, this.options.animation);
    }
  };
  ChartElement2.prototype.appendVisual = function appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  };
  ChartElement2.prototype.clipRoot = function clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackRoot = function stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackVisual = function stackVisual(childVisual) {
    var zIndex = childVisual.options.zIndex || 0;
    var visuals = this.visual.children;
    var length = visuals.length;
    var pos;
    for (pos = 0; pos < length; pos++) {
      var sibling = visuals[pos];
      var here = valueOrDefault(sibling.options.zIndex, 0);
      if (here > zIndex) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  };
  ChartElement2.prototype.traverse = function traverse(callback) {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      var child = children[i];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  };
  ChartElement2.prototype.closest = function closest(match) {
    var element = this;
    var matched = false;
    while (element && !matched) {
      matched = match(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  };
  ChartElement2.prototype.renderComplete = function renderComplete() {
  };
  ChartElement2.prototype.hasHighlight = function hasHighlight() {
    var options = (this.options || {}).highlight;
    return !(!this.createHighlight || options && options.visible === false || this.visible === false);
  };
  ChartElement2.prototype.toggleHighlight = function toggleHighlight(show2, opacity) {
    var this$1 = this;
    var options = (this.options || {}).highlight || {};
    var customVisual = options.visual;
    var highlight = this._highlight;
    if (!highlight) {
      var highlightOptions2 = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(Object.assign(this.highlightVisualArgs(), {
          createVisual: function() {
            return this$1.createHighlight(highlightOptions2);
          },
          sender: this.getSender(),
          series: this.series,
          dataItem: this.dataItem,
          category: this.category,
          value: this.value,
          percentage: this.percentage,
          runningTotal: this.runningTotal,
          total: this.total
        }));
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions2);
      }
      if (!defined(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  };
  ChartElement2.prototype.toggleFocusHighlight = function toggleFocusHighlight(show2) {
    var options = ((this.options || {}).accessibility || {}).highlight || {};
    var focusHighlight = this._focusHighlight;
    if (!show2 && !focusHighlight) {
      return;
    }
    if (!focusHighlight) {
      var rootBackground = this.getRoot().options.background;
      var highlightColor = auto_text_color_default(rootBackground);
      var focusHighlightOptions = {
        fill: {
          opacity: options.opacity,
          color: options.color
        },
        stroke: Object.assign({}, {
          color: highlightColor
        }, options.border),
        zIndex: options.zIndex
      };
      focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);
      this.appendVisual(focusHighlight);
    }
    focusHighlight.visible(show2);
  };
  ChartElement2.prototype.createGradientOverlay = function createGradientOverlay(element, options, gradientOptions) {
    var overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  };
  ChartElement2.prototype.createGradient = function createGradient(options) {
    if (this.parent) {
      return this.parent.createGradient(options);
    }
  };
  ChartElement2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return true;
  };
  return ChartElement2;
}(class_default);
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = function(ChartElement2) {
  function BoxElement2(options) {
    ChartElement2.call(this, options);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  if (ChartElement2) BoxElement2.__proto__ = ChartElement2;
  BoxElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BoxElement2.prototype.constructor = BoxElement2;
  BoxElement2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options = this.options;
    var width = options.width;
    var height = options.height;
    var shrinkToFit = options.shrinkToFit;
    var hasSetSize = width && height;
    var margin = options.margin;
    var padding = options.padding;
    var borderWidth = options.border.width;
    var box;
    var reflowPaddingBox = function() {
      this$1.align(targetBox, X, options.align);
      this$1.align(targetBox, Y, options.vAlign);
      this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    var contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    ChartElement2.prototype.reflow.call(this, contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left, box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top);
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      var item = children[i];
      item.reflow(item.box);
    }
  };
  BoxElement2.prototype.align = function align(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  };
  BoxElement2.prototype.hasBox = function hasBox() {
    var options = this.options;
    return options.border.width || options.background;
  };
  BoxElement2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options;
    if (options.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle()));
    }
  };
  BoxElement2.prototype.visualStyle = function visualStyle() {
    var options = this.options;
    var border = options.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      cursor: options.cursor
    };
  };
  return BoxElement2;
}(chart_element_default);
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/utils/add-accessibility-attributes-to-visual.js
function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {
  if (accessibilityOptions) {
    visual.options.className = accessibilityOptions.className;
    visual.options.role = accessibilityOptions.role;
    visual.options.ariaLabel = accessibilityOptions.ariaLabel;
    visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;
    visual.options.ariaChecked = accessibilityOptions.ariaChecked;
  }
}

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = function(BoxElement2) {
  function ShapeElement2(options, pointData) {
    BoxElement2.call(this, options);
    this.pointData = pointData;
  }
  if (BoxElement2) ShapeElement2.__proto__ = BoxElement2;
  ShapeElement2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  ShapeElement2.prototype.constructor = ShapeElement2;
  ShapeElement2.prototype.getElement = function getElement() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.paddingBox;
    var type = options.type;
    var rotation = options.rotation;
    var center = box.center();
    var halfWidth = box.width() / 2;
    var halfHeight = box.height() / 2;
    if (!options.visible || !this.hasBox()) {
      return null;
    }
    var style = this.visualStyle();
    var element;
    if (type === CIRCLE) {
      element = new drawing_exports.Circle(new geometry_exports.Circle([round(box.x1 + halfWidth, COORD_PRECISION), round(box.y1 + halfHeight, COORD_PRECISION)], Math.min(halfWidth, halfHeight)), style);
    } else if (type === TRIANGLE) {
      element = drawing_exports.Path.fromPoints([[box.x1 + halfWidth, box.y1], [box.x1, box.y2], [box.x2, box.y2]], style).close();
    } else if (type === CROSS) {
      element = new drawing_exports.MultiPath(style);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      var rect = box.toRect();
      if (type === ROUNDED_RECT) {
        var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element.transform(geometry_exports.transform().rotate(-rotation, [center.x, center.y]));
    }
    element.options.zIndex = options.zIndex;
    return element;
  };
  ShapeElement2.prototype.createElement = function createElement() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var pointData = this.pointData || {};
    var visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  ShapeElement2.prototype.visualOptions = function visualOptions() {
    var options = this.options;
    return {
      background: options.background,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      type: options.type,
      size: options.width,
      visible: options.visible
    };
  };
  ShapeElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
    addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);
  };
  return ShapeElement2;
}(box_element_default);
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r, s) {
  if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {
    return s;
  }
  var a = Math.min(r.x1, s.x1);
  var b = Math.max(r.x1, s.x1);
  var c = Math.min(r.x2, s.x2);
  var d = Math.max(r.x2, s.x2);
  var e = Math.min(r.y1, s.y1);
  var f = Math.max(r.y1, s.y1);
  var g = Math.min(r.y2, s.y2);
  var h = Math.max(r.y2, s.y2);
  var boxes = [];
  boxes[0] = new box_default(b, e, c, f);
  boxes[1] = new box_default(a, f, b, g);
  boxes[2] = new box_default(c, f, d, g);
  boxes[3] = new box_default(b, g, c, h);
  if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) {
    boxes[4] = new box_default(a, e, b, f);
    boxes[5] = new box_default(c, g, d, h);
  } else {
    boxes[4] = new box_default(c, e, d, f);
    boxes[5] = new box_default(a, g, b, h);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = function(ChartElement2) {
  function RootElement2(options) {
    ChartElement2.call(this, options);
    var rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  if (ChartElement2) RootElement2.__proto__ = ChartElement2;
  RootElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RootElement2.prototype.constructor = RootElement2;
  RootElement2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var currentBox = new box_default(0, 0, options.width, options.height);
    this.box = currentBox.unpad(options.margin);
    for (var i = 0; i < children.length; i++) {
      children[i].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i].box) || new box_default();
    }
  };
  RootElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  };
  RootElement2.prototype.createBackground = function createBackground() {
    var options = this.options;
    var border = options.border || {};
    var box = this.box.clone().pad(options.margin).unpad(border.width);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  };
  RootElement2.prototype.getRoot = function getRoot() {
    return this;
  };
  RootElement2.prototype.createGradient = function createGradient(options) {
    var gradients = this.gradients;
    var hashCode = objectKey(options);
    var gradient = gradients_default[options.gradient];
    var drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      var gradientOptions = Object.assign({}, gradient, options);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  };
  RootElement2.prototype.cleanGradients = function cleanGradients() {
    var gradients = this.gradients;
    for (var hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  };
  RootElement2.prototype.size = function size() {
    var options = this.options;
    return new box_default(0, 0, options.width, options.height);
  };
  return RootElement2;
}(chart_element_default);
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options) {
  var stops = options.stops;
  var usedSpace = options.innerRadius / options.radius * 100;
  var length = stops.length;
  var currentStops = [];
  for (var i = 0; i < length; i++) {
    var currentStop = Object.assign({}, stops[i]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = function(ChartElement2) {
  function FloatElement2(options) {
    ChartElement2.call(this, options);
    this._initDirection();
  }
  if (ChartElement2) FloatElement2.__proto__ = ChartElement2;
  FloatElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FloatElement2.prototype.constructor = FloatElement2;
  FloatElement2.prototype._initDirection = function _initDirection() {
    var options = this.options;
    if (options.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options.spacing;
      this.elementSpacing = options.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options.vSpacing;
      this.elementSpacing = options.spacing;
    }
  };
  FloatElement2.prototype.reflow = function reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  };
  FloatElement2.prototype.reflowChildren = function reflowChildren() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var elementAxis = ref2.elementAxis;
    var groupAxis = ref2.groupAxis;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var ref$1 = this.groupOptions();
    var groups = ref$1.groups;
    var groupsSize = ref$1.groupsSize;
    var maxGroupElementsSize = ref$1.maxGroupElementsSize;
    var groupsCount = groups.length;
    var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      var groupStart = groupsStart;
      for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        var group = groups[groupIdx];
        var groupElements = group.groupElements;
        var elementStart = box[elementAxis + 1];
        var groupElementsCount = groupElements.length;
        for (var idx = 0; idx < groupElementsCount; idx++) {
          var element = groupElements[idx];
          var elementSize2 = this$1.elementSize(element);
          var groupElementStart = groupStart + this$1.alignStart(elementSize2[groupSizeField], group.groupSize);
          var elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize2[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize2[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize2[elementSizeField] + this$1.elementSpacing;
        }
        groupStart += group.groupSize + this$1.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  };
  FloatElement2.prototype.alignStart = function alignStart(size, maxSize) {
    var start = 0;
    var align = this.options.align;
    if (align === RIGHT || align === BOTTOM) {
      start = maxSize - size;
    } else if (align === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  };
  FloatElement2.prototype.groupOptions = function groupOptions() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var children = ref2.children;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var elementSpacing = ref2.elementSpacing;
    var groupSpacing = ref2.groupSpacing;
    var maxSize = round(box[elementSizeField]());
    var childrenCount = children.length;
    var groups = [];
    var groupSize = 0;
    var groupElementsSize = 0;
    var groupsSize = 0;
    var maxGroupElementsSize = 0;
    var groupElements = [];
    for (var idx = 0; idx < childrenCount; idx++) {
      var element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      var elementSize2 = this$1.elementSize(element);
      if (this$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize2[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize2[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize2[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  };
  FloatElement2.prototype.elementSize = function elementSize2(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  };
  FloatElement2.prototype.createVisual = function createVisual() {
  };
  return FloatElement2;
}(chart_element_default);
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text = function(ChartElement2) {
  function Text3(content, options) {
    ChartElement2.call(this, options);
    this.content = content;
    this.reflow(new box_default());
  }
  if (ChartElement2) Text3.__proto__ = ChartElement2;
  Text3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Text3.prototype.constructor = Text3;
  Text3.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var size = options.size = drawing_exports.util.measureText(this.content, {
      font: options.font
    });
    this.baseline = size.baseline;
    this.box = new box_default(targetBox.x1, targetBox.y1, targetBox.x1 + size.width, targetBox.y1 + size.height);
  };
  Text3.prototype.createVisual = function createVisual() {
    var ref2 = this.options;
    var font2 = ref2.font;
    var color = ref2.color;
    var opacity = ref2.opacity;
    var cursor = ref2.cursor;
    var stroke = ref2.stroke;
    var paintOrder = ref2.paintOrder;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font: font2,
      fill: {
        color,
        opacity
      },
      cursor,
      stroke,
      paintOrder
    });
  };
  return Text3;
}(chart_element_default);
setDefaultOptions(Text, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default = Text;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  var origin = rect.origin;
  var bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = function(BoxElement2) {
  function TextBox2(content, options, data) {
    BoxElement2.call(this, options);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  if (BoxElement2) TextBox2.__proto__ = BoxElement2;
  TextBox2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  TextBox2.prototype.constructor = TextBox2;
  TextBox2.prototype._initContainer = function _initContainer() {
    var options = this.options;
    var rows = String(this.content).split(ROWS_SPLIT_REGEX);
    var floatElement = new float_element_default({
      vertical: true,
      align: options.align,
      wrap: false
    });
    var textOptions = deepExtend({}, options, {
      opacity: 1,
      animation: null
    });
    this.container = floatElement;
    this.append(floatElement);
    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      var text = new text_default(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  };
  TextBox2.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var visualFn = options.visual;
    this.container.options.align = options.align;
    if (visualFn && !this._boxReflow) {
      var visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      var visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      BoxElement2.prototype.reflow.call(this, targetBox);
      if (options.rotation) {
        var margin = getSpacing(options.margin);
        var box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  };
  TextBox2.prototype.createVisual = function createVisual() {
    var options = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options.zIndex,
      noclip: options.noclip
    });
    if (this.hasBox()) {
      var box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  };
  TextBox2.prototype.renderVisual = function renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      var visual = this.visual;
      if (visual && !defined(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  TextBox2.prototype.visualContext = function visualContext(targetBox) {
    var this$1 = this;
    var context = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: function() {
        this$1._boxReflow = true;
        this$1.reflow(targetBox);
        this$1._boxReflow = false;
        return this$1.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context, this.data);
    }
    return context;
  };
  TextBox2.prototype.getDefaultVisual = function getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    var visual = this.visual;
    delete this.visual;
    return visual;
  };
  TextBox2.prototype.rotate = function rotate() {
    var options = this.options;
    this.box.rotate(options.rotation);
    this.align(this.targetBox, X, options.align);
    this.align(this.targetBox, Y, options.vAlign);
    return this.box;
  };
  TextBox2.prototype.rotationTransform = function rotationTransform() {
    var rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    var ref2 = this.normalBox.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  };
  return TextBox2;
}(box_element_default);
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = function(ChartElement2) {
  function Title3(options) {
    ChartElement2.call(this, options);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  if (ChartElement2) Title3.__proto__ = ChartElement2;
  Title3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Title3.prototype.constructor = Title3;
  Title3.prototype.reflow = function reflow(targetBox) {
    ChartElement2.prototype.reflow.call(this, targetBox);
    this.box.snapTo(targetBox, X);
  };
  Title3.buildTitle = function buildTitle(options, defaultOptions) {
    var titleOptions = options;
    if (typeof options === "string") {
      titleOptions = {
        text: options
      };
    }
    titleOptions = Object.assign({
      visible: true
    }, defaultOptions, titleOptions);
    var title2;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title2 = new Title3(titleOptions);
    }
    return title2;
  };
  Title3.orderTitles = function orderTitles(titles) {
    var items = [].concat(titles);
    var top = items.filter(function(item) {
      return item && item.options.position !== BOTTOM;
    });
    var bottom = items.filter(function(item) {
      return item && item.options.position === BOTTOM;
    });
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  };
  return Title3;
}(chart_element_default);
function collapseVerticalMargins(items) {
  for (var i = 1; i < items.length; i++) {
    var box = items[i]._textBox;
    var prevBox = items[i - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), {
      bottom: 0
    });
    box.options.margin = Object.assign(getSpacing(box.options.margin), {
      top: 0
    });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = function(TextBox2) {
  function AxisLabel2(value2, text, index, dataItem, options) {
    TextBox2.call(this, text, options);
    this.text = text;
    this.value = value2;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  if (TextBox2) AxisLabel2.__proto__ = TextBox2;
  AxisLabel2.prototype = Object.create(TextBox2 && TextBox2.prototype);
  AxisLabel2.prototype.constructor = AxisLabel2;
  AxisLabel2.prototype.visualContext = function visualContext(targetBox) {
    var context = TextBox2.prototype.visualContext.call(this, targetBox);
    context.value = this.value;
    context.dataItem = this.dataItem;
    context.format = this.options.format;
    context.culture = this.options.culture;
    return context;
  };
  AxisLabel2.prototype.click = function click(widget, e) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement(e),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  };
  AxisLabel2.prototype.rotate = function rotate() {
    if (this.options.alignRotation !== CENTER) {
      var box = this.normalBox.toRect();
      var transform = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform.matrix()));
    } else {
      TextBox2.prototype.rotate.call(this);
    }
    return this.box;
  };
  AxisLabel2.prototype.rotationTransform = function rotationTransform() {
    var options = this.options;
    var rotation = options.rotation;
    if (!rotation) {
      return null;
    }
    if (options.alignRotation === CENTER) {
      return TextBox2.prototype.rotationTransform.call(this);
    }
    var rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    var box = this.normalBox.toRect();
    var rect = this.targetBox.toRect();
    var rotationOrigin = options.rotationOrigin || TOP;
    var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    var topLeft = box.topLeft().transformCopy(rotationMatrix);
    var topRight = box.topRight().transformCopy(rotationMatrix);
    var bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    var rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    var translate2 = {};
    translate2[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];
    var distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var alignStart, alignEnd;
    if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {
      alignStart = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart = topLeft;
      alignEnd = bottomLeft;
    }
    var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  };
  return AxisLabel2;
}(text_box_default);
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = function(BoxElement2) {
  function Note2(fields, options, chartService) {
    BoxElement2.call(this, options);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  if (BoxElement2) Note2.__proto__ = BoxElement2;
  Note2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Note2.prototype.constructor = Note2;
  Note2.prototype.hide = function hide2() {
    this.options.visible = false;
  };
  Note2.prototype.show = function show2() {
    this.options.visible = true;
  };
  Note2.prototype.render = function render() {
    var this$1 = this;
    var options = this.options;
    if (options.visible) {
      var label = options.label;
      var icon = options.icon;
      var box = new box_default();
      var childAlias = function() {
        return this$1;
      };
      var size = icon.size;
      var text = this.fields.text;
      var width, height;
      if (defined(label) && label.visible) {
        var noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      var marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  };
  Note2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var label = ref2.label;
    var marker = ref2.marker;
    var wrapperBox = ref2.wrapperBox;
    var center = targetBox.center();
    var length = options.line.length;
    var position = options.position;
    if (options.visible) {
      var lineStart, box, contentBox;
      if (inArray(position, [LEFT, RIGHT])) {
        if (position === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [lineStart, [contentBox.x2, center.y]];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [lineStart, [contentBox.x1, center.y]];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [lineStart, [center.x, contentBox.y1]];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [lineStart, [center.x, contentBox.y2]];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  };
  Note2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  };
  Note2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options = this.options;
    var customVisual = options.visual;
    if (options.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options.background,
          border: options.background,
          icon: options.icon,
          label: options.label,
          line: options.line,
          position: options.position,
          visible: options.visible
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  Note2.prototype.createLine = function createLine() {
    var options = this.options.line;
    if (this.linePoints) {
      var path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options.color,
          width: options.width,
          dashType: options.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  };
  Note2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.out = function out(widget, e) {
    var args = this.eventArgs(e);
    widget.trigger(NOTE_LEAVE, args);
  };
  Note2.prototype.eventArgs = function eventArgs(e) {
    var options = this.options;
    return Object.assign(this.fields, {
      element: eventElement(e),
      text: defined(options.label) ? options.label.text : "",
      visual: this.visual
    });
  };
  return Note2;
}(box_element_default);
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: function(format, value2) {
    return value2;
  },
  toString: function(value2) {
    return value2;
  },
  parseDate: function(value2) {
    return new Date(value2);
  },
  firstDay: function() {
    return 0;
  }
};
var current2 = defaultImplementation;
var IntlService2 = function IntlService3() {
};
var staticAccessors = {
  implementation: {
    configurable: true
  }
};
IntlService2.register = function register2(userImplementation) {
  current2 = userImplementation;
};
staticAccessors.implementation.get = function() {
  return current2;
};
Object.defineProperties(IntlService2, staticAccessors);
var intl_service_default = IntlService2;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = function FormatService2(intlService) {
  this._intlService = intlService;
};
var prototypeAccessors2 = {
  intl: {
    configurable: true
  }
};
prototypeAccessors2.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors2.intl.set = function(value2) {
  this._intlService = value2;
};
FormatService.prototype.auto = function auto(formatString) {
  var values5 = [], len = arguments.length - 1;
  while (len-- > 0) values5[len] = arguments[len + 1];
  var intl = this.intl;
  if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
    return intl.format.apply(intl, [formatString].concat(values5));
  }
  return intl.toString(values5[0], formatString);
};
FormatService.prototype.localeAuto = function localeAuto(formatString, values5, locale) {
  var intl = this.intl;
  var result;
  if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
    result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
      var value2 = values5[parseInt(index, 10)];
      return intl.toString(value2, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
    });
  } else {
    result = intl.toString(values5[0], formatString, locale);
  }
  return result;
};
Object.defineProperties(FormatService.prototype, prototypeAccessors2);
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = function ChartService2(chart, context) {
  if (context === void 0) context = {};
  this._intlService = context.intlService;
  this.sender = context.sender || chart;
  this.format = new format_service_default(context.intlService);
  this.chart = chart;
  this.rtl = Boolean(context.rtl);
};
var prototypeAccessors3 = {
  intl: {
    configurable: true
  }
};
prototypeAccessors3.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors3.intl.set = function(value2) {
  this._intlService = value2;
  this.format.intl = value2;
};
ChartService.prototype.notify = function notify(name2, args) {
  if (this.chart) {
    this.chart.trigger(name2, args);
  }
};
ChartService.prototype.isPannable = function isPannable(axis) {
  var pannable = ((this.chart || {}).options || {}).pannable;
  return pannable && pannable.lock !== axis;
};
Object.defineProperties(ChartService.prototype, prototypeAccessors3);
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = function DomEventsBuilder2() {
};
DomEventsBuilder.register = function register3(userImplementation) {
  current3 = userImplementation;
};
DomEventsBuilder.create = function create(element, events) {
  var builder;
  if (current3) {
    builder = current3.create(element, events);
  } else {
    builder = new user_events_default(element, Object.assign({}, {
      multiTouch: true
    }, events));
  }
  return builder;
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options, tickOptions) {
  var tickX = options.tickX;
  var tickY = options.tickY;
  var position = options.position;
  var tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options.vertical) {
    tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);
  } else {
    tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options, gridLine) {
  var lineStart = options.lineStart;
  var lineEnd = options.lineEnd;
  var position = options.position;
  var line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options.vertical) {
    line.moveTo(lineStart, position).lineTo(lineEnd, position);
  } else {
    line.moveTo(position, lineStart).lineTo(position, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = function(ChartElement2) {
  function Axis2(options, chartService) {
    if (chartService === void 0) chartService = new chart_service_default();
    ChartElement2.call(this, options);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  if (ChartElement2) Axis2.__proto__ = ChartElement2;
  Axis2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Axis2.prototype.constructor = Axis2;
  Axis2.prototype.initFields = function initFields() {
  };
  Axis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  };
  Axis2.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {
    var rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  };
  Axis2.prototype.createLabels = function createLabels() {
    var this$1 = this;
    var options = this.options;
    var align = options.vertical ? RIGHT : CENTER;
    var labelOptions = deepExtend({}, options.labels, {
      align,
      zIndex: options.zIndex
    });
    var step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options.autoRotateLabels = true;
      }
      var range = this.labelsRange();
      for (var idx = range.min; idx < range.max; idx += step) {
        var labelContext = {
          index: idx,
          count: range.max
        };
        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this$1.append(label);
          this$1.labels.push(label);
        }
      }
    }
  };
  Axis2.prototype.clearLabels = function clearLabels() {
    this.children = grep(this.children, function(child) {
      return !(child instanceof axis_label_default);
    });
    this.labels = [];
  };
  Axis2.prototype.clearTitle = function clearTitle() {
    var this$1 = this;
    if (this.title) {
      this.children = grep(this.children, function(child) {
        return child !== this$1.title;
      });
      this.title = void 0;
    }
  };
  Axis2.prototype.clear = function clear3() {
    this.clearLabels();
    this.clearTitle();
  };
  Axis2.prototype.lineBox = function lineBox() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var axisX = mirror ? box.x1 : box.x2;
    var axisY = mirror ? box.y2 : box.y1;
    var lineWidth = options.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  };
  Axis2.prototype.createTitle = function createTitle() {
    var options = this.options;
    var titleOptions = deepExtend({
      rotation: options.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options.title);
    if (titleOptions.visible && titleOptions.text) {
      var title2 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title2);
      this.title = title2;
    }
  };
  Axis2.prototype.createNotes = function createNotes() {
    var this$1 = this;
    var options = this.options;
    var notes2 = options.notes;
    var items = notes2.data || [];
    this.notes = [];
    for (var i = 0; i < items.length; i++) {
      var item = deepExtend({}, notes2, items[i]);
      item.value = this$1.parseNoteValue(item.value);
      var note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this$1.chartService);
      if (note.options.visible) {
        if (defined(note.options.position)) {
          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options.vertical) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        }
        this$1.append(note);
        this$1.notes.push(note);
      }
    }
  };
  Axis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return value2;
  };
  Axis2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    this.createPlotBands();
  };
  Axis2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.createBackground();
    this.createLine();
  };
  Axis2.prototype.gridLinesVisual = function gridLinesVisual() {
    var gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  };
  Axis2.prototype.createTicks = function createTicks(lineGroup) {
    var options = this.options;
    var lineBox = this.lineBox();
    var mirror = options.labels.mirror;
    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (var i = tickOptions.skip; i < count; i += step) {
          if (defined(skipUnit) && i % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options.majorTicks);
    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);
  };
  Axis2.prototype.createLine = function createLine() {
    var options = this.options;
    var line = options.line;
    var lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      var path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options._alignLines) {
        alignPathToPixel(path);
      }
      var group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  };
  Axis2.prototype.getActualTickSize = function getActualTickSize() {
    var options = this.options;
    var tickSize = 0;
    if (options.majorTicks.visible && options.minorTicks.visible) {
      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);
    } else if (options.majorTicks.visible) {
      tickSize = options.majorTicks.size;
    } else if (options.minorTicks.visible) {
      tickSize = options.minorTicks.size;
    }
    return tickSize;
  };
  Axis2.prototype.createBackground = function createBackground() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var background = options.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  };
  Axis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var options = this.options;
    var plotBands = options.plotBands || [];
    var vertical = options.vertical;
    var plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    var altAxis = grep(this.pane.axes, function(axis) {
      return axis.options.vertical !== this$1.options.vertical;
    })[0];
    for (var idx = 0; idx < plotBands.length; idx++) {
      var item = plotBands[idx];
      var slotX = void 0, slotY = void 0;
      var labelOptions = item.label;
      var label = void 0;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this$1.getSlot(item.from, item.to, true);
      } else {
        slotX = this$1.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this$1.createPlotBandLabel(labelOptions, item, new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2));
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        var bandRect = new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);
        var path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  };
  Axis2.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    var text = label.text;
    var textbox;
    if (defined(label) && label.visible) {
      var labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({
          text,
          item
        });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  };
  Axis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var minorUnit = options.minorUnit;
    var vertical = options.vertical;
    var axisLineVisible = altAxis.options.line.visible;
    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;
    var lineBox = altAxis.lineBox();
    var linePos = lineBox[vertical ? "y1" : "x1"];
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (var i = gridLine.skip; i < count; i += step) {
          var pos = round(tickPositions[i]);
          if (!inArray(pos, majorTicks)) {
            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  };
  Axis2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var title2 = ref2.title;
    var vertical = options.vertical;
    var count = labels.length;
    var sizeFn = vertical ? WIDTH : HEIGHT;
    var titleSize = title2 ? title2.box[sizeFn]() : 0;
    var space = this.getActualTickSize() + options.margin + titleSize;
    var rootBox = (this.getRoot() || {}).box || box;
    var boxSize = rootBox[sizeFn]();
    var maxLabelSize = 0;
    for (var i = 0; i < count; i++) {
      var labelSize = labels[i].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);
    } else {
      this.box = new box_default(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  };
  Axis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getMajorTickPositions();
  };
  Axis2.prototype.labelTickIndex = function labelTickIndex(label) {
    return label.index;
  };
  Axis2.prototype.arrangeLabels = function arrangeLabels() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var tickPositions = this.getLabelsTickPositions();
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var labelSize = vertical ? label.box.height() : label.box.width();
      var firstTickPosition = tickPositions[tickIx];
      var nextTickPosition = tickPositions[tickIx + 1];
      var positionStart = void 0, positionEnd = void 0;
      if (vertical) {
        if (labelsBetweenTicks) {
          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this$1.positionLabel(label, mirror, positionStart, positionEnd);
    }
  };
  Axis2.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {
    if (positionEnd === void 0) positionEnd = positionStart;
    var options = this.options;
    var vertical = options.vertical;
    var lineBox = this.lineBox();
    var labelOffset = this.getActualTickSize() + options.margin;
    var labelBox;
    if (vertical) {
      var labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      var labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(positionStart, labelY, positionEnd, labelY + label.box.height());
    }
    label.reflow(labelBox);
  };
  Axis2.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  };
  Axis2.prototype.autoRotateLabels = function autoRotateLabels() {
    var this$1 = this;
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    var tickPositions = this.getMajorTickPositions();
    var labels = this.labels;
    var limit = Math.min(labels.length, tickPositions.length - 1);
    var angle = 0;
    for (var idx = 0; idx < limit; idx++) {
      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      var labelBox = labels[idx].box;
      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {
        labels[idx$1].options.rotation = angle;
        labels[idx$1].reflow(new box_default());
      }
      return true;
    }
  };
  Axis2.prototype.arrangeTitle = function arrangeTitle() {
    var ref2 = this;
    var options = ref2.options;
    var title2 = ref2.title;
    var mirror = options.labels.mirror;
    var vertical = options.vertical;
    if (title2) {
      if (vertical) {
        title2.options.align = mirror ? RIGHT : LEFT;
        title2.options.vAlign = title2.options.position;
      } else {
        title2.options.align = title2.options.position;
        title2.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title2.reflow(this.box);
    }
  };
  Axis2.prototype.arrangeNotes = function arrangeNotes() {
    var this$1 = this;
    for (var idx = 0; idx < this.notes.length; idx++) {
      var item = this$1.notes[idx];
      var value2 = item.options.value;
      var slot = void 0;
      if (defined(value2)) {
        if (this$1.shouldRenderNote(value2)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this$1.noteSlot(value2);
      } else {
        item.hide();
      }
      item.reflow(slot || this$1.lineBox());
    }
  };
  Axis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  Axis2.prototype.alignTo = function alignTo(secondAxis) {
    var lineBox = secondAxis.lineBox();
    var vertical = this.options.vertical;
    var pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  };
  Axis2.prototype.axisLabelText = function axisLabelText(value2, options, context) {
    var this$1 = this;
    var text;
    var tmpl = getTemplate(options);
    var defaultText = function() {
      if (!options.format) {
        return value2;
      }
      return this$1.chartService.format.localeAuto(options.format, [value2], options.culture);
    };
    if (tmpl) {
      var templateContext = Object.assign({}, context, {
        get text() {
          return defaultText();
        },
        value: value2,
        format: options.format,
        culture: options.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  };
  Axis2.prototype.slot = function slot(from, to, limit) {
    var slot2 = this.getSlot(from, to, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  Axis2.prototype.contentBox = function contentBox() {
    var box = this.box.clone();
    var labels = this.labels;
    if (labels.length) {
      var axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        var offset = this.maxLabelOffset();
        box[axis + 1] -= offset.start;
        box[axis + 2] += offset.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        var lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  };
  Axis2.prototype.maxLabelOffset = function maxLabelOffset() {
    var this$1 = this;
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var tickPositions = this.getLabelsTickPositions();
    var offsetField = vertical ? Y : X;
    var labels = this.labels;
    var startPosition = reverse ? 1 : 0;
    var endPosition = reverse ? 0 : 1;
    var maxStartOffset = 0;
    var maxEndOffset = 0;
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var startTick = void 0, endTick = void 0;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  };
  Axis2.prototype.limitRange = function limitRange(from, to, min4, max3, offset) {
    var options = this.options;
    if (from < min4 && offset < 0 && (!defined(options.min) || options.min <= min4) || max3 < to && offset > 0 && (!defined(options.max) || max3 <= options.max)) {
      return null;
    }
    if (to < min4 && offset > 0 || max3 < from && offset < 0) {
      return {
        min: from,
        max: to
      };
    }
    var rangeSize = to - from;
    var minValue = from;
    var maxValue = to;
    if (from < min4 && offset < 0) {
      minValue = limitValue(from, min4, max3);
      maxValue = limitValue(from + rangeSize, min4 + rangeSize, max3);
    } else if (to > max3 && offset > 0) {
      maxValue = limitValue(to, min4, max3);
      minValue = limitValue(to - rangeSize, min4, max3 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  };
  Axis2.prototype.valueRange = function valueRange3() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  };
  Axis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  };
  Axis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = this.lineDir();
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  Axis2.prototype.pointOffset = function pointOffset(point) {
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];
    var offset = relative / lineSize;
    return offset;
  };
  Axis2.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {
    var MAX_SCALE = 0.999;
    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);
    var delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  };
  Axis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.options.justified;
  };
  Axis2.prototype.prepareUserOptions = function prepareUserOptions() {
  };
  return Axis2;
}(chart_element_default);
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a, b) {
  var diff = a.getTime() - b;
  var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value2) {
  var result;
  if (value2 instanceof Date) {
    result = value2;
  } else if (value2) {
    result = new Date(value2);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay) {
  if (weekStartDay === void 0) weekStartDay = 0;
  var daysToSubtract = 0;
  var day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  var roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value2, unit2, weekStartDay) {
  var result = dateValue;
  if (dateValue) {
    var date = toDate(dateValue);
    var hours = date.getHours();
    if (unit2 === YEARS) {
      result = new Date(date.getFullYear() + value2, 0, 1);
      adjustDST(result, 0);
    } else if (unit2 === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value2, 1);
      adjustDST(result, hours);
    } else if (unit2 === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value2 * 7, DAYS);
      adjustDST(result, hours);
    } else if (unit2 === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value2);
      adjustDST(result, hours);
    } else if (unit2 === HOURS) {
      result = addHours(date, value2);
    } else if (unit2 === MINUTES) {
      result = addTicks(date, value2 * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit2 === SECONDS) {
      result = addTicks(date, value2 * TIME_PER_SECOND);
    } else if (unit2 === MILLISECONDS) {
      result = addTicks(date, value2);
    }
    if (unit2 !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit2, weekStartDay) {
  return addDuration(toDate(date), 0, unit2, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit2, weekStartDay) {
  var date = toDate(dateValue);
  if (date && floorDate(date, unit2, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit2, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a, b) {
  if (a && b) {
    return a.getTime() - b.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a, b) {
  return a.getTime() - b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value2) {
  if (isArray(value2)) {
    var result = [];
    for (var idx = 0; idx < value2.length; idx++) {
      result.push(toTime(value2[idx]));
    }
    return result;
  } else if (value2) {
    return toDate(value2).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a, b) {
  if (a && b) {
    return toTime(a) === toTime(b);
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value2, start, baseUnit, baseUnitStep) {
  var date = toDate(value2);
  var startDate = toDate(start);
  var index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a, b, unit2) {
  var diff;
  if (unit2 === YEARS) {
    diff = b.getFullYear() - a.getFullYear();
  } else if (unit2 === MONTHS) {
    diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();
  } else if (unit2 === DAYS) {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit2]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate(intlService, date) {
  var result;
  if (isString(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    var result = [];
    for (var idx = 0; idx < dates.length; idx++) {
      result.push(parseDate(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay(options, intlService) {
  if (isNumber(options.weekStartDay)) {
    return options.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value2, arr) {
  if (value2 instanceof Date) {
    var length = arr.length;
    for (var idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value2)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value2);
}
var CategoryAxis = function(Axis2) {
  function CategoryAxis2() {
    Axis2.apply(this, arguments);
  }
  if (Axis2) CategoryAxis2.__proto__ = Axis2;
  CategoryAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  CategoryAxis2.prototype.constructor = CategoryAxis2;
  CategoryAxis2.prototype.initFields = function initFields() {
    this._ticks = {};
  };
  CategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    return "";
  };
  CategoryAxis2.prototype.clone = function clone3() {
    var copy = new CategoryAxis2(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  };
  CategoryAxis2.prototype.initUserOptions = function initUserOptions(options) {
    var categories = options.categories || [];
    var definedMin = defined(options.min);
    var definedMax = defined(options.max);
    options.srcCategories = options.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      var min4 = definedMin ? Math.floor(options.min) : 0;
      var max3;
      if (definedMax) {
        max3 = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);
      } else {
        max3 = categories.length;
      }
      options.categories = options.categories.slice(min4, max3);
    }
    return options;
  };
  CategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    var options = this.options;
    var length = options.categories.length || 1;
    var min4 = isNumber(options.min) ? options.min % 1 : 0;
    var max3;
    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {
      max3 = length - (1 - options.max % 1);
    } else {
      max3 = length - (options.justified ? 1 : 0);
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.range = function range() {
    var options = this.options;
    var min4 = isNumber(options.min) ? options.min : 0;
    var max3 = isNumber(options.max) ? options.max : this.totalRange().max;
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.roundedRange = function roundedRange() {
    return this.range();
  };
  CategoryAxis2.prototype.totalRange = function totalRange() {
    var options = this.options;
    return {
      min: 0,
      max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)
    };
  };
  CategoryAxis2.prototype.scaleOptions = function scaleOptions() {
    var ref2 = this.rangeIndices();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var lineBox = this.lineBox();
    var size = this.options.vertical ? lineBox.height() : lineBox.width();
    var scale = size / (max3 - min4 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    Axis2.prototype.arrangeLabels.call(this);
    this.hideOutOfRangeLabels();
  };
  CategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    var ref2 = this;
    var box = ref2.box;
    var labels = ref2.labels;
    if (labels.length > 0) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      var firstLabel = labels[0];
      var lastLabel = last(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  };
  CategoryAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTicks().majorTicks;
  };
  CategoryAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTicks().minorTicks;
  };
  CategoryAxis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  };
  CategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this.rangeIndices();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var limit = Math.ceil(max3);
    var current4 = Math.floor(min4);
    var indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  };
  CategoryAxis2.prototype.getTickPositions = function getTickPositions(stepSize) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min4 = ref$1.min;
    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    var indices = this.tickIndices(stepSize);
    var positions = [];
    for (var idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round(scale * (indices[idx] - min4), COORD_PRECISION));
    }
    return positions;
  };
  CategoryAxis2.prototype.getTicks = function getTicks() {
    var options = this.options;
    var cache = this._ticks;
    var range = this.rangeIndices();
    var lineBox = this.lineBox();
    var hash = lineBox.getHash() + range.min + "," + range.max + options.reverse + options.justified;
    if (cache._hash !== hash) {
      var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;
      cache._hash = hash;
      cache.labelTicks = this.getTickPositions(1);
      cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);
      cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache;
  };
  CategoryAxis2.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    var axis = this.options.vertical ? Y : X;
    var inRange = function(position) {
      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];
    };
    var end = positions.length - 1;
    var startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    var endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  };
  CategoryAxis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = reverse ? -1 : 1;
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  CategoryAxis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    return reverse ? -1 : 1;
  };
  CategoryAxis2.prototype.getSlot = function getSlot(from, to, limit) {
    var options = this.options;
    var reverse = options.reverse;
    var justified = options.justified;
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var box = ref2.box;
    var min4 = ref2.min;
    var ref$1 = this.lineInfo();
    var valueAxis = ref$1.axis;
    var lineStart = ref$1.lineStart;
    var slotBox = box.clone();
    var singleSlot = !defined(to);
    var start = valueOrDefault(from, 0);
    var end = valueOrDefault(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    var p1 = lineStart + (start - min4) * scale;
    var p2 = lineStart + (end + 1 - min4) * scale;
    if (singleSlot && justified) {
      p2 = p1;
    }
    if (limit) {
      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p2 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p2;
    return slotBox;
  };
  CategoryAxis2.prototype.limitSlot = function limitSlot(slot) {
    var vertical = this.options.vertical;
    var valueAxis = vertical ? Y : X;
    var lineBox = this.lineBox();
    var limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  };
  CategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var min4 = Math.floor(this.options.min || 0);
    var start = from;
    var end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber(start)) {
      start -= min4;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber(end)) {
      end -= min4;
    }
    return Axis2.prototype.slot.call(this, start, end, limit);
  };
  CategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min4 = ref$1.min;
    var max3 = ref$1.max;
    var startValue = reverse ? max3 : min4;
    var lineStart = box[valueAxis + 1];
    var lineEnd = box[valueAxis + 2];
    var pos = point[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    var value2 = startValue + (pos - lineStart) / scale;
    var diff = value2 % 1;
    if (justified) {
      value2 = Math.round(value2);
    } else if (diff === 0 && value2 > 0) {
      value2--;
    }
    return Math.floor(value2);
  };
  CategoryAxis2.prototype.getCategory = function getCategory(point) {
    var index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  };
  CategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.totalIndex(value2) - Math.floor(this.options.min || 0);
  };
  CategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    var options = this.options;
    return (total3 ? options.srcCategories : options.categories)[index];
  };
  CategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return (this.options.categories || []).length;
  };
  CategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var lineBox = this.lineBox();
    var size = options.vertical ? lineBox.height() : lineBox.width();
    var range = options.categories.length;
    var scale = size / range;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset,
      max: range + offset
    };
  };
  CategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var rangeIndices = this.limitedRangeIndices();
    var range = rangeIndices.max - rangeIndices.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = rangeIndices.min + minDelta;
    var max3 = rangeIndices.max - maxDelta;
    if (max3 - min4 < MIN_CATEGORY_RANGE) {
      max3 = min4 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this.totalRange();
    var totalMin = ref2.min;
    var totalMax = ref2.max;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  CategoryAxis2.prototype.labelsCount = function labelsCount() {
    var labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  };
  CategoryAxis2.prototype.labelsRange = function labelsRange() {
    var options = this.options;
    var justified = options.justified;
    var labelOptions = options.labels;
    var ref2 = this.limitedRangeIndices(true);
    var min4 = ref2.min;
    var max3 = ref2.max;
    var start = Math.floor(min4);
    if (!justified) {
      min4 = Math.floor(min4);
      max3 = Math.ceil(max3);
    } else {
      min4 = Math.ceil(min4);
      max3 = Math.floor(max3);
    }
    var skip;
    if (min4 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min4 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options.categories.length ? max3 + (justified ? 1 : 0) : 0) - start
    };
  };
  CategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var dataItem = options.dataItems ? options.dataItems[index] : null;
    var category = valueOrDefault(options.categories[index], "");
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  };
  CategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.limitedRangeIndices();
    return Math.floor(range.min) <= value2 && value2 <= Math.ceil(range.max);
  };
  CategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    var options = this.options;
    var index = value2 - Math.floor(options.min || 0);
    return this.getSlot(index);
  };
  CategoryAxis2.prototype.arrangeNotes = function arrangeNotes() {
    Axis2.prototype.arrangeNotes.call(this);
    this.hideOutOfRangeNotes();
  };
  CategoryAxis2.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {
    var ref2 = this;
    var notes2 = ref2.notes;
    var box = ref2.box;
    if (notes2 && notes2.length) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      for (var idx = 0; idx < notes2.length; idx++) {
        var note = notes2[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  };
  CategoryAxis2.prototype.pan = function pan(delta) {
    var range = this.limitedRangeIndices(true);
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    var totalRange = this.totalRange();
    var min4 = range.min + offset;
    var max3 = range.max + offset;
    return this.limitRange(min4, max3, 0, totalRange.max, offset);
  };
  CategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var range = this.limitedRangeIndices(true);
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var lineStart = box[valueAxis + (reverse ? 2 : 1)];
    var diffStart = start[valueAxis] - lineStart;
    var diffEnd = end[valueAxis] - lineStart;
    var min4 = range.min + diffStart / scale;
    var max3 = range.min + diffEnd / scale;
    var rangeMin = Math.min(min4, max3);
    var rangeMax = Math.max(min4, max3);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  };
  CategoryAxis2.prototype.valueRange = function valueRange3() {
    return this.range();
  };
  CategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    var options = this.options;
    var index = this._categoriesMap ? this._categoriesMap.get(value2) : indexOf(value2, options.srcCategories);
    return index;
  };
  CategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var options = this.options;
    var min4 = 0;
    if (isNumber(options.min)) {
      min4 = Math.floor(options.min);
    }
    var max3;
    if (isNumber(options.max)) {
      max3 = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;
    } else {
      max3 = this.totalCount() - 1;
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.limitedRangeIndices = function limitedRangeIndices(totalLimit) {
    var options = this.options;
    var min4 = isNumber(options.min) ? options.min : 0;
    var max3;
    if (isNumber(options.max)) {
      max3 = options.max;
    } else if (isNumber(options.min)) {
      max3 = min4 + options.categories.length;
    } else {
      max3 = this.totalRange().max || 1;
    }
    if (totalLimit) {
      var totalRange = this.totalRange();
      min4 = limitValue(min4, 0, totalRange.max);
      max3 = limitValue(max3, 0, totalRange.max);
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    return {
      min: 0,
      max: this.totalRange().max || 1
    };
  };
  CategoryAxis2.prototype.indexCategories = function indexCategories() {
    if (!this._categoriesMap) {
      var map3 = this._categoriesMap = new hash_map_default();
      var srcCategories = this.options.srcCategories;
      for (var idx = 0; idx < srcCategories.length; idx++) {
        map3.set(srcCategories[idx], idx);
      }
    }
  };
  CategoryAxis2.prototype.totalCount = function totalCount3() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  };
  return CategoryAxis2;
}(axis_default);
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS];
var FIT = "fit";
function categoryRange(categories, clearCache) {
  if (clearCache) {
    categories._range = void 0;
  }
  var range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = function EmptyDateRange2(options) {
  this.options = options;
};
EmptyDateRange.prototype.displayIndices = function displayIndices() {
  return {
    min: 0,
    max: 1
  };
};
EmptyDateRange.prototype.displayRange = function displayRange() {
  return {};
};
EmptyDateRange.prototype.total = function total() {
  return {};
};
EmptyDateRange.prototype.valueRange = function valueRange() {
  return {};
};
EmptyDateRange.prototype.valueIndex = function valueIndex() {
  return -1;
};
EmptyDateRange.prototype.values = function values3() {
  return [];
};
EmptyDateRange.prototype.totalIndex = function totalIndex() {
  return -1;
};
EmptyDateRange.prototype.valuesCount = function valuesCount() {
  return 0;
};
EmptyDateRange.prototype.totalCount = function totalCount() {
  return 0;
};
EmptyDateRange.prototype.dateAt = function dateAt() {
  return null;
};
var DateRange = function DateRange2(start, end, options) {
  this.options = options;
  options.baseUnitStep = options.baseUnitStep || 1;
  var roundToBaseUnit = options.roundToBaseUnit;
  var justified = options.justified;
  this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);
  var lowerEnd = this.roundToTotalStep(end);
  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;
  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
  var min4 = options.min || start;
  this.valueStart = this.roundToTotalStep(min4);
  this.displayStart = roundToBaseUnit ? this.valueStart : min4;
  var max3 = options.max;
  if (!max3) {
    this.valueEnd = lowerEnd;
    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
  } else {
    var next = !justified && dateEquals(max3, this.roundToTotalStep(max3)) ? -1 : 0;
    this.valueEnd = this.roundToTotalStep(max3, false, next);
    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max3, !justified) : options.max;
  }
  if (this.valueEnd < this.valueStart) {
    this.valueEnd = this.valueStart;
  }
  if (this.displayEnd <= this.displayStart) {
    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
  }
};
DateRange.prototype.displayRange = function displayRange2() {
  return {
    min: this.displayStart,
    max: this.displayEnd
  };
};
DateRange.prototype.displayIndices = function displayIndices2() {
  if (!this._indices) {
    var options = this.options;
    var baseUnit = options.baseUnit;
    var baseUnitStep = options.baseUnitStep;
    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
    this._indices = {
      min: minIdx,
      max: maxIdx
    };
  }
  return this._indices;
};
DateRange.prototype.total = function total2() {
  return {
    min: this.start,
    max: this.end
  };
};
DateRange.prototype.totalCount = function totalCount2() {
  var last2 = this.totalIndex(this.end);
  return last2 + (this.options.justified ? 1 : 0);
};
DateRange.prototype.valueRange = function valueRange2() {
  return {
    min: this.valueStart,
    max: this.valueEnd
  };
};
DateRange.prototype.valueIndex = function valueIndex2(value2) {
  var options = this.options;
  return Math.floor(dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep));
};
DateRange.prototype.totalIndex = function totalIndex2(value2) {
  var options = this.options;
  return Math.floor(dateIndex(value2, this.start, options.baseUnit, options.baseUnitStep));
};
DateRange.prototype.dateIndex = function dateIndex$1(value2) {
  var options = this.options;
  return dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep);
};
DateRange.prototype.valuesCount = function valuesCount2() {
  var maxIdx = this.valueIndex(this.valueEnd);
  return maxIdx + 1;
};
DateRange.prototype.values = function values4() {
  var values5 = this._values;
  if (!values5) {
    var options = this.options;
    var range = this.valueRange();
    this._values = values5 = [];
    for (var date = range.min; date <= range.max; ) {
      values5.push(date);
      date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);
    }
  }
  return values5;
};
DateRange.prototype.dateAt = function dateAt2(index, total3) {
  var options = this.options;
  return addDuration(total3 ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);
};
DateRange.prototype.roundToTotalStep = function roundToTotalStep(value2, upper, next) {
  var ref2 = this.options;
  var baseUnit = ref2.baseUnit;
  var baseUnitStep = ref2.baseUnitStep;
  var weekStartDay = ref2.weekStartDay;
  var start = this.start;
  var step = dateIndex(value2, start, baseUnit, baseUnitStep);
  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
  if (next) {
    roundedStep += next;
  }
  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
};
function autoBaseUnit(options, startUnit, startStep) {
  var categoryLimits = categoryRange(options.categories);
  var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);
  var autoBaseUnitSteps = options.autoBaseUnitSteps;
  var maxDateGroups = options.maxDateGroups;
  var autoUnit = options.baseUnit === FIT;
  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;
  var units = span / TIME_PER_UNIT[baseUnit];
  var totalUnits = units;
  var unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options.baseUnitStep = step;
  options.baseUnit = baseUnit;
}
function defaultBaseUnit(options) {
  var categories = options.categories;
  var count = defined(categories) ? categories.length : 0;
  var minDiff = MAX_VALUE;
  var lastCategory, unit2;
  for (var categoryIx = 0; categoryIx < count; categoryIx++) {
    var category = categories[categoryIx];
    if (category && lastCategory) {
      var diff = Math.abs(absoluteDateDiff(category, lastCategory));
      if (diff !== 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit2 = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit2 = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit2 = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit2 = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit2 = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit2 = MINUTES;
        } else {
          unit2 = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options.baseUnit = unit2 || DAYS;
}
function initUnit(options) {
  var baseUnit = (options.baseUnit || "").toLowerCase();
  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options);
  }
  if (baseUnit === FIT || options.baseUnitStep === AUTO) {
    autoBaseUnit(options);
  }
  return options;
}
var DateCategoryAxis = function(CategoryAxis2) {
  function DateCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2) DateCategoryAxis2.__proto__ = CategoryAxis2;
  DateCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  DateCategoryAxis2.prototype.constructor = DateCategoryAxis2;
  DateCategoryAxis2.prototype.clone = function clone3() {
    var copy = new DateCategoryAxis2(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  };
  DateCategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    var start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  };
  DateCategoryAxis2.prototype.initUserOptions = function initUserOptions(options) {
    return options;
  };
  DateCategoryAxis2.prototype.initFields = function initFields() {
    CategoryAxis2.prototype.initFields.call(this);
    var chartService = this.chartService;
    var intlService = chartService.intl;
    var options = this.options;
    var categories = options.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options = deepExtend({
      roundToBaseUnit: true
    }, options, {
      categories,
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      weekStartDay: firstDay(options, intlService)
    });
    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {
      options.roundToBaseUnit = false;
    }
    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;
    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;
    this.options = options;
    options.srcCategories = categories;
    if (categories.length > 0) {
      var range = categoryRange(categories, true);
      var maxDivisions = options.maxDivisions;
      var safeOptions = initUnit(options);
      var forecast = options._forecast;
      if (forecast) {
        if (forecast.before > 0) {
          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
        if (forecast.after > 0) {
          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
      }
      this.dataRange = new DateRange(range.min, range.max, safeOptions);
      if (maxDivisions) {
        var dataRange = this.dataRange.displayRange();
        var divisionOptions = Object.assign({}, options, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        var dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options.baseUnit = options.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options);
    }
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this;
    var dataRange = ref2.dataRange;
    var divisionRange = ref2.divisionRange;
    var valuesCount3 = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount3) {
      return CategoryAxis2.prototype.tickIndices.call(this, stepSize);
    }
    var indices = [];
    var values5 = divisionRange.values();
    var offset = 0;
    if (!this.options.justified) {
      values5 = values5.concat(divisionRange.dateAt(valuesCount3));
      offset = 0.5;
    }
    for (var idx = 0; idx < values5.length; idx++) {
      indices.push(dataRange.dateIndex(values5[idx]) + offset);
      if (stepSize !== 1 && idx >= 1) {
        var last2 = indices.length - 1;
        indices.splice(idx, 0, indices[last2 - 1] + (indices[last2] - indices[last2 - 1]) * stepSize);
      }
    }
    return indices;
  };
  DateCategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    var categories = this.options.categories || [];
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0 && categories.length;
  };
  DateCategoryAxis2.prototype.parseNoteValue = function parseNoteValue(value2) {
    return parseDate(this.chartService.intl, value2);
  };
  DateCategoryAxis2.prototype.noteSlot = function noteSlot(value2) {
    return this.getSlot(value2);
  };
  DateCategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var baseUnit = options.baseUnit;
    var weekStartDay = options.weekStartDay;
    var vertical = options.vertical;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / (range.max - range.min);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      var from = addTicks(options.min || range.min, offset);
      var to = addTicks(options.max || range.max, offset);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  };
  DateCategoryAxis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  };
  DateCategoryAxis2.prototype.pan = function pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    var options = this.options;
    var lineBox = this.lineBox();
    var size = options.vertical ? lineBox.height() : lineBox.width();
    var ref2 = this.dataRange.displayRange();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var totalLimits = this.dataRange.total();
    var scale = size / (max3 - min4);
    var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);
    var from = addTicks(min4, offset);
    var to = addTicks(max3, offset);
    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options.baseUnit;
      panRange.baseUnitStep = options.baseUnitStep || 1;
      panRange.userSetBaseUnit = options.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;
      return panRange;
    }
  };
  DateCategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    var pointsRange2 = CategoryAxis2.prototype.pointsRange.call(this, start, end);
    var datesRange = this.dataRange.displayRange();
    var indicesRange = this.dataRange.displayIndices();
    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    var options = this.options;
    var min4 = addTicks(datesRange.min, pointsRange2.min * scale);
    var max3 = addTicks(datesRange.min, pointsRange2.max * scale);
    return {
      min: min4,
      max: max3,
      baseUnit: options.userSetBaseUnit || options.baseUnit,
      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
    };
  };
  DateCategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    var options = this.options;
    var fit = options.userSetBaseUnit === FIT;
    var totalLimits = this.dataRange.total();
    var ref2 = this.dataRange.displayRange();
    var rangeMin = ref2.min;
    var rangeMax = ref2.max;
    var position = Math.abs(this.pointOffset(cursor));
    var range = rangeMax - rangeMin;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = Math.round(position * delta);
    var maxDelta = Math.round((1 - position) * delta);
    var ref$1 = this.dataRange.options;
    var baseUnit = ref$1.baseUnit;
    var min4 = new Date(rangeMin.getTime() + minDelta);
    var max3 = new Date(rangeMax.getTime() - maxDelta);
    if (fit) {
      var autoBaseUnitSteps = options.autoBaseUnitSteps;
      var maxDateGroups = options.maxDateGroups;
      var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      var rangeDiff = dateDiff(rangeMax, rangeMin);
      var diff = dateDiff(max3, min4);
      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      var autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min4 = addTicks(rangeMin, ticks);
        max3 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        var stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min4 = addTicks(rangeMin, -ticks);
          max3 = addTicks(rangeMax, ticks);
          min4 = addTicks(min4, limitValue(max3, totalLimits.min, totalLimits.max) - max3);
          max3 = addTicks(max3, limitValue(min4, totalLimits.min, totalLimits.max) - min4);
        }
      }
    }
    if (min4 && max3 && dateDiff(max3, min4) > 0) {
      return {
        min: min4,
        max: max3,
        baseUnit: options.userSetBaseUnit || options.baseUnit,
        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
      };
    }
  };
  DateCategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var totalLimits = this.dataRange.total();
    var range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  };
  DateCategoryAxis2.prototype.range = function range() {
    return this.dataRange.displayRange();
  };
  DateCategoryAxis2.prototype.createLabels = function createLabels() {
    CategoryAxis2.prototype.createLabels.call(this);
    this.createRangeLabels();
  };
  DateCategoryAxis2.prototype.clearLabels = function clearLabels() {
    CategoryAxis2.prototype.clearLabels.call(this);
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    this.arrangeRangeLabels();
    CategoryAxis2.prototype.arrangeLabels.call(this);
  };
  DateCategoryAxis2.prototype.arrangeRangeLabels = function arrangeRangeLabels() {
    var ref2 = this;
    var options = ref2.options;
    var rangeLabels = ref2.rangeLabels;
    if (rangeLabels.length === 0) {
      return;
    }
    var lineBox = this.lineBox();
    var vertical = options.vertical;
    var mirror = options.rangeLabels.mirror || options.labels.mirror;
    var firstLabel = rangeLabels[0];
    if (firstLabel) {
      var position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position);
    }
    var lastLabel = rangeLabels[1];
    if (lastLabel) {
      var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position$1);
    }
  };
  DateCategoryAxis2.prototype.autoRotateLabels = function autoRotateLabels() {
    CategoryAxis2.prototype.autoRotateLabels.call(this);
    this.autoRotateRangeLabels();
  };
  DateCategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    CategoryAxis2.prototype.hideOutOfRangeLabels.call(this);
    this.hideOverlappingLabels();
  };
  DateCategoryAxis2.prototype.hideOverlappingLabels = function hideOverlappingLabels() {
    var ref2 = this;
    var rangeLabels = ref2.rangeLabels;
    var labels = ref2.labels;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    var firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (var i = 0; i < labels.length; i++) {
        var overlaps = clip(firstRangeLabel, labels[i]);
        if (!overlaps) {
          break;
        }
      }
    }
    var lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {
        var overlaps$1 = clip(lastRangeLabel, labels[i$1]);
        if (!overlaps$1) {
          break;
        }
      }
    }
  };
  DateCategoryAxis2.prototype.contentBox = function contentBox() {
    var box = CategoryAxis2.prototype.contentBox.call(this);
    var rangeLabels = this.rangeLabels;
    for (var i = 0; i < rangeLabels.length; i++) {
      var label = rangeLabels[i];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  };
  DateCategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    if (labelContext === void 0) labelContext = {};
    var options = this.options;
    var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;
    var date = this.divisionRange.dateAt(index);
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  };
  DateCategoryAxis2.prototype.createRangeLabels = function createRangeLabels() {
    var this$1 = this;
    var ref2 = this.divisionRange;
    var displayStart = ref2.displayStart;
    var displayEnd = ref2.displayEnd;
    var options = this.options;
    var labelOptions = Object.assign({}, options.labels, options.rangeLabels, {
      align: CENTER,
      zIndex: options.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options.autoRotateRangeLabels = true;
    }
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var createLabel = function(index, date, text) {
      if (text) {
        var label = new axis_label_default(date, text, index, null, labelOptions);
        this$1.append(label);
        this$1.rangeLabels.push(label);
      }
    };
    var startText = this.axisLabelText(displayStart, labelOptions, {
      index: 0,
      count: 2
    });
    createLabel(0, displayStart, startText);
    var endText = this.axisLabelText(displayEnd, labelOptions, {
      index: 1,
      count: 2
    });
    createLabel(1, displayEnd, endText);
  };
  DateCategoryAxis2.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {
    var this$1 = this;
    var labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    var rotateLabel = function(label, tickPositions2, index) {
      var width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      var angle = this$1.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    var tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  };
  DateCategoryAxis2.prototype.categoryIndex = function categoryIndex(value2) {
    return this.dataRange.valueIndex(value2);
  };
  DateCategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var dateRange = this.dataRange;
    var start = from;
    var end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    var slot2 = this.getSlot(start, end, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  DateCategoryAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var start = a;
    var end = b;
    if (typeof start === OBJECT) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT) {
      end = this.categoryIndex(end);
    }
    return CategoryAxis2.prototype.getSlot.call(this, start, end, limit);
  };
  DateCategoryAxis2.prototype.valueRange = function valueRange3() {
    var options = this.options;
    var range = categoryRange(options.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  };
  DateCategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    return this.dataRange.dateAt(index, total3);
  };
  DateCategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return this.dataRange.valuesCount();
  };
  DateCategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    return this.dataRange.displayIndices();
  };
  DateCategoryAxis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  };
  DateCategoryAxis2.prototype.prepareUserOptions = function prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  };
  DateCategoryAxis2.prototype.getCategory = function getCategory(point) {
    var index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  };
  DateCategoryAxis2.prototype.totalIndex = function totalIndex3(value2) {
    return this.dataRange.totalIndex(value2);
  };
  DateCategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalRange = function totalRange() {
    return this.dataRange.total();
  };
  DateCategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices() {
    var range = this.dataRange.total();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalCount = function totalCount3() {
    return this.dataRange.totalCount();
  };
  DateCategoryAxis2.prototype.isEmpty = function isEmpty() {
    return !this.options.srcCategories.length;
  };
  DateCategoryAxis2.prototype.roundedRange = function roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    var options = this.options;
    var datesRange = categoryRange(options.srcCategories);
    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  };
  return DateCategoryAxis2;
}(category_axis_default);
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 0;
  }
  var axisMin;
  if (min4 >= 0 && max3 >= 0) {
    var minValue = min4 === max3 ? 0 : min4;
    var diff = (max3 - minValue) / max3;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max3 - minValue) / 2);
  } else {
    axisMin = min4;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 1;
  }
  var axisMax;
  if (min4 <= 0 && max3 <= 0) {
    var maxValue = min4 === max3 ? 0 : max3;
    var diff = Math.abs((maxValue - min4) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min4 - maxValue) / 2);
  } else {
    axisMax = max3;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value2, step) {
  return round(Math.floor(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value2, step) {
  return round(Math.ceil(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value2) {
  return Math.max(Math.min(value2, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = function(Axis2) {
  function NumericAxis2(seriesMin, seriesMax, options, chartService) {
    Axis2.call(this, Object.assign({}, options, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  if (Axis2) NumericAxis2.__proto__ = Axis2;
  NumericAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  NumericAxis2.prototype.constructor = NumericAxis2;
  NumericAxis2.prototype.initUserOptions = function initUserOptions(options) {
    var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);
    this.totalOptions = totalAxisOptions(autoOptions, options);
    return axisOptions(autoOptions, options);
  };
  NumericAxis2.prototype.initFields = function initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  };
  NumericAxis2.prototype.clone = function clone3() {
    return new NumericAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  NumericAxis2.prototype.startValue = function startValue() {
    return 0;
  };
  NumericAxis2.prototype.range = function range() {
    var options = this.options;
    return {
      min: options.min,
      max: options.max
    };
  };
  NumericAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    var options = this.options;
    var range = options.max - options.min;
    return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;
  };
  NumericAxis2.prototype.getTickPositions = function getTickPositions(unit2, skipUnit) {
    var options = this.options;
    var ref2 = this.lineInfo();
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var range = options.max - options.min;
    var scale = lineSize / range;
    var step = unit2 * scale;
    var divisions = this.getDivisions(unit2);
    var positions = [];
    var pos = lineBox[axisOrigin];
    var skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit2;
    }
    for (var idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  };
  NumericAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  NumericAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  NumericAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    if (limit === void 0) limit = false;
    var options = this.options;
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var lineStart = ref2.lineStart;
    var step = axisDir * (lineSize / (options.max - options.min));
    var start = valueOrDefault(a, b || 0);
    var end = valueOrDefault(b, a || 0);
    if (limit) {
      start = limitValue(start, options.min, options.max);
      end = limitValue(end, options.min, options.max);
    }
    var p1 = Math.min(start, end) - options.min;
    var p2 = Math.max(start, end) - options.min;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  NumericAxis2.prototype.getValue = function getValue(point) {
    var options = this.options;
    var max3 = Number(options.max);
    var min4 = Number(options.min);
    var offset = this.pointOffset(point);
    var valueOffset = offset * (max3 - min4);
    if (offset < 0 || offset > 1) {
      return null;
    }
    var value2 = min4 + valueOffset;
    return round(value2, DEFAULT_PRECISION);
  };
  NumericAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var vertical = options.vertical;
    var reverse = options.reverse;
    var max3 = options.max;
    var min4 = options.min;
    var ref2 = this.lineInfo();
    var lineSize = ref2.lineSize;
    var range = max3 - min4;
    var scale = lineSize / range;
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: min4 + offset,
      max: max3 + offset,
      offset
    };
  };
  NumericAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  NumericAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var value2 = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  };
  NumericAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  NumericAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  NumericAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    if (this.isValidRange(min4, max3)) {
      return {
        min: min4,
        max: max3
      };
    }
  };
  NumericAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = round(this.options.min + minDelta, DEFAULT_PRECISION);
    var max3 = round(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max3 - min4 < MIN_VALUE_RANGE) {
      max3 = min4 + MIN_VALUE_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  };
  NumericAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax),
      narrowRange: false
    };
  };
  NumericAxis2.prototype.isValidRange = function isValidRange(min4, max3) {
    return max3 - min4 > MIN_VALUE_RANGE;
  };
  return NumericAxis2;
}(axis_default);
function autoAxisOptions(seriesMin, seriesMax, options) {
  var narrowRange = options.narrowRange;
  var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  var majorUnit = autoMajorUnit(autoMin, autoMax);
  var autoOptions = {
    majorUnit
  };
  if (options.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options) {
  return {
    min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,
    max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options, fields) {
  for (var idx = 0; idx < fields.length; idx++) {
    var field = fields[idx];
    if (options[field] === null) {
      options[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  var options = userOptions;
  var userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined(userOptions.min);
    userSetMax = defined(userOptions.max);
    var userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options.min, options.max);
    }
  }
  autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;
  var result = deepExtend(autoOptions, options);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value2, divisor, ratio) {
  var remainder = round(Math.abs(value2 % divisor), DEFAULT_PRECISION);
  var threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = function(Axis2) {
  function DateValueAxis2(seriesMin, seriesMax, axisOptions2, chartService) {
    var min4 = toDate(seriesMin);
    var max3 = toDate(seriesMax);
    var intlService = chartService.intl;
    var options = axisOptions2 || {};
    options = deepExtend(options || {}, {
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),
      weekStartDay: firstDay(options, intlService)
    });
    options = applyDefaults(min4, max3, options);
    Axis2.call(this, options, chartService);
    this.intlService = intlService;
    this.seriesMin = min4;
    this.seriesMax = max3;
    var weekStartDay = options.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min4) - 1, options.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max3) + 1, options.baseUnit, weekStartDay));
  }
  if (Axis2) DateValueAxis2.__proto__ = Axis2;
  DateValueAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  DateValueAxis2.prototype.constructor = DateValueAxis2;
  DateValueAxis2.prototype.clone = function clone3() {
    return new DateValueAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  DateValueAxis2.prototype.range = function range() {
    var options = this.options;
    return {
      min: options.min,
      max: options.max
    };
  };
  DateValueAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    var options = this.options;
    return Math.floor(duration(options.min, options.max, options.baseUnit) / stepValue + 1);
  };
  DateValueAxis2.prototype.getTickPositions = function getTickPositions(step) {
    var options = this.options;
    var ref2 = this.lineInfo();
    var dir = ref2.axisDir;
    var lineSize = ref2.lineSize;
    var start = ref2.lineStart;
    var divisions = this.getDivisions(step);
    var timeRange = dateDiff(options.max, options.min);
    var scale = lineSize / timeRange;
    var weekStartDay = options.weekStartDay || 0;
    var positions = [start];
    for (var i = 1; i < divisions; i++) {
      var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);
      var pos = start + dateDiff(date, options.min) * scale * dir;
      positions.push(round(pos, COORD_PRECISION));
    }
    return positions;
  };
  DateValueAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  DateValueAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    return numeric_axis_default.prototype.getSlot.call(this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit);
  };
  DateValueAxis2.prototype.getValue = function getValue(point) {
    var value2 = numeric_axis_default.prototype.getValue.call(this, point);
    return value2 !== null ? toDate(value2) : null;
  };
  DateValueAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options = this.options;
    var offset = index * options.majorUnit;
    var weekStartDay = options.weekStartDay || 0;
    var date = options.min;
    if (offset > 0) {
      date = addDuration(date, offset, options.baseUnit, weekStartDay);
    }
    var unitFormat = labelOptions.dateFormats[options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  };
  DateValueAxis2.prototype.translateRange = function translateRange(delta) {
    var options = this.options;
    var lineBox = this.lineBox();
    var vertical = options.vertical;
    var reverse = options.reverse;
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / dateDiff(range.max, range.min);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    var from = addTicks(options.min, offset);
    var to = addTicks(options.max, offset);
    return {
      min: from,
      max: to,
      offset
    };
  };
  DateValueAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0;
  };
  DateValueAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta, true);
    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  };
  DateValueAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    return {
      min: toDate(min4),
      max: toDate(max3)
    };
  };
  DateValueAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min4 = toDate(toTime(this.options.min) + minDelta);
    var max3 = toDate(toTime(this.options.max) - maxDelta);
    if (max3 - min4 < MIN_VALUE_RANGE2) {
      max3 = toDate(toTime(min4) + MIN_VALUE_RANGE2);
    }
    return {
      min: min4,
      max: max3
    };
  };
  DateValueAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var min4 = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));
    var max3 = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min4,
      max: max3
    };
  };
  return DateValueAxis2;
}(axis_default);
function timeUnits(delta) {
  var unit2 = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit2 = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit2 = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit2 = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit2 = DAYS;
  }
  return unit2;
}
function applyDefaults(seriesMin, seriesMax, options) {
  var min4 = options.min || seriesMin;
  var max3 = options.max || seriesMax;
  var baseUnit = options.baseUnit || (max3 && min4 ? timeUnits(absoluteDateDiff(max3, min4)) : HOURS);
  var baseUnitTime = TIME_PER_UNIT[baseUnit];
  var weekStartDay = options.weekStartDay || 0;
  var autoMin = floorDate(toTime(min4) - 1, baseUnit, weekStartDay) || toDate(max3);
  var autoMax = ceilDate(toTime(max3) + 1, baseUnit, weekStartDay);
  var userMajorUnit = options.majorUnit ? options.majorUnit : void 0;
  var majorUnit = userMajorUnit || ceil(autoMajorUnit(autoMin.getTime(), autoMax.getTime()), baseUnitTime) / baseUnitTime;
  var actualUnits = duration(autoMin, autoMax, baseUnit);
  var totalUnits = ceil(actualUnits, majorUnit);
  var unitsToAdd = totalUnits - actualUnits;
  var head = Math.floor(unitsToAdd / 2);
  var tail = unitsToAdd - head;
  if (!options.baseUnit) {
    delete options.baseUnit;
  }
  options.baseUnit = options.baseUnit || baseUnit;
  options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options.minorUnit = options.minorUnit || majorUnit / 5;
  options.majorUnit = majorUnit;
  return options;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = function(Axis2) {
  function LogarithmicAxis2(seriesMin, seriesMax, options, chartService) {
    var axisOptions2 = deepExtend({
      majorUnit: DEFAULT_MAJOR_UNIT,
      min: seriesMin,
      max: seriesMax
    }, options);
    var base = axisOptions2.majorUnit;
    var autoMax = autoAxisMax2(seriesMax, base);
    var autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    var range = initRange(autoMin, autoMax, axisOptions2, options);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);
    Axis2.call(this, axisOptions2, chartService);
    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;
    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;
    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  if (Axis2) LogarithmicAxis2.__proto__ = Axis2;
  LogarithmicAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  LogarithmicAxis2.prototype.constructor = LogarithmicAxis2;
  LogarithmicAxis2.prototype.clone = function clone3() {
    return new LogarithmicAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  LogarithmicAxis2.prototype.startValue = function startValue() {
    return this.options.min;
  };
  LogarithmicAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options.majorUnit;
    var min4 = options.min;
    var max3 = options.max;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineBox = ref$1.lineBox;
    var lineSize = ref$1.lineSize;
    var lineStart = ref$1.lineStart;
    var step = axisDir * (lineSize / (logMax - logMin));
    var start = valueOrDefault(a, b || 1);
    var end = valueOrDefault(b, a || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue(start, min4, max3);
      end = limitValue(end, min4, max3);
    }
    start = log(start, base);
    end = log(end, base);
    var p1 = Math.min(start, end) - logMin;
    var p2 = Math.max(start, end) - logMin;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  LogarithmicAxis2.prototype.getValue = function getValue(point) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options.majorUnit;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineStart = ref$1.lineStart;
    var lineSize = ref$1.lineSize;
    var step = (logMax - logMin) / lineSize;
    var offset = axisDir * (point[axis] - lineStart);
    var valueOffset = offset * step;
    if (offset < 0 || offset > lineSize) {
      return null;
    }
    var value2 = logMin + valueOffset;
    return round(Math.pow(base, value2), DEFAULT_PRECISION);
  };
  LogarithmicAxis2.prototype.range = function range() {
    var options = this.options;
    return {
      min: options.min,
      max: options.max
    };
  };
  LogarithmicAxis2.prototype.translateRange = function translateRange(delta) {
    var ref2 = this;
    var options = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var reverse = options.reverse;
    var vertical = options.vertical;
    var base = options.majorUnit;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var scale = size / (logMax - logMin);
    var offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: Math.pow(base, logMin + offset),
      max: Math.pow(base, logMax + offset),
      offset
    };
  };
  LogarithmicAxis2.prototype.labelsCount = function labelsCount() {
    var floorMax = Math.floor(this.logMax);
    var count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  };
  LogarithmicAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    var ticks = [];
    this.traverseMajorTicksPositions(function(position) {
      ticks.push(position);
    }, {
      step: 1,
      skip: 0
    });
    return ticks;
  };
  LogarithmicAxis2.prototype.createTicks = function createTicks(lineGroup) {
    var options = this.options;
    var majorTicks = options.majorTicks;
    var minorTicks = options.minorTicks;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var lineBox = this.lineBox();
    var ticks = [];
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  };
  LogarithmicAxis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var vertical = options.vertical;
    var lineBox = altAxis.lineBox();
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  };
  LogarithmicAxis2.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {
    var ref2 = this.lineInfo();
    var lineStart = ref2.lineStart;
    var step = ref2.step;
    var ref$1 = this;
    var logMin = ref$1.logMin;
    var logMax = ref$1.logMax;
    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position, tickOptions);
    }
  };
  LogarithmicAxis2.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {
    var this$1 = this;
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var ref$1 = this.lineInfo();
    var lineStart = ref$1.lineStart;
    var step = ref$1.step;
    var ref$2 = this;
    var logMin = ref$2.logMin;
    var logMax = ref$2.logMax;
    var start = Math.floor(logMin);
    for (var power = start; power < logMax; power++) {
      var minorOptions = this$1._minorIntervalOptions(power);
      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        var value2 = minorOptions.value + idx * minorOptions.minorStep;
        if (value2 > max3) {
          break;
        }
        if (value2 >= min4) {
          var position = round(lineStart + step * (log(value2, base) - logMin), DEFAULT_PRECISION);
          callback(position, tickOptions);
        }
      }
    }
  };
  LogarithmicAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var power = Math.ceil(this.logMin + index);
    var value2 = Math.pow(this.options.majorUnit, power);
    var text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  };
  LogarithmicAxis2.prototype.shouldRenderNote = function shouldRenderNote(value2) {
    var range = this.range();
    return range.min <= value2 && value2 <= range.max;
  };
  LogarithmicAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  LogarithmicAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min4 = Math.min(startValue, endValue);
    var max3 = Math.max(startValue, endValue);
    return {
      min: min4,
      max: max3
    };
  };
  LogarithmicAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var ref2 = this.options;
    var base = ref2.majorUnit;
    var logMin = log(this.options.min, base);
    var logMax = log(this.options.max, base);
    var position = Math.abs(this.pointOffset(cursor));
    var range = logMax - logMin;
    var delta = this.scaleToDelta(scale, range);
    var min4 = Math.pow(base, logMin + position * delta);
    var max3 = Math.pow(base, logMax - (1 - position) * delta);
    if (max3 - min4 < MIN_VALUE_RANGE3) {
      max3 = min4 + MIN_VALUE_RANGE3;
    }
    return {
      min: min4,
      max: max3
    };
  };
  LogarithmicAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  };
  LogarithmicAxis2.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {
    var ref2 = this.options;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var value2 = Math.pow(base, power);
    var nextValue = Math.pow(base, power + 1);
    var difference = nextValue - value2;
    var minorStep = difference / minorUnit;
    return {
      value: value2,
      minorStep
    };
  };
  LogarithmicAxis2.prototype.lineInfo = function lineInfo() {
    var info = Axis2.prototype.lineInfo.call(this);
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  };
  return LogarithmicAxis2;
}(axis_default);
function initRange(autoMin, autoMax, axisOptions2, options) {
  var min4 = axisOptions2.min;
  var max3 = axisOptions2.max;
  if (defined(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.max)) {
    max3 = autoMax;
  } else if (options.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.min)) {
    min4 = autoMin;
  } else if (options.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min4,
    max: max3
  };
}
function autoAxisMin2(min4, max3, options) {
  var base = options.majorUnit;
  var autoMin = min4;
  if (min4 <= 0) {
    autoMin = max3 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min4, base)));
  }
  return autoMin;
}
function autoAxisMax2(max3, base) {
  var logMaxRemainder = round(log(max3, base), DEFAULT_PRECISION) % 1;
  var autoMax;
  if (max3 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max3, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max3, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x, base) {
  return Math.log(x) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    var options = this.options;
    var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    var gridLines = [];
    var skipMajor = false;
    var majorAngles, minorAngles;
    if (options.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(majorAngles, radius, options.majorGridLines);
    }
    if (options.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append(gridLines, this.renderMinorGridLines(minorAngles, radius, options.minorGridLines, altAxis, skipMajor));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options) {
    return this.renderGridLines(angles, radius, options);
  },
  renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {
    var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options, radiusCallback);
  },
  renderGridLines: function(angles, radius, options, radiusCallback) {
    var style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    var center = this.box.center();
    var circle = new geometry_exports.Circle([center.x, center.y], radius);
    var container = this.gridLinesVisual();
    for (var i = 0; i < angles.length; i++) {
      var line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    var this$1 = this;
    var divs = this.intervals(size, skip, step, skipAngles);
    var options = altAxis.options;
    var altAxisVisible = options.visible && (options.line || {}).visible !== false;
    return map(divs, function(d) {
      var alpha = this$1.intervalAngle(d);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = function(CategoryAxis2) {
  function RadarCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2) RadarCategoryAxis2.__proto__ = CategoryAxis2;
  RadarCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  RadarCategoryAxis2.prototype.constructor = RadarCategoryAxis2;
  RadarCategoryAxis2.prototype.range = function range() {
    return {
      min: 0,
      max: this.options.categories.length
    };
  };
  RadarCategoryAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  RadarCategoryAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  RadarCategoryAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  RadarCategoryAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0) skipAngles = false;
    var options = this.options;
    var categories = options.categories.length;
    var divCount = categories / size || 1;
    var divAngle = 360 / divCount;
    var skip = skipOption || 0;
    var step = stepOption || 1;
    var divs = [];
    var angle = 0;
    for (var i = skip; i < divCount; i += step) {
      if (options.reverse) {
        angle = 360 - i * divAngle;
      } else {
        angle = i * divAngle;
      }
      angle = round(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  };
  RadarCategoryAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(1);
  };
  RadarCategoryAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(0.5);
  };
  RadarCategoryAxis2.prototype.intervalAngle = function intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  };
  RadarCategoryAxis2.prototype.majorAngles = function majorAngles() {
    var this$1 = this;
    return map(this.majorIntervals(), function(interval) {
      return this$1.intervalAngle(interval);
    });
  };
  RadarCategoryAxis2.prototype.createLine = function createLine() {
    return [];
  };
  RadarCategoryAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  };
  RadarCategoryAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var ref2 = this.options;
    var minorGridLines = ref2.minorGridLines;
    var majorGridLines = ref2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  RadarCategoryAxis2.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      var minorAngle = rad(360 / (this.options.categories.length * 2));
      var minorRadius = Math.cos(minorAngle) * radius;
      var majorAngles = this.majorAngles();
      var radiusCallback2 = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback2;
    }
  };
  RadarCategoryAxis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var plotBands = this.options.plotBands || [];
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var slot = this$1.plotBandSlot(band);
      var singleSlot = this$1.getSlot(band.from);
      var head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      var tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      var ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  };
  RadarCategoryAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  };
  RadarCategoryAxis2.prototype.getSlot = function getSlot(from, to) {
    var options = this.options;
    var justified = options.justified;
    var box = this.box;
    var divs = this.majorAngles();
    var totalDivs = divs.length;
    var slotAngle = 360 / totalDivs;
    var fromValue = from;
    if (options.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);
    var slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    var slots = toValue - fromValue + 1;
    var angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  };
  RadarCategoryAxis2.prototype.slot = function slot(from, to) {
    var slot2 = this.getSlot(from, to);
    var startAngle = slot2.startAngle + 180;
    var endAngle = startAngle + slot2.angle;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  RadarCategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point) {
    var this$1 = this;
    var length = this.options.categories.length;
    var index = null;
    for (var i = 0; i < length; i++) {
      var slot = this$1.getSlot(i);
      if (slot.containsPoint(point)) {
        index = i;
        break;
      }
    }
    return index;
  };
  return RadarCategoryAxis2;
}(category_axis_default);
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = function(Axis2) {
  function PolarAxis2(options, chartService) {
    Axis2.call(this, options, chartService);
    var instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  if (Axis2) PolarAxis2.__proto__ = Axis2;
  PolarAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  PolarAxis2.prototype.constructor = PolarAxis2;
  PolarAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  };
  PolarAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  PolarAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    var divs = this.intervals(options.majorUnit, skip, step);
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  PolarAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  PolarAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0) skipAngles = false;
    var min4 = this.options.min;
    var divisions = this.getDivisions(size);
    var divs = [];
    var skip = skipOption || 0;
    var step = stepOption || 1;
    for (var i = skip; i < divisions; i += step) {
      var current4 = (360 + min4 + i * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  };
  PolarAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(this.options.majorUnit);
  };
  PolarAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(this.options.minorUnit);
  };
  PolarAxis2.prototype.intervalAngle = function intervalAngle(i) {
    return (540 - i - this.options.startAngle) % 360;
  };
  PolarAxis2.prototype.createLine = function createLine() {
    return [];
  };
  PolarAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  };
  PolarAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var options = this.options;
    var minorGridLines = options.minorGridLines;
    var majorGridLines = options.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  PolarAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  };
  PolarAxis2.prototype.getSlot = function getSlot(a, b) {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var startAngle = options.startAngle;
    var start = limitValue(a, options.min, options.max);
    var end = limitValue(b || start, start, options.max);
    if (options.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  };
  PolarAxis2.prototype.slot = function slot(from, to) {
    if (to === void 0) to = from;
    var options = this.options;
    var start = 360 - options.startAngle;
    var slot2 = this.getSlot(from, to);
    var min4 = Math.min(from, to);
    var max3 = Math.max(from, to);
    var startAngle, endAngle;
    if (options.reverse) {
      startAngle = min4;
      endAngle = max3;
    } else {
      startAngle = 360 - max3;
      endAngle = 360 - min4;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  PolarAxis2.prototype.getValue = function getValue(point) {
    var options = this.options;
    var center = this.box.center();
    var dx = point.x - center.x;
    var dy = point.y - center.y;
    var theta = Math.round(deg(Math.atan2(dy, dx)));
    var start = options.startAngle;
    if (!options.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  };
  PolarAxis2.prototype.valueRange = function valueRange3() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  };
  return PolarAxis2;
}(axis_default);
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    var this$1 = this;
    var ref2 = this.options;
    var type = ref2.majorGridLines.type;
    var plotBands = ref2.plotBands;
    if (plotBands === void 0) plotBands = [];
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      var slot = this$1.getSlot(band.from, band.to, true);
      var ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      var shape = void 0;
      if (type === ARC) {
        shape = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape = drawing_exports.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    var innerPoints = [];
    var outerPoints = [];
    var center = [ring.center.x, ring.center.y];
    var innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    var outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (var i = 0; i < angles.length; i++) {
      innerPoints.push(innerCircle.pointAt(angles[i] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    var options = this.options;
    var majorTicks = this.radarMajorGridLinePositions();
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var gridLines = [];
    if (options.majorGridLines.visible) {
      gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);
    }
    if (options.minorGridLines.visible) {
      var minorTicks = this.radarMinorGridLinePositions();
      append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options) {
    var style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    var skip = options.skip;
    if (skip === void 0) skip = 0;
    var step = options.step;
    if (step === void 0) step = 0;
    var container = this.gridLinesVisual();
    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {
      var tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        var circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          var line = new drawing_exports.Path(style);
          for (var angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point) {
    var lineBox = this.lineBox();
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var radius = point.distanceTo(center);
    var distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      var dx = point.x - center.x;
      var dy = point.y - center.y;
      var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a, b) {
        return angularDistance(a, theta) - angularDistance(b, theta);
      });
      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      var alpha = angularDistance(theta, majorAngles[0]);
      var gamma = 90 - midAngle;
      var beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));
    }
    return this.axisType().prototype.getValue.call(this, new point_default(lineBox.x1, lineBox.y2 - distance));
  }
};
function angularDistance(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = function(NumericAxis2) {
  function RadarNumericAxis2() {
    NumericAxis2.apply(this, arguments);
  }
  if (NumericAxis2) RadarNumericAxis2.__proto__ = NumericAxis2;
  RadarNumericAxis2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadarNumericAxis2.prototype.constructor = RadarNumericAxis2;
  RadarNumericAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  RadarNumericAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var options = this.options;
    var minorSkipStep = 0;
    if (options.majorGridLines.visible) {
      minorSkipStep = options.majorUnit;
    }
    return this.getTickPositions(options.minorUnit, minorSkipStep);
  };
  RadarNumericAxis2.prototype.axisType = function axisType() {
    return NumericAxis2;
  };
  return RadarNumericAxis2;
}(numeric_axis_default);
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = function(LogarithmicAxis2) {
  function RadarLogarithmicAxis2() {
    LogarithmicAxis2.apply(this, arguments);
  }
  if (LogarithmicAxis2) RadarLogarithmicAxis2.__proto__ = LogarithmicAxis2;
  RadarLogarithmicAxis2.prototype = Object.create(LogarithmicAxis2 && LogarithmicAxis2.prototype);
  RadarLogarithmicAxis2.prototype.constructor = RadarLogarithmicAxis2;
  RadarLogarithmicAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    var positions = [];
    this.traverseMajorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.majorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var positions = [];
    this.traverseMinorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.minorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.axisType = function axisType() {
    return LogarithmicAxis2;
  };
  return RadarLogarithmicAxis2;
}(logarithmic_axis_default);
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var CurveProcessor = function(Class) {
  function CurveProcessor2(closed) {
    Class.call(this);
    this.closed = closed;
  }
  if (Class) CurveProcessor2.__proto__ = Class;
  CurveProcessor2.prototype = Object.create(Class && Class.prototype);
  CurveProcessor2.prototype.constructor = CurveProcessor2;
  CurveProcessor2.prototype.process = function process(dataPoints) {
    var this$1 = this;
    var points = dataPoints.slice(0);
    var segments = [];
    var closed = this.closed;
    var length = points.length;
    if (length > 2) {
      this.removeDuplicates(0, points);
      length = points.length;
    }
    if (length < 2 || length === 2 && points[0].equals(points[1])) {
      return segments;
    }
    var p0 = points[0];
    var p1 = points[1];
    var p2 = points[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points[length - 1])) {
      closed = true;
      points.pop();
      length--;
    }
    if (length === 2) {
      var tangent = this.tangent(p0, p1, X, Y);
      last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));
      segments.push(new geometry_exports.Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));
      return segments;
    }
    var initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points[length - 1];
      p1 = points[0];
      p2 = points[1];
      var controlPoints = this.controlPoints(p0, p1, p2);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      var tangent$1 = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);
    }
    var cp0 = initialControlPoint;
    for (var idx = 0; idx <= length - 3; idx++) {
      this$1.removeDuplicates(idx, points);
      length = points.length;
      if (idx + 3 <= length) {
        p0 = points[idx];
        p1 = points[idx + 1];
        p2 = points[idx + 2];
        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);
        last(segments).controlOut(cp0);
        cp0 = controlPoints$1[1];
        var cp1 = controlPoints$1[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points[length - 2];
      p1 = points[length - 1];
      p2 = points[0];
      var controlPoints$2 = this.controlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(p1, controlPoints$2[0]));
      last(segments).controlOut(controlPoints$2[1]);
      segments.push(new geometry_exports.Segment(p2, lastControlPoint));
    } else {
      var tangent$2 = this.tangent(p1, p2, X, Y);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(p2, this.secondControlPoint(tangent$2, p1, p2, X, Y)));
    }
    return segments;
  };
  CurveProcessor2.prototype.removeDuplicates = function removeDuplicates(idx, points) {
    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {
      points.splice(idx + 1, 1);
    }
  };
  CurveProcessor2.prototype.invertAxis = function invertAxis(p0, p1, p2) {
    var invertAxis2 = false;
    if (p0.x === p1.x) {
      invertAxis2 = true;
    } else if (p1.x === p2.x) {
      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
        invertAxis2 = true;
      }
    } else {
      var fn = this.lineFunction(p0, p1);
      var y2 = this.calculateFunction(fn, p2.x);
      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
        invertAxis2 = true;
      }
    }
    return invertAxis2;
  };
  CurveProcessor2.prototype.isLine = function isLine(p0, p1, p2) {
    var fn = this.lineFunction(p0, p1);
    var y2 = this.calculateFunction(fn, p2.x);
    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);
  };
  CurveProcessor2.prototype.lineFunction = function lineFunction(p1, p2) {
    var a = (p2.y - p1.y) / (p2.x - p1.x);
    var b = p1.y - a * p1.x;
    return [b, a];
  };
  CurveProcessor2.prototype.controlPoints = function controlPoints(p0, p1, p2) {
    var xField = X;
    var yField = Y;
    var restrict = false;
    var switchOrientation = false;
    var tangent;
    if (this.isLine(p0, p1, p2)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      var monotonic = {
        x: this.isMonotonicByField(p0, p1, p2, X),
        y: this.isMonotonicByField(p0, p1, p2, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p2, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p2)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          var sign;
          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
          switchOrientation = true;
        }
      }
    }
    var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      var oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);
      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);
    }
    return [secondControlPoint, firstControlPoint];
  };
  CurveProcessor2.prototype.restrictControlPoint = function restrictControlPoint(p1, p2, cp, tangent) {
    if (p1.y < p2.y) {
      if (p2.y < cp.y) {
        cp.x = p1.x + (p2.y - p1.y) / tangent;
        cp.y = p2.y;
      } else if (cp.y < p1.y) {
        cp.x = p2.x - (p2.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p2.y) {
        cp.x = p1.x - (p1.y - p2.y) / tangent;
        cp.y = p2.y;
      } else if (p1.y < cp.y) {
        cp.x = p2.x + (p1.y - p2.y) / tangent;
        cp.y = p1.y;
      }
    }
  };
  CurveProcessor2.prototype.tangent = function tangent(p0, p1, xField, yField) {
    var x = p1[xField] - p0[xField];
    var y = p1[yField] - p0[yField];
    var tangent2;
    if (x === 0) {
      tangent2 = 0;
    } else {
      tangent2 = y / x;
    }
    return tangent2;
  };
  CurveProcessor2.prototype.isMonotonicByField = function isMonotonicByField(p0, p1, p2, field) {
    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
  };
  CurveProcessor2.prototype.firstControlPoint = function firstControlPoint(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.secondControlPoint = function secondControlPoint(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT;
    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.point = function point(xValue, yValue, xField, yField) {
    var controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  };
  CurveProcessor2.prototype.calculateFunction = function calculateFunction(fn, x) {
    var length = fn.length;
    var result = 0;
    for (var i = 0; i < length; i++) {
      result += Math.pow(x, i) * fn[i];
    }
    return result;
  };
  return CurveProcessor2;
}(class_default);
function numberSign(value2) {
  return value2 <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = function(Class) {
  function ChartAxis2(axis) {
    Class.call(this);
    this._axis = axis;
    this.options = axis.options;
  }
  if (Class) ChartAxis2.__proto__ = Class;
  ChartAxis2.prototype = Object.create(Class && Class.prototype);
  ChartAxis2.prototype.constructor = ChartAxis2;
  ChartAxis2.prototype.value = function value2(point) {
    var axis = this._axis;
    var value3 = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);
    return value3;
  };
  ChartAxis2.prototype.slot = function slot(from, to, limit) {
    if (limit === void 0) limit = true;
    return this._axis.slot(from, to, limit);
  };
  ChartAxis2.prototype.range = function range() {
    return this._axis.range();
  };
  ChartAxis2.prototype.valueRange = function valueRange3() {
    return this._axis.valueRange();
  };
  return ChartAxis2;
}(class_default);
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name2, axes) {
  for (var idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name2) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = function ChartPane2(pane) {
  this.visual = pane.visual;
  this.chartsVisual = pane.chartContainer.visual;
  this._pane = pane;
};
ChartPane.prototype.findAxisByName = function findAxisByName$1(name2) {
  return findAxisByName(name2, this._pane.axes);
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = function(Class) {
  function ChartPlotArea2(plotArea) {
    Class.call(this);
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
  if (Class) ChartPlotArea2.__proto__ = Class;
  ChartPlotArea2.prototype = Object.create(Class && Class.prototype);
  ChartPlotArea2.prototype.constructor = ChartPlotArea2;
  return ChartPlotArea2;
}(class_default);
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values5) {
  var length = values5.length;
  var count = 0;
  for (var i = 0; i < length; i++) {
    var num = values5[i];
    if (isNumber(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values5) {
    var length = values5.length;
    var min4 = MAX_VALUE;
    for (var i = 0; i < length; i++) {
      var value2 = values5[i];
      if (isNumber(value2)) {
        min4 = Math.min(min4, value2);
      }
    }
    return min4 === MAX_VALUE ? values5[0] : min4;
  },
  max: function(values5) {
    var length = values5.length;
    var max3 = MIN_VALUE;
    for (var i = 0; i < length; i++) {
      var value2 = values5[i];
      if (isNumber(value2)) {
        max3 = Math.max(max3, value2);
      }
    }
    return max3 === MIN_VALUE ? values5[0] : max3;
  },
  sum: function(values5) {
    var length = values5.length;
    var sum2 = 0;
    for (var i = 0; i < length; i++) {
      var value2 = values5[i];
      if (isNumber(value2)) {
        sum2 += value2;
      }
    }
    return sum2;
  },
  sumOrNull: function(values5) {
    var result = null;
    if (countNumbers(values5)) {
      result = Aggregates.sum(values5);
    }
    return result;
  },
  count: function(values5) {
    var length = values5.length;
    var count = 0;
    for (var i = 0; i < length; i++) {
      var value2 = values5[i];
      if (value2 !== null && defined(value2)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values5) {
    var count = countNumbers(values5);
    var result = values5[0];
    if (count > 0) {
      result = Aggregates.sum(values5) / count;
    }
    return result;
  },
  first: function(values5) {
    var length = values5.length;
    for (var i = 0; i < length; i++) {
      var value2 = values5[i];
      if (value2 !== null && defined(value2)) {
        return value2;
      }
    }
    return values5[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  var get3 = getter2(field, true);
  return get3(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = function(Class) {
  function SeriesBinder2() {
    Class.call(this);
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  if (Class) SeriesBinder2.__proto__ = Class;
  SeriesBinder2.prototype = Object.create(Class && Class.prototype);
  SeriesBinder2.prototype.constructor = SeriesBinder2;
  SeriesBinder2.prototype.register = function register4(seriesTypes, valueFields, otherFields) {
    var this$1 = this;
    if (valueFields === void 0) valueFields = [VALUE];
    if (otherFields === void 0) otherFields = {};
    for (var i = 0; i < seriesTypes.length; i++) {
      var type = seriesTypes[i];
      this$1._valueFields[type] = valueFields;
      this$1._otherFields[type] = otherFields;
      this$1._nullValue[type] = this$1._makeValue(valueFields, null);
      this$1._undefinedValue[type] = this$1._makeValue(valueFields, void 0);
    }
  };
  SeriesBinder2.prototype.canonicalFields = function canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  };
  SeriesBinder2.prototype.valueFields = function valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.otherFields = function otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var data = series.data;
    var pointData = defined(item) ? item : data[pointIx];
    var result = {
      valueFields: {
        value: pointData
      }
    };
    var valueFields = this.valueFields(series);
    var otherFields = this._otherFields[series.type];
    var fields, value2;
    if (pointData === null) {
      value2 = this._nullValue[series.type];
    } else if (!defined(pointData)) {
      value2 = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      var fieldData = pointData.slice(valueFields.length);
      value2 = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      var srcValueFields = this.sourceFields(series, valueFields);
      var srcPointFields = this.sourceFields(series, otherFields);
      value2 = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined(value2)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value2[valueFields[0]];
      } else {
        result.valueFields = value2;
      }
    }
    result.fields = fields || {};
    return result;
  };
  SeriesBinder2.prototype._makeValue = function _makeValue(fields, initialValue) {
    var value2 = {};
    var length = fields.length;
    for (var i = 0; i < length; i++) {
      var fieldName = fields[i];
      value2[fieldName] = initialValue;
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromArray = function _bindFromArray(array, fields) {
    var value2 = {};
    if (fields) {
      var length = Math.min(fields.length, array.length);
      for (var i = 0; i < length; i++) {
        value2[fields[i]] = array[i];
      }
    }
    return value2;
  };
  SeriesBinder2.prototype._bindFromObject = function _bindFromObject(object, fields, srcFields) {
    if (srcFields === void 0) srcFields = fields;
    var value2 = {};
    if (fields) {
      var length = fields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = fields[i];
        var srcFieldName = srcFields[i];
        if (srcFieldName !== null) {
          value2[fieldName] = getField(srcFieldName, object);
        }
      }
    }
    return value2;
  };
  SeriesBinder2.prototype.sourceFields = function sourceFields(series, canonicalFields) {
    var sourceFields2 = [];
    if (canonicalFields) {
      var length = canonicalFields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = canonicalFields[i];
        var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields2.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields2;
  };
  return SeriesBinder2;
}(class_default);
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = function(Class) {
  function ErrorRangeCalculator2(errorValue, series, field) {
    Class.call(this);
    this.initGlobalRanges(errorValue, series, field);
  }
  if (Class) ErrorRangeCalculator2.__proto__ = Class;
  ErrorRangeCalculator2.prototype = Object.create(Class && Class.prototype);
  ErrorRangeCalculator2.prototype.constructor = ErrorRangeCalculator2;
  ErrorRangeCalculator2.prototype.initGlobalRanges = function initGlobalRanges(errorValue, series, field) {
    var data = series.data;
    var deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      var average = this.getAverage(data);
      var deviation = this.getStandardDeviation(data, average, false);
      var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      var errorRange = {
        low: average.value - deviation * multiple,
        high: average.value + deviation * multiple
      };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      var standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value2) {
        return {
          low: value2 - standardError,
          high: value2 + standardError
        };
      };
    }
  };
  ErrorRangeCalculator2.prototype.createValueGetter = function createValueGetter(series, field) {
    var data = series.data;
    var binder = series_binder_default.current;
    var valueFields = binder.valueFields(series);
    var item = defined(data[0]) ? data[0] : {};
    var valueGetter10;
    if (isArray(item)) {
      var index = field ? valueFields.indexOf(field) : 0;
      valueGetter10 = getter2("[" + index + "]");
    } else if (isNumber(item)) {
      valueGetter10 = getter2();
    } else if (typeof item === OBJECT) {
      var srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter10 = getter2(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter10;
  };
  ErrorRangeCalculator2.prototype.getErrorRange = function getErrorRange(pointValue, errorValue) {
    var low, high, value2;
    if (!defined(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber(value2 = parseFloat(errorValue))) {
      low = pointValue - value2;
      high = pointValue + value2;
    } else if (value2 = percentRegex.exec(errorValue)) {
      var percentValue = pointValue * (parseFloat(value2[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return {
      low,
      high
    };
  };
  ErrorRangeCalculator2.prototype.getStandardError = function getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  };
  ErrorRangeCalculator2.prototype.getStandardDeviation = function getStandardDeviation(data, average, isSample) {
    var this$1 = this;
    var length = data.length;
    var total3 = isSample ? average.count - 1 : average.count;
    var squareDifferenceSum = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1.valueGetter(data[idx]);
      if (isNumber(value2)) {
        squareDifferenceSum += Math.pow(value2 - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total3);
  };
  ErrorRangeCalculator2.prototype.getAverage = function getAverage(data) {
    var this$1 = this;
    var length = data.length;
    var sum2 = 0;
    var count = 0;
    for (var idx = 0; idx < length; idx++) {
      var value2 = this$1.valueGetter(data[idx]);
      if (isNumber(value2)) {
        sum2 += value2;
        count++;
      }
    }
    return {
      value: sum2 / count,
      count
    };
  };
  return ErrorRangeCalculator2;
}(class_default);
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser2 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser2.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var PYRAMID = "pyramid";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT, BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL];
var TRENDLINE_EXPONENTIAL = "exponentialTrendline";
var TRENDLINE_LINEAR = "linearTrendline";
var TRENDLINE_LOGARITHMIC = "logarithmicTrendline";
var TRENDLINE_MOVING_AVERAGE = "movingAverageTrendline";
var TRENDLINE_POLYNOMIAL = "polynomialTrendline";
var TRENDLINE_POWER = "powerTrendline";
var TRENDLINE_SERIES = [TRENDLINE_EXPONENTIAL, TRENDLINE_LINEAR, TRENDLINE_LOGARITHMIC, TRENDLINE_MOVING_AVERAGE, TRENDLINE_POLYNOMIAL, TRENDLINE_POWER];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT2 = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var CHART_POINT_ROLE = "graphics-symbol";
var CHART_POINT_CLASSNAME = "k-chart-point";
var CHART_POINT_ROLE_DESCRIPTION = "Point";
var LEGEND_ITEM_ROLE = "checkbox";
var LEGEND_ITEM_CLASSNAME = "k-chart-legend-item";
var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = "Legend item";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";
var MIN_MOVING_AVERAGE_PERIOD = 2;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = function(ChartElement2) {
  function ErrorBarBase2(low, high, isVertical, chart, series, options) {
    ChartElement2.call(this, options);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  if (ChartElement2) ErrorBarBase2.__proto__ = ChartElement2;
  ErrorBarBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ErrorBarBase2.prototype.constructor = ErrorBarBase2;
  ErrorBarBase2.prototype.reflow = function reflow(targetBox) {
    var endCaps = this.options.endCaps;
    var isVertical = this.isVertical;
    var axis = this.getAxis();
    var valueBox = axis.getSlot(this.low, this.high);
    var centerBox = targetBox.center();
    var capsWidth = this.getCapsWidth(targetBox, isVertical);
    var capValue = isVertical ? centerBox.x : centerBox.y;
    var capStart = capValue - capsWidth;
    var capEnd = capValue + capsWidth;
    var linePoints;
    if (isVertical) {
      linePoints = [new point_default(centerBox.x, valueBox.y1), new point_default(centerBox.x, valueBox.y2)];
      if (endCaps) {
        linePoints.push(new point_default(capStart, valueBox.y1), new point_default(capEnd, valueBox.y1), new point_default(capStart, valueBox.y2), new point_default(capEnd, valueBox.y2));
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [new point_default(valueBox.x1, centerBox.y), new point_default(valueBox.x2, centerBox.y)];
      if (endCaps) {
        linePoints.push(new point_default(valueBox.x1, capStart), new point_default(valueBox.x1, capEnd), new point_default(valueBox.x2, capStart), new point_default(valueBox.x2, capEnd));
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  };
  ErrorBarBase2.prototype.getCapsWidth = function getCapsWidth(box, isVertical) {
    var boxSize = isVertical ? box.width() : box.height();
    var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  };
  ErrorBarBase2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options = this.options;
    var visual = options.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options.endCaps,
          color: options.color,
          line: options.line
        },
        createVisual: function() {
          this$1.createDefaultVisual();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  };
  ErrorBarBase2.prototype.createDefaultVisual = function createDefaultVisual() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var linePoints = ref2.linePoints;
    var lineOptions = {
      stroke: {
        color: options.color,
        width: options.line.width,
        dashType: options.line.dashType
      }
    };
    ChartElement2.prototype.createVisual.call(this);
    for (var idx = 0; idx < linePoints.length; idx += 2) {
      var line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this$1.visual.append(line);
    }
  };
  return ErrorBarBase2;
}(chart_element_default);
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = function(ErrorBarBase2) {
  function CategoricalErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2) CategoricalErrorBar2.__proto__ = ErrorBarBase2;
  CategoricalErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  CategoricalErrorBar2.prototype.constructor = CategoricalErrorBar2;
  CategoricalErrorBar2.prototype.getAxis = function getAxis() {
    var axis = this.chart.seriesValueAxis(this.series);
    return axis;
  };
  return CategoricalErrorBar2;
}(error_bar_base_default);
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (var idx = 0; idx < elements.length; idx++) {
    if (defined(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values5) {
  return countNumbers(values5) === values5.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  var visible = fields.visible;
  if (defined(visible)) {
    return visible;
  }
  var pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  var data = series.data;
  var points = [];
  var sum2 = 0;
  var count = 0;
  for (var idx = 0; idx < data.length; idx++) {
    var pointData = series_binder_default.current.bindPoint(series, idx);
    var value2 = pointData.valueFields.value;
    if (isString(value2)) {
      value2 = parseFloat(value2);
    }
    if (isNumber(value2)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value2);
      points.push(pointData);
      if (pointData.visible) {
        sum2 += pointData.value;
      }
      if (value2 !== 0) {
        count++;
      }
    } else {
      points.push(null);
    }
  }
  return {
    total: sum2,
    points,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  var seriesCount = series.length;
  var categories = 0;
  for (var i = 0; i < seriesCount; i++) {
    categories = Math.max(categories, series[i].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a, b) {
  if (a && b) {
    return a.toLowerCase() === b.toLowerCase();
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options, context, state, dryRun) {
  if (state === void 0) state = {};
  if (dryRun === void 0) dryRun = false;
  var defaults = state.defaults = state.defaults || {};
  var depth = state.depth = state.depth || 0;
  var needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (var property in options) {
    if (!inArray(property, state.excluded) && hasOwnProperty(options, property)) {
      var propValue = options[property];
      if (isFunction(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options[property] = valueOrDefault(propValue(context), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  var result = [];
  var seriesTypes = [].concat(types);
  for (var idx = 0; idx < series.length; idx++) {
    var currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/parse-date-category.js
var dateCache = /* @__PURE__ */ new WeakMap();
function parseDateCategory(category, row, intlService) {
  if (row === null || typeof row !== "object") {
    return parseDate(intlService, category);
  }
  var date = dateCache.get(row);
  if (!date) {
    date = parseDate(intlService, category);
    dateCache.set(row, date);
  }
  return date;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options) {
  var overlay = options.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value2) {
  return defined(value2) && value2 !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  var type = axisOptions2.type;
  var dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}
function hasValue2(series, item) {
  var fields = series_binder_default.current.bindPoint(series, null, item);
  var valueFields = fields.valueFields;
  for (var field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext(ref2) {
  var start = ref2.start;
  var dir = ref2.dir;
  var min4 = ref2.min;
  var max3 = ref2.max;
  var getter3 = ref2.getter;
  var hasItem = ref2.hasItem;
  var series = ref2.series;
  var pointHasValue, outPoint;
  var idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter3(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min4 <= idx && idx <= max3 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter3, hasItem) {
  var min4 = range.min;
  var max3 = range.max;
  var hasMinPoint = min4 > 0 && min4 < count;
  var hasMaxPoint = max3 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    var missingValues = seriesMissingValues(series);
    var minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter3(min4 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter3(max3 + 1);
      }
    } else {
      var outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter3(min4 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min4,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter3,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter3(max3 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max3,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter3,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = function(ChartElement2) {
  function CategoricalChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  if (ChartElement2) CategoricalChart2.__proto__ = ChartElement2;
  CategoricalChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  CategoricalChart2.prototype.constructor = CategoricalChart2;
  CategoricalChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  CategoricalChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options;
  };
  CategoricalChart2.prototype.plotValue = function plotValue(point) {
    if (!point) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber(point.value)) {
      var categoryIx = point.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      var otherValues = [];
      var categorySum = 0;
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (other) {
          var stack = point.series.stack;
          var otherStack = other.series.stack;
          if (stack && otherStack && stack.group !== otherStack.group) {
            continue;
          }
          if (isNumber(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point.value / categorySum;
      }
    }
    return point.value;
  };
  CategoricalChart2.prototype.plotRange = function plotRange(point, startValue) {
    var this$1 = this;
    if (startValue === void 0) startValue = 0;
    var categoryPoints = this.categoryPoints[point.categoryIx];
    if (this.options.isStacked) {
      var plotValue = this.plotValue(point);
      var positive = plotValue >= 0;
      var prevValue = startValue;
      var isStackedBar = false;
      var stack = defined(point.series.stack) ? point.series.stack : this.options.defaultStack;
      var isNonGroupStack = function(stack2) {
        return stack2 === true || typeof stack2 === OBJECT && !stack2.group;
      };
      if (stack) {
        for (var i = 0; i < categoryPoints.length; i++) {
          var other = categoryPoints[i];
          if (point === other) {
            break;
          }
          var otherStack = defined(other.series.stack) ? other.series.stack : this$1.options.defaultStack;
          if (!otherStack) {
            continue;
          }
          if (typeof stack === STRING && stack !== otherStack) {
            continue;
          }
          if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {
            continue;
          }
          if (stack.group && stack.group !== otherStack.group) {
            continue;
          }
          var otherValue = this$1.plotValue(other);
          if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
            if (startValue === 0 || otherValue !== 0) {
              prevValue += otherValue;
              plotValue += otherValue;
              isStackedBar = true;
              if (this$1.options.isStacked100) {
                plotValue = Math.min(plotValue, 1);
              }
            }
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    var series = point.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];
  };
  CategoricalChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var this$1 = this;
    var min4 = MAX_VALUE;
    var max3 = MIN_VALUE;
    for (var i = 0; i < this.categoryPoints.length; i++) {
      var categoryPoints = this$1.categoryPoints[i];
      if (!categoryPoints) {
        continue;
      }
      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
        var point = categoryPoints[pIx];
        if (point) {
          if (point.series.stack === stackName || point.series.axis === axisName) {
            var to = this$1.plotRange(point, 0)[1];
            if (defined(to) && isFinite(to)) {
              max3 = Math.max(max3, to);
              min4 = Math.min(min4, to);
            }
          }
        }
      }
    }
    return {
      min: min4,
      max: max3
    };
  };
  CategoricalChart2.prototype.updateStackRange = function updateStackRange() {
    var this$1 = this;
    var ref2 = this.options;
    var isStacked = ref2.isStacked;
    var chartSeries = ref2.series;
    var limitsCache = {};
    if (isStacked) {
      for (var i = 0; i < chartSeries.length; i++) {
        var series = chartSeries[i];
        var axisName = series.axis;
        var key = axisName + series.stack;
        var limits = limitsCache[key];
        if (!limits) {
          limits = this$1.stackLimits(axisName, series.stack);
          var errorTotals = this$1.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this$1.valueAxisRanges[axisName] = limits;
        }
      }
    }
  };
  CategoricalChart2.prototype.addErrorBar = function addErrorBar(point, data, categoryIx) {
    var value2 = point.value;
    var series = point.series;
    var seriesIx = point.seriesIx;
    var errorBars = point.options.errorBars;
    var lowValue = data.fields[ERROR_LOW_FIELD];
    var highValue = data.fields[ERROR_HIGH_FIELD];
    var errorRange;
    if (isNumber(lowValue) && isNumber(highValue)) {
      errorRange = {
        low: lowValue,
        high: highValue
      };
    } else if (errorBars && defined(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value2, errorBars.value);
    }
    if (errorRange) {
      point.low = errorRange.low;
      point.high = errorRange.high;
      this.addPointErrorBar(point, categoryIx);
    }
  };
  CategoricalChart2.prototype.addPointErrorBar = function addPointErrorBar(point, categoryIx) {
    var isVertical = !this.options.invertAxes;
    var options = point.options.errorBars;
    var series = point.series;
    var low = point.low;
    var high = point.high;
    if (this.options.isStacked) {
      var stackedErrorRange = this.stackedErrorRange(point, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      var fields = {
        categoryIx,
        series
      };
      this.updateRange({
        value: low
      }, fields);
      this.updateRange({
        value: high
      }, fields);
    }
    var errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars = [errorBar];
    point.append(errorBar);
  };
  CategoricalChart2.prototype.stackedErrorRange = function stackedErrorRange(point, categoryIx) {
    var plotValue = this.plotRange(point, 0)[1] - point.value;
    var low = point.low + plotValue;
    var high = point.high + plotValue;
    this.errorTotals = this.errorTotals || {
      positive: [],
      negative: []
    };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return {
      low,
      high
    };
  };
  CategoricalChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    var seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    var point = this.createPoint(data, fields);
    if (point) {
      Object.assign(point, fields);
      point.owner = this;
      point.noteText = data.fields.noteText;
      if (!defined(point.dataItem)) {
        point.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point, data, categoryIx);
    }
    this.points.push(point);
    seriesPoints.push(point);
    categoryPoints.push(point);
    this.updateRange(data.valueFields, fields);
  };
  CategoricalChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: ["data", "aggregate", "_events", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint", "drilldownSeriesFactory", "ariaTemplate", "ariaContent"]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value: value2,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  };
  CategoricalChart2.prototype.updateRange = function updateRange(data, fields) {
    var axisName = fields.series.axis;
    var value2 = data.value;
    var axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value2) && value2 !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      axisRange.min = Math.min(axisRange.min, value2);
      axisRange.max = Math.max(axisRange.max, value2);
    }
  };
  CategoricalChart2.prototype.seriesValueAxis = function seriesValueAxis(series) {
    var plotArea = this.plotArea;
    var axisName = series.axis;
    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  };
  CategoricalChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var categorySlots = this.categorySlots = [];
    var chartPoints = this.points;
    var categoryAxis = this.categoryAxis;
    var pointIx = 0;
    this.traverseDataPoints(function(data, fields) {
      var categoryIx = fields.categoryIx;
      var currentSeries = fields.series;
      var valueAxis = this$1.seriesValueAxis(currentSeries);
      var point = chartPoints[pointIx++];
      var categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point) {
        var plotRange = this$1.plotRange(point, valueAxis.startValue());
        var valueSlot = this$1.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);
          point.aboveAxis = this$1.aboveAxis(point, valueAxis);
          point.stackValue = plotRange[1];
          if (this$1.options.isStacked100) {
            point.percentage = this$1.plotValue(point);
          }
          this$1.reflowPoint(point, pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  };
  CategoricalChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  };
  CategoricalChart2.prototype.limitPoints = function limitPoints() {
    var this$1 = this;
    var categoryPoints = this.categoryPoints;
    var points = categoryPoints[0].concat(last(categoryPoints));
    for (var idx = 0; idx < points.length; idx++) {
      if (points[idx]) {
        this$1.limitPoint(points[idx]);
      }
    }
  };
  CategoricalChart2.prototype.limitPoint = function limitPoint(point) {
    var limitedSlot = this.categoryAxis.limitSlot(point.box);
    if (!limitedSlot.equals(point.box)) {
      point.reflow(limitedSlot);
    }
  };
  CategoricalChart2.prototype.aboveAxis = function aboveAxis(point, valueAxis) {
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    var value2 = point.value;
    return valueAxis.options.reverse ? value2 < axisCrossingValue : value2 >= axisCrossingValue;
  };
  CategoricalChart2.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {
    var categoryAxis = this.categoryAxis;
    var options = valueAxis.options;
    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  };
  CategoricalChart2.prototype.reflowPoint = function reflowPoint(point, pointSlot) {
    point.reflow(pointSlot);
  };
  CategoricalChart2.prototype.reflowCategories = function reflowCategories() {
  };
  CategoricalChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var options = this.options;
    var invertAxes = options.invertAxes;
    var slotX = invertAxes ? valueSlot : categorySlot;
    var slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  CategoricalChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  CategoricalChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var count = categoriesCount(series);
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (var categoryIx = 0; categoryIx < count; categoryIx++) {
      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {
        var currentSeries = series[seriesIx$1];
        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);
        var pointData = this$1.plotArea.bindPoint(currentSeries, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx: seriesIx$1
        });
      }
    }
    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {
      this$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);
    }
  };
  CategoricalChart2.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {
    var outOfRangePoint = series[field];
    if (outOfRangePoint) {
      var categoryIx = outOfRangePoint.categoryIx;
      var pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  };
  CategoricalChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    if (point.value === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value);
  };
  CategoricalChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.value;
  };
  return CategoricalChart2;
}(chart_element_default);
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e) {
    return chart.trigger(SERIES_CLICK, this.eventArgs(e));
  },
  hover: function(chart, e) {
    return chart.trigger(SERIES_HOVER, this.eventArgs(e));
  },
  over: function(chart, e) {
    return chart.trigger(SERIES_OVER, this.eventArgs(e));
  },
  out: function(chart, e) {
    return chart.trigger(SERIES_LEAVE, this.eventArgs(e));
  },
  eventArgs: function(e) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement(e),
      originalEvent: e,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    var options = this.options.notes;
    var text = this.noteText || options.label.text;
    if (options.visible !== false && defined(text) && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = function(ChartElement2) {
  function LinePoint2(value2, options) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
  }
  if (ChartElement2) LinePoint2.__proto__ = ChartElement2;
  LinePoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LinePoint2.prototype.constructor = LinePoint2;
  LinePoint2.prototype.render = function render() {
    var ref2 = this.options;
    var markers = ref2.markers;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  LinePoint2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  LinePoint2.prototype.createLabelElement = function createLabelElement(options) {
    return new text_box_default(this.getLabelText(options), deepExtend({
      align: CENTER,
      vAlign: CENTER,
      margin: {
        left: 5,
        right: 5
      },
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    }, options), this.pointData());
  };
  LinePoint2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  };
  LinePoint2.prototype.getAriaLabelText = function getAriaLabelText2() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  };
  LinePoint2.prototype.markerBorder = function markerBorder() {
    var options = this.options.markers;
    var background = options.background;
    var border = deepExtend({
      color: this.color
    }, options.border);
    if (!defined(border.color)) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  };
  LinePoint2.prototype.createVisual = function createVisual() {
  };
  LinePoint2.prototype.createMarker = function createMarker() {
    var options = this.options.markers;
    var marker = new shape_element_default({
      type: options.type,
      width: options.size,
      height: options.size,
      rotation: options.rotation,
      background: options.background,
      border: this.markerBorder(),
      opacity: options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual,
      accessibilityOptions: deepExtend({
        ariaLabel: this.getAriaLabelText(this.options.labels)
      }, this.options.accessibility)
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  };
  LinePoint2.prototype.markerBox = function markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  };
  LinePoint2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var aboveAxis = ref2.aboveAxis;
    var vertical = options.vertical;
    this.render();
    this.box = targetBox;
    var childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(childBox);
      }
    }
    if (this.note) {
      var noteTargetBox = this.markerBox();
      if (!(options.markers.visible && options.markers.size)) {
        var center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  };
  LinePoint2.prototype.reflowLabel = function reflowLabel(box) {
    var ref2 = this;
    var options = ref2.options;
    var label = ref2.label;
    var anchor = options.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  };
  LinePoint2.prototype.createHighlight = function createHighlight() {
    var markers = this.options.highlight.markers;
    var defaultColor = this.markerBorder().color;
    var options = this.options.markers;
    var size = options.size + (options.border.width || 0) + (markers.border.width || 0);
    var shadow = new shape_element_default({
      type: options.type,
      width: size,
      height: size,
      rotation: options.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault(markers.border.opacity, 1)
      },
      opacity: valueOrDefault(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  };
  LinePoint2.prototype.highlightVisual = function highlightVisual() {
    return (this.marker || {}).visual;
  };
  LinePoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var marker = this.marker;
    var visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      var size = this.options.markers.size;
      var halfSize = size / 2;
      var center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  };
  LinePoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.accessibility.highlight;
    var size = markerOptions.size + (markerOptions.border.width || 0);
    var highlight = new shape_element_default({
      type: markerOptions.type,
      width: size,
      height: size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      opacity: highlightOptions2.opacity,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this._childBox);
    return highlight.getElement();
  };
  LinePoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var markerBox = this.markerBox();
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      var x = markerBox.x2 + TOOLTIP_OFFSET;
      var horizontalAlign = LEFT;
      var y, verticalAlign;
      if (this.aboveAxis) {
        y = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  LinePoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  LinePoint2.prototype.overlapsBox = function overlapsBox(box) {
    var markerBox = this.markerBox();
    return markerBox.overlaps(box);
  };
  LinePoint2.prototype.unclipElements = function unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  };
  LinePoint2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  LinePoint2.prototype.focusVisual = function focusVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", this._id);
      }
      this.toggleFocusHighlight(true);
    }
  };
  LinePoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", "");
      }
      this.toggleFocusHighlight(false);
    }
  };
  LinePoint2.prototype.getIndex = function getIndex() {
    return defined(this.categoryIx) ? this.categoryIx : this.pointIx;
  };
  return LinePoint2;
}(chart_element_default);
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  },
  accessibility: {
    tabIndex: 0,
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = function(ChartElement2) {
  function LineSegment2(linePoints, series, seriesIx) {
    ChartElement2.call(this);
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  if (ChartElement2) LineSegment2.__proto__ = ChartElement2;
  LineSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LineSegment2.prototype.constructor = LineSegment2;
  LineSegment2.prototype.points = function points() {
    return this.toGeometryPoints(this.linePoints);
  };
  LineSegment2.prototype.toGeometryPoints = function toGeometryPoints(points) {
    var result = [];
    for (var i = 0, length = points.length; i < length; i++) {
      if (points[i] && points[i].visible !== false) {
        result.push(points[i]._childBox.toRect().center());
      }
    }
    return result;
  };
  LineSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: function() {
          this$1.segmentVisual();
          return this$1.visual;
        }
      });
      if (this.visual && !defined(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  };
  LineSegment2.prototype.segmentVisual = function segmentVisual() {
    var ref2 = this;
    var options = ref2.options;
    var series = ref2.series;
    var color = series.color;
    var defaults = series._defaults;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    var line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options.closed) {
      line.close();
    }
    this.visual = line;
  };
  LineSegment2.prototype.aliasFor = function aliasFor(e, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  };
  return LineSegment2;
}(chart_element_default);
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points) {
    var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    var ref2 = categoryAxis.options;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var stepAxis = vertical ? X : Y;
    var axis = vertical ? Y : X;
    var stepDir = reverse ? 2 : 1;
    var dir = stepDir;
    var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);
    var result = [previousPoint];
    for (var idx = 1; idx < points.length; idx++) {
      var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point[stepAxis]) {
        var stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point[axis];
        result.push(stepPoint, point);
      }
      previousPoint = point;
    }
    if (!justified) {
      result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  var box = lintPoint.box;
  var result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = function(LineSegment2) {
  function StepLineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2) StepLineSegment2.__proto__ = LineSegment2;
  StepLineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  StepLineSegment2.prototype.constructor = StepLineSegment2;
  StepLineSegment2.prototype.points = function points() {
    return this.calculateStepPoints(this.linePoints);
  };
  return StepLineSegment2;
}(line_segment_default);
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = function(LineSegment2) {
  function SplineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2) SplineSegment2.__proto__ = LineSegment2;
  SplineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  SplineSegment2.prototype.constructor = SplineSegment2;
  SplineSegment2.prototype.segmentVisual = function segmentVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    var curveProcessor = new curve_processor_default(this.options.closed);
    var segments = curveProcessor.process(this.points());
    var curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  };
  return SplineSegment2;
}(line_segment_default);
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var seriesPoints = ref2.seriesPoints;
    var series = options.series;
    var seriesCount = seriesPoints.length;
    var lastSegment;
    this._segments = [];
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);
      var pointCount = sortedPoints.length;
      var linePoints = [];
      for (var pointIx = 0; pointIx < pointCount; pointIx++) {
        var point = sortedPoints[pointIx];
        if (point) {
          linePoints.push(point);
        } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this$1.createSegment(linePoints, currentSeries, seriesIx, lastSegment);
            this$1._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this$1.createSegment(linePoints, currentSeries, seriesIx, lastSegment);
        this$1._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points) {
    return points;
  },
  seriesMissingValues: function(series) {
    var missingValues = series.missingValues;
    var assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x, y, seriesIx) {
    var target = new point_default(x, y);
    var allPoints = this.seriesPoints[seriesIx];
    var nearestPointDistance = MAX_VALUE;
    var nearestPoint;
    for (var i = 0; i < allPoints.length; i++) {
      var point = allPoints[i];
      if (point && defined(point.value) && point.value !== null && point.visible !== false) {
        var pointBox = point.box;
        var pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = function(superclass) {
  function ClipAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) ClipAnimation2.__proto__ = superclass;
  ClipAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ClipAnimation2.prototype.constructor = ClipAnimation2;
  ClipAnimation2.prototype.setup = function setup() {
    this._setEnd(this.options.box.x1);
  };
  ClipAnimation2.prototype.step = function step(pos) {
    var box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  };
  ClipAnimation2.prototype._setEnd = function _setEnd(x) {
    var element = this.element;
    var segments = element.segments;
    var topRight = segments[1].anchor();
    var bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x);
    element.resume();
    bottomRight.setX(x);
  };
  return ClipAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    var root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      var box = root.size();
      var clipPath = drawing_exports.Path.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    var points = this.animationPoints();
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      if (point && point.visual && defined(point.visual.options.zIndex)) {
        point.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = function(CategoricalChart2) {
  function LineChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) LineChart2.__proto__ = CategoricalChart2;
  LineChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  LineChart2.prototype.constructor = LineChart2;
  LineChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
    this.renderSegments();
  };
  LineChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  LineChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var missingValues = this.seriesMissingValues(series);
    var value2 = data.valueFields.value;
    if (!defined(value2) || value2 === null) {
      if (missingValues === ZERO) {
        value2 = 0;
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  LineChart2.prototype.plotRange = function plotRange(point) {
    var this$1 = this;
    var plotValue = this.plotValue(point);
    if (this.options.isStacked) {
      var categoryIx = point.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (point === other) {
          break;
        }
        plotValue += this$1.plotValue(other);
        if (this$1.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  };
  LineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  LineChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result.concat(this._segments);
  };
  LineChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return LineChart2;
}(categorical_chart_default);
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = function(LineSegment2) {
  function AreaSegment2(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    LineSegment2.call(this, linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  if (LineSegment2) AreaSegment2.__proto__ = LineSegment2;
  AreaSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  AreaSegment2.prototype.constructor = AreaSegment2;
  AreaSegment2.prototype.createVisual = function createVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var lineOptions = series.line || {};
    var color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: {
        color,
        opacity: series.opacity
      },
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  };
  AreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  };
  AreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  };
  AreaSegment2.prototype.stackSegments = function stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  };
  AreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  };
  AreaSegment2.prototype.segmentsFromPoints = function segmentsFromPoints(points) {
    return points.map(function(point) {
      return new geometry_exports.Segment(point);
    });
  };
  AreaSegment2.prototype.createStroke = function createStroke(style) {
    var stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  };
  AreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  };
  AreaSegment2.prototype.createFill = function createFill(style) {
    var strokeSegments = this.strokeSegments();
    var fillSegments = strokeSegments.slice(0);
    var hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      var stackSegments = this.stackSegments();
      append(fillSegments, stackSegments);
    }
    var fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  };
  AreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var chart = this.parent;
    var invertAxes = chart.options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.series);
    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    var segments = this.strokeSegments();
    var firstPoint = segments[0].anchor();
    var lastPoint = last(segments).anchor();
    var end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  };
  return AreaSegment2;
}(line_segment_default);
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = function(AreaSegment2) {
  function StepAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) StepAreaSegment2.__proto__ = AreaSegment2;
  StepAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  StepAreaSegment2.prototype.constructor = StepAreaSegment2;
  StepAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  };
  StepAreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  };
  return StepAreaSegment2;
}(area_segment_default);
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = function(AreaSegment2) {
  function SplineAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) SplineAreaSegment2.__proto__ = AreaSegment2;
  SplineAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  SplineAreaSegment2.prototype.constructor = SplineAreaSegment2;
  SplineAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    var curveProcessor = new curve_processor_default(this.options.closed);
    var linePoints = this.points();
    return curveProcessor.process(linePoints);
  };
  SplineAreaSegment2.prototype.createStackSegments = function createStackSegments() {
    var strokeSegments = this.strokeSegments();
    var stackSegments = [];
    for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {
      var segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(segment.anchor(), segment.controlOut(), segment.controlIn()));
    }
    return stackSegments;
  };
  return SplineAreaSegment2;
}(area_segment_default);
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = function(LineChart2) {
  function AreaChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2) AreaChart2.__proto__ = LineChart2;
  AreaChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  AreaChart2.prototype.constructor = AreaChart2;
  AreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      var missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    var pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  };
  AreaChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    LineChart2.prototype.reflow.call(this, targetBox);
    var stackPoints = this._stackPoints;
    if (stackPoints) {
      for (var idx = 0; idx < stackPoints.length; idx++) {
        var stackPoint = stackPoints[idx];
        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  };
  AreaChart2.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {
    var this$1 = this;
    var seriesPoints = this.seriesPoints;
    var startIdx = linePoints[0].categoryIx;
    var length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    var endIdx = startIdx + length;
    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    var stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      var pointIx = categoryIx + pointOffset;
      var currentSeriesIx = seriesIx;
      var point = void 0;
      do {
        currentSeriesIx--;
        point = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point);
      if (point) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        var gapStackPoint = this$1._createGapStackPoint(categoryIx);
        this$1._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  };
  AreaChart2.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    var seriesPoints = this.seriesPoints;
    var index = seriesIdx;
    var point;
    while (index > 0 && !point) {
      index--;
      point = seriesPoints[index][segmentIx];
    }
    if (!point) {
      point = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point);
    } else {
      point = seriesPoints[index][pointIx];
    }
    return point;
  };
  AreaChart2.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {
    var options = this.pointOptions({}, 0);
    var point = new line_point_default(0, options);
    point.categoryIx = categoryIx;
    point.series = {};
    return point;
  };
  AreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  AreaChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return AreaChart2;
}(line_chart_default);
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = function(Class) {
  function AxisGroupRangeTracker2() {
    Class.call(this);
    this.axisRanges = {};
  }
  if (Class) AxisGroupRangeTracker2.__proto__ = Class;
  AxisGroupRangeTracker2.prototype = Object.create(Class && Class.prototype);
  AxisGroupRangeTracker2.prototype.constructor = AxisGroupRangeTracker2;
  AxisGroupRangeTracker2.prototype.update = function update(chartAxisRanges) {
    var axisRanges2 = this.axisRanges;
    for (var axisName in chartAxisRanges) {
      var chartRange = chartAxisRanges[axisName];
      var range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  };
  AxisGroupRangeTracker2.prototype.reset = function reset(axisName) {
    this.axisRanges[axisName] = void 0;
  };
  AxisGroupRangeTracker2.prototype.query = function query(axisName) {
    return this.axisRanges[axisName];
  };
  return AxisGroupRangeTracker2;
}(class_default);
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = function(ChartElement2) {
  function BarLabel2(content, options, pointData) {
    ChartElement2.call(this, options);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  if (ChartElement2) BarLabel2.__proto__ = ChartElement2;
  BarLabel2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BarLabel2.prototype.constructor = BarLabel2;
  BarLabel2.prototype.createVisual = function createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  };
  BarLabel2.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var vertical = options.vertical;
    var aboveAxis = options.aboveAxis;
    var text = this.children[0];
    var textOptions = text.options;
    var box = text.box;
    var padding = text.options.padding;
    var labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          labelBox = new box_default(targetBox.x1, targetBox.y1 - box.height(), targetBox.x2, targetBox.y1);
        } else {
          labelBox = new box_default(targetBox.x1, targetBox.y2, targetBox.x2, targetBox.y2 + box.height());
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(targetBox.x2, targetBox.y1, targetBox.x2 + box.width(), targetBox.y2);
        } else {
          labelBox = new box_default(targetBox.x1 - box.width(), targetBox.y1, targetBox.x1, targetBox.y2);
        }
      }
    }
    if (!options.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  };
  BarLabel2.prototype.alignToClipBox = function alignToClipBox(clipBox) {
    var vertical = this.options.vertical;
    var field = vertical ? Y : X;
    var start = field + "1";
    var end = field + "2";
    var text = this.children[0];
    var parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      var targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  };
  return BarLabel2;
}(chart_element_default);
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/accessibility-attributes-mixin.js
var AccessibilityAttributesMixin = {
  addAccessibilityAttributesToVisual: function() {
    this._id = this._id || guid();
    var accessibilityOptions = deepExtend({
      ariaLabel: this.getAriaLabelText()
    }, this.options.accessibility);
    addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
  },
  getAriaLabelText: function getAriaLabelText() {
    var labels = this.options.labels;
    var ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  },
  focusVisual: function focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
  },
  clearFocusFromVisual: function clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
  }
};
var accessibility_attributes_mixin_default = AccessibilityAttributesMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = function(ChartElement2) {
  function Bar2(value2, options) {
    ChartElement2.call(this);
    this.options = options;
    this.color = options.color || WHITE;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.value = value2;
  }
  if (ChartElement2) Bar2.__proto__ = ChartElement2;
  Bar2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bar2.prototype.constructor = Bar2;
  Bar2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  Bar2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bar2.prototype.createLabelElement = function createLabelElement(options) {
    return new bar_label_default(this.getLabelText(options), deepExtend({
      vertical: this.options.vertical
    }, options), this.pointData());
  };
  Bar2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  Bar2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Bar2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(targetBox);
      }
    }
  };
  Bar2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var options = ref2.options;
    var customVisual = options.visual;
    if (this.visible !== false) {
      ChartElement2.prototype.createVisual.call(this);
      this.addAccessibilityAttributesToVisual();
      if (customVisual) {
        var visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createRect(group);
            return group;
          },
          options
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  };
  Bar2.prototype.createRect = function createRect(visual) {
    var options = this.options;
    var border = options.border;
    var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;
    var rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    var path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: {
        color: this.color,
        opacity: options.opacity
      },
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    var width = this.box.width();
    var height = this.box.height();
    var size = options.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options)) {
      var overlay = this.createGradientOverlay(path, {
        baseColor: this.color
      }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay));
      visual.append(overlay);
    }
  };
  Bar2.prototype.createHighlight = function createHighlight(style) {
    var highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  Bar2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  Bar2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var highlight = drawing_exports.Path.fromRect(this.box.pad(borderWidth / 2).toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.getBorderColor = function getBorderColor() {
    var color = this.color;
    var border = this.options.border;
    var brightness = border._brightness || BORDER_BRIGHTNESS;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  };
  Bar2.prototype.tooltipAnchor = function tooltipAnchor() {
    var ref2 = this;
    var options = ref2.options;
    var box = ref2.box;
    var aboveAxis = ref2.aboveAxis;
    var clipBox = this.owner.pane.clipBox() || box;
    var horizontalAlign = LEFT;
    var verticalAlign = TOP;
    var x, y;
    if (options.vertical) {
      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y = Math.max(box.y1, clipBox.y1);
      } else {
        y = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      var x1 = Math.max(box.x1, clipBox.x1);
      var x2 = Math.min(box.x2, clipBox.x2);
      if (options.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x = x2;
        } else {
          x = x1;
        }
        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x = x2 + TOOLTIP_OFFSET;
        } else {
          x = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default(x, y),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  Bar2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bar2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  };
  Bar2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bar2;
}(chart_element_default);
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
deepExtend(Bar.prototype, accessibility_attributes_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = function(ChartElement2) {
  function ClusterLayout2(options) {
    ChartElement2.call(this, options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2) ClusterLayout2.__proto__ = ChartElement2;
  ClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ClusterLayout2.prototype.constructor = ClusterLayout2;
  ClusterLayout2.prototype.reflow = function reflow(box) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var gap = ref2.gap;
    var spacing = ref2.spacing;
    var children = this.children;
    var count = children.length;
    var axis = vertical ? Y : X;
    var slots = count + gap + spacing * (count - 1);
    var slotSize = (vertical ? box.height() : box.width()) / slots;
    var position = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, function(child, idx) {
      var childBox = (child.box || box).clone();
      childBox[axis + 1] = position;
      childBox[axis + 2] = position + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position += slotSize * spacing;
      }
      position += slotSize;
    });
  };
  return ClusterLayout2;
}(chart_element_default);
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = function(ChartElement2) {
  function StackWrap2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2) StackWrap2.__proto__ = ChartElement2;
  StackWrap2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  StackWrap2.prototype.constructor = StackWrap2;
  StackWrap2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var positionAxis = this.options.vertical ? X : Y;
    var children = this.children;
    var childrenCount = children.length;
    var box = this.box = new box_default();
    for (var i = 0; i < childrenCount; i++) {
      var currentChild = children[i];
      if (currentChild.visible !== false) {
        var childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i === 0) {
          box = this$1.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  };
  return StackWrap2;
}(chart_element_default);
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = function(CategoricalChart2) {
  function BarChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) BarChart2.__proto__ = CategoricalChart2;
  BarChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BarChart2.prototype.constructor = BarChart2;
  BarChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
  };
  BarChart2.prototype.pointType = function pointType() {
    return bar_default;
  };
  BarChart2.prototype.clusterType = function clusterType() {
    return cluster_layout_default;
  };
  BarChart2.prototype.stackType = function stackType() {
    return stack_wrap_default;
  };
  BarChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var limits = CategoricalChart2.prototype.stackLimits.call(this, axisName, stackName);
    return limits;
  };
  BarChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var stackOrDefault = defined(series.stack) ? series.stack : options.defaultStack;
    var value2 = this.pointValue(data);
    var pointOptions = this.pointOptions(series, seriesIx);
    var labelOptions = pointOptions.labels;
    if (stackOrDefault) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = stackOrDefault;
    var color = data.fields.color || series.color;
    if (value2 < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var pointType = this.pointType();
    var point = new pointType(value2, pointOptions);
    point.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      var clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (options.isStacked) {
      var stackWrap = this.getStackWrap(stackOrDefault, cluster);
      stackWrap.append(point);
    } else {
      cluster.append(point);
    }
    return point;
  };
  BarChart2.prototype.getStackWrap = function getStackWrap(stack, cluster) {
    var stackGroup = typeof stack === OBJECT ? stack.group || true : stack;
    var wraps = cluster.children;
    var stackWrap;
    if (typeof stackGroup === STRING || stackGroup === true) {
      for (var i = 0; i < wraps.length; i++) {
        if (wraps[i]._stackGroup === stackGroup) {
          stackWrap = wraps[i];
          break;
        }
      }
    }
    if (!stackWrap) {
      var stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  };
  BarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {
    var options = this.options;
    var categorySlot2 = categoryAxis.getSlot(categoryIx);
    var startValue = valueAxis.startValue();
    if (options.isStacked) {
      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      var stackAxis = options.invertAxes ? X : Y;
      categorySlot2[stackAxis + 1] = categorySlot2[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot2;
  };
  BarChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BarChart2.prototype.createAnimation = function createAnimation() {
    this._setAnimationOptions();
    CategoricalChart2.prototype.createAnimation.call(this);
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  };
  BarChart2.prototype._setChildrenAnimation = function _setChildrenAnimation() {
    var this$1 = this;
    var points = this.points;
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      var pointVisual = point.visual;
      if (pointVisual && defined(pointVisual.options.zIndex)) {
        point.options.animation = this$1.options.animation;
        point.createAnimation();
      }
    }
  };
  BarChart2.prototype._setAnimationOptions = function _setAnimationOptions() {
    var options = this.options;
    var animation = options.animation || {};
    var origin;
    if (options.isStacked) {
      var valueAxis = this.seriesValueAxis(options.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options.invertAxes;
  };
  return BarChart2;
}(categorical_chart_default);
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = function(ChartElement2) {
  function Candlestick2(value2, options) {
    ChartElement2.call(this, options);
    this.value = value2;
  }
  if (ChartElement2) Candlestick2.__proto__ = ChartElement2;
  Candlestick2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Candlestick2.prototype.constructor = Candlestick2;
  Candlestick2.prototype.getLabelText = function getLabelText(options) {
    return this.formatValue(options.format);
  };
  Candlestick2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var ocSlot = valueAxis.getSlot(value2.open, value2.close);
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    var mid = lhSlot.center().x;
    var points = [];
    points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  };
  Candlestick2.prototype.reflowNote = function reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  };
  Candlestick2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(this._mainVisual);
    this.createOverlay();
  };
  Candlestick2.prototype.mainVisual = function mainVisual(options) {
    var group = new drawing_exports.Group();
    this.createBody(group, options);
    this.createLines(group, options);
    return group;
  };
  Candlestick2.prototype.createBody = function createBody(container, options) {
    var body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: {
        color: this.color,
        opacity: options.opacity
      },
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options)) {
      container.append(this.createGradientOverlay(body, {
        baseColor: this.color
      }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay)));
    }
  };
  Candlestick2.prototype.createLines = function createLines(container, options) {
    this.drawLines(container, options, this.lines, options.line);
  };
  Candlestick2.prototype.drawLines = function drawLines(container, options, lines, lineOptions) {
    if (!lines) {
      return;
    }
    var lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault(lineOptions.opacity, options.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (var i = 0; i < lines.length; i++) {
      var line = drawing_exports.Path.fromPoints(lines[i], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  };
  Candlestick2.prototype.getBorderColor = function getBorderColor() {
    var border = this.options.border;
    var borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  };
  Candlestick2.prototype.createOverlay = function createOverlay() {
    var overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  };
  Candlestick2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var normalColor = this.color;
    this.color = highlight.color || this.color;
    var overlay = this.mainVisual(deepExtend({}, this.options, {
      line: {
        color: this.getBorderColor()
      }
    }, highlight));
    this.color = normalColor;
    return overlay;
  };
  Candlestick2.prototype.highlightVisual = function highlightVisual() {
    return this._mainVisual;
  };
  Candlestick2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  };
  Candlestick2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    var clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  };
  Candlestick2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Candlestick2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Candlestick2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      value: this.value,
      meanPoints: this.meanPoints,
      medianPoints: this.medianPoints,
      whiskerPoints: this.whiskerPoints,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  Candlestick2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Candlestick2;
}(chart_element_default);
Candlestick.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  labels: {
    format: ""
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
deepExtend(Candlestick.prototype, accessibility_attributes_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = function(CategoricalChart2) {
  function CandlestickChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) CandlestickChart2.__proto__ = CategoricalChart2;
  CandlestickChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  CandlestickChart2.prototype.constructor = CandlestickChart2;
  CandlestickChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  CandlestickChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var value2 = data.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
      point.noteText = data.fields.noteText;
    }
    this.points.push(point);
    categoryPoints.push(point);
  };
  CandlestickChart2.prototype.pointType = function pointType() {
    return candlestick_default;
  };
  CandlestickChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var pointType = this.pointType();
    var value2 = data.valueFields;
    var pointOptions = deepExtend({}, series);
    var color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (series.type === CANDLESTICK || series.type === OHLC) {
      if (value2.open > value2.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    var point = new pointType(value2, pointOptions);
    point.color = color;
    return point;
  };
  CandlestickChart2.prototype.splitValue = function splitValue(value2) {
    return [value2.low, value2.open, value2.close, value2.high];
  };
  CandlestickChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2);
    var axisRange = this.valueAxisRanges[axisName] || {
      min: MAX_VALUE,
      max: MIN_VALUE
    };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  CandlestickChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.open, value2.high, value2.low, value2.close, point.category);
  };
  CandlestickChart2.prototype.animationPoints = function animationPoints() {
    return this.points;
  };
  return CandlestickChart2;
}(categorical_chart_default);
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = function(Candlestick2) {
  function BoxPlot2(value2, options) {
    Candlestick2.call(this, value2, options);
    this.createNote();
  }
  if (Candlestick2) BoxPlot2.__proto__ = Candlestick2;
  BoxPlot2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  BoxPlot2.prototype.constructor = BoxPlot2;
  BoxPlot2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value2.q1, value2.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value2.lower, value2.upper);
    this.reflowWhiskerSlot(box);
    var medianSlot = valueAxis.getSlot(value2.median);
    if (value2.mean) {
      var meanSlot = valueAxis.getSlot(value2.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  };
  BoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [[[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]];
  };
  BoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().x;
    return [[[mid - 5, whiskerSlot.y1], [mid + 5, whiskerSlot.y1], [mid, whiskerSlot.y1], [mid, boxSlot.y1]], [[mid - 5, whiskerSlot.y2], [mid + 5, whiskerSlot.y2], [mid, whiskerSlot.y2], [mid, boxSlot.y2]]];
  };
  BoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [[[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]];
  };
  BoxPlot2.prototype.renderOutliers = function renderOutliers(options) {
    var this$1 = this;
    var value2 = this.value;
    var outliers = value2.outliers || [];
    var outerFence = Math.abs(value2.q3 - value2.q1) * 3;
    var elements = [];
    var markers = options.markers || {};
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i];
      if (outlierValue < value2.q3 + outerFence && outlierValue > value2.q1 - outerFence) {
        markers = options.outliers;
      } else {
        markers = options.extremes;
      }
      var markersBorder = deepExtend({}, markers.border);
      if (!defined(markersBorder.color)) {
        if (defined(this$1.color)) {
          markersBorder.color = this$1.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      var shape = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape.value = outlierValue;
      elements.push(shape);
    }
    this.reflowOutliers(elements);
    return elements;
  };
  BoxPlot2.prototype.reflowOutliers = function reflowOutliers(outliers) {
    var this$1 = this;
    var valueAxis = this.owner.seriesValueAxis(this.options);
    var center = this.box.center();
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i].value;
      var markerBox = valueAxis.getSlot(outlierValue);
      if (this$1.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this$1.box = this$1.box.wrap(markerBox);
      outliers[i].reflow(markerBox);
    }
  };
  BoxPlot2.prototype.mainVisual = function mainVisual(options) {
    var group = Candlestick2.prototype.mainVisual.call(this, options);
    var outliers = this.renderOutliers(options);
    for (var i = 0; i < outliers.length; i++) {
      var element = outliers[i].getElement();
      if (element) {
        group.append(element);
      }
    }
    return group;
  };
  BoxPlot2.prototype.createLines = function createLines(container, options) {
    this.drawLines(container, options, this.whiskerPoints, options.whiskers);
    this.drawLines(container, options, this.medianPoints, options.median);
    this.drawLines(container, options, this.meanPoints, options.mean);
  };
  BoxPlot2.prototype.getBorderColor = function getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return Candlestick2.prototype.getBorderColor.call(this);
  };
  return BoxPlot2;
}(candlestick_default);
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = function(BoxPlot2) {
  function VerticalBoxPlot2() {
    BoxPlot2.apply(this, arguments);
  }
  if (BoxPlot2) VerticalBoxPlot2.__proto__ = BoxPlot2;
  VerticalBoxPlot2.prototype = Object.create(BoxPlot2 && BoxPlot2.prototype);
  VerticalBoxPlot2.prototype.constructor = VerticalBoxPlot2;
  VerticalBoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [[[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]];
  };
  VerticalBoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().y;
    return [[[whiskerSlot.x1, mid - 5], [whiskerSlot.x1, mid + 5], [whiskerSlot.x1, mid], [boxSlot.x1, mid]], [[whiskerSlot.x2, mid - 5], [whiskerSlot.x2, mid + 5], [whiskerSlot.x2, mid], [boxSlot.x2, mid]]];
  };
  VerticalBoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [[[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]];
  };
  return VerticalBoxPlot2;
}(box_plot_default);
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = function(CandlestickChart2) {
  function BoxPlotChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2) BoxPlotChart2.__proto__ = CandlestickChart2;
  BoxPlotChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  BoxPlotChart2.prototype.constructor = BoxPlotChart2;
  BoxPlotChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var value2 = data.valueFields;
    var valueParts = this.splitValue(value2);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
    }
    this.points.push(point);
    categoryPoints.push(point);
  };
  BoxPlotChart2.prototype.pointType = function pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  };
  BoxPlotChart2.prototype.splitValue = function splitValue(value2) {
    return [value2.lower, value2.q1, value2.median, value2.q3, value2.upper];
  };
  BoxPlotChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value2).concat(this.filterOutliers(value2.outliers));
    if (defined(value2.mean)) {
      parts = parts.concat(value2.mean);
    }
    var axisRange = this.valueAxisRanges[axisName] || {
      min: MAX_VALUE,
      max: MIN_VALUE
    };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  BoxPlotChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.lower, value2.q1, value2.median, value2.q3, value2.upper, value2.mean, point.category);
  };
  BoxPlotChart2.prototype.filterOutliers = function filterOutliers(items) {
    var length = (items || []).length;
    var result = [];
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (defined(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  };
  BoxPlotChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return BoxPlotChart2;
}(candlestick_chart_default);
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = function(ErrorBarBase2) {
  function ScatterErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2) ScatterErrorBar2.__proto__ = ErrorBarBase2;
  ScatterErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  ScatterErrorBar2.prototype.constructor = ScatterErrorBar2;
  ScatterErrorBar2.prototype.getAxis = function getAxis() {
    var axes = this.chart.seriesAxes(this.series);
    var axis = this.isVertical ? axes.y : axes.x;
    return axis;
  };
  return ScatterErrorBar2;
}(error_bar_base_default);
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = function(ChartElement2) {
  function ScatterChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2) ScatterChart2.__proto__ = ChartElement2;
  ScatterChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ScatterChart2.prototype.constructor = ScatterChart2;
  ScatterChart2.prototype._initFields = function _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  };
  ScatterChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  ScatterChart2.prototype.addErrorBar = function addErrorBar(point, field, fields) {
    var value2 = point.value[field];
    var valueErrorField = field + "Value";
    var lowField = field + "ErrorLow";
    var highField = field + "ErrorHigh";
    var seriesIx = fields.seriesIx;
    var series = fields.series;
    var errorBars = point.options.errorBars;
    var lowValue = fields[lowField];
    var highValue = fields[highField];
    if (isNumber(value2)) {
      var errorRange;
      if (isNumber(lowValue) && isNumber(highValue)) {
        errorRange = {
          low: lowValue,
          high: highValue
        };
      }
      if (errorBars && defined(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || {
          x: [],
          y: []
        };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value2, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point, field);
      }
    }
  };
  ScatterChart2.prototype.addPointErrorBar = function addPointErrorBar(errorRange, point, field) {
    var low = errorRange.low;
    var high = errorRange.high;
    var series = point.series;
    var options = point.options.errorBars;
    var isVertical = field === Y;
    var item = {};
    point[field + "Low"] = low;
    point[field + "High"] = high;
    point.errorBars = point.errorBars || [];
    var errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars.push(errorBar);
    point.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  };
  ScatterChart2.prototype.addValue = function addValue(value2, fields) {
    var x = value2.x;
    var y = value2.y;
    var seriesIx = fields.seriesIx;
    var series = this.options.series[seriesIx];
    var missingValues = this.seriesMissingValues(series);
    var seriesPoints = this.seriesPoints[seriesIx];
    var pointValue = value2;
    if (!(hasValue(x) && hasValue(y))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    var point;
    if (pointValue) {
      point = this.createPoint(pointValue, fields);
      if (point) {
        Object.assign(point, fields);
        this.addErrorBar(point, X, fields);
        this.addErrorBar(point, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point);
    seriesPoints.push(point);
  };
  ScatterChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues;
  };
  ScatterChart2.prototype.createMissingValue = function createMissingValue() {
  };
  ScatterChart2.prototype.updateRange = function updateRange(value2, series) {
    var intlService = this.chartService.intl;
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var x = value2.x;
    var y = value2.y;
    var xAxisRange = this.xAxisRanges[xAxisName];
    var yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      if (isString(x)) {
        x = parseDate(intlService, x);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x);
      xAxisRange.max = Math.max(xAxisRange.max, x);
    }
    if (hasValue(y)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      if (isString(y)) {
        y = parseDate(intlService, y);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y);
      yAxisRange.max = Math.max(yAxisRange.max, y);
    }
  };
  ScatterChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: ["data", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint", "drilldownSeriesFactory", "ariaTemplate", "ariaContent"]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  };
  ScatterChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  ScatterChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options;
  };
  ScatterChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  ScatterChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  };
  ScatterChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point = chartPoints[pointIx++];
      var seriesAxes = this$1.seriesAxes(fields.series);
      var slotX = seriesAxes.x.getSlot(value2.x, value2.x, limit);
      var slotY = seriesAxes.y.getSlot(value2.y, value2.y, limit);
      if (point) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  ScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  ScatterChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var seriesPoints = ref2.seriesPoints;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$1.valueFields;
        var fields = ref$1.fields;
        callback(value2, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this$1
        }, fields));
      }
    }
  };
  ScatterChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y);
  };
  ScatterChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  };
  return ScatterChart2;
}(chart_element_default);
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default);
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = function(LinePoint2) {
  function Bubble2(value2, options) {
    LinePoint2.call(this, value2, options);
    this.category = value2.category;
  }
  if (LinePoint2) Bubble2.__proto__ = LinePoint2;
  Bubble2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  Bubble2.prototype.constructor = Bubble2;
  Bubble2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var border = highlight.border;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width + border.width) / 2;
    var highlightGroup = new drawing_exports.Group();
    var shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    var overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: {
        color: markers.background,
        opacity: highlight.opacity
      }
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  };
  Bubble2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var highlightOptions2 = this.options.accessibility.highlight;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width) / 2 + highlightOptions2.border.width / 2;
    var highlight = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), style);
    return highlight;
  };
  return Bubble2;
}(line_point_default);
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = function(ScatterChart2) {
  function BubbleChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) BubbleChart2.__proto__ = ScatterChart2;
  BubbleChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  BubbleChart2.prototype.constructor = BubbleChart2;
  BubbleChart2.prototype._initFields = function _initFields() {
    this._maxSize = MIN_VALUE;
    ScatterChart2.prototype._initFields.call(this);
  };
  BubbleChart2.prototype.addValue = function addValue(value2, fields) {
    if (value2.size !== null && (value2.size > 0 || value2.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value2.size));
      ScatterChart2.prototype.addValue.call(this, value2, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  };
  BubbleChart2.prototype.reflow = function reflow(box) {
    this.updateBubblesSize(box);
    ScatterChart2.prototype.reflow.call(this, box);
  };
  BubbleChart2.prototype.pointType = function pointType() {
    return bubble_default;
  };
  BubbleChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointsCount = series.data.length;
    var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    var animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    var color = fields.color || series.color;
    if (value2.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault(series.negativeValues.color, color);
    }
    var pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    var point = new bubble_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  BubbleChart2.prototype.updateBubblesSize = function updateBubblesSize(box) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var boxSize = Math.min(box.width(), box.height());
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesPoints = this$1.seriesPoints[seriesIx];
      var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      var maxSize = currentSeries.maxSize || boxSize * 0.2;
      var minR = minSize / 2;
      var maxR = maxSize / 2;
      var minArea = Math.PI * minR * minR;
      var maxArea = Math.PI * maxR * maxR;
      var areaRange = maxArea - minArea;
      var areaRatio = areaRange / this$1._maxSize;
      for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        var point = seriesPoints[pointIx];
        if (point) {
          var area = Math.abs(point.value.size) * areaRatio;
          var radius = Math.sqrt((minArea + area) / Math.PI);
          var baseZIndex = valueOrDefault(point.options.zIndex, 0);
          var zIndex = baseZIndex + (1 - radius / maxR);
          deepExtend(point.options, {
            zIndex,
            markers: {
              size: radius * 2,
              zIndex
            },
            labels: {
              zIndex: zIndex + 1
            }
          });
        }
      }
    }
  };
  BubbleChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.size, point.category);
  };
  BubbleChart2.prototype.createAnimation = function createAnimation() {
  };
  BubbleChart2.prototype.createVisual = function createVisual() {
  };
  return BubbleChart2;
}(scatter_chart_default);
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = function(ShapeElement2) {
  function Target2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) Target2.__proto__ = ShapeElement2;
  Target2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  Target2.prototype.constructor = Target2;
  return Target2;
}(shape_element_default);
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = function(ChartElement2) {
  function Bullet2(value2, options) {
    ChartElement2.call(this, options);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  if (ChartElement2) Bullet2.__proto__ = ChartElement2;
  Bullet2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bullet2.prototype.constructor = Bullet2;
  Bullet2.prototype.render = function render() {
    var options = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined(this.value.target)) {
        this.target = new target_default({
          type: options.target.shape,
          background: options.target.color || this.color,
          opacity: options.opacity,
          zIndex: options.zIndex,
          border: options.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  };
  Bullet2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  Bullet2.prototype.createLabelElement = function createLabelElement(options) {
    return new bar_label_default(this.getLabelText(options), options, this.pointData());
  };
  Bullet2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  Bullet2.prototype.reflow = function reflow(box) {
    this.render();
    var ref2 = this;
    var options = ref2.options;
    var target = ref2.target;
    var chart = ref2.owner;
    var invertAxes = options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.options);
    var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);
    var targetValueSlot = valueAxis.getSlot(this.value.target);
    var targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    var targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      var targetSlot = new box_default(targetSlotX.x1, targetSlotY.y1, targetSlotX.x2, targetSlotY.y2);
      target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;
      target.options.width = invertAxes ? options.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    var label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  };
  Bullet2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    var options = this.options;
    var body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: this.color,
        opacity: options.opacity
      },
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: options.border.color || this.color,
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  };
  Bullet2.prototype.createAnimation = function createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(this.bodyVisual, this.options.animation);
    }
  };
  Bullet2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  };
  Bullet2.prototype.highlightVisual = function highlightVisual() {
    return this.bodyVisual;
  };
  Bullet2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  };
  Bullet2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  Bullet2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  };
  Bullet2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bullet2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return Bullet2;
}(chart_element_default);
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
Bullet.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
deepExtend(Bullet.prototype, accessibility_attributes_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = function(CategoricalChart2) {
  function BulletChart2(plotArea, options) {
    wrapData(options);
    CategoricalChart2.call(this, plotArea, options);
  }
  if (CategoricalChart2) BulletChart2.__proto__ = CategoricalChart2;
  BulletChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BulletChart2.prototype.constructor = BulletChart2;
  BulletChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BulletChart2.prototype.plotRange = function plotRange(point) {
    var series = point.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point.value.current || axisCrossingValue];
  };
  BulletChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var value2 = data.valueFields;
    var bulletOptions = deepExtend({
      vertical: !options.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options.invertAxes
    }, series);
    var color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value2, fields);
    if (isFunction(series.color)) {
      color = bulletOptions.color;
    }
    var bullet = new bullet_default(value2, bulletOptions);
    bullet.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  };
  BulletChart2.prototype.updateRange = function updateRange(value2, fields) {
    var current4 = value2.current;
    var target = value2.target;
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    if (defined(current4) && !isNaN(current4) && defined(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  };
  BulletChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value.current, point.value.target);
  };
  BulletChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.current;
  };
  BulletChart2.prototype.aboveAxis = function aboveAxis(point) {
    var value2 = point.value.current;
    return value2 > 0;
  };
  BulletChart2.prototype.createAnimation = function createAnimation() {
    var this$1 = this;
    var points = this.points;
    this._setAnimationOptions();
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      point.options.animation = this$1.options.animation;
      point.createAnimation();
    }
  };
  return BulletChart2;
}(categorical_chart_default);
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options) {
  var series = options.series;
  for (var i = 0; i < series.length; i++) {
    var seriesItem = series[i];
    var data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = function(Class) {
  function BaseTooltip3(chartService, options) {
    Class.call(this);
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options);
  }
  if (Class) BaseTooltip3.__proto__ = Class;
  BaseTooltip3.prototype = Object.create(Class && Class.prototype);
  BaseTooltip3.prototype.constructor = BaseTooltip3;
  BaseTooltip3.prototype.getStyle = function getStyle(options, point) {
    var background = options.background;
    var border = options.border.color;
    if (point) {
      var pointColor = point.color || point.options.color;
      background = valueOrDefault(background, pointColor);
      border = valueOrDefault(border, pointColor);
    }
    var padding = getSpacing(options.padding || {}, "auto");
    return {
      backgroundColor: background,
      borderColor: border,
      font: options.font,
      color: options.color,
      opacity: options.opacity,
      borderWidth: styleValue(options.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  };
  BaseTooltip3.prototype.show = function show2(options, tooltipOptions, point) {
    options.format = tooltipOptions.format;
    var style = this.getStyle(tooltipOptions, point);
    options.style = style;
    var background = new color_default(style.backgroundColor);
    if (!defined(tooltipOptions.color) && !background.isDark()) {
      options.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options);
    this.visible = true;
  };
  BaseTooltip3.prototype.hide = function hide2() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  };
  BaseTooltip3.prototype.destroy = function destroy() {
    delete this.chartService;
  };
  return BaseTooltip3;
}(class_default);
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = function(BaseTooltip3) {
  function CrosshairTooltip2(chartService, crosshair, options) {
    BaseTooltip3.call(this, chartService, options);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  if (BaseTooltip3) CrosshairTooltip2.__proto__ = BaseTooltip3;
  CrosshairTooltip2.prototype = Object.create(BaseTooltip3 && BaseTooltip3.prototype);
  CrosshairTooltip2.prototype.constructor = CrosshairTooltip2;
  CrosshairTooltip2.prototype.initAxisName = function initAxisName() {
    var axis = this.crosshair.axis;
    var plotArea = axis.plotArea;
    var name2;
    if (plotArea.categoryAxis) {
      name2 = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name2 = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name2;
  };
  CrosshairTooltip2.prototype.showAt = function showAt(point) {
    var ref2 = this;
    var axis = ref2.crosshair.axis;
    var options = ref2.options;
    var value2 = axis[options.stickyMode ? "getCategory" : "getValue"](point);
    var formattedValue = value2;
    if (options.format) {
      formattedValue = this.formatService.auto(options.format, value2);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value2);
    }
    this.show({
      point,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  };
  CrosshairTooltip2.prototype.hide = function hide2() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  };
  CrosshairTooltip2.prototype.getAnchor = function getAnchor() {
    var ref2 = this;
    var crosshair = ref2.crosshair;
    var ref_options = ref2.options;
    var position = ref_options.position;
    var padding = ref_options.padding;
    var vertical = !crosshair.axis.options.vertical;
    var lineBox = crosshair.line.bbox();
    var horizontalAlign, verticalAlign, point;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position === BOTTOM) {
        verticalAlign = TOP;
        point = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position === LEFT) {
        horizontalAlign = RIGHT;
        point = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  return CrosshairTooltip2;
}(base_tooltip_default);
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = function(ChartElement2) {
  function Crosshair2(chartService, axis, options) {
    ChartElement2.call(this, options);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    var tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(chartService, this, deepExtend({}, tooltipOptions, {
        stickyMode: this.stickyMode
      }));
    }
  }
  if (ChartElement2) Crosshair2.__proto__ = ChartElement2;
  Crosshair2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Crosshair2.prototype.constructor = Crosshair2;
  Crosshair2.prototype.showAt = function showAt(point) {
    this.point = point;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point);
    }
  };
  Crosshair2.prototype.hide = function hide2() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  };
  Crosshair2.prototype.moveLine = function moveLine() {
    var ref2 = this;
    var axis = ref2.axis;
    var point = ref2.point;
    var vertical = axis.options.vertical;
    var box = this.getBox();
    var dim = vertical ? Y : X;
    var lineStart = new geometry_exports.Point(box.x1, box.y1);
    var lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point) {
      if (this.stickyMode) {
        var slot = axis.getSlot(axis.pointCategoryIndex(point));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  };
  Crosshair2.prototype.getBox = function getBox() {
    var axis = this.axis;
    var axes = axis.pane.axes;
    var length = axes.length;
    var vertical = axis.options.vertical;
    var box = axis.lineBox().clone();
    var dim = vertical ? X : Y;
    var axisLineBox;
    for (var i = 0; i < length; i++) {
      var currentAxis = axes[i];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  };
  Crosshair2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options.color,
        width: options.width,
        opacity: options.opacity,
        dashType: options.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  };
  Crosshair2.prototype.destroy = function destroy() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    ChartElement2.prototype.destroy.call(this);
  };
  return Crosshair2;
}(chart_element_default);
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = function(ChartElement2) {
  function ChartContainer2(options, pane) {
    ChartElement2.call(this, options);
    this.pane = pane;
  }
  if (ChartElement2) ChartContainer2.__proto__ = ChartElement2;
  ChartContainer2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ChartContainer2.prototype.constructor = ChartContainer2;
  ChartContainer2.prototype.shouldClip = function shouldClip() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      if (children[i].options.clip === true) {
        return true;
      }
    }
    return false;
  };
  ChartContainer2.prototype._clipBox = function _clipBox() {
    return this.pane.chartsBox();
  };
  ChartContainer2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      var clipBox = this.clipBox = this._clipBox();
      var clipRect = clipBox.toRect();
      var clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  };
  ChartContainer2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  ChartContainer2.prototype.unclipLabels = function unclipLabels() {
    var ref2 = this;
    var charts = ref2.children;
    var clipBox = ref2.clipBox;
    for (var i = 0; i < charts.length; i++) {
      var points = charts[i].points || {};
      var length = points.length;
      for (var j = 0; j < length; j++) {
        var point = points[j];
        if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {
          if (point.unclipElements) {
            point.unclipElements();
          } else {
            var label = point.label;
            var note = point.note;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note && note.options.visible) {
              note.options.noclip = true;
            }
          }
        }
      }
    }
  };
  ChartContainer2.prototype.destroy = function destroy() {
    ChartElement2.prototype.destroy.call(this);
    delete this.parent;
  };
  return ChartContainer2;
}(chart_element_default);
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = function(BoxElement2) {
  function Pane3(options) {
    BoxElement2.call(this, options);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  if (BoxElement2) Pane3.__proto__ = BoxElement2;
  Pane3.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Pane3.prototype.constructor = Pane3;
  Pane3.prototype.createTitle = function createTitle() {
    var titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, Pane3.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  };
  Pane3.prototype.appendAxis = function appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  };
  Pane3.prototype.appendAxisAt = function appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  };
  Pane3.prototype.appendChart = function appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  };
  Pane3.prototype.empty = function empty() {
    var this$1 = this;
    var plotArea = this.parent;
    if (plotArea) {
      for (var i = 0; i < this.axes.length; i++) {
        plotArea.removeAxis(this$1.axes[i]);
      }
      for (var i$1 = 0; i$1 < this.charts.length; i$1++) {
        plotArea.removeChart(this$1.charts[i$1]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  };
  Pane3.prototype.reflow = function reflow(targetBox) {
    var content;
    if (last(this.children) === this.content) {
      content = this.children.pop();
    }
    BoxElement2.prototype.reflow.call(this, targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  };
  Pane3.prototype.visualStyle = function visualStyle() {
    var style = BoxElement2.prototype.visualStyle.call(this);
    style.zIndex = -10;
    return style;
  };
  Pane3.prototype.renderComplete = function renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  };
  Pane3.prototype.stackRoot = function stackRoot() {
    return this;
  };
  Pane3.prototype.clipRoot = function clipRoot() {
    return this;
  };
  Pane3.prototype.createGridLines = function createGridLines() {
    var axes = this.axes;
    var allAxes = axes.concat(this.parent.axes);
    var vGridLines = [];
    var hGridLines = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var vertical = axis.options.vertical;
      var gridLines = vertical ? vGridLines : hGridLines;
      for (var j = 0; j < allAxes.length; j++) {
        if (gridLines.length === 0) {
          var altAxis = allAxes[j];
          if (vertical !== altAxis.options.vertical) {
            append(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  };
  Pane3.prototype.refresh = function refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  };
  Pane3.prototype.chartsBox = function chartsBox() {
    var axes = this.axes;
    var length = axes.length;
    var chartsBox2 = new box_default();
    for (var idx = 0; idx < length; idx++) {
      var axis = axes[idx];
      var axisValueField = axis.options.vertical ? Y : X;
      var lineBox = axis.lineBox();
      chartsBox2[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox2[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox2.x2 === 0) {
      var allAxes = this.parent.axes;
      var length$1 = allAxes.length;
      for (var idx$1 = 0; idx$1 < length$1; idx$1++) {
        var axis$1 = allAxes[idx$1];
        if (!axis$1.options.vertical) {
          var lineBox$1 = axis$1.lineBox();
          chartsBox2.x1 = lineBox$1.x1;
          chartsBox2.x2 = lineBox$1.x2;
        }
      }
    }
    return chartsBox2;
  };
  Pane3.prototype.clipBox = function clipBox() {
    return this.chartContainer.clipBox;
  };
  Pane3.prototype.notifyRender = function notifyRender() {
    var service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  };
  return Pane3;
}(box_element_default);
var ID2 = 1;
function paneID() {
  return "pane" + ID2++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var PlotAreaBase = function(ChartElement2) {
  function PlotAreaBase2(series, options, chartService) {
    ChartElement2.call(this, options);
    this.initFields(series, options);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.data = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options;
    this.originalSeries = series;
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  if (ChartElement2) PlotAreaBase2.__proto__ = ChartElement2;
  PlotAreaBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PlotAreaBase2.prototype.constructor = PlotAreaBase2;
  PlotAreaBase2.prototype.initFields = function initFields() {
  };
  PlotAreaBase2.prototype.initSeries = function initSeries() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      series[i].index = i;
    }
  };
  PlotAreaBase2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var cached = this._bindCache.get(series);
    if (!cached) {
      cached = [];
      this._bindCache.set(series, cached);
    }
    var data = cached[pointIx];
    if (!data) {
      data = cached[pointIx] = series_binder_default.current.bindPoint(series, pointIx, item);
    }
    return data;
  };
  PlotAreaBase2.prototype.createPanes = function createPanes() {
    var this$1 = this;
    var titleOptions = this.options.title || {};
    var paneDefaults = this.options.paneDefaults;
    var paneOptions = this.options.panes || [];
    var panesLength = Math.max(paneOptions.length, 1);
    var panes = [];
    var defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (var i = 0; i < panesLength; i++) {
      var options = deepExtend({}, defaults, paneOptions[i]);
      if (isString(options.title)) {
        options.title = deepExtend({
          text: options.title
        }, defaults.title);
      }
      var currentPane = new pane_default(options);
      currentPane.paneIndex = i;
      panes.push(currentPane);
      this$1.append(currentPane);
    }
    this.panes = panes;
  };
  PlotAreaBase2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return axis.options.crosshair;
  };
  PlotAreaBase2.prototype.createCrosshairs = function createCrosshairs(panes) {
    var this$1 = this;
    if (panes === void 0) panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      for (var j = 0; j < pane.axes.length; j++) {
        var axis = pane.axes[j];
        var options = this$1.crosshairOptions(axis);
        if (options && options.visible) {
          var currentCrosshair = new crosshair_default(this$1.chartService, axis, options);
          this$1.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  };
  PlotAreaBase2.prototype.removeCrosshairs = function removeCrosshairs(pane) {
    var crosshairs = this.crosshairs;
    var axes = pane.axes;
    for (var i = crosshairs.length - 1; i >= 0; i--) {
      for (var j = 0; j < axes.length; j++) {
        if (crosshairs[i].axis === axes[j]) {
          crosshairs.splice(i, 1);
          break;
        }
      }
    }
  };
  PlotAreaBase2.prototype.hideCrosshairs = function hideCrosshairs() {
    var crosshairs = this.crosshairs;
    for (var idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  };
  PlotAreaBase2.prototype.findPane = function findPane(name2) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].options.name === name2) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane || panes[0];
  };
  PlotAreaBase2.prototype.findPointPane = function findPointPane(point) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].box.containsPoint(point)) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane;
  };
  PlotAreaBase2.prototype.appendAxis = function appendAxis(axis) {
    var pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  };
  PlotAreaBase2.prototype.removeAxis = function removeAxis(axisToRemove) {
    var this$1 = this;
    var filteredAxes = [];
    for (var i = 0; i < this.axes.length; i++) {
      var axis = this$1.axes[i];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  };
  PlotAreaBase2.prototype.appendChart = function appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  };
  PlotAreaBase2.prototype.removeChart = function removeChart(chartToRemove) {
    var this$1 = this;
    var filteredCharts = [];
    for (var i = 0; i < this.charts.length; i++) {
      var chart = this$1.charts[i];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  };
  PlotAreaBase2.prototype.addToLegend = function addToLegend(series) {
    var count = series.length;
    var legend2 = this.options.legend;
    var labels = legend2.labels || {};
    var inactiveItems = legend2.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    var data = [];
    for (var i = 0; i < count; i++) {
      var currentSeries = series[i];
      var seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      var text = currentSeries.name;
      var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      var defaults = currentSeries._defaults;
      var color = currentSeries.color;
      if (isFunction(color) && defaults) {
        color = defaults.color;
      }
      var itemLabelOptions = void 0, markerColor = void 0;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append(legend2.data, data);
  };
  PlotAreaBase2.prototype.groupAxes = function groupAxes(panes) {
    var xAxes = [];
    var yAxes = [];
    for (var paneIx = 0; paneIx < panes.length; paneIx++) {
      var paneAxes = panes[paneIx].axes;
      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        var axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return {
      x: xAxes,
      y: yAxes,
      any: xAxes.concat(yAxes)
    };
  };
  PlotAreaBase2.prototype.groupSeriesByPane = function groupSeriesByPane() {
    var this$1 = this;
    var series = this.series;
    var seriesByPane = {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var pane = this$1.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  };
  PlotAreaBase2.prototype.filterVisibleSeries = function filterVisibleSeries(series) {
    var result = [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.reflow = function reflow(targetBox) {
    var options = this.options.plotArea;
    var panes = this.panes;
    var margin = getSpacing(options.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  };
  PlotAreaBase2.prototype.redraw = function redraw(panes) {
    var this$1 = this;
    var panesArray = [].concat(panes);
    this.initSeries();
    var root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (var i = 0; i < panesArray.length; i++) {
      this$1.removeCrosshairs(panesArray[i]);
      panesArray[i].empty();
    }
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (var i$1 = 0; i$1 < panesArray.length; i$1++) {
      panesArray[i$1].refresh();
    }
  };
  PlotAreaBase2.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {
    var options = axis.options;
    var crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);
    var valuesToAdd = crossingAxes.length - crossingValues.length;
    var defaultValue = crossingValues[0] || 0;
    for (var i = 0; i < valuesToAdd; i++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  };
  PlotAreaBase2.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    var slot = axis.getSlot(crossingValue, crossingValue, true);
    var slotEdge = axis.options.reverse ? 2 : 1;
    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    var targetEdge = targetAxis.options.reverse ? 2 : 1;
    var axisBox = axis.box.translate(targetSlot[X + targetEdge] - slot[X + slotEdge], targetSlot[Y + targetEdge] - slot[Y + slotEdge]);
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  };
  PlotAreaBase2.prototype.alignAxes = function alignAxes(xAxes, yAxes) {
    var this$1 = this;
    var xAnchor = xAxes[0];
    var yAnchor = yAxes[0];
    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    var leftAnchors = {};
    var rightAnchors = {};
    var topAnchors = {};
    var bottomAnchors = {};
    for (var i = 0; i < yAxes.length; i++) {
      var axis = yAxes[i];
      var pane = axis.pane;
      var paneId = pane.id;
      var visible = axis.options.visible !== false;
      var anchor = paneAnchor(xAxes, pane) || xAnchor;
      var anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);
      }
      this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0));
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
        if (rightAnchors[paneId]) {
          axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0));
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      var paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;
      if (paneYAnchor !== axis) {
        axis.alignTo(paneYAnchor);
        axis.reflow(axis.box);
      }
    }
    for (var i$1 = 0; i$1 < xAxes.length; i$1++) {
      var axis$1 = xAxes[i$1];
      var pane$1 = axis$1.pane;
      var paneId$1 = pane$1.id;
      var visible$1 = axis$1.options.visible !== false;
      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;
      var anchorCrossings$1 = yAnchorCrossings;
      if (anchor$1 !== yAnchor) {
        anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);
      }
      this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
      if (axis$1.options._overlap) {
        continue;
      }
      if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {
        if (!axis$1._mirrored) {
          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;
          axis$1._mirrored = true;
        }
        this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
        if (topAnchors[paneId$1]) {
          axis$1.reflow(axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin));
        }
        if (visible$1) {
          topAnchors[paneId$1] = axis$1;
        }
      }
      if (round(axis$1.lineBox().y2, COORD_PRECISION) === round(anchor$1.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId$1]) {
          axis$1.reflow(axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin));
        }
        if (visible$1) {
          bottomAnchors[paneId$1] = axis$1;
        }
      }
      if (i$1 !== 0) {
        axis$1.alignTo(xAnchor);
        axis$1.reflow(axis$1.box);
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {
    var axes = this.groupAxes(panes).any;
    var axisBox = axisGroupBox(axes);
    var overflowX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());
      }
    }
    if (overflowX !== 0) {
      for (var i$1 = 0; i$1 < axes.length; i$1++) {
        var currentAxis = axes[i$1];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {
    var shrinked;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var axes = currentPane.axes;
      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (var j = 0; j < axes.length; j++) {
          var currentAxis = axes[j];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(currentAxis.box.shrink(0, overflowY));
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  };
  PlotAreaBase2.prototype.fitAxes = function fitAxes(panes) {
    var axes = this.groupAxes(panes).any;
    var offsetX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var paneAxes = currentPane.axes;
      var paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        var axisBox = axisGroupBox(paneAxes);
        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (var j = 0; j < paneAxes.length; j++) {
          var currentAxis = paneAxes[j];
          currentAxis.reflow(currentAxis.box.translate(0, offsetY));
        }
      }
    }
    for (var i$1 = 0; i$1 < axes.length; i$1++) {
      var currentAxis$1 = axes[i$1];
      currentAxis$1.reflow(currentAxis$1.box.translate(offsetX, 0));
    }
  };
  PlotAreaBase2.prototype.reflowAxes = function reflowAxes(panes) {
    var this$1 = this;
    var axes = this.groupAxes(panes);
    for (var i = 0; i < panes.length; i++) {
      this$1.reflowPaneAxes(panes[i]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  };
  PlotAreaBase2.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {
    var this$1 = this;
    var ref2 = this;
    var panes = ref2.panes;
    var axes = allPaneAxes(panes);
    var rotated;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {
        this$1.reflowPaneAxes(panes[idx$1]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {
    var axes = pane.axes;
    var length = axes.length;
    if (length > 0) {
      for (var i = 0; i < length; i++) {
        axes[i].reflow(pane.contentBox);
      }
    }
  };
  PlotAreaBase2.prototype.reflowCharts = function reflowCharts(panes) {
    var charts = this.charts;
    var count = charts.length;
    var box = this.box;
    for (var i = 0; i < count; i++) {
      var chartPane = charts[i].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i].reflow(box);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPanes = function reflowPanes() {
    var ref2 = this;
    var box = ref2.box;
    var panes = ref2.panes;
    var panesLength = panes.length;
    var remainingHeight = box.height();
    var autoHeightPanes = 0;
    var top = box.y1;
    for (var i = 0; i < panesLength; i++) {
      var currentPane = panes[i];
      var height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          var percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (var i$1 = 0; i$1 < panesLength; i$1++) {
      var currentPane$1 = panes[i$1];
      if (!currentPane$1.options.height) {
        currentPane$1.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (var i$2 = 0; i$2 < panesLength; i$2++) {
      var currentPane$2 = panes[i$2];
      var paneBox = box.clone().move(box.x1, top);
      currentPane$2.reflow(paneBox);
      top += currentPane$2.options.height;
    }
  };
  PlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    var axes = this.axes;
    var axesCount = axes.length;
    var box;
    for (var i = 0; i < axesCount; i++) {
      var axisA = axes[i];
      for (var j = 0; j < axesCount; j++) {
        var axisB = axes[j];
        if (axisA.options.vertical !== axisB.options.vertical) {
          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  };
  PlotAreaBase2.prototype.chartsBoxes = function chartsBoxes() {
    var panes = this.panes;
    var boxes = [];
    for (var idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  };
  PlotAreaBase2.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  };
  PlotAreaBase2.prototype.backgroundContainsPoint = function backgroundContainsPoint(point) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point)) {
        return true;
      }
    }
  };
  PlotAreaBase2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options = this.options.plotArea;
    var opacity = options.opacity;
    var background = options.background;
    var border = options.border;
    if (border === void 0) border = {};
    if (isTransparent(background)) {
      background = WHITE;
      opacity = 0;
    }
    var bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  };
  PlotAreaBase2.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {
    var charts = this.charts;
    var result = [];
    if (categoryIndex !== null) {
      for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        var points = charts[i].categoryPoints[categoryIndex];
        if (points && points.length) {
          for (var j = 0; j < points.length; j++) {
            var point = points[j];
            if (point && defined(point.value) && point.value !== null) {
              result.push(point);
            }
          }
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point) {
      return point.series.index === seriesIndex;
    });
  };
  PlotAreaBase2.prototype.pointsByPointIndex = function pointsByPointIndex(pointIndex) {
    return this.filterPoints(function(point) {
      return point.getIndex() === pointIndex;
    });
  };
  PlotAreaBase2.prototype.pointsBySeriesName = function pointsBySeriesName(name2) {
    return this.filterPoints(function(point) {
      return point.series.name === name2;
    });
  };
  PlotAreaBase2.prototype.filterPoints = function filterPoints(callback) {
    var charts = this.charts;
    var result = [];
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points = chart.points;
      for (var j = 0; j < points.length; j++) {
        var point = points[j];
        if (point && point.visible !== false && callback(point)) {
          result.push(point);
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.findPoint = function findPoint(callback) {
    var charts = this.charts;
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points = chart.points;
      for (var j = 0; j < points.length; j++) {
        var point = points[j];
        if (point && point.visible !== false && callback(point)) {
          return point;
        }
      }
    }
  };
  PlotAreaBase2.prototype.paneByPoint = function paneByPoint(point) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      if (pane.box.containsPoint(point)) {
        return pane;
      }
    }
  };
  PlotAreaBase2.prototype.detachLabels = function detachLabels() {
    var axes = this.groupAxes(this.panes);
    var xAxes = axes.x;
    var yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  };
  PlotAreaBase2.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {
    var this$1 = this;
    var labelAxisCount = 0;
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var pane = axis.pane;
      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      var axisIndex = i + labelAxisCount;
      var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        var pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  };
  PlotAreaBase2.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {
    var labelOptions = axis.options.labels;
    var position = labelOptions.position;
    var onAxis = position !== END && position !== START;
    var visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    var allAxes = this.groupAxes(this.panes);
    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    var end = position === END;
    var range = anchor.range();
    var edge = end ? range.max : range.min;
    var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    var labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  };
  PlotAreaBase2.prototype.isTrendline = function isTrendline(series) {
    return series && inArray(series.type, TRENDLINE_SERIES);
  };
  PlotAreaBase2.prototype.trendlineFactory = function trendlineFactory2() {
  };
  PlotAreaBase2.prototype.createTrendlineSeries = function createTrendlineSeries() {
    var this$1 = this;
    var modifiedSeries = [];
    this.series = this.series.map(function(series) {
      if (!this$1.isTrendline(series)) {
        return series;
      }
      var forSeries = this$1.seriesByName(series.for);
      if (!forSeries) {
        throw new Error('Invalid Configuration: Unable to locate linked series "' + series.for + '" for trendline "' + series.name + '".');
      }
      var valueFields = series_binder_default.current.valueFields(forSeries);
      var field = last(valueFields);
      var trendlineSeries = this$1.trendlineFactory(Object.assign({}, {
        field
      }, series), forSeries);
      if (trendlineSeries) {
        if (forSeries.visible === false) {
          trendlineSeries.visible = false;
        }
        if (trendlineSeries.color === INHERIT) {
          trendlineSeries.color = forSeries.color;
        }
        modifiedSeries.push(trendlineSeries);
      }
      return trendlineSeries;
    }).filter(function(series) {
      return series !== null;
    });
    return modifiedSeries;
  };
  PlotAreaBase2.prototype.seriesByName = function seriesByName(name2) {
    return this.series.find(function(series) {
      return series.name === name2;
    });
  };
  PlotAreaBase2.prototype.getFirstPoint = function getFirstPoint() {
    return this.pointsBySeriesIndex(0)[0];
  };
  PlotAreaBase2.prototype.getPointBelow = function getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  };
  PlotAreaBase2.prototype.getPointAbove = function getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  };
  PlotAreaBase2.prototype.getPointToTheRight = function getPointToTheRight(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, 1);
  };
  PlotAreaBase2.prototype.getPointToTheLeft = function getPointToTheLeft(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, -1);
  };
  PlotAreaBase2.prototype._getNextPoint = function _getNextPoint(point, getPointsFunc, increment) {
    var this$1 = this;
    var points = getPointsFunc.call(this, point);
    var pointIndex = points.indexOf(point);
    var nextIndex = pointIndex + increment;
    var loopPoints = function(direction) {
      var result;
      var offset = 0;
      do {
        offset += direction;
        result = getPointsFunc.call(this$1, point, offset);
      } while (result.length === 0);
      return result;
    };
    if (nextIndex < 0) {
      points = loopPoints(-1);
      return points.at(-1);
    } else if (nextIndex >= points.length) {
      points = loopPoints(1);
      return points.at(0);
    }
    return points[nextIndex];
  };
  PlotAreaBase2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsByPointIndex(basePoint.getIndex());
  };
  PlotAreaBase2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    if (offset === void 0) offset = 0;
    var index = cycleIndex(basePoint.series.index + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  };
  return PlotAreaBase2;
}(chart_element_default);
function isSingleAxis(axis) {
  return !axis.pane.axes.some(function(a) {
    return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false;
  });
}
function axisGroupBox(axes) {
  var length = axes.length;
  var box;
  for (var i = 0; i < length; i++) {
    var axis = axes[i];
    var visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      var axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (var i = 0; i < axes.length; i++) {
    var anchor = axes[i];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}
var allPaneAxes = function(panes) {
  return panes.reduce(function(acc, pane) {
    return acc.concat(pane.axes);
  }, []);
};
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_HOVER);
  },
  click: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = function(Class) {
  function SeriesAggregator2(series, binder, defaultAggregates) {
    Class.call(this);
    var canonicalFields = binder.canonicalFields(series);
    var valueFields = binder.valueFields(series);
    var sourceFields = binder.sourceFields(series, canonicalFields);
    var seriesFields = this._seriesFields = [];
    var defaults = defaultAggregates.query(series.type);
    var rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (var i = 0; i < canonicalFields.length; i++) {
      var field = canonicalFields[i];
      var fieldAggregate = void 0;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i],
          transform: isFunction(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  if (Class) SeriesAggregator2.__proto__ = Class;
  SeriesAggregator2.prototype = Object.create(Class && Class.prototype);
  SeriesAggregator2.prototype.constructor = SeriesAggregator2;
  SeriesAggregator2.prototype.aggregatePoints = function aggregatePoints(srcPoints, group) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2._series;
    var seriesFields = ref2._seriesFields;
    var data = this._bindPoints(srcPoints || []);
    var firstDataItem = data.dataItems[0];
    var result = {};
    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {
      var fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (var i = 0; i < seriesFields.length; i++) {
      var field = seriesFields[i];
      var srcValues = this$1._bindField(data.values, field.canonicalName);
      var value2 = field.transform(srcValues, series, data.dataItems, group);
      if (value2 !== null && isObject(value2) && !defined(value2.length) && !(value2 instanceof Date)) {
        result = value2;
        break;
      } else {
        if (defined(value2)) {
          setValue(field.name, result, value2);
        }
      }
    }
    return result;
  };
  SeriesAggregator2.prototype._bindPoints = function _bindPoints(points) {
    var ref2 = this;
    var binder = ref2._binder;
    var series = ref2._series;
    var values5 = [];
    var dataItems = [];
    for (var i = 0; i < points.length; i++) {
      var pointIx = points[i];
      values5.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values: values5,
      dataItems
    };
  };
  SeriesAggregator2.prototype._bindField = function _bindField(data, field) {
    var values5 = [];
    var count = data.length;
    for (var i = 0; i < count; i++) {
      var item = data[i];
      var valueFields = item.valueFields;
      var value2 = void 0;
      if (defined(valueFields[field])) {
        value2 = valueFields[field];
      } else {
        value2 = item.fields[field];
      }
      values5.push(value2);
    }
    return values5;
  };
  return SeriesAggregator2;
}(class_default);
function setValue(fieldName, target, value2) {
  var parentObj = target;
  var field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    var parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value2;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = function(Class) {
  function DefaultAggregates2() {
    Class.call(this);
    this._defaults = {};
  }
  if (Class) DefaultAggregates2.__proto__ = Class;
  DefaultAggregates2.prototype = Object.create(Class && Class.prototype);
  DefaultAggregates2.prototype.constructor = DefaultAggregates2;
  DefaultAggregates2.prototype.register = function register4(seriesTypes, aggregates) {
    var this$1 = this;
    for (var i = 0; i < seriesTypes.length; i++) {
      this$1._defaults[seriesTypes[i]] = aggregates;
    }
  };
  DefaultAggregates2.prototype.query = function query(seriesType) {
    return this._defaults[seriesType];
  };
  return DefaultAggregates2;
}(class_default);
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = function(Bar2) {
  function RangeBar2() {
    Bar2.apply(this, arguments);
  }
  if (Bar2) RangeBar2.__proto__ = Bar2;
  RangeBar2.prototype = Object.create(Bar2 && Bar2.prototype);
  RangeBar2.prototype.constructor = RangeBar2;
  RangeBar2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var fromOptions = deepExtend({}, labels, labels.from);
    var toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this.createLabelElement(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this.createLabelElement(toOptions);
      this.append(this.labelTo);
    }
  };
  RangeBar2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var ref2 = this;
    var labelFrom = ref2.labelFrom;
    var labelTo = ref2.labelTo;
    var value2 = ref2.value;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value2.from > value2.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value2.to > value2.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  };
  return RangeBar2;
}(bar_default);
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = function(BarChart2) {
  function RangeBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) RangeBarChart2.__proto__ = BarChart2;
  RangeBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RangeBarChart2.prototype.constructor = RangeBarChart2;
  RangeBarChart2.prototype.pointType = function pointType() {
    return range_bar_default;
  };
  RangeBarChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields;
  };
  RangeBarChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    if (point.value.from === null && point.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value.from, point.value.to);
  };
  RangeBarChart2.prototype.plotRange = function plotRange(point) {
    if (!point) {
      return 0;
    }
    return [point.value.from, point.value.to];
  };
  RangeBarChart2.prototype.updateRange = function updateRange(value2, fields) {
    var axisName = fields.series.axis;
    var from = value2.from;
    var to = value2.to;
    var axisRange = this.valueAxisRanges[axisName];
    if (value2 !== null && isNumber(from) && isNumber(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  };
  RangeBarChart2.prototype.aboveAxis = function aboveAxis(point) {
    var value2 = point.value;
    return value2.from < value2.to;
  };
  return RangeBarChart2;
}(bar_chart_default);
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = function(LinePoint2) {
  function RangeLinePoint2() {
    LinePoint2.apply(this, arguments);
  }
  if (LinePoint2) RangeLinePoint2.__proto__ = LinePoint2;
  RangeLinePoint2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  RangeLinePoint2.prototype.constructor = RangeLinePoint2;
  RangeLinePoint2.prototype.aliasFor = function aliasFor() {
    return this.parent;
  };
  return RangeLinePoint2;
}(line_point_default);
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = function(ChartElement2) {
  function RangeAreaPoint2(value2, options) {
    ChartElement2.call(this);
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
    this.initLabelsFormat();
  }
  if (ChartElement2) RangeAreaPoint2.__proto__ = ChartElement2;
  RangeAreaPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RangeAreaPoint2.prototype.constructor = RangeAreaPoint2;
  RangeAreaPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    var value2 = this.value;
    var fromPoint = this.fromPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    var toPoint = this.toPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  };
  RangeAreaPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var fromBox = targetBox.from;
    var toBox = targetBox.to;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  };
  RangeAreaPoint2.prototype.createHighlight = function createHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.visual;
  };
  RangeAreaPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  };
  RangeAreaPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createFocusHighlight());
    group.append(this.toPoint.createFocusHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      var box = this.box;
      var center = box.center();
      var horizontalAlign = LEFT;
      var x, y, verticalAlign;
      if (this.options.vertical) {
        x = center.x;
        y = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x = box.x2 + TOOLTIP_OFFSET;
        y = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  RangeAreaPoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  RangeAreaPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  RangeAreaPoint2.prototype.unclipElements = function unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  };
  RangeAreaPoint2.prototype.initLabelsFormat = function initLabelsFormat() {
    var labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  };
  RangeAreaPoint2.prototype.positionLabels = function positionLabels(fromBox, toBox) {
    var ref2 = this.options;
    var labels = ref2.labels;
    var vertical = ref2.vertical;
    if (labels.position === AUTO2) {
      var fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  };
  RangeAreaPoint2.prototype.copyFields = function copyFields(point) {
    point.dataItem = this.dataItem;
    point.category = this.category;
    point.series = this.series;
    point.color = this.color;
    point.owner = this.owner;
  };
  RangeAreaPoint2.prototype.focusVisual = function focusVisual2() {
    this.fromPoint.focusVisual();
  };
  RangeAreaPoint2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.toPoint.clearFocusFromVisual();
  };
  RangeAreaPoint2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RangeAreaPoint2;
}(chart_element_default);
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = function(AreaSegment2) {
  function RangeAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) RangeAreaSegment2.__proto__ = AreaSegment2;
  RangeAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RangeAreaSegment2.prototype.constructor = RangeAreaSegment2;
  RangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  };
  RangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  };
  RangeAreaSegment2.prototype.createStroke = function createStroke(style) {
    var toPath = new drawing_exports.Path(style);
    var fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  };
  RangeAreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return true;
  };
  RangeAreaSegment2.prototype.fromPoints = function fromPoints() {
    return this.linePoints.map(function(point) {
      return point.fromPoint;
    });
  };
  RangeAreaSegment2.prototype.toPoints = function toPoints() {
    return this.linePoints.map(function(point) {
      return point.toPoint;
    });
  };
  return RangeAreaSegment2;
}(area_segment_default);
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = function(RangeAreaSegment2) {
  function SplineRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2) SplineRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  SplineRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  SplineRangeAreaSegment2.prototype.constructor = SplineRangeAreaSegment2;
  SplineRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  };
  SplineRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  };
  SplineRangeAreaSegment2.prototype.createCurveSegments = function createCurveSegments(points) {
    var curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points));
  };
  return SplineRangeAreaSegment2;
}(range_area_segment_default);
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = function(RangeAreaSegment2) {
  function StepRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2) StepRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  StepRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  StepRangeAreaSegment2.prototype.constructor = StepRangeAreaSegment2;
  StepRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  };
  StepRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  };
  return StepRangeAreaSegment2;
}(range_area_segment_default);
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = function(CategoricalChart2) {
  function RangeAreaChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2) RangeAreaChart2.__proto__ = CategoricalChart2;
  RangeAreaChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  RangeAreaChart2.prototype.constructor = RangeAreaChart2;
  RangeAreaChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.renderSegments();
  };
  RangeAreaChart2.prototype.pointType = function pointType() {
    return range_area_point_default;
  };
  RangeAreaChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var value2 = data.valueFields;
    if (!hasValue(value2.from) && !hasValue(value2.to)) {
      if (this.seriesMissingValues(series) === ZERO) {
        value2 = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    var color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    var point = new range_area_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  RangeAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segmentType;
    if (style === "smooth") {
      segmentType = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType = step_range_area_segment_default;
    } else {
      segmentType = range_area_segment_default;
    }
    return new segmentType(linePoints, currentSeries, seriesIx);
  };
  RangeAreaChart2.prototype.plotRange = function plotRange(point, startValue) {
    if (!point) {
      return [startValue, startValue];
    }
    return [point.value.from, point.value.to];
  };
  RangeAreaChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  };
  RangeAreaChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var from = valueSlot.from;
    var to = valueSlot.to;
    var fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  };
  RangeAreaChart2.prototype.addValue = function addValue(data, fields) {
    var valueFields = data.valueFields;
    if (!isNumber(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    CategoricalChart2.prototype.addValue.call(this, data, fields);
  };
  RangeAreaChart2.prototype.updateRange = function updateRange(value2, fields) {
    if (value2 !== null && isNumber(value2.from) && isNumber(value2.to)) {
      var axisName = fields.series.axis;
      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || {
        min: MAX_VALUE,
        max: MIN_VALUE
      };
      var from = value2.from;
      var to = value2.to;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  };
  RangeAreaChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.from, value2.to);
  };
  RangeAreaChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      var point = points[idx];
      if (point) {
        result.push((point.fromPoint || {}).marker);
        result.push((point.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  };
  return RangeAreaChart2;
}(categorical_chart_default);
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = function(Candlestick2) {
  function OHLCPoint2() {
    Candlestick2.apply(this, arguments);
  }
  if (Candlestick2) OHLCPoint2.__proto__ = Candlestick2;
  OHLCPoint2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  OHLCPoint2.prototype.constructor = OHLCPoint2;
  OHLCPoint2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options = ref2.options;
    var value2 = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options);
    var oPoints = [];
    var cPoints = [];
    var lhPoints = [];
    var lhSlot = valueAxis.getSlot(value2.low, value2.high);
    var oSlot = valueAxis.getSlot(value2.open, value2.open);
    var cSlot = valueAxis.getSlot(value2.close, value2.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    var mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [oPoints, cPoints, lhPoints];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  };
  OHLCPoint2.prototype.createBody = function createBody() {
  };
  return OHLCPoint2;
}(candlestick_default);
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = function(CandlestickChart2) {
  function OHLCChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2) OHLCChart2.__proto__ = CandlestickChart2;
  OHLCChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  OHLCChart2.prototype.constructor = OHLCChart2;
  OHLCChart2.prototype.pointType = function pointType() {
    return ohlc_point_default;
  };
  return OHLCChart2;
}(candlestick_chart_default);
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = function(ChartElement2) {
  function WaterfallSegment2(from, to, series) {
    ChartElement2.call(this);
    this.from = from;
    this.to = to;
    this.series = series;
  }
  if (ChartElement2) WaterfallSegment2.__proto__ = ChartElement2;
  WaterfallSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  WaterfallSegment2.prototype.constructor = WaterfallSegment2;
  WaterfallSegment2.prototype.linePoints = function linePoints() {
    var from = this.from;
    var ref2 = this;
    var fromBox = ref2.from.box;
    var toBox = ref2.to.box;
    var points = [];
    if (from.isVertical) {
      var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points.push([fromBox.x1, y], [toBox.x2, y]);
    } else {
      var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points.push([x, fromBox.y1], [x, toBox.y2]);
    }
    return points;
  };
  WaterfallSegment2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var line = this.series.line || {};
    var path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  };
  return WaterfallSegment2;
}(chart_element_default);
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = function(BarChart2) {
  function WaterfallChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) WaterfallChart2.__proto__ = BarChart2;
  WaterfallChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  WaterfallChart2.prototype.constructor = WaterfallChart2;
  WaterfallChart2.prototype.render = function render() {
    BarChart2.prototype.render.call(this);
    this.createSegments();
  };
  WaterfallChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var totalCategories = categoriesCount(series);
    var isVertical = !this.options.invertAxes;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var total3 = 0;
      var runningTotal = 0;
      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        var data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        var value2 = data.valueFields.value;
        var summary = data.fields.summary;
        var from = total3;
        var to = void 0;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total3;
            from = 0;
            to = total3;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber(value2)) {
          runningTotal += value2;
          total3 += value2;
          to = total3;
        }
        callback(data, {
          category: this$1.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total: total3,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  };
  WaterfallChart2.prototype.updateRange = function updateRange(value2, fields) {
    BarChart2.prototype.updateRange.call(this, {
      value: fields.to
    }, fields);
  };
  WaterfallChart2.prototype.aboveAxis = function aboveAxis(point) {
    return point.value >= 0;
  };
  WaterfallChart2.prototype.plotRange = function plotRange(point) {
    return [point.from, point.to];
  };
  WaterfallChart2.prototype.createSegments = function createSegments() {
    var this$1 = this;
    var series = this.options.series;
    var seriesPoints = this.seriesPoints;
    var segments = this.segments = [];
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var points = seriesPoints[seriesIx];
      if (points) {
        var prevPoint = void 0;
        for (var pointIx = 0; pointIx < points.length; pointIx++) {
          var point = points[pointIx];
          if (point && prevPoint) {
            var segment = new waterfall_segment_default(prevPoint, point, currentSeries);
            segments.push(segment);
            this$1.append(segment);
          }
          prevPoint = point;
        }
      }
    }
  };
  return WaterfallChart2;
}(bar_chart_default);
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-factory.js
function trendlineFactory(registry2, type, context) {
  var impl = registry2[String(type)];
  if (impl) {
    return impl(context);
  }
  return null;
}
var trendline_factory_default = trendlineFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-slope.js
function calculateSlope(sourceValues, valueGetter10) {
  var x = 0;
  var y = 0;
  var x2 = 0;
  var xy = 0;
  var count = 0;
  var slope, intercept;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i = 0; i < sourceValues.length; i++) {
    var value2 = sourceValues[i];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      x += xValue;
      y += yValue;
      x2 += Math.pow(xValue, 2);
      xy += xValue * yValue;
    }
  }
  if (count > 0) {
    slope = (count * xy - x * y) / (count * x2 - Math.pow(x, 2));
    intercept = (y - slope * x) / count;
  }
  return {
    slope,
    intercept,
    count,
    xMin,
    xMax
  };
}
var calculate_slope_default = calculateSlope;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/check-all-positive.js
var checkAllPositive = function(sourceValues, fieldName) {
  return sourceValues.every(function(ref2) {
    var valueFields = ref2.valueFields;
    return !hasValue(valueFields[fieldName]) || valueFields[fieldName] > 0;
  });
};
var check_all_positive_default = checkAllPositive;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-trendline-data.js
function getTrendlineData(valueMapper, categoryAxis) {
  var data = [];
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))
  };
  for (var i = range.min; i < range.max; i++) {
    var x = i + 1;
    data[i] = {
      category: categoryAxis.categoryAt(i, true),
      value: valueMapper(x)
    };
  }
  return data;
}
var get_trendline_data_default = getTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/exponential-trendline.js
function exponentialTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData({
    seriesValues,
    categoryAxis,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: categoryIx + 1,
      yValue: Math.log(valueFields[fieldName])
    };
    ;
  };
};
function getData(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a = Math.exp(intercept);
    var b = slope;
    return get_trendline_data_default(function(x) {
      return a * Math.exp(b * x);
    }, categoryAxis);
  }
  return null;
}
var exponential_trendline_default = exponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/linear-trendline.js
function linearTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData2({
    seriesValues,
    categoryAxis,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter2 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: categoryIx + 1,
      yValue: valueFields[fieldName]
    };
    ;
  };
};
function getData2(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), valueGetter2(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    return get_trendline_data_default(function(x) {
      return slope * x + intercept;
    }, categoryAxis);
  }
  return null;
}
var linear_trendline_default = linearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/logarithmic-trendline.js
function logarithmicTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData3({
    seriesValues,
    categoryAxis,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter3 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: Math.log(categoryIx + 1),
      yValue: valueFields[fieldName]
    };
    ;
  };
};
function getData3(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), valueGetter3(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a = slope;
    var b = intercept;
    return get_trendline_data_default(function(x) {
      return a * Math.log(x) + b;
    }, categoryAxis);
  }
  return null;
}
var logarithmic_trendline_default = logarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-moving-average.js
function calculateMovingAverage(sourceValues, valueGetter10, period) {
  var averagePoints = [];
  var values5 = [];
  var start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;
  var end = 0;
  var sum2 = 0;
  for (var i = 0; i < sourceValues.length; i++) {
    var value2 = sourceValues[i];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(yValue) && yValue !== null) {
      values5.push(yValue);
      sum2 += yValue;
      end = Math.max(i, end);
    } else {
      values5.push(null);
    }
    if (i >= start) {
      var count = values5.filter(function(value3) {
        return value3 !== null;
      }).length;
      var lastValue = values5.shift() || 0;
      if (count > 0) {
        var average = sum2 / count;
        averagePoints.push([xValue, average]);
        sum2 -= lastValue;
        continue;
      }
    }
    averagePoints.push([xValue, null]);
  }
  return averagePoints.slice(0, end + 1);
}
var calculate_moving_average_default = calculateMovingAverage;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/moving-average.js
function movingAverageTrendline(context) {
  var options = context.options;
  var data = getData4(context);
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter4 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: categoryIx,
      yValue: valueFields[fieldName]
    };
    ;
  };
};
function calculatePoints(ref2) {
  var options = ref2.options;
  var categoryAxis = ref2.categoryAxis;
  var seriesValues = ref2.seriesValues;
  var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var totalRange = categoryAxis.totalRangeIndices();
  var currentRange = categoryAxis.currentRangeIndices();
  var range = {
    min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))
  };
  return calculate_moving_average_default(seriesValues(range), valueGetter4(options.field), period);
}
function getData4(context) {
  var categoryAxis = context.categoryAxis;
  var points = calculatePoints(context);
  var data = [];
  points.forEach(function(ref2) {
    var categoryIx = ref2[0];
    var value2 = ref2[1];
    data[categoryIx] = {
      category: categoryAxis.categoryAt(categoryIx, true),
      value: value2
    };
  });
  if (data.length > 0) {
    return data;
  }
  return null;
}
var moving_average_default = movingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-polynomial.js
var MIN_ORDER = 1;
var MAX_ORDER = 6;
function calculatePolynomial(sourceValues, valueGetter10, order) {
  var k = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;
  var X2 = new matrix_default();
  var Y2 = new matrix_default();
  var count = 0;
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  var valueMapper = function(x) {
    return x;
  };
  var coefficients = [];
  for (var i = 0; i < sourceValues.length; i++) {
    var value2 = sourceValues[i];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      Y2.set(i, 0, yValue);
      X2.set(i, 0, 1);
      X2.set(i, 1, xValue);
      for (var pow3 = 2; pow3 <= k; pow3++) {
        X2.set(i, pow3, Math.pow(X2.get(i, 1), pow3));
      }
    } else {
      X2.set(i, 0, 0);
    }
  }
  X2.width = Math.min(k, count);
  if (count > 0) {
    coefficients = linearRegression(X2, Y2);
    valueMapper = function(x) {
      return coefficients.reduce(function(y, a, n) {
        return y + a * Math.pow(x, n);
      }, 0);
    };
  }
  return {
    coefficients,
    count,
    valueMapper,
    xMin,
    xMax
  };
}
function linearRegression(X2, Y2) {
  var Xt = X2.transpose();
  var B = Xt.multiply(X2).inverse().multiply(Xt).multiply(Y2);
  var coefficients = [];
  for (var i = 0; i < B.height; i++) {
    coefficients.push(B.get(i, 0));
  }
  return coefficients;
}
var calculate_polynomial_default = calculatePolynomial;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/polynomial-trendline.js
function polynomialTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData5({
    seriesValues,
    categoryAxis,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter5 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: categoryIx + 1,
      yValue: valueFields[fieldName]
    };
    ;
  };
};
function getData5(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var order = (options.trendline || {}).order;
  var ref$1 = calculate_polynomial_default(seriesValues(), valueGetter5(options.field), order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  if (count > 0) {
    return get_trendline_data_default(function(x) {
      return valueMapper(x);
    }, categoryAxis);
  }
  return null;
}
var polynomial_trendline_default = polynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/power-trendline.js
function powerTrendline(context) {
  var options = context.options;
  var categoryAxis = context.categoryAxis;
  var seriesValues = context.seriesValues;
  var data = getData6({
    seriesValues,
    categoryAxis,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "line",
      data,
      categoryField: "category",
      field: "value"
    });
  }
  return null;
}
var valueGetter6 = function(fieldName) {
  return function(ref2) {
    var categoryIx = ref2.categoryIx;
    var valueFields = ref2.valueFields;
    return {
      xValue: Math.log(categoryIx + 1),
      yValue: Math.log(valueFields[fieldName])
    };
    ;
  };
};
function getData6(ref2) {
  var seriesValues = ref2.seriesValues;
  var categoryAxis = ref2.categoryAxis;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter6(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  if (count > 0) {
    var a = Math.exp(intercept);
    var b = slope;
    return get_trendline_data_default(function(x) {
      return a * Math.pow(x, b);
    }, categoryAxis);
  }
  return null;
}
var power_trendline_default = powerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-registry.js
var registry = {};
registry[TRENDLINE_EXPONENTIAL] = exponential_trendline_default;
registry[TRENDLINE_LINEAR] = linear_trendline_default;
registry[TRENDLINE_LOGARITHMIC] = logarithmic_trendline_default;
registry[TRENDLINE_MOVING_AVERAGE] = moving_average_default;
registry[TRENDLINE_POLYNOMIAL] = polynomial_trendline_default;
registry[TRENDLINE_POWER] = power_trendline_default;
var trendline_registry_default = registry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = function(PlotAreaBase2) {
  function CategoricalPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) CategoricalPlotArea2.__proto__ = PlotAreaBase2;
  CategoricalPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  CategoricalPlotArea2.prototype.constructor = CategoricalPlotArea2;
  CategoricalPlotArea2.prototype.initFields = function initFields(series) {
    var this$1 = this;
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    this._seriesPointsCache = {};
    this._currentPointsCache = {};
    if (series.length > 0) {
      this.invertAxes = inArray(series[0].type, [BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA, RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT]);
      for (var i = 0; i < series.length; i++) {
        var stack = series[i].stack;
        if (stack && stack.type === "100%") {
          this$1.stack100 = true;
          break;
        }
      }
    }
  };
  CategoricalPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0) panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createTrendlineSeries(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  };
  CategoricalPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  };
  CategoricalPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options, series) {
    var categoryAxis = this.seriesCategoryAxis(options);
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendline_factory_default(trendline_registry_default, options.type, {
      options,
      categoryAxis,
      seriesValues
    });
    if (trendline) {
      trendline.categoryAxis = series.categoryAxis;
      trendline.valueAxis = series.valueAxis;
      return this.filterSeries(trendline, categoryAxis);
    }
    return trendline;
  };
  CategoricalPlotArea2.prototype.trendlineAggregateForecast = function trendlineAggregateForecast() {
    return this.series.map(function(series) {
      return (series.trendline || {}).forecast;
    }).filter(function(forecast) {
      return forecast !== void 0;
    }).reduce(function(result, forecast) {
      return {
        before: Math.max(result.before, forecast.before || 0),
        after: Math.max(result.after, forecast.after || 0)
      };
    }, {
      before: 0,
      after: 0
    });
  };
  CategoricalPlotArea2.prototype.seriesValues = function seriesValues(seriesIx, range) {
    var this$1 = this;
    var result = [];
    var series = this.srcSeries[seriesIx];
    var categoryAxis = this.seriesCategoryAxis(series);
    var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
    if (dateAxis) {
      this._seriesPointsCache = {};
      this._currentPointsCache = {};
      categoryAxis.options.dataItems = [];
      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());
    }
    var min4 = range ? range.min : 0;
    var max3 = range ? range.max : series.data.length;
    for (var categoryIx = min4; categoryIx < max3; categoryIx++) {
      var data = this$1.bindPoint(series, categoryIx);
      result.push({
        categoryIx,
        category: data.fields.category,
        valueFields: data.valueFields
      });
    }
    return result;
  };
  CategoricalPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var visibleSeries = this$1.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);
      for (var groupIx = 0; groupIx < groups.length; groupIx++) {
        this$1.createChartGroup(groups[groupIx], pane);
      }
    }
  };
  CategoricalPlotArea2.prototype.createChartGroup = function createChartGroup(series, pane) {
    this.createAreaChart(filterSeriesByType(series, [AREA, VERTICAL_AREA]), pane);
    this.createRangeAreaChart(filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]), pane);
    this.createBarChart(filterSeriesByType(series, [COLUMN, BAR]), pane);
    this.createRangeBarChart(filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]), pane);
    this.createBulletChart(filterSeriesByType(series, [BULLET, VERTICAL_BULLET]), pane);
    this.createCandlestickChart(filterSeriesByType(series, CANDLESTICK), pane);
    this.createBoxPlotChart(filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]), pane);
    this.createOHLCChart(filterSeriesByType(series, OHLC), pane);
    this.createWaterfallChart(filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]), pane);
    this.createLineChart(filterSeriesByType(series, [LINE, VERTICAL_LINE]), pane);
  };
  CategoricalPlotArea2.prototype.aggregateCategories = function aggregateCategories(panes) {
    var this$1 = this;
    var series = [].concat(this.series);
    var processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (!this$1.isTrendline(currentSeries)) {
        var categoryAxis = this$1.seriesCategoryAxis(currentSeries);
        var axisPane = this$1.findPane(categoryAxis.options.pane);
        var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
          currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());
        } else {
          currentSeries = this$1.filterSeries(currentSeries, categoryAxis);
        }
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  };
  CategoricalPlotArea2.prototype.filterSeries = function filterSeries(series, categoryAxis) {
    var dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {
      return series;
    }
    var range = categoryAxis.currentRangeIndices();
    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    var currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, function(idx) {
        return {
          item: series.data[idx],
          category: categoryAxis.categoryAt(idx, true),
          categoryIx: idx - range.min
        };
      }, function(idx) {
        return defined(series.data[idx]);
      });
    }
    return currentSeries;
  };
  CategoricalPlotArea2.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  };
  CategoricalPlotArea2.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {
    var this$1 = this;
    var key = series.index + ";" + categoryAxis.categoriesHash();
    if (this._seriesPointsCache && this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    var axisOptions2 = categoryAxis.options;
    var srcCategories = axisOptions2.srcCategories;
    var dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    var srcData = series.data;
    var result = [];
    if (!dateAxis) {
      categoryAxis.indexCategories();
    }
    for (var idx = 0; idx < srcData.length; idx++) {
      var category = series_binder_default.current.bindPoint(series, idx).fields.category;
      if (dateAxis) {
        category = parseDateCategory(category, srcData[idx], this$1.chartService.intl);
      }
      if (!defined(category)) {
        category = srcCategories[idx];
      }
      if (defined(category) && category !== null) {
        var categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || {
          items: [],
          category
        };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  };
  CategoricalPlotArea2.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis, range) {
    var srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    var srcPoints = this.seriesSourcePoints(series, categoryAxis);
    var result = deepExtend({}, series);
    var aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    var data = result.data = [];
    var dataItems = categoryAxis.options.dataItems || [];
    var categoryItem = function(idx2) {
      var categoryIdx = idx2 - range.min;
      var point2 = srcPoints[idx2];
      if (!point2) {
        point2 = srcPoints[idx2] = {};
      }
      point2.categoryIx = categoryIdx;
      if (!point2.item) {
        var category = categoryAxis.categoryAt(idx2, true);
        point2.category = category;
        point2.item = aggregator.aggregatePoints(point2.items, category);
      }
      return point2;
    };
    for (var idx = range.min; idx <= range.max; idx++) {
      var point = categoryItem(idx);
      data[point.categoryIx] = point.item;
      if (point.items && point.items.length) {
        dataItems[point.categoryIx] = point.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function(idx2) {
        return srcPoints[idx2];
      });
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  };
  CategoricalPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    var series = chart.options.series;
    var categoryAxis = this.seriesCategoryAxis(series[0]);
    var categories = categoryAxis.options.categories;
    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  CategoricalPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var axisName = series.axis;
    var axisOptions2 = [].concat(options.valueAxis);
    var axis = grep(axisOptions2, function(a) {
      return a.name === axisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = (panes[0] || {}).name || "default";
    var paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  };
  CategoricalPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {
    var axisName = series.categoryAxis;
    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  };
  CategoricalPlotArea2.prototype.stackableChartOptions = function stackableChartOptions(series, pane) {
    var anyStackedSeries = series.some(function(s) {
      return s.stack;
    });
    var isStacked100 = series.some(function(s) {
      return s.stack && s.stack.type === "100%";
    });
    var clip = pane.options.clip;
    return {
      defaultStack: series[0].stack,
      isStacked: anyStackedSeries,
      isStacked100,
      clip
    };
  };
  CategoricalPlotArea2.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {
    var categoryAxes = [];
    var unique = {};
    for (var idx = 0; idx < series.length; idx++) {
      var name2 = series[idx].categoryAxis || "$$default$$";
      if (!hasOwnProperty(unique, name2)) {
        unique[name2] = true;
        categoryAxes.push(name2);
      }
    }
    var groups = [];
    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      var axis = categoryAxes[axisIx];
      var axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  };
  CategoricalPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(barChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  };
  CategoricalPlotArea2.prototype.createBulletChart = function createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  };
  CategoricalPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(lineChart, pane);
  };
  CategoricalPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(areaChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  };
  CategoricalPlotArea2.prototype.createOHLCChart = function createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  };
  CategoricalPlotArea2.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    var this$1 = this;
    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      var currentSeries = this$1.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        var line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {
      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      if (axes[i] instanceof category_axis_default) {
        axes[i].createLabels();
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxes = function createCategoryAxes(panes) {
    var this$1 = this;
    var invertAxes = this.invertAxes;
    var definitions = [].concat(this.options.categoryAxis);
    var axes = [];
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var categories = axisOptions2.categories;
        if (categories === void 0) categories = [];
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this$1.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined(axisOptions2.justified)) {
          axisOptions2.justified = this$1.isJustified();
        }
        if (this$1.axisRequiresRounding(name2, i)) {
          axisOptions2.justified = false;
        }
        var categoryAxis = void 0;
        if (isDateAxis(axisOptions2, categories[0])) {
          axisOptions2._forecast = this$1.trendlineAggregateForecast();
          categoryAxis = new date_category_axis_default(axisOptions2, this$1.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this$1.chartService);
        }
        definitions[i].categories = categoryAxis.options.srcCategories;
        if (name2) {
          if (this$1.namedCategoryAxes[name2]) {
            throw new Error("Category axis with name " + name2 + " is already defined");
          }
          this$1.namedCategoryAxes[name2] = categoryAxis;
        }
        categoryAxis.axisIndex = i;
        axes.push(categoryAxis);
        this$1.appendAxis(categoryAxis);
      }
    }
    var primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype.isJustified = function isJustified() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  };
  CategoricalPlotArea2.prototype.createValueAxes = function createValueAxes(panes) {
    var this$1 = this;
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var definitions = [].concat(this.options.valueAxis);
    var invertAxes = this.invertAxes;
    var baseOptions = {
      vertical: !invertAxes,
      reverse: invertAxes && this.chartService.rtl
    };
    var axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = {
        format: "P0"
      };
    }
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? {
          min: 0.1,
          max: 1
        } : {
          min: 0,
          max: 1
        };
        var range = tracker.query(name2) || defaultRange || defaultAxisRange;
        if (i === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        var axisType = void 0;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        var valueAxis = new axisType(range.min, range.max, deepExtend({}, baseOptions, axisOptions2), this$1.chartService);
        if (name2) {
          if (this$1.namedValueAxes[name2]) {
            throw new Error("Value axis with name " + name2 + " is already defined");
          }
          this$1.namedValueAxes[name2] = valueAxis;
        }
        valueAxis.axisIndex = i;
        axes.push(valueAxis);
        this$1.appendAxis(valueAxis);
      }
    }
    var primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point = new point_default(coords.x, coords.y);
    var pane = this.pointPane(point);
    var categories = [];
    var values5 = [];
    if (!pane) {
      return;
    }
    var allAxes = pane.axes;
    for (var i = 0; i < allAxes.length; i++) {
      var axis = allAxes[i];
      if (axis.getValue) {
        appendIfNotNull(values5, axis.getValue(point));
      } else {
        appendIfNotNull(categories, axis.getCategory(point));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point));
    }
    if (categories.length > 0 && values5.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values5)
      });
    }
  };
  CategoricalPlotArea2.prototype.pointPane = function pointPane(point) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.contentBox.containsPoint(point)) {
        return currentPane;
      }
    }
  };
  CategoricalPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    updateAxisOptions(this.options, axis, options);
    updateAxisOptions(this.originalOptions, axis, options);
  };
  CategoricalPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset) {
    if (offset === void 0) offset = 0;
    if (this.invertAxes) {
      return this._siblingsBySeriesIndex(basePoint.series.index, offset);
    }
    return this._siblingsByPointIndex(basePoint.getIndex());
  };
  CategoricalPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    if (offset === void 0) offset = 0;
    if (this.invertAxes) {
      return this._siblingsByPointIndex(basePoint.getIndex());
    }
    var siblings = this._siblingsBySeriesIndex(basePoint.series.index, offset);
    if (this.chartService.rtl) {
      return siblings.reverse();
    }
    return siblings;
  };
  CategoricalPlotArea2.prototype._siblingsByPointIndex = function _siblingsByPointIndex(pointIndex) {
    var this$1 = this;
    var charts = this.charts;
    var result = [];
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      if (chart.pane && chart.pane.options.name === "_navigator") {
        continue;
      }
      var chartPoints = chart.points.filter(function(point) {
        return point && point.visible !== false && point.getIndex() === pointIndex;
      });
      result.push.apply(result, chartPoints.sort(this$1._getSeriesCompareFn(chartPoints[0])));
    }
    return result;
  };
  CategoricalPlotArea2.prototype._siblingsBySeriesIndex = function _siblingsBySeriesIndex(seriesIndex, offset) {
    var index = cycleIndex(seriesIndex + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  };
  CategoricalPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn(point) {
    var isStacked = this._isInStackedSeries(point);
    if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {
      return function(a, b) {
        return a.box.center().x - b.box.center().x;
      };
    }
    return function(a, b) {
      return a.box.center().y - b.box.center().y;
    };
  };
  CategoricalPlotArea2.prototype._isInStackedSeries = function _isInStackedSeries(point) {
    var sortableSeries = inArray(point.series.type, [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]);
    var stackableSeries = inArray(point.series.type, [COLUMN, BAR]);
    return sortableSeries || stackableSeries && point.options.isStacked;
  };
  return CategoricalPlotArea2;
}(plotarea_base_default);
function updateAxisOptions(targetOptions, axis, options) {
  var axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s) {
    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = function(Class) {
  function Highlight2() {
    Class.call(this);
    this._points = [];
  }
  if (Class) Highlight2.__proto__ = Class;
  Highlight2.prototype = Object.create(Class && Class.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.destroy = function destroy() {
    this._points = [];
  };
  Highlight2.prototype.show = function show2(points, opacity) {
    var this$1 = this;
    var arrayPoints = [].concat(points);
    this.hide();
    for (var i = 0; i < arrayPoints.length; i++) {
      var point = arrayPoints[i];
      if (point && point.toggleHighlight && point.hasHighlight()) {
        this$1.togglePointHighlight(point, true, opacity);
        this$1._points.push(point);
      }
    }
  };
  Highlight2.prototype.togglePointHighlight = function togglePointHighlight(point, show2, opacity) {
    var toggleHandler = (point.options.highlight || {}).toggle;
    if (toggleHandler) {
      var eventArgs = {
        category: point.category,
        series: point.series,
        dataItem: point.dataItem,
        value: point.value,
        stackValue: point.stackValue,
        preventDefault: preventDefault3,
        visual: point.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point.toggleHighlight(show2, opacity);
      }
    } else {
      point.toggleHighlight(show2, opacity);
    }
  };
  Highlight2.prototype.hide = function hide2() {
    var this$1 = this;
    var points = this._points;
    while (points.length) {
      this$1.togglePointHighlight(points.pop(), false);
    }
  };
  Highlight2.prototype.isHighlighted = function isHighlighted(element) {
    var points = this._points;
    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      if (element === point) {
        return true;
      }
    }
    return false;
  };
  return Highlight2;
}(class_default);
function preventDefault3() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e, mouseKey) {
  var key = (mouseKey || "").toLowerCase();
  var event = e.event;
  var accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  var ranges = {};
  for (var idx = 0; idx < axisRanges2.length; idx++) {
    var axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = function(Class) {
  function Pannable2(plotArea, options) {
    Class.call(this);
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options);
  }
  if (Class) Pannable2.__proto__ = Class;
  Pannable2.prototype = Object.create(Class && Class.prototype);
  Pannable2.prototype.constructor = Pannable2;
  Pannable2.prototype.start = function start(e) {
    this._active = acceptKey(e, this.options.key);
    return this._active;
  };
  Pannable2.prototype.move = function move(e) {
    if (this._active) {
      var axisRanges2 = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  };
  Pannable2.prototype.end = function end() {
    var active = this._active;
    this._active = false;
    return active;
  };
  Pannable2.prototype.pan = function pan() {
    var ref2 = this;
    var plotArea = ref2.plotArea;
    var axisRanges2 = ref2.axisRanges;
    if (axisRanges2.length) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  Pannable2.prototype.destroy = function destroy() {
    delete this.plotArea;
  };
  Pannable2.prototype._panAxes = function _panAxes(e, position) {
    var plotArea = this.plotArea;
    var delta = -e[position].delta;
    var lock = (this.options.lock || "").toLowerCase();
    var updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position) {
      var axes = plotArea.axes;
      for (var idx = 0; idx < axes.length; idx++) {
        var axis = axes[idx];
        if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {
          var range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  };
  return Pannable2;
}(class_default);
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = function(Class) {
  function ZoomSelection2(chart, options) {
    Class.call(this);
    this.chart = chart;
    this.options = deepExtend({}, this.options, options);
    this.createElement();
  }
  if (Class) ZoomSelection2.__proto__ = Class;
  ZoomSelection2.prototype = Object.create(Class && Class.prototype);
  ZoomSelection2.prototype.constructor = ZoomSelection2;
  ZoomSelection2.prototype.createElement = function createElement() {
    var marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  };
  ZoomSelection2.prototype.removeElement = function removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  };
  ZoomSelection2.prototype.setStyles = function setStyles(styles) {
    elementStyles(this._marquee, styles);
  };
  ZoomSelection2.prototype.start = function start(e) {
    if (acceptKey(e, this.options.key)) {
      var chart = this.chart;
      var point = chart._eventCoordinates(e);
      var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);
      var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        var offset = this._elementOffset();
        clipBox.translate(offset.left, offset.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e.pageX + 1,
          top: e.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  };
  ZoomSelection2.prototype._elementOffset = function _elementOffset() {
    var chartElement = this.chart.element;
    var ref2 = elementStyles(chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref2.paddingLeft;
    var paddingTop = ref2.paddingTop;
    var offset = elementOffset(chartElement);
    return {
      left: paddingLeft + offset.left,
      top: paddingTop + offset.top
    };
  };
  ZoomSelection2.prototype.move = function move(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e));
    }
  };
  ZoomSelection2.prototype.end = function end(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      var elementOffset2 = this._elementOffset();
      var selectionPosition = this._selectionPosition(e);
      selectionPosition.left -= elementOffset2.left;
      selectionPosition.top -= elementOffset2.top;
      var start = {
        x: selectionPosition.left,
        y: selectionPosition.top
      };
      var end2 = {
        x: selectionPosition.left + selectionPosition.width,
        y: selectionPosition.top + selectionPosition.height
      };
      this._updateAxisRanges(start, end2);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  };
  ZoomSelection2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      var plotArea = this.chart._plotArea;
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  ZoomSelection2.prototype.destroy = function destroy() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  };
  ZoomSelection2.prototype._updateAxisRanges = function _updateAxisRanges(start, end) {
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this._zoomPane.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {
        var range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  };
  ZoomSelection2.prototype._selectionPosition = function _selectionPosition(e) {
    var clipBox = this._zoomPaneClipBox;
    var startLocation = {
      x: e.x.startLocation,
      y: e.y.startLocation
    };
    var pageX = e.x.location;
    var pageY = e.y.location;
    var lock = (this.options.lock || "").toLowerCase();
    var left = Math.min(startLocation.x, pageX);
    var top = Math.min(startLocation.y, pageY);
    var width = Math.abs(startLocation.x - pageX);
    var height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  };
  return ZoomSelection2;
}(class_default);
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = function(Class) {
  function MousewheelZoom2(chart, options) {
    Class.call(this);
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options);
  }
  if (Class) MousewheelZoom2.__proto__ = Class;
  MousewheelZoom2.prototype = Object.create(Class && Class.prototype);
  MousewheelZoom2.prototype.constructor = MousewheelZoom2;
  MousewheelZoom2.prototype.updateRanges = function updateRanges(delta, coords) {
    var this$1 = this;
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this.chart._plotArea.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        var rate = limitValue(this$1.options.rate, MIN_RATE, MAX_RATE);
        var range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  };
  MousewheelZoom2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    var plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  MousewheelZoom2.prototype.destroy = function destroy() {
    delete this.chart;
  };
  return MousewheelZoom2;
}(class_default);
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var alignItems = function(rtl) {
  return rtl ? END : START;
};
var LegendLayout = function(ChartElement2) {
  function LegendLayout2(options, chartService) {
    ChartElement2.call(this, options);
    this.chartService = chartService;
  }
  if (ChartElement2) LegendLayout2.__proto__ = ChartElement2;
  LegendLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LegendLayout2.prototype.constructor = LegendLayout2;
  LegendLayout2.prototype.render = function render() {
    var ref2 = this;
    var children = ref2.children;
    var options = ref2.options;
    var vertical = options.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options.spacing,
      lineSpacing: vertical ? options.spacing : 0,
      orientation: vertical ? VERTICAL : HORIZONTAL,
      reverse: options.rtl,
      alignItems: vertical ? alignItems(options.rtl) : CENTER
    });
    for (var idx = 0; idx < children.length; idx++) {
      var legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  };
  LegendLayout2.prototype.reflow = function reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    var bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  };
  LegendLayout2.prototype.renderVisual = function renderVisual() {
    this.addVisual();
  };
  LegendLayout2.prototype.createVisual = function createVisual() {
  };
  return LegendLayout2;
}(chart_element_default);
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-marker.js
var DEFAULT_MARKER_SIZE = 10;
var DEFAULT_MARKER_BORDER_WIDTH = 2;
var LegendItemMarker = function(ShapeElement2) {
  function LegendItemMarker2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemMarker2.__proto__ = ShapeElement2;
  LegendItemMarker2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemMarker2.prototype.constructor = LegendItemMarker2;
  LegendItemMarker2.prototype.visualStyle = function visualStyle() {
    var options = this.markerOptions();
    var border = options.border;
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      cursor: options.cursor
    };
  };
  LegendItemMarker2.prototype.markerOptions = function markerOptions() {
    return this.options;
  };
  LegendItemMarker2.prototype.markerHighlightOptions = function markerHighlightOptions() {
    var options = this.markerOptions();
    var borderWidth = options.highlight.border.width;
    return deepExtend({}, options, {
      background: options.border.color
    }, options.highlight, options.type === CROSS ? {
      background: options.highlight.border.color,
      border: {
        color: options.highlight.background,
        width: borderWidth / 2
      },
      width: options.width,
      height: options.height,
      margin: {
        top: 0,
        left: 0
      }
    } : {});
  };
  LegendItemMarker2.prototype.createHighlight = function createHighlight() {
    var highlight = new ShapeElement2(this.markerHighlightOptions());
    var box = this.paddingBox.clone();
    highlight.reflow(box.pad(highlight.options.border.width));
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemMarker2;
}(shape_element_default);
setDefaultOptions(LegendItemMarker, {
  border: {
    width: DEFAULT_MARKER_BORDER_WIDTH
  },
  width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  background: WHITE,
  margin: {
    top: -1,
    left: -1
  },
  vAlign: TOP,
  align: LEFT,
  highlight: {
    width: DEFAULT_MARKER_SIZE,
    height: DEFAULT_MARKER_SIZE,
    border: {
      color: WHITE,
      width: DEFAULT_MARKER_BORDER_WIDTH
    }
  }
});
var legend_item_marker_default = LegendItemMarker;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line-area.js
var MarkerLineArea = function(ShapeElement2) {
  function MarkerLineArea2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) MarkerLineArea2.__proto__ = ShapeElement2;
  MarkerLineArea2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  MarkerLineArea2.prototype.constructor = MarkerLineArea2;
  MarkerLineArea2.prototype.getElement = function getElement() {
    var group = new drawing_exports.Group();
    var element = new drawing_exports.MultiPath(this.visualStyle());
    var ref2 = this;
    var box = ref2.paddingBox;
    var halfHeight = box.height() / 2;
    element.moveTo(box.x1, box.y1 + halfHeight).lineTo(box.x1, box.y2).lineTo(box.x2, box.y2);
    group.append(element);
    return group;
  };
  return MarkerLineArea2;
}(shape_element_default);
setDefaultOptions(MarkerLineArea, {
  width: 15,
  height: 15,
  align: RIGHT,
  vAlign: BOTTOM,
  margin: {
    right: -2,
    bottom: 2
  }
});
var legend_item_line_area_default = MarkerLineArea;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line.js
var LegendItemLine = function(ShapeElement2) {
  function LegendItemLine2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemLine2.__proto__ = ShapeElement2;
  LegendItemLine2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemLine2.prototype.constructor = LegendItemLine2;
  LegendItemLine2.prototype.getElement = function getElement() {
    var group = new drawing_exports.Group();
    var element = new drawing_exports.MultiPath({
      stroke: {
        color: this.options.border.color,
        opacity: this.options.opacity,
        width: this.options.height,
        dashType: this.options.dashType
      }
    });
    var box = this.paddingBox;
    var centerY = box.center().y;
    element.moveTo(box.x1, centerY).lineTo(box.x2, centerY);
    group.append(element);
    return group;
  };
  LegendItemLine2.prototype.createHighlight = function createHighlight() {
    this.highlight = [this.createHighlightLine(), this.createHighlightMarker()];
    return this.highlight;
  };
  LegendItemLine2.prototype.createHighlightLine = function createHighlightLine() {
    var options = deepExtend({}, {
      border: {
        color: this.options.border.color,
        opacity: this.options.border.opacity,
        dashType: this.options.border.dashType
      }
    }, this.options.highlight);
    var highlightLine = new legend_item_line_area_default(options);
    highlightLine.reflow(this.parent.paddingBox.clone());
    this.highlightLine = highlightLine.getElement();
    return this.highlightLine;
  };
  LegendItemLine2.prototype.createHighlightMarker = function createHighlightMarker() {
    var options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlightMarker = new ShapeElement2(options);
    var paddingBox = this.parent.paddingBox;
    var borderWidth = options.border.width;
    var box = this.parent.box.clone();
    box.pad({
      left: borderWidth - paddingBox.x1,
      top: borderWidth - paddingBox.y1
    });
    highlightMarker.reflow(box);
    this.highlightMarker = highlightMarker.getElement();
    return this.highlightMarker;
  };
  return LegendItemLine2;
}(shape_element_default);
setDefaultOptions(LegendItemLine, {
  border: {
    width: 0
  },
  type: RECT,
  align: LEFT,
  vAlign: CENTER,
  highlight: {
    border: {
      width: DEFAULT_MARKER_BORDER_WIDTH
    },
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      align: LEFT,
      vAlign: TOP
    }
  }
});
var legend_item_line_default = LegendItemLine;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-square.js
var LegendItemSquare = function(ShapeElement2) {
  function LegendItemSquare2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2) LegendItemSquare2.__proto__ = ShapeElement2;
  LegendItemSquare2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  LegendItemSquare2.prototype.constructor = LegendItemSquare2;
  LegendItemSquare2.prototype.createHighlight = function createHighlight() {
    var options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    var highlight = new ShapeElement2(options);
    var box = this.paddingBox.clone();
    var targetBox = this.parent.box.clone();
    box.align(targetBox, X, LEFT);
    box.align(targetBox, Y, TOP);
    highlight.reflow(box);
    this.highlight = [highlight.getElement()];
    return this.highlight;
  };
  return LegendItemSquare2;
}(shape_element_default);
setDefaultOptions(LegendItemSquare, {
  highlight: {
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      margin: {
        top: -3,
        left: -3
      }
    }
  }
});
var legend_item_square_default = LegendItemSquare;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = function(BoxElement2) {
  function LegendItem2(options) {
    BoxElement2.call(this, options);
    this.createContainer();
    if (!options.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
    this._id = guid();
    this.options.accessibility.ariaChecked = options.active;
  }
  if (BoxElement2) LegendItem2.__proto__ = BoxElement2;
  LegendItem2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  LegendItem2.prototype.constructor = LegendItem2;
  LegendItem2.prototype.createContainer = function createContainer() {
    this.container = new float_element_default({
      vertical: false,
      wrap: false,
      align: CENTER,
      spacing: this.options.spacing
    });
    this.append(this.container);
  };
  LegendItem2.prototype.createMarker = function createMarker() {
    this.markerWrap = new BoxElement2({
      vertical: false,
      shrinkToFit: true,
      wrap: false,
      margin: 1,
      width: 22,
      height: 22
    });
    this.container.append(this.markerWrap);
    this.createMarkerArea();
    if (this.options.markers.visible) {
      this._marker = this._createMarker();
      this.markerWrap.append(this._marker);
    }
  };
  LegendItem2.prototype.createMarkerArea = function createMarkerArea() {
    var options = this.options;
    var markerColor = options.markerColor;
    var line = options.line;
    if (line === void 0) line = {};
    var lineOptions = {
      border: {
        color: line.color || markerColor,
        opacity: line.opacity,
        dashType: line.dashType
      }
    };
    return this._createLine(lineOptions) || this._createMarkerLine(lineOptions, line) || this._createSquare();
  };
  LegendItem2.prototype.markerOptions = function markerOptions() {
    var options = this.options;
    var markers = options.markers;
    if (markers === void 0) markers = {};
    var markerColor = options.markerColor;
    var border = markers.border;
    if (border === void 0) border = {};
    markers.zIndex = void 0;
    return deepExtend({}, markers, {
      border: {
        color: border.color || markerColor
      },
      highlight: options.highlight.markers
    });
  };
  LegendItem2.prototype._highlightOptions = function _highlightOptions() {
    var options = this.options;
    return deepExtend({
      markers: {
        type: options.markers.type
      }
    }, options.highlight);
  };
  LegendItem2.prototype._createLine = function _createLine(lineOptions) {
    var options = this.options;
    if (options.type === LINE && !options.markers.visible) {
      this._line = new legend_item_line_default(deepExtend({}, {
        background: options.markerColor,
        highlight: this._highlightOptions()
      }, lineOptions, options.line));
      this.markerWrap.append(this._line);
    }
    return this._line;
  };
  LegendItem2.prototype._createMarkerLine = function _createMarkerLine(lineOptions, line) {
    var options = this.options;
    if (options.type === LINE) {
      this._markerLineArea = new legend_item_line_area_default(deepExtend({}, {
        border: {
          width: line.height
        }
      }, lineOptions));
      this.markerWrap.append(this._markerLineArea);
    }
    return this._markerLineArea;
  };
  LegendItem2.prototype._createSquare = function _createSquare() {
    var options = this.options;
    if (options.type === AREA) {
      this._square = new legend_item_square_default(Object.assign({}, {
        border: options.border,
        vAlign: options.markers.visible ? BOTTOM : CENTER,
        highlight: this._highlightOptions()
      }, options.area, {
        background: options.area.background || options.markerColor
      }));
      this.markerWrap.append(this._square);
    }
    return this._square;
  };
  LegendItem2.prototype._createMarker = function _createMarker() {
    return new legend_item_marker_default(this.markerOptions());
  };
  LegendItem2.prototype._highlightMarkers = function _highlightMarkers() {
    if (this.options.active) {
      this._toggleHighlight(true);
    }
  };
  LegendItem2.prototype._restoreMarkers = function _restoreMarkers() {
    this._toggleHighlight(false);
  };
  LegendItem2.prototype._toggleHighlight = function _toggleHighlight(show2) {
    var this$1 = this;
    if (!this.options.highlight.visible) {
      return;
    }
    var element = this._marker || this._square || this._line;
    if (element && element === this._line) {
      this._line.visual.visible(!show2);
    }
    if (element) {
      var highlight = element.highlight;
      if (!highlight) {
        highlight = element.createHighlight();
        highlight.forEach(function(h) {
          return h && this$1.markerWrap.appendVisual(h);
        });
      }
      highlight.forEach(function(h) {
        return h && h.visible(show2);
      });
    }
  };
  LegendItem2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labelOptions = deepExtend({}, options.labels);
    this.container.append(new text_box_default(options.text, labelOptions));
  };
  LegendItem2.prototype.getAriaLabelText = function getAriaLabelText2() {
    return this.options.text;
  };
  LegendItem2.prototype.focusVisual = function focusVisual2() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
    this._highlightMarkers();
  };
  LegendItem2.prototype.clearFocusFromVisual = function clearFocusFromVisual2() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
    this._restoreMarkers();
  };
  LegendItem2.prototype.renderComplete = function renderComplete() {
    BoxElement2.prototype.renderComplete.call(this);
    var cursor = this.options.cursor || {};
    var eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  };
  LegendItem2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === "contextmenu") {
      e.preventDefault();
    }
  };
  LegendItem2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
      this._highlightMarkers();
    }
    return true;
  };
  LegendItem2.prototype.out = function out(widget, e) {
    widget._unsetActivePoint();
    this._restoreMarkers();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));
  };
  LegendItem2.prototype.eventArgs = function eventArgs(e) {
    var options = this.options;
    return {
      element: eventElement(e),
      text: options.text,
      series: options.series,
      seriesIndex: options.series.index,
      pointIndex: options.pointIndex
    };
  };
  LegendItem2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    var options = this.options;
    if (this.options.visible) {
      var accessibilityOptions = deepExtend({
        ariaLabel: options.accessibility.ariaLabel !== void 0 ? options.accessibility.ariaLabel : options.text
      }, options.accessibility);
      addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
    }
  };
  LegendItem2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options = this.options;
    var customVisual = options.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options.active,
        series: options.series,
        sender: this.getSender(),
        pointIndex: options.pointIndex,
        options: {
          type: options.type,
          // Passing the markerColor as a background option for backwards compatibility.
          // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual
          markers: deepExtend({
            background: this.options.markerColor
          }, this.markerOptions()),
          labels: options.labels
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          this$1.renderComplete();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
      this._marker = this._markerLineArea = this._square = this._line = null;
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  LegendItem2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = style.stroke.width;
    return drawing_exports.Path.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style);
  };
  return LegendItem2;
}(box_element_default);
setDefaultOptions(LegendItem, {
  accessibility: {
    role: LEGEND_ITEM_ROLE,
    className: LEGEND_ITEM_CLASSNAME,
    ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION
  },
  markers: {},
  highlight: {
    visible: true,
    markers: {}
  }
});
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var CUSTOM = "custom";
var Legend = function(ChartElement2) {
  function Legend3(options, chartService) {
    if (chartService === void 0) chartService = {};
    ChartElement2.call(this, options);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options.title);
    this.createItems();
  }
  if (ChartElement2) Legend3.__proto__ = ChartElement2;
  Legend3.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Legend3.prototype.constructor = Legend3;
  Legend3.prototype.createContainers = function createContainers() {
    var options = this.options;
    var position = options.position;
    var userAlign = options.align;
    var align = position;
    var vAlign = CENTER;
    if (position === CUSTOM) {
      align = LEFT;
    } else if (inArray(position, [TOP, BOTTOM])) {
      if (userAlign === START) {
        align = LEFT;
      } else if (userAlign === END) {
        align = RIGHT;
      } else {
        align = CENTER;
      }
      vAlign = position;
    } else if (userAlign) {
      if (userAlign === START) {
        vAlign = TOP;
      } else if (userAlign === END) {
        vAlign = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options.margin,
      padding: options.padding,
      background: options.background,
      border: options.border,
      vAlign,
      align,
      zIndex: options.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign,
        align,
        zIndex: options.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  };
  Legend3.prototype.createItems = function createItems() {
    var chartService = this.getService();
    var options = this.options;
    var vertical = this.isVertical();
    var innerElement = new legend_layout_default({
      vertical,
      spacing: options.spacing,
      rtl: chartService.rtl
    }, chartService);
    var data = options.data;
    if (options.reverse) {
      data = data.slice(0).reverse();
    }
    var count = data.length;
    for (var i = 0; i < count; i++) {
      var dataItem = data[i];
      var ref2 = dataItem.series || {};
      var markers = ref2.markers;
      if (markers === void 0) markers = {};
      var dashType = ref2.dashType;
      var legendItem = ref2.legendItem;
      var opacity = ref2.opacity;
      var markersOptions = deepExtend({
        visible: markers.visible !== false,
        type: CIRCLE
      }, markers);
      delete markersOptions.size;
      var itemOptions = deepExtend({}, {
        markers: markersOptions,
        labels: options.labels,
        rtl: chartService.rtl,
        line: Object.assign({}, {
          dashType
        }, options.line),
        area: Object.assign({}, {
          opacity
        }, options.area),
        opacity,
        accessibility: options.accessibility
      }, options.item, legendItem, dataItem, {
        markers: options.markers
      });
      innerElement.append(new legend_item_default(itemOptions));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  };
  Legend3.prototype.isVertical = function isVertical() {
    var ref2 = this.options;
    var orientation = ref2.orientation;
    var position = ref2.position;
    var vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));
    return vertical;
  };
  Legend3.prototype.hasItems = function hasItems() {
    return this.container.children[0].children.length > 0;
  };
  Legend3.prototype.getItems = function getItems() {
    return this.itemsContainer.children[0].children;
  };
  Legend3.prototype.reflow = function reflow(targetBox) {
    var options = this.options;
    var legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  };
  Legend3.prototype.containerReflow = function containerReflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var container = ref2.container;
    var position = options.position;
    var width = options.width;
    var height = options.height;
    var pos = position === TOP || position === BOTTOM ? X : Y;
    var vertical = this.isVertical();
    var alignTarget = targetBox.clone();
    var containerBox = targetBox.clone();
    if (position === LEFT || position === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    var box = containerBox.clone();
    if (options.offsetX || options.offsetY) {
      containerBox.translate(options.offsetX, options.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  };
  Legend3.prototype.containerCustomReflow = function containerCustomReflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var container = ref2.container;
    var offsetX = options.offsetX;
    var offsetY = options.offsetY;
    var width = options.width;
    var height = options.height;
    var vertical = this.isVertical();
    var containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(offsetX, offsetY, offsetX + containerBox.width(), offsetY + containerBox.height()));
  };
  Legend3.prototype.renderVisual = function renderVisual() {
    if (this.hasItems()) {
      ChartElement2.prototype.renderVisual.call(this);
    }
  };
  Legend3.prototype.createLegendTitle = function createLegendTitle(title2) {
    var titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title2);
    var text = titleOptions.text;
    if (!title2 || title2.visible === false || !title2.text) {
      return;
    }
    if (defined(titleOptions) && titleOptions.visible) {
      var labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({
          text
        });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  };
  Legend3.prototype.createTitleLayout = function createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  };
  Legend3.prototype.hasTitle = function hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);
  };
  Legend3.prototype.appendTitleLayoutContent = function appendTitleLayoutContent() {
    var options = this.options;
    if (options.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  };
  return Legend3;
}(chart_element_default);
setDefaultOptions(Legend, {
  position: RIGHT,
  data: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(2),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {},
  line: {
    width: 20,
    height: 2,
    cursor: POINTER,
    opacity: 1
  },
  area: {
    type: SQUARE,
    align: RIGHT,
    width: 15,
    height: 15
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = function(Class) {
  function PlotAreaFactory2() {
    Class.call(this);
    this._registry = [];
  }
  if (Class) PlotAreaFactory2.__proto__ = Class;
  PlotAreaFactory2.prototype = Object.create(Class && Class.prototype);
  PlotAreaFactory2.prototype.constructor = PlotAreaFactory2;
  PlotAreaFactory2.prototype.register = function register4(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  };
  PlotAreaFactory2.prototype.create = function create2(srcSeries, options, chartService) {
    var registry2 = this._registry;
    var match = registry2[0];
    var series;
    for (var idx = 0; idx < registry2.length; idx++) {
      var entry = registry2[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      var trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);
      if (series.length - trendlines.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options, chartService);
  };
  return PlotAreaFactory2;
}(class_default);
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(classNames) {
  var element = document.createElement("div");
  if (classNames) {
    element.className = classNames;
  }
  return element;
}
function closestHandle(element) {
  var current4 = element;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = function(Class) {
  function Selection2(chart, categoryAxis, options, observer) {
    Class.call(this);
    var chartElement = chart.element;
    this.options = deepExtend({}, this.options, options);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  if (Class) Selection2.__proto__ = Class;
  Selection2.prototype = Object.create(Class && Class.prototype);
  Selection2.prototype.constructor = Selection2;
  Selection2.prototype.onPane = function onPane(pane) {
    return this.categoryAxis.pane === pane;
  };
  Selection2.prototype.createElements = function createElements() {
    var options = this.options;
    var wrapper2 = this.wrapper = createDiv("k-selector k-pointer-events-none");
    elementStyles(wrapper2, {
      top: options.offset.top,
      left: options.offset.left,
      width: options.width,
      height: options.height,
      direction: "ltr"
    });
    var selection = this.selection = createDiv("k-selection k-pointer-events-none");
    this.leftMask = createDiv("k-mask k-pointer-events-none");
    this.rightMask = createDiv("k-mask k-pointer-events-none");
    wrapper2.appendChild(this.leftMask);
    wrapper2.appendChild(this.rightMask);
    wrapper2.appendChild(selection);
    var body = this.body = createDiv("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    var leftHandle = this.leftHandle = createDiv("k-handle k-left-handle k-pointer-events-auto");
    var rightHandle = this.rightHandle = createDiv("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper2);
    var selectionStyles = elementStyles(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    var leftHandleHeight = elementStyles(leftHandle, "height").height;
    var rightHandleHeight = elementStyles(rightHandle, "height").height;
    options.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper2.style.cssText = wrapper2.style.cssText;
  };
  Selection2.prototype.bindEvents = function bindEvents$1() {
    var obj;
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
    }
    this._domEvents = dom_events_builder_default.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  };
  Selection2.prototype.initOptions = function initOptions() {
    var ref2 = this;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var box = categoryAxis.pane.chartsBox();
    var intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options, {
        min: parseDate(intlService, options.min),
        max: parseDate(intlService, options.max),
        from: parseDate(intlService, options.from),
        to: parseDate(intlService, options.to)
      });
    }
    var ref$1 = elementStyles(this.chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref$1.paddingLeft;
    var paddingTop = ref$1.paddingTop;
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options.min,
      to: options.max
    }, options);
  };
  Selection2.prototype.destroy = function destroy() {
    var obj;
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  };
  Selection2.prototype._rangeEventArgs = function _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  };
  Selection2.prototype._pointInPane = function _pointInPane(x, y) {
    var paneBox = this.categoryAxis.pane.box;
    var modelCoords = this.chart._toModelCoordinates(x, y);
    return paneBox.containsPoint(modelCoords);
  };
  Selection2.prototype._start = function _start(e) {
    var options = this.options;
    var target = eventElement(e);
    if (this._state || !target) {
      return;
    }
    var coords = eventCoordinates(e);
    var inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    var handle = closestHandle(target);
    var bodyRect = this.body.getBoundingClientRect();
    var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e.x ? e.x.location : 0,
      inBody,
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    var args = this._rangeEventArgs({
      from: this._index(options.from),
      to: this._index(options.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  };
  Selection2.prototype._press = function _press(e) {
    var handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement(e));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  };
  Selection2.prototype._move = function _move(e) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var state = ref2._state;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var target = state.moveTarget;
    var reverse = categoryAxis.options.reverse;
    var from = this._index(options.from);
    var to = this._index(options.to);
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var delta = state.startLocation - e.x.location;
    var oldRange = {
      from: range.from,
      to: range.to
    };
    var span = range.to - range.from;
    var scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    var offset = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    var leftHandle = target && hasClasses(target, "k-left-handle");
    var rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(Math.max(min4, from - offset), max3 - span);
      range.to = Math.min(range.from + span, max3);
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(Math.max(min4, from - offset), max3 - 1);
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(Math.max(min4 + 1, to - offset), max3);
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT2, this._rangeEventArgs(range));
    }
  };
  Selection2.prototype._end = function _end() {
    if (this._state) {
      var moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      var range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  };
  Selection2.prototype._tap = function _tap(e) {
    var ref2 = this;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var coords = this.chart._eventCoordinates(e);
    var categoryIx = categoryAxis.pointCategoryIndex(new point_default(coords.x, categoryAxis.box.y1));
    var from = this._index(options.from);
    var to = this._index(options.to);
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var span = to - from;
    var mid = from + span / 2;
    var range = {};
    var rightClick = e.event.which === 3;
    var offset = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset--;
    }
    range.from = Math.min(Math.max(min4, from - offset), max3 - span);
    range.to = Math.min(range.from + span, max3);
    this._start(e);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT2, this._rangeEventArgs(range));
      this._end();
    }
  };
  Selection2.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    this._start(e);
    if (this._state) {
      var range = this._state.range;
      e.preventDefault();
      e.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT2, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(function() {
        this$1._end();
      }, MOUSEWHEEL_DELAY);
    }
  };
  Selection2.prototype._gesturestart = function _gesturestart(e) {
    var options = this.options;
    var touch = e.touches[0];
    var inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    var args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e.preventDefault();
    }
  };
  Selection2.prototype._gestureend = function _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  };
  Selection2.prototype._gesturechange = function _gesturechange(e) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var chart = ref2.chart;
    var state = ref2._state;
    var options = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;
    var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;
    var left = Math.min(p0, p1);
    var right = Math.max(p0, p1);
    e.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default(left)) || options.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default(right)) || options.max;
    this.move(range.from, range.to);
    this.trigger(SELECT2, this._rangeEventArgs(range));
  };
  Selection2.prototype._index = function _index(value2) {
    var index = value2;
    if (value2 instanceof Date) {
      index = this.categoryAxis.categoryIndex(value2);
    }
    return index;
  };
  Selection2.prototype._value = function _value(index) {
    var value2 = index;
    if (this._dateAxis) {
      value2 = this.categoryAxis.categoryAt(index);
      if (value2 > this.options.max) {
        value2 = this.options.max;
      }
    }
    return value2;
  };
  Selection2.prototype._slot = function _slot(value2) {
    var categoryAxis = this.categoryAxis;
    var index = this._index(value2);
    return categoryAxis.getSlot(index, index, true);
  };
  Selection2.prototype.move = function move(from, to) {
    var options = this.options;
    var reverse = this.categoryAxis.options.reverse;
    var offset = options.offset;
    var padding = options.padding;
    var border = options.selection.border;
    var left = reverse ? to : from;
    var right = reverse ? from : to;
    var edge = "x" + (reverse ? 2 : 1);
    var box = this._slot(left);
    var leftMaskWidth = round(box[edge] - offset.left + padding.left);
    elementStyles(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));
    elementStyles(this.rightMask, {
      width: rightMaskWidth
    });
    var distance = options.width - rightMaskWidth;
    if (distance !== options.width) {
      distance += border.right;
    }
    elementStyles(this.rightMask, {
      left: distance
    });
    elementStyles(this.selection, {
      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  };
  Selection2.prototype.set = function set3(from, to) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var fromValue = limitValue(this._index(from), min4, max3);
    var toValue = limitValue(this._index(to), fromValue + 1, max3);
    if (options.visible) {
      this.move(fromValue, toValue);
    }
    options.from = this._value(fromValue);
    options.to = this._value(toValue);
  };
  Selection2.prototype.expand = function expand(delta) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var zDir = options.mousewheel.zoom;
    var from = this._index(options.from);
    var to = this._index(options.to);
    var range = {
      from,
      to
    };
    var oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue(limitValue(from - delta, 0, to - 1), min4, max3);
    }
    if (zDir !== LEFT) {
      range.to = limitValue(limitValue(to + delta, range.from + 1, max3), min4, max3);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.zoom = function zoom(delta, coords) {
    var options = this.options;
    var min4 = this._index(options.min);
    var max3 = this._index(options.max);
    var from = this._index(options.from);
    var to = this._index(options.to);
    var range = {
      from,
      to
    };
    var oldRange = deepExtend({}, range);
    var ref2 = this.categoryAxis.options;
    var reverse = ref2.reverse;
    var origin = X + (reverse ? "2" : "1");
    var lineBox = this.categoryAxis.lineBox();
    var relative = Math.abs(lineBox[origin] - coords[X]);
    var size = lineBox.width();
    var position = round(relative / size, 2);
    var minDelta = round(position * delta);
    var maxDelta = round((1 - position) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue(limitValue(from - minDelta, 0, to - 1), min4, max3);
    range.to = limitValue(limitValue(to + maxDelta, range.from + 1, max3), min4, max3);
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.trigger = function trigger2(name2, args) {
    return (this.observer || this.chart).trigger(name2, args);
  };
  return Selection2;
}(class_default);
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = function(BaseTooltip3) {
  function Tooltip3() {
    BaseTooltip3.apply(this, arguments);
  }
  if (BaseTooltip3) Tooltip3.__proto__ = BaseTooltip3;
  Tooltip3.prototype = Object.create(BaseTooltip3 && BaseTooltip3.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  Tooltip3.prototype.show = function show2(point) {
    if (!point || !point.tooltipAnchor || this._current && this._current === point) {
      return;
    }
    var options = deepExtend({}, this.options, point.options.tooltip);
    var anchor = point.tooltipAnchor();
    if (anchor) {
      this._current = point;
      BaseTooltip3.prototype.show.call(this, {
        point,
        anchor
      }, options, point);
    } else {
      this.hide();
    }
  };
  Tooltip3.prototype.hide = function hide2() {
    delete this._current;
    BaseTooltip3.prototype.hide.call(this);
  };
  return Tooltip3;
}(base_tooltip_default);
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = function(BaseTooltip3) {
  function SharedTooltip3(plotArea, options) {
    BaseTooltip3.call(this, plotArea.chartService, options);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  if (BaseTooltip3) SharedTooltip3.__proto__ = BaseTooltip3;
  SharedTooltip3.prototype = Object.create(BaseTooltip3 && BaseTooltip3.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype.showAt = function showAt(points, coords) {
    var tooltipPoints = grep(points, function(point2) {
      var tooltip = point2.series.tooltip;
      var excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      var point = tooltipPoints[0];
      var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);
      var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);
      this.show({
        anchor,
        shared: true,
        points,
        category: point.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point.category),
        series: this.plotArea.series
      }, this.options);
    }
  };
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(point, slot) {
    var axis = this.plotArea.categoryAxis;
    var align = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point.x = slot.center().x;
    }
    return {
      point,
      align
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point, slot) {
    var box = point.owner.pane.chartsBox();
    var vertical = this.plotArea.categoryAxis.options.vertical;
    var center = box.center();
    var slotCenter = slot.center();
    var align = {
      horizontal: "center",
      vertical: "center"
    };
    var centerPoint;
    if (vertical) {
      centerPoint = new point_default(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align
    };
  };
  return SharedTooltip3;
}(base_tooltip_default);
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = function(superclass) {
  function BarChartAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BarChartAnimation2.__proto__ = superclass;
  BarChartAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarChartAnimation2.prototype.constructor = BarChartAnimation2;
  BarChartAnimation2.prototype.setup = function setup() {
    var ref2 = this;
    var element = ref2.element;
    var options = ref2.options;
    var bbox = element.bbox();
    if (bbox) {
      this.origin = options.origin;
      var axis = options.vertical ? Y : X;
      var fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(geometry_exports.transform().scale(fromScale.x, fromScale.y));
    } else {
      this.abort();
    }
  };
  BarChartAnimation2.prototype.step = function step(pos) {
    var scaleX = interpolateValue(this.fromScale.x, 1, pos);
    var scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(geometry_exports.transform().scale(scaleX, scaleY, this.origin));
  };
  BarChartAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    this.element.transform(null);
  };
  return BarChartAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = function(superclass) {
  function BubbleAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BubbleAnimation2.__proto__ = superclass;
  BubbleAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BubbleAnimation2.prototype.constructor = BubbleAnimation2;
  BubbleAnimation2.prototype.setup = function setup() {
    var center = this.center = this.element.bbox().center();
    this.element.transform(geometry_exports.transform().scale(START_SCALE, START_SCALE, center));
  };
  BubbleAnimation2.prototype.step = function step(pos) {
    this.element.transform(geometry_exports.transform().scale(pos, pos, this.center));
  };
  return BubbleAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = function(superclass) {
  function FadeInAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) FadeInAnimation2.__proto__ = superclass;
  FadeInAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeInAnimation2.prototype.constructor = FadeInAnimation2;
  FadeInAnimation2.prototype.setup = function setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  };
  FadeInAnimation2.prototype.step = function step(pos) {
    this.element.opacity(pos * this.fadeTo);
  };
  return FadeInAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = function(superclass) {
  function PieAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) PieAnimation2.__proto__ = superclass;
  PieAnimation2.prototype = Object.create(superclass && superclass.prototype);
  PieAnimation2.prototype.constructor = PieAnimation2;
  PieAnimation2.prototype.setup = function setup() {
    this.element.transform(geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center));
  };
  PieAnimation2.prototype.step = function step(pos) {
    this.element.transform(geometry_exports.transform().scale(pos, pos, this.options.center));
  };
  return PieAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = function(ScatterChart2) {
  function ScatterLineChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) ScatterLineChart2.__proto__ = ScatterChart2;
  ScatterLineChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  ScatterLineChart2.prototype.constructor = ScatterLineChart2;
  ScatterLineChart2.prototype.render = function render() {
    ScatterChart2.prototype.render.call(this);
    this.renderSegments();
  };
  ScatterLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  ScatterLineChart2.prototype.animationPoints = function animationPoints() {
    var points = ScatterChart2.prototype.animationPoints.call(this);
    return points.concat(this._segments);
  };
  ScatterLineChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    if (missingValues === ZERO) {
      var missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  };
  return ScatterLineChart2;
}(scatter_chart_default);
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-scatter-trendline-data.js
function getScatterTrendlineData(valueMapper, range, options) {
  var data = [];
  var xMin = range.xMin;
  var xMax = range.xMax;
  var forecast = (options || {}).forecast;
  if (forecast) {
    if (forecast.before > 0) {
      xMin -= forecast.before;
    }
    if (forecast.after > 0) {
      xMax += forecast.after;
    }
  }
  var samplingInterval = (options || {}).samplingInterval;
  var delta = valueOrDefault(samplingInterval, autoMajorUnit(xMin, xMax) / 10);
  if (samplingInterval <= 0) {
    delta = xMax - xMin;
  }
  for (var x = xMin; x <= xMax; x += delta) {
    data.push([x, valueMapper(x)]);
  }
  return data;
}
var get_scatter_trendline_data_default = getScatterTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-exponential-trendline.js
function scatterExponentialTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData7({
    seriesValues,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
var valueGetter7 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return {
      xValue: valueFields.x,
      yValue: Math.log(valueFields[fieldName])
    };
    ;
  };
};
function getData7(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter7(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = {
    xMin,
    xMax
  };
  if (count > 0) {
    var a = Math.exp(intercept);
    var b = slope;
    return get_scatter_trendline_data_default(function(x) {
      return a * Math.exp(b * x);
    }, range, options.trendline);
  }
  return null;
}
var scatter_exponential_trendline_default = scatterExponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-value-getter.js
var scatterValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return {
      xValue: valueFields.x,
      yValue: valueFields[fieldName]
    };
    ;
  };
};
var scatter_value_getter_default = scatterValueGetter;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-linear-trendline.js
function scatterLinearTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData8({
    seriesValues,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
function getData8(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var ref$1 = calculate_slope_default(seriesValues(), scatter_value_getter_default(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = {
    xMin,
    xMax
  };
  if (count > 0) {
    return get_scatter_trendline_data_default(function(x) {
      return slope * x + intercept;
    }, range, options.trendline);
  }
  return null;
}
var scatter_linear_trendline_default = scatterLinearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/x-value-limits.js
function xValueLimits(sourceValues, valueGetter10) {
  var xMin = Number.MAX_VALUE;
  var xMax = Number.MIN_VALUE;
  for (var i = 0; i < sourceValues.length; i++) {
    var value2 = sourceValues[i];
    var ref2 = valueGetter10(value2);
    var xValue = ref2.xValue;
    var yValue = ref2.yValue;
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
    }
  }
  return {
    xMin,
    xMax
  };
}
var x_value_limits_default = xValueLimits;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-logarithmic-trendline.js
function scatterLogarithmicTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData9({
    seriesValues,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
var valueGetter8 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return {
      xValue: valueFields.x,
      yValue: valueFields[fieldName]
    };
    ;
  };
};
var logValueGetter = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return {
      xValue: Math.log(valueFields.x),
      yValue: valueFields[fieldName]
    };
    ;
  };
};
function getData9(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, logValueGetter(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = x_value_limits_default(sourceValues, valueGetter8(options.field));
  if (count > 0) {
    var a = slope;
    var b = intercept;
    return get_scatter_trendline_data_default(function(x) {
      return a * Math.log(x) + b;
    }, range, options.trendline);
  }
  return null;
}
var scatter_logarithmic_trendline_default = scatterLogarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-moving-average.js
function scatterMovingAverageTrendline(context) {
  var options = context.options;
  var data = getData10(context);
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
function getData10(ref2) {
  var options = ref2.options;
  var seriesValues = ref2.seriesValues;
  var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  var range = {
    before: period,
    after: period
  };
  var data = calculate_moving_average_default(seriesValues(range), scatter_value_getter_default(options.field), period);
  if (data.length > 0) {
    return data;
  }
  return null;
}
var scatter_moving_average_default = scatterMovingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-polynomial-trendline.js
function scatterPolynomialTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData11({
    seriesValues,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
function getData11(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var order = (options.trendline || {}).order;
  var valueGetter10 = scatter_value_getter_default(options.field);
  var ref$1 = calculate_polynomial_default(seriesValues(), valueGetter10, order);
  var count = ref$1.count;
  var valueMapper = ref$1.valueMapper;
  var xMin = ref$1.xMin;
  var xMax = ref$1.xMax;
  var range = {
    xMin,
    xMax
  };
  if (count > 0) {
    return get_scatter_trendline_data_default(valueMapper, range, options.trendline);
  }
  return null;
}
var scatter_polynomial_trendline_default = scatterPolynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-power-trendline.js
function scatterPowerTrendline(context) {
  var options = context.options;
  var seriesValues = context.seriesValues;
  var data = getData12({
    seriesValues,
    options
  });
  if (data) {
    return Object.assign({}, options, {
      type: "scatterLine",
      data
    });
  }
  return null;
}
var valueGetter9 = function(fieldName) {
  return function(ref2) {
    var valueFields = ref2.valueFields;
    return {
      xValue: Math.log(valueFields.x),
      yValue: Math.log(valueFields[fieldName])
    };
    ;
  };
};
function getData12(ref2) {
  var seriesValues = ref2.seriesValues;
  var options = ref2.options;
  var sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  var ref$1 = calculate_slope_default(sourceValues, valueGetter9(options.field));
  var slope = ref$1.slope;
  var intercept = ref$1.intercept;
  var count = ref$1.count;
  var range = x_value_limits_default(sourceValues, scatter_value_getter_default(options.field));
  if (count > 0) {
    var a = Math.exp(intercept);
    var b = slope;
    return get_scatter_trendline_data_default(function(x) {
      return a * Math.pow(x, b);
    }, range, options.trendline);
  }
  return null;
}
var scatter_power_trendline_default = scatterPowerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-trendline-registry.js
var scatterRegistry = {};
scatterRegistry[TRENDLINE_EXPONENTIAL] = scatter_exponential_trendline_default;
scatterRegistry[TRENDLINE_LINEAR] = scatter_linear_trendline_default;
scatterRegistry[TRENDLINE_LOGARITHMIC] = scatter_logarithmic_trendline_default;
scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatter_moving_average_default;
scatterRegistry[TRENDLINE_POLYNOMIAL] = scatter_polynomial_trendline_default;
scatterRegistry[TRENDLINE_POWER] = scatter_power_trendline_default;
var scatter_trendline_registry_default = scatterRegistry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = function(PlotAreaBase2) {
  function XYPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) XYPlotArea2.__proto__ = PlotAreaBase2;
  XYPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  XYPlotArea2.prototype.constructor = XYPlotArea2;
  XYPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  };
  XYPlotArea2.prototype.render = function render(panes) {
    var this$1 = this;
    if (panes === void 0) panes = this.panes;
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createScatterChart(filterSeriesByType(filteredSeries, SCATTER), pane);
      this$1.createScatterLineChart(filterSeriesByType(filteredSeries, SCATTER_LINE), pane);
      this$1.createBubbleChart(filterSeriesByType(filteredSeries, BUBBLE), pane);
    }
    this.createAxes(panes);
  };
  XYPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  XYPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  XYPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  XYPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(new scatter_chart_default(this, {
        series,
        clip: pane.options.clip
      }), pane);
    }
  };
  XYPlotArea2.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(new scatter_line_chart_default(this, {
        series,
        clip: pane.options.clip
      }), pane);
    }
  };
  XYPlotArea2.prototype.createBubbleChart = function createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(new bubble_chart_default(this, {
        series,
        clip: pane.options.clip
      }), pane);
    }
  };
  XYPlotArea2.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {
    var axisName = options.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    var axisOptions2 = deepExtend({
      reverse: !vertical && this.chartService.rtl
    }, options, {
      vertical
    });
    var isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    var defaultRange = tracker.query();
    var defaultAxisRange = isLog ? {
      min: 0.1,
      max: 1
    } : {
      min: 0,
      max: 1
    };
    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    var typeSamples = [axisOptions2.min, axisOptions2.max];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    var axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  };
  XYPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options = this.options;
    var xAxesOptions = [].concat(options.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  XYPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point = new point_default(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      var currentValue = axis.getValue(point);
      if (currentValue !== null) {
        values5.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  XYPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options);
    updateAxisOptions2(this.originalOptions, index, vertical, options);
  };
  XYPlotArea2.prototype.trendlineFactory = function trendlineFactory$1(options, series) {
    var seriesValues = this.seriesValues.bind(this, series.index);
    var trendline = trendline_factory_default(scatter_trendline_registry_default, options.type, {
      options,
      seriesValues
    });
    if (trendline) {
      trendline.xAxis = series.xAxis;
      trendline.yAxis = series.yAxis;
    }
    return trendline;
  };
  XYPlotArea2.prototype.seriesValues = function seriesValues(seriesIx) {
    var this$1 = this;
    var result = [];
    var currentSeries = this.series[seriesIx];
    for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
      var data = this$1.bindPoint(currentSeries, pointIx);
      result.push({
        pointIx,
        valueFields: data.valueFields
      });
    }
    return result;
  };
  return XYPlotArea2;
}(plotarea_base_default);
function updateAxisOptions2(targetOptions, axisIndex, vertical, options) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = function(ChartElement2) {
  function PieSegment2(value2, sector, options) {
    ChartElement2.call(this, options);
    this.value = value2;
    this.sector = sector;
  }
  if (ChartElement2) PieSegment2.__proto__ = ChartElement2;
  PieSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieSegment2.prototype.constructor = PieSegment2;
  PieSegment2.prototype.render = function render() {
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    this.createLabel();
  };
  PieSegment2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var chartService = this.owner.chartService;
    var labelText = this.getLabelText(labels);
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        var themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), this.pointData());
      this.append(this.label);
    }
  };
  PieSegment2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.owner.chartService.format.auto(options.format, this.value);
  };
  PieSegment2.prototype.reflow = function reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  };
  PieSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var labelsDistance = labelsOptions.distance;
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      var labelWidth = label.box.width();
      var lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        var x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  };
  PieSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var sector = ref2.sector;
    var options = ref2.options;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (this.value) {
      if (options.visual) {
        var startAngle = (sector.startAngle + 180) % 360;
        var visual = options.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options,
          sender: this.getSender(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  };
  PieSegment2.prototype.createSegmentVisual = function createSegmentVisual(group) {
    var ref2 = this;
    var sector = ref2.sector;
    var options = ref2.options;
    var borderOptions = options.border || {};
    var border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    var color = options.color;
    var fill = {
      color,
      opacity: options.opacity
    };
    var visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options.opacity
      },
      zIndex: options.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options.overlay)));
    }
  };
  PieSegment2.prototype.createSegment = function createSegment(sector, options) {
    if (options.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options);
    }
    return shape_builder_default.current.createRing(sector, options);
  };
  PieSegment2.prototype.createAnimation = function createAnimation() {
    var ref2 = this;
    var options = ref2.options;
    var center = ref2.sector.center;
    deepExtend(options, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    ChartElement2.prototype.createAnimation.call(this);
  };
  PieSegment2.prototype.createHighlight = function createHighlight(options) {
    var highlight = this.options.highlight || {};
    var border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  };
  PieSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  PieSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  };
  PieSegment2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var result = this.createSegment(this.sector, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    }));
    var clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(result.bbox()));
    clipPath.paths.push(this.createSegment(this.sector, {}));
    result.clip(clipPath);
    return result;
  };
  PieSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  };
  PieSegment2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  PieSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  PieSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return PieSegment2;
}(chart_element_default);
var RAD_30 = round(rad(30), DEFAULT_PRECISION);
var RAD_60 = round(rad(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  var radians = rad(angle);
  var sine = round(Math.sin(radians), DEFAULT_PRECISION);
  var cosine = round(Math.cos(radians), DEFAULT_PRECISION);
  var horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  var vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true,
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
deepExtend(PieSegment.prototype, accessibility_attributes_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value2, point, options) {
    var legendOptions = this.options.legend || {};
    var labelsOptions = legendOptions.labels || {};
    var inactiveItems = legendOptions.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    if (options && options.visibleInLegend !== false) {
      var pointVisible = options.visible !== false;
      var labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      var text = options.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options.series,
          dataItem: options.dataItem,
          percentage: options.percentage,
          value: value2
        });
      }
      var itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options.index,
          text,
          series: options.series,
          markerColor,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = function(ChartElement2) {
  function PieChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2) PieChart2.__proto__ = ChartElement2;
  PieChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieChart2.prototype.constructor = PieChart2;
  PieChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  PieChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var options = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0) seriesColors = [];
    var colorsCount = seriesColors.length;
    var series = options.series;
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var data = currentSeries.data;
      var ref$1 = bindSegments(currentSeries);
      var total3 = ref$1.total;
      var points = ref$1.points;
      var count = ref$1.count;
      var anglePerValue = 360 / total3;
      var constantAngle = void 0;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      var currentAngle = void 0;
      if (defined(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (var i = 0; i < points.length; i++) {
        var pointData = points[i];
        if (!pointData) {
          continue;
        }
        var fields = pointData.fields;
        var value2 = pointData.value;
        var visible = pointData.visible;
        var angle = value2 !== 0 ? constantAngle || value2 * anglePerValue : 0;
        var explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i % colorsCount];
        }
        callback(value2, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this$1,
          category: defined(fields.category) ? fields.category : "",
          index: i,
          series: currentSeries,
          seriesIx,
          dataItem: data[i],
          percentage: total3 !== 0 ? value2 / total3 : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  };
  PieChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options, value2, fields) {
    var series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, {
      defaults: series._defaults,
      excluded: ["data", "content", "template", "visual", "toggle", "ariaTemplate", "ariaContent"]
    });
  };
  PieChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, {
      index: fields.index
    });
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new pie_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  PieChart2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options = ref2.options;
    var points = ref2.points;
    var seriesConfigs = ref2.seriesConfigs;
    if (seriesConfigs === void 0) seriesConfigs = [];
    var count = points.length;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    var newBoxCenter = newBox.center();
    var boxCenter = box.center();
    var seriesCount = options.series.length;
    var leftSideLabels = [];
    var rightSideLabels = [];
    var padding = valueOrDefault(options.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    var radius = halfMinWidth - padding;
    var center = new point_default(radius + newBox.x1 + padding, radius + newBox.y1 + padding);
    for (var i = 0; i < count; i++) {
      var segment = points[i];
      var sector = segment.sector;
      var seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        var seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      var label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  };
  PieChart2.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {
    var segment = last(this.points);
    var sector = segment.sector;
    var count = labels.length - 1;
    var lr = sector.radius + segment.options.labels.distance;
    var distances = [];
    var firstBox = labels[0].box;
    var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (var i = 0; i < count; i++) {
      var secondBox = labels[i + 1].box;
      firstBox = labels[i].box;
      distance = round(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  };
  PieChart2.prototype.distributeLabels = function distributeLabels(distances, labels) {
    var this$1 = this;
    var count = distances.length;
    var left, right, remaining;
    for (var i = 0; i < count; i++) {
      remaining = -distances[i];
      left = right = i;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this$1._takeDistance(distances, i, --left, remaining);
        remaining = this$1._takeDistance(distances, i, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  };
  PieChart2.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {
    var result = amount;
    if (distances[position] > 0) {
      var available = Math.min(distances[position], result);
      result -= available;
      distances[position] -= available;
      distances[anchor] += available;
    }
    return result;
  };
  PieChart2.prototype.reflowLabels = function reflowLabels(distances, labels) {
    var this$1 = this;
    var segment = last(this.points);
    var sector = segment.sector;
    var labelOptions = segment.options.labels;
    var labelsCount = labels.length;
    var labelDistance = labelOptions.distance;
    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    var boxX;
    distances[0] += 2;
    for (var i = 0; i < labelsCount; i++) {
      var label = labels[i];
      var box = label.box;
      boxY += distances[i];
      boxX = this$1.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  };
  PieChart2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var connectors = ref2.options.connectors;
    var points = ref2.points;
    var count = points.length;
    var space = 4;
    ChartElement2.prototype.createVisual.call(this);
    this._connectorLines = [];
    for (var i = 0; i < count; i++) {
      var segment = points[i];
      var sector = segment.sector;
      var label = segment.label;
      var angle = sector.middle();
      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        var connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          var box = label.box;
          var centerPoint = sector.center;
          var start = sector.point(angle);
          var middle = new point_default(box.x1, box.center().y);
          var sr = void 0, end = void 0, crossing = void 0;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this$1._connectorLines.push(connectorLine);
          this$1.visual.append(connectorLine);
        }
      }
    }
  };
  PieChart2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    if (find(this.options.series, function(options) {
      return options.autoFit;
    })) {
      var targetBox = this.targetBox;
      var pieCenter = this.box.center();
      var bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      var bboxBottom = bbox.bottomRight();
      var scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  };
  PieChart2.prototype.labelComparator = function labelComparator(reverse) {
    var reverseValue = reverse ? -1 : 1;
    return function(a, b) {
      var first = (a.parent.sector.middle() + 270) % 360;
      var second = (b.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  };
  PieChart2.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {
    var radius = sector.radius;
    var sector_center = sector.center;
    var cx = sector_center.x;
    var cy = sector_center.y;
    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);
  };
  PieChart2.prototype.pointInCircle = function pointInCircle(point, center, radius) {
    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);
  };
  PieChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value);
  };
  PieChart2.prototype.animationDelay = function animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  };
  PieChart2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  return PieChart2;
}(chart_element_default);
function intersection(a1, a2, b1, b2) {
  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
  var result;
  if (ub !== 0) {
    var ua = uat / ub;
    result = new point_default(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = function(PlotAreaBase2) {
  function PiePlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) PiePlotArea2.__proto__ = PlotAreaBase2;
  PiePlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PiePlotArea2.prototype.constructor = PiePlotArea2;
  PiePlotArea2.prototype.render = function render() {
    this.createPieChart(this.series);
  };
  PiePlotArea2.prototype.createPieChart = function createPieChart(series) {
    var firstSeries = series[0];
    var pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  };
  PiePlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  PiePlotArea2.prototype.getPointBelow = function getPointBelow(point) {
    return this.getPointToTheRight(point);
  };
  PiePlotArea2.prototype.getPointAbove = function getPointAbove(point) {
    return this.getPointToTheLeft(point);
  };
  return PiePlotArea2;
}(plotarea_base_default);
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = function(PieSegment2) {
  function DonutSegment2() {
    PieSegment2.apply(this, arguments);
  }
  if (PieSegment2) DonutSegment2.__proto__ = PieSegment2;
  DonutSegment2.prototype = Object.create(PieSegment2 && PieSegment2.prototype);
  DonutSegment2.prototype.constructor = DonutSegment2;
  DonutSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        var lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        PieSegment2.prototype.reflowLabel.call(this);
      }
    }
  };
  DonutSegment2.prototype.createSegment = function createSegment(sector, options) {
    return shape_builder_default.current.createRing(sector, options);
  };
  return DonutSegment2;
}(pie_segment_default);
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = function(PieChart2) {
  function DonutChart2() {
    PieChart2.apply(this, arguments);
  }
  if (PieChart2) DonutChart2.__proto__ = PieChart2;
  DonutChart2.prototype = Object.create(PieChart2 && PieChart2.prototype);
  DonutChart2.prototype.constructor = DonutChart2;
  DonutChart2.prototype.addValue = function addValue(value2, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, {
      index: fields.index
    });
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new donut_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  DonutChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options = this.options;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var series = options.series;
    var seriesCount = series.length;
    var padding = valueOrDefault(options.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    var totalSize = halfMinWidth - padding;
    var seriesWithoutSize = 0;
    var holeSize;
    for (var i = 0; i < seriesCount; i++) {
      var currentSeries = series[i];
      if (i === 0) {
        if (defined(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined(currentSeries.margin) && i !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined(holeSize)) {
      var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    var innerRadius = holeSize;
    var margin = 0;
    var size, radius;
    this.seriesConfigs = [];
    for (var i$1 = 0; i$1 < seriesCount; i$1++) {
      var currentSeries$1 = series[i$1];
      size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this$1.seriesConfigs.push({
        innerRadius,
        radius
      });
      margin = currentSeries$1.margin || 0;
      innerRadius = radius;
    }
    PieChart2.prototype.reflow.call(this, targetBox);
  };
  DonutChart2.prototype.animationDelay = function animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  };
  return DonutChart2;
}(pie_chart_default);
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = function(PiePlotArea2) {
  function DonutPlotArea2() {
    PiePlotArea2.apply(this, arguments);
  }
  if (PiePlotArea2) DonutPlotArea2.__proto__ = PiePlotArea2;
  DonutPlotArea2.prototype = Object.create(PiePlotArea2 && PiePlotArea2.prototype);
  DonutPlotArea2.prototype.constructor = DonutPlotArea2;
  DonutPlotArea2.prototype.render = function render() {
    this.createDonutChart(this.series);
  };
  DonutPlotArea2.prototype.createDonutChart = function createDonutChart(series) {
    var firstSeries = series[0];
    var donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  };
  DonutPlotArea2.prototype.getPointBelow = function getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  };
  DonutPlotArea2.prototype.getPointAbove = function getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  };
  return DonutPlotArea2;
}(pie_plotarea_default);
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = function(PlotAreaBase2) {
  function PolarPlotAreaBase2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) PolarPlotAreaBase2.__proto__ = PlotAreaBase2;
  PolarPlotAreaBase2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PolarPlotAreaBase2.prototype.constructor = PolarPlotAreaBase2;
  PolarPlotAreaBase2.prototype.initFields = function initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  };
  PolarPlotAreaBase2.prototype.render = function render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  };
  PolarPlotAreaBase2.prototype.alignAxes = function alignAxes() {
    var axis = this.valueAxis;
    var range = axis.range();
    var crossingValue = axis.options.reverse ? range.max : range.min;
    var slot = axis.getSlot(crossingValue);
    var center = this.polarAxis.getSlot(0).center;
    var axisBox = axis.box.translate(center.x - slot.x1, center.y - slot.y1);
    axis.reflow(axisBox);
  };
  PolarPlotAreaBase2.prototype.createValueAxis = function createValueAxis() {
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    var axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = {
        min: 0.1,
        max: 1
      };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = {
        min: 0,
        max: 1
      };
    }
    var range = tracker.query(name) || defaultRange || axisDefaultRange;
    if (range && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var valueAxis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  };
  PolarPlotAreaBase2.prototype.reflowAxes = function reflowAxes() {
    var ref2 = this;
    var options = ref2.options.plotArea;
    var valueAxis = ref2.valueAxis;
    var polarAxis = ref2.polarAxis;
    var box = ref2.box;
    var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    var padding = getSpacing(options.padding || {}, defaultPadding);
    var paddingBox = box.clone().unpad(padding);
    var axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({
      top: heightDiff
    }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  };
  PolarPlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    return this.box;
  };
  PolarPlotAreaBase2.prototype.detachLabels = function detachLabels() {
  };
  return PolarPlotAreaBase2;
}(plotarea_base_default);
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = function(ScatterChart2) {
  function PolarScatterChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2) PolarScatterChart2.__proto__ = ScatterChart2;
  PolarScatterChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  PolarScatterChart2.prototype.constructor = PolarScatterChart2;
  PolarScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    var valueRadius = slotX.center.y - slotY.y1;
    var slot = point_default.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  return PolarScatterChart2;
}(scatter_chart_default);
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = function(ScatterLineChart2) {
  function PolarLineChart2() {
    ScatterLineChart2.apply(this, arguments);
  }
  if (ScatterLineChart2) PolarLineChart2.__proto__ = ScatterLineChart2;
  PolarLineChart2.prototype = Object.create(ScatterLineChart2 && ScatterLineChart2.prototype);
  PolarLineChart2.prototype.constructor = PolarLineChart2;
  return PolarLineChart2;
}(scatter_line_chart_default);
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = function(SplineAreaSegment2) {
  function SplinePolarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2) SplinePolarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplinePolarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplinePolarAreaSegment2.prototype.constructor = SplinePolarAreaSegment2;
  SplinePolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  };
  SplinePolarAreaSegment2.prototype._polarAxisCenter = function _polarAxisCenter() {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    return center;
  };
  SplinePolarAreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      var center = this._polarAxisCenter();
      var curveProcessor = new curve_processor_default(false);
      var linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  };
  return SplinePolarAreaSegment2;
}(spline_area_segment_default);
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = function(AreaSegment2) {
  function PolarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) PolarAreaSegment2.__proto__ = AreaSegment2;
  PolarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  PolarAreaSegment2.prototype.constructor = PolarAreaSegment2;
  PolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    var centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  };
  return PolarAreaSegment2;
}(area_segment_default);
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = function(PolarLineChart2) {
  function PolarAreaChart2() {
    PolarLineChart2.apply(this, arguments);
  }
  if (PolarLineChart2) PolarAreaChart2.__proto__ = PolarLineChart2;
  PolarAreaChart2.prototype = Object.create(PolarLineChart2 && PolarLineChart2.prototype);
  PolarAreaChart2.prototype.constructor = PolarAreaChart2;
  PolarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  };
  PolarAreaChart2.prototype.createMissingValue = function createMissingValue(value2, missingValues) {
    var missingValue;
    if (hasValue(value2.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (missingValues === ZERO) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  };
  PolarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  PolarAreaChart2.prototype._hasMissingValuesGap = function _hasMissingValuesGap() {
    var this$1 = this;
    var series = this.options.series;
    for (var idx = 0; idx < series.length; idx++) {
      if (this$1.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  };
  PolarAreaChart2.prototype.sortPoints = function sortPoints(points) {
    var this$1 = this;
    points.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (var idx = 0; idx < points.length; idx++) {
        var point = points[idx];
        if (point) {
          var value2 = point.value;
          if (!hasValue(value2.y) && this$1.seriesMissingValues(point.series) === GAP) {
            delete points[idx];
          }
        }
      }
    }
    return points;
  };
  return PolarAreaChart2;
}(polar_line_chart_default);
function xComparer(a, b) {
  return a.value.x - b.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = function(PolarPlotAreaBase2) {
  function PolarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2) PolarPlotArea2.__proto__ = PolarPlotAreaBase2;
  PolarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  PolarPlotArea2.prototype.constructor = PolarPlotArea2;
  PolarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  };
  PolarPlotArea2.prototype.render = function render() {
    this.series = [].concat(this.originalSeries);
    this.createTrendlineSeries();
    PolarPlotAreaBase2.prototype.render.call(this);
  };
  PolarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: {
        type: ARC
      },
      minorGridLines: {
        type: ARC
      }
    }, this.options.yAxis);
  };
  PolarPlotArea2.prototype.createValueAxis = function createValueAxis() {
    PolarPlotAreaBase2.prototype.createValueAxis.call(this);
    this.axisY = this.valueAxis;
  };
  PolarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options, series) {
    var trendline = xy_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = POLAR_LINE;
    }
    return trendline;
  };
  PolarPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  };
  PolarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createLineChart(filterSeriesByType(series, [POLAR_LINE]), pane);
    this.createScatterChart(filterSeriesByType(series, [POLAR_SCATTER]), pane);
    this.createAreaChart(filterSeriesByType(series, [POLAR_AREA]), pane);
  };
  PolarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new polar_line_chart_default(this, {
      series
    });
    this.appendChart(lineChart, pane);
  };
  PolarPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var scatterChart = new polar_scatter_chart_default(this, {
      series
    });
    this.appendChart(scatterChart, pane);
  };
  PolarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new polar_area_chart_default(this, {
      series
    });
    this.appendChart(areaChart, pane);
  };
  PolarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point = new point_default(coords.x, coords.y);
    var xValue = this.axisX.getValue(point);
    var yValue = this.axisY.getValue(point);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement(e),
        x: xValue,
        y: yValue
      });
    }
  };
  PolarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return PolarPlotArea2;
}(polar_plotarea_base_default);
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default, {
  seriesValues: xy_plotarea_default.prototype.seriesValues
});
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  var seriesSegments = [];
  for (var idx = 0; idx < segments.length; idx++) {
    var segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = function(LineChart2) {
  function RadarLineChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2) RadarLineChart2.__proto__ = LineChart2;
  RadarLineChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  RadarLineChart2.prototype.constructor = RadarLineChart2;
  RadarLineChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var valueRadius = categorySlot.center.y - valueSlot.y1;
    var slot = point_default.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  RadarLineChart2.prototype.renderSegments = function renderSegments() {
    LineChart2.prototype.renderSegments.call(this);
    if (this._segments && this._segments.length > 1) {
      var seriesSegments = groupBySeriesIx(this._segments);
      for (var idx = 0; idx < seriesSegments.length; idx++) {
        var segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          var firstPoint = segments[0].linePoints[0];
          var lastSegment = last(segments);
          var lastPoint = last(lastSegment.linePoints);
          var isFirstDataPoint = firstPoint.categoryIx === 0;
          var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  };
  RadarLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    var segment = new pointType(linePoints, currentSeries, seriesIx);
    var missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  };
  return RadarLineChart2;
}(line_chart_default);
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = function(SplineAreaSegment2) {
  function SplineRadarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2) SplineRadarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplineRadarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplineRadarAreaSegment2.prototype.constructor = SplineRadarAreaSegment2;
  SplineRadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return SplineRadarAreaSegment2;
}(spline_area_segment_default);
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = function(AreaSegment2) {
  function RadarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2) RadarAreaSegment2.__proto__ = AreaSegment2;
  RadarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RadarAreaSegment2.prototype.constructor = RadarAreaSegment2;
  RadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return RadarAreaSegment2;
}(area_segment_default);
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = function(RadarLineChart2) {
  function RadarAreaChart2() {
    RadarLineChart2.apply(this, arguments);
  }
  if (RadarLineChart2) RadarAreaChart2.__proto__ = RadarLineChart2;
  RadarAreaChart2.prototype = Object.create(RadarLineChart2 && RadarLineChart2.prototype);
  RadarAreaChart2.prototype.constructor = RadarAreaChart2;
  RadarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    var segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  };
  RadarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO;
  };
  return RadarAreaChart2;
}(radar_line_chart_default);
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = function(DonutSegment2) {
  function RadarSegment2(value2, options) {
    DonutSegment2.call(this, value2, null, options);
  }
  if (DonutSegment2) RadarSegment2.__proto__ = DonutSegment2;
  RadarSegment2.prototype = Object.create(DonutSegment2 && DonutSegment2.prototype);
  RadarSegment2.prototype.constructor = RadarSegment2;
  RadarSegment2.prototype.getIndex = function getIndex() {
    return this.categoryIx;
  };
  return RadarSegment2;
}(donut_segment_default);
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = function(ChartElement2) {
  function RadarClusterLayout2(options) {
    ChartElement2.call(this, options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  if (ChartElement2) RadarClusterLayout2.__proto__ = ChartElement2;
  RadarClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarClusterLayout2.prototype.constructor = RadarClusterLayout2;
  RadarClusterLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var options = ref2.options;
    var children = ref2.children;
    var gap = options.gap;
    var spacing = options.spacing;
    var count = children.length;
    var slots = count + gap + spacing * (count - 1);
    var slotAngle = sector.angle / slots;
    var angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, function(child) {
      var slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  };
  return RadarClusterLayout2;
}(chart_element_default);
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = function(ChartElement2) {
  function RadarStackLayout2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2) RadarStackLayout2.__proto__ = ChartElement2;
  RadarStackLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarStackLayout2.prototype.constructor = RadarStackLayout2;
  RadarStackLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var reverse = ref2.options.reverse;
    var children = ref2.children;
    var childrenCount = children.length;
    var first = reverse ? childrenCount - 1 : 0;
    var step = reverse ? -1 : 1;
    this.box = new box_default();
    for (var i = first; i >= 0 && i < childrenCount; i += step) {
      var childSector = children[i].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  };
  return RadarStackLayout2;
}(chart_element_default);
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = function(BarChart2) {
  function RadarBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2) RadarBarChart2.__proto__ = BarChart2;
  RadarBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RadarBarChart2.prototype.constructor = RadarBarChart2;
  RadarBarChart2.prototype.pointType = function pointType() {
    return radar_segment_default;
  };
  RadarBarChart2.prototype.clusterType = function clusterType() {
    return radar_cluster_layout_default;
  };
  RadarBarChart2.prototype.stackType = function stackType() {
    return radar_stack_layout_default;
  };
  RadarBarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  RadarBarChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var slot = categorySlot.clone();
    var y = categorySlot.center.y;
    slot.radius = y - valueSlot.y1;
    slot.innerRadius = y - valueSlot.y2;
    return slot;
  };
  RadarBarChart2.prototype.reflowPoint = function reflowPoint(point, pointSlot) {
    point.sector = pointSlot;
    point.reflow();
  };
  RadarBarChart2.prototype.createAnimation = function createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    BarChart2.prototype.createAnimation.call(this);
  };
  return RadarBarChart2;
}(bar_chart_default);
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = function(PolarPlotAreaBase2) {
  function RadarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2) RadarPlotArea2.__proto__ = PolarPlotAreaBase2;
  RadarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  RadarPlotArea2.prototype.constructor = RadarPlotArea2;
  RadarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createTrendlineSeries();
    this.createCategoryAxesLabels();
  };
  RadarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: {
          type: ARC
        },
        minorGridLines: {
          type: ARC
        }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: {
          format: "P0"
        }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  };
  RadarPlotArea2.prototype.aggregateCategories = function aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  };
  RadarPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  };
  RadarPlotArea2.prototype.filterSeries = function filterSeries(currentSeries) {
    return currentSeries;
  };
  RadarPlotArea2.prototype.trendlineFactory = function trendlineFactory2(options, series) {
    var trendline = categorical_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = RADAR_LINE;
    }
    return trendline;
  };
  RadarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createAreaChart(filterSeriesByType(series, [RADAR_AREA]), pane);
    this.createLineChart(filterSeriesByType(series, [RADAR_LINE]), pane);
    this.createBarChart(filterSeriesByType(series, [RADAR_COLUMN]), pane);
  };
  RadarPlotArea2.prototype.chartOptions = function chartOptions(series) {
    var options = {
      series
    };
    var firstSeries = series[0];
    if (firstSeries) {
      var filteredSeries = this.filterVisibleSeries(series);
      var stack = firstSeries.stack;
      options.isStacked = stack && filteredSeries.length > 1;
      options.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;
      if (options.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options;
  };
  RadarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  };
  RadarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  };
  RadarPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var options = this.chartOptions(series);
    var filteredSeries = this.filterVisibleSeries(series);
    var anyStackedSeries = filteredSeries.some(function(s) {
      return s.stack;
    });
    var isStacked100 = filteredSeries.some(function(s) {
      return s.stack && s.stack.type === "100%";
    });
    options.gap = firstSeries.gap;
    options.spacing = firstSeries.spacing;
    options.defaultStack = firstSeries.stack && filteredSeries.length > 1;
    options.isStacked = anyStackedSeries && filteredSeries.length > 1;
    options.isStacked100 = isStacked100 && filteredSeries.length > 1;
    var barChart = new radar_bar_chart_default(this, options);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  };
  RadarPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis() {
    return this.categoryAxis;
  };
  RadarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point = new point_default(coords.x, coords.y);
    var category = this.categoryAxis.getCategory(point);
    var value2 = this.valueAxis.getValue(point);
    if (category !== null && value2 !== null) {
      chart.trigger(eventType, {
        element: eventElement(e),
        category,
        value: value2
      });
    }
  };
  RadarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  RadarPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return PolarPlotAreaBase2.prototype._pointsByVertical.call(this, basePoint).sort(this._getSeriesCompareFn());
  };
  RadarPlotArea2.prototype._getSeriesCompareFn = function _getSeriesCompareFn() {
    return function(a, b) {
      return b.value - a.value;
    };
  };
  return RadarPlotArea2;
}(polar_plotarea_base_default);
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints,
  seriesValues: categorical_plotarea_default.prototype.seriesValues
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = function(ChartElement2) {
  function FunnelSegment2(value2, options, segmentOptions) {
    ChartElement2.call(this, options);
    this.value = value2;
    this.options.index = segmentOptions.index;
  }
  if (ChartElement2) FunnelSegment2.__proto__ = ChartElement2;
  FunnelSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelSegment2.prototype.constructor = FunnelSegment2;
  FunnelSegment2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  };
  FunnelSegment2.prototype.reflow = function reflow(chartBox) {
    var points = this.points;
    var label = this.children[0];
    var x1 = Math.min(points[0].x, points[3].x);
    var x2 = Math.max(points[1].x, points[2].x);
    this.box = new box_default(x1, points[0].y, x2, points[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points[0].y, chartBox.x2, points[2].y));
    }
  };
  FunnelSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options = this.options;
    var visual;
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
    if (options.visual) {
      visual = options.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options,
        sender: this.getSender(),
        createVisual: function() {
          return this$1.createPath();
        }
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  };
  FunnelSegment2.prototype.createPath = function createPath() {
    var options = this.options;
    var border = options.border;
    var path = drawing_exports.Path.fromPoints(this.points, {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  };
  FunnelSegment2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  };
  FunnelSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  FunnelSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  };
  FunnelSegment2.prototype.createFocusHighlight = function createFocusHighlight(style) {
    var borderWidth = this.options.accessibility.highlight.border.width;
    var result = drawing_exports.Path.fromPoints(this.points, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    })).close();
    var clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(this.box.clone().pad(borderWidth).toRect()));
    clipPath.paths.push(drawing_exports.Path.fromPoints(this.points));
    result.clip(clipPath);
    return result;
  };
  FunnelSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    return {
      point: new point_default(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  };
  FunnelSegment2.prototype.formatValue = function formatValue(format) {
    var point = this;
    return point.owner.formatPointValue(point, format);
  };
  FunnelSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  FunnelSegment2.prototype.getIndex = function getIndex() {
    return this.index;
  };
  return FunnelSegment2;
}(chart_element_default);
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  },
  labels: {
    format: ""
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
deepExtend(FunnelSegment.prototype, accessibility_attributes_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = function(ChartElement2) {
  function FunnelChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2) FunnelChart2.__proto__ = ChartElement2;
  FunnelChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelChart2.prototype.constructor = FunnelChart2;
  FunnelChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    return this.plotArea.chartService.format.auto(format, point.value);
  };
  FunnelChart2.prototype.render = function render() {
    var this$1 = this;
    var seriesIx = 0;
    var ref2 = this;
    var options = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0) seriesColors = [];
    var series = options.series[seriesIx];
    var data = series.data;
    if (!data) {
      return;
    }
    var ref$1 = bindSegments(series);
    var total3 = ref$1.total;
    var points = ref$1.points;
    for (var i = 0; i < points.length; i++) {
      var pointData = points[i];
      if (!pointData) {
        continue;
      }
      var fields = pointData.fields;
      if (!isFunction(series.color)) {
        series.color = fields.color || seriesColors[i % seriesColors.length];
      }
      fields = deepExtend({
        index: i,
        owner: this$1,
        series,
        seriesIx,
        dataItem: data[i],
        percentage: pointData.value / total3
      }, fields, {
        visible: pointData.visible
      });
      var value2 = pointData.valueFields.value;
      var segment = this$1.createSegment(value2, fields);
      var label = this$1.createLabel(value2, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  };
  FunnelChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options, value2, fields) {
    var series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, {
      defaults: series._defaults,
      excluded: ["data", "content", "template", "toggle", "visual", "ariaTemplate", "ariaContent"]
    });
  };
  FunnelChart2.prototype.createSegment = function createSegment(value2, fields) {
    var seriesOptions = deepExtend({}, fields.series);
    this.evalSegmentOptions(seriesOptions, value2, fields);
    this.createLegendItem(value2, seriesOptions, fields);
    if (fields.visible !== false) {
      var segment = new funnel_segment_default(value2, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  };
  FunnelChart2.prototype.createLabel = function createLabel(value2, fields) {
    var series = fields.series;
    var dataItem = fields.dataItem;
    var labels = deepExtend({}, this.options.labels, series.labels);
    var text = value2;
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var data = {
        dataItem,
        value: value2,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value2, fields);
      var textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  };
  FunnelChart2.prototype.labelPadding = function labelPadding() {
    var labels = this.labels;
    var padding = {
      left: 0,
      right: 0
    };
    for (var i = 0; i < labels.length; i++) {
      var label = labels[i];
      var align = label.options.align;
      if (align !== CENTER) {
        var width = labels[i].box.width();
        if (align === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  };
  FunnelChart2.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var firstSegment = segments[0];
    var maxSegment = firstSegment;
    for (var idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    var previousOffset = (width - lastUpperSide) / 2;
    var previousHeight = 0;
    for (var idx$1 = 0; idx$1 < count; idx$1++) {
      var percentage = segments[idx$1].percentage;
      var nextSegment = segments[idx$1 + 1];
      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      var points = segments[idx$1].points = [];
      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      var offset = void 0;
      if (!percentage) {
        offset = nextPercentage ? 0 : width / 2;
      } else {
        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset = limitValue(offset, 0, width);
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + offset, box.y1 + height + previousHeight));
      previousOffset = offset;
      previousHeight += height + options.segmentSpacing;
      lastUpperSide = limitValue(width - 2 * offset, 0, width);
    }
  };
  FunnelChart2.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var decreasingWidth = options.neckRatio <= 1;
    var neckRatio = decreasingWidth ? options.neckRatio * width : width;
    var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;
    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    var finalNarrow = (topMostWidth - neckRatio) / 2;
    var previousHeight = 0;
    for (var idx = 0; idx < count; idx++) {
      var points = segments[idx].points = [];
      var percentage = segments[idx].percentage;
      var offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      var height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
      previousOffset += offset;
      previousHeight += height + options.segmentSpacing;
    }
  };
  FunnelChart2.prototype.reflow = function reflow(chartBox) {
    var points = this.points;
    var count = points.length;
    if (!count) {
      return;
    }
    var options = this.options;
    var box = chartBox.clone().unpad(this.labelPadding());
    var totalHeight = box.height() - options.segmentSpacing * (count - 1);
    var width = box.width();
    if (options.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (var idx = 0; idx < count; idx++) {
      points[idx].reflow(chartBox);
    }
  };
  return FunnelChart2;
}(chart_element_default);
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/pyramid-chart.js
var MAX_NECK_RATIO = 1e6;
var PyramidChart = function(FunnelChart2) {
  function PyramidChart2(plotArea, options) {
    options.dynamicSlope = false;
    options.neckRatio = MAX_NECK_RATIO;
    FunnelChart2.call(this, plotArea, options);
  }
  if (FunnelChart2) PyramidChart2.__proto__ = FunnelChart2;
  PyramidChart2.prototype = Object.create(FunnelChart2 && FunnelChart2.prototype);
  PyramidChart2.prototype.constructor = PyramidChart2;
  return PyramidChart2;
}(funnel_chart_default);
var pyramid_chart_default = PyramidChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = function(PlotAreaBase2) {
  function FunnelPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) FunnelPlotArea2.__proto__ = PlotAreaBase2;
  FunnelPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  FunnelPlotArea2.prototype.constructor = FunnelPlotArea2;
  FunnelPlotArea2.prototype.render = function render() {
    this.createChart(funnel_chart_default, filterSeriesByType(this.series, [FUNNEL]));
    this.createChart(pyramid_chart_default, filterSeriesByType(this.series, [PYRAMID]));
  };
  FunnelPlotArea2.prototype.createChart = function createChart(chartType, series) {
    var firstSeries = series[0];
    if (!firstSeries) {
      return;
    }
    var chart = new chartType(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(chart);
  };
  FunnelPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append(this.options.legend.data, chart.legendItems);
  };
  FunnelPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint) {
    return this.pointsBySeriesIndex(basePoint.series.index);
  };
  FunnelPlotArea2.prototype.getPointToTheRight = function getPointToTheRight(point) {
    return this.getPointBelow(point);
  };
  FunnelPlotArea2.prototype.getPointToTheLeft = function getPointToTheLeft(point) {
    return this.getPointAbove(point);
  };
  return FunnelPlotArea2;
}(plotarea_base_default);
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = function(color, minLightnessOffset) {
  if (minLightnessOffset === void 0) minLightnessOffset = 0.05;
  var baseColor = parseColor(color);
  var offset = 1 - minLightnessOffset;
  return function(value2) {
    var hsl = baseColor.toHSL();
    var range = 100 - hsl.l;
    var point = offset - value2;
    hsl.l += Math.min(point * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = function(ChartElement2) {
  function HeatmapPoint2(value2, options) {
    ChartElement2.call(this);
    this.options = options;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  if (ChartElement2) HeatmapPoint2.__proto__ = ChartElement2;
  HeatmapPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapPoint2.prototype.constructor = HeatmapPoint2;
  HeatmapPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  };
  HeatmapPoint2.prototype.createLabel = function createLabel() {
    var options = this.options;
    var labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  };
  HeatmapPoint2.prototype.createLabelElement = function createLabelElement(options) {
    var labelColor = options.color;
    if (!labelColor) {
      labelColor = auto_text_color_default(this.color);
    }
    return new text_box_default(this.getLabelText(options), deepExtend({
      align: CENTER,
      vAlign: CENTER,
      margin: {
        left: 5,
        right: 5
      },
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    }, options, {
      color: labelColor
    }), this.pointData());
  };
  HeatmapPoint2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  };
  HeatmapPoint2.prototype.formatValue = function formatValue(format) {
    return this.owner.formatPointValue(this, format);
  };
  HeatmapPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  };
  HeatmapPoint2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.addAccessibilityAttributesToVisual();
  };
  HeatmapPoint2.prototype.markerBox = function markerBox() {
    var options = this.options;
    var markers = options.markers;
    var border = markers.border;
    var rect = this.box.toRect();
    var type = valueOrDefault(markers.type, "rect");
    var isRoundRect = type === ROUNDED_RECT;
    var borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);
    var halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      var center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  };
  HeatmapPoint2.prototype.markerBorder = function markerBorder() {
    var options = this.options;
    var markers = options.markers;
    var border = markers.border;
    var opacity = valueOrDefault(border.opacity, options.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  };
  HeatmapPoint2.prototype.createMarker = function createMarker() {
    var options = this.options;
    var markerOptions = options.markers;
    var marker = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  };
  HeatmapPoint2.prototype.createHighlight = function createHighlight(style) {
    var options = this.options;
    var markerOptions = this.options.highlight.markers || this.options.markers;
    var highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    var visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  };
  HeatmapPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  HeatmapPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  HeatmapPoint2.prototype.createFocusHighlight = function createFocusHighlight() {
    var markerOptions = this.options.markers;
    var highlightOptions2 = this.options.accessibility.highlight;
    var highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      borderRadius: markerOptions.borderRadius,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this.markerBox());
    return highlight.getElement();
  };
  HeatmapPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var left = this.box.center().x;
    var top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  };
  HeatmapPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  HeatmapPoint2.prototype.unclipElements = function unclipElements() {
  };
  HeatmapPoint2.prototype.pointData = function pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  };
  return HeatmapPoint2;
}(chart_element_default);
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
deepExtend(HeatmapPoint.prototype, accessibility_attributes_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: {
    top: 1
  },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = function(ChartElement2) {
  function HeatmapChart2(plotArea, options) {
    ChartElement2.call(this, options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2) HeatmapChart2.__proto__ = ChartElement2;
  HeatmapChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapChart2.prototype.constructor = HeatmapChart2;
  HeatmapChart2.prototype._initFields = function _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = {
      min: MAX_VALUE,
      max: MIN_VALUE
    };
    this._evalSeries = [];
  };
  HeatmapChart2.prototype.render = function render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  };
  HeatmapChart2.prototype.setRange = function setRange() {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var valueFields = ref$1.valueFields;
        if (defined(valueFields.value) && valueFields.value !== null) {
          this$1.valueRange.min = Math.min(this$1.valueRange.min, valueFields.value);
          this$1.valueRange.max = Math.max(this$1.valueRange.max, valueFields.value);
        }
      }
    }
  };
  HeatmapChart2.prototype.addValue = function addValue(value2, fields) {
    var point;
    if (value2 && defined(value2.value) && value2.value !== null) {
      point = this.createPoint(value2, fields);
      if (point) {
        Object.assign(point, fields);
      }
    }
    this.points.push(point);
  };
  HeatmapChart2.prototype.evalPointOptions = function evalPointOptions(options, value2, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: ["data", "tooltip", "content", "template", "visual", "toggle", "drilldownSeriesFactory", "ariaTemplate", "ariaContent"]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    var pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  };
  HeatmapChart2.prototype.pointType = function pointType() {
    return heatmap_point_default;
  };
  HeatmapChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options = this.seriesOptions[seriesIx];
    if (!options) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options;
  };
  HeatmapChart2.prototype.createPoint = function createPoint(value2, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      var scale = color_scale_default(color);
      color = scale(value2.value / this.valueRange.max);
    }
    var point = new heatmap_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  };
  HeatmapChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      xAxis,
      yAxis
    };
  };
  HeatmapChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value2, fields) {
      var point = chartPoints[pointIx++];
      var ref2 = this$1.seriesAxes(fields.series);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var indexX = xAxis.categoryIndex(value2.x);
      var indexY = yAxis.categoryIndex(value2.y);
      var slotX = xAxis.getSlot(indexX, indexX, limit);
      var slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  HeatmapChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  HeatmapChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var ref$1 = this$1.seriesAxes(currentSeries);
      var xAxis = ref$1.xAxis;
      var yAxis = ref$1.yAxis;
      var xRange = xAxis.currentRangeIndices();
      var yRange = yAxis.currentRangeIndices();
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$2 = this$1.plotArea.bindPoint(currentSeries, pointIx);
        var value2 = ref$2.valueFields;
        var fields = ref$2.fields;
        var xIndex = xAxis.totalIndex(value2.x);
        var yIndex = yAxis.totalIndex(value2.y);
        var xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        var yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value2, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this$1
          }, fields));
        }
      }
    }
  };
  HeatmapChart2.prototype.formatPointValue = function formatPointValue(point, format) {
    var value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.value);
  };
  HeatmapChart2.prototype.animationPoints = function animationPoints() {
    var points = this.points;
    var result = [];
    for (var idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  };
  return HeatmapChart2;
}(chart_element_default);
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = function(PlotAreaBase2) {
  function HeatmapPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2) HeatmapPlotArea2.__proto__ = PlotAreaBase2;
  HeatmapPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  HeatmapPlotArea2.prototype.constructor = HeatmapPlotArea2;
  HeatmapPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  };
  HeatmapPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0) panes = this.panes;
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  };
  HeatmapPlotArea2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var data = currentSeries.data || [];
      var ref2 = this$1.seriesAxes(currentSeries);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var xCategories = createHashSet(xAxis.categories || []);
      var yCategories = createHashSet(yAxis.categories || []);
      for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {
        var ref$1 = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        var x = ref$1.x;
        var y = ref$1.y;
        if (!xCategories.has(x)) {
          xCategories.add(x);
        }
        if (!yCategories.has(y)) {
          yCategories.add(y);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  };
  HeatmapPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createHeatmapChart(filterSeriesByType(filteredSeries, [HEATMAP]), pane);
    }
  };
  HeatmapPlotArea2.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {
    var chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  };
  HeatmapPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  HeatmapPlotArea2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxis;
    var yAxis;
    var options = this.options;
    var xAxisOptions = [].concat(options.xAxis);
    var xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find(function(axis) {
        return axis.name === xAxisName;
      });
    } else {
      xAxis = xAxisOptions[0];
    }
    var yAxisOptions = [].concat(options.yAxis);
    var yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find(function(axis) {
        return axis.name === yAxisName;
      });
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      xAxis,
      yAxis
    };
  };
  HeatmapPlotArea2.prototype.createAxisLabels = function createAxisLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      axes[i].createLabels();
    }
  };
  HeatmapPlotArea2.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {
    var axisName = options.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,
      justified: false
    });
    var firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    var typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    var axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.indexCategories();
    return axis;
  };
  HeatmapPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options = this.options;
    var xAxesOptions = [].concat(options.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  HeatmapPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  HeatmapPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point = new point_default(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values5, axis.getCategory(point));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  HeatmapPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options);
    updateAxisOptions3(this.originalOptions, index, vertical, options);
  };
  HeatmapPlotArea2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, {
      zIndex: 0
    });
  };
  HeatmapPlotArea2.prototype._pointsByVertical = function _pointsByVertical(basePoint, offset) {
    var this$1 = this;
    if (offset === void 0) offset = 0;
    var normalizedOffset = this.axisX.options.reverse ? offset * -1 : offset;
    var axisXItems = this.axisX.children;
    var xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;
    xIndex = cycleIndex(xIndex, axisXItems.length);
    var targetXValue = axisXItems[xIndex].value;
    var points = this.filterPoints(function(point) {
      return compareValues(point.pointData().x, targetXValue);
    }).sort(function(a, b) {
      return this$1._getPointAxisYIndex(a) - this$1._getPointAxisYIndex(b);
    });
    if (this.axisY.options.reverse) {
      return points.reverse();
    }
    return points;
  };
  HeatmapPlotArea2.prototype._pointsByHorizontal = function _pointsByHorizontal(basePoint, offset) {
    var this$1 = this;
    if (offset === void 0) offset = 0;
    var normalizedOffset = this.axisY.options.reverse ? offset * -1 : offset;
    var axisYItems = this.axisY.children;
    var yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;
    yIndex = cycleIndex(yIndex, axisYItems.length);
    var targetYValue = axisYItems[yIndex].value;
    var points = this.filterPoints(function(point) {
      return compareValues(point.pointData().y, targetYValue);
    }).sort(function(a, b) {
      return this$1._getPointAxisXIndex(a) - this$1._getPointAxisXIndex(b);
    });
    if (this.axisX.options.reverse) {
      return points.reverse();
    }
    return points;
  };
  HeatmapPlotArea2.prototype._getPointAxisXIndex = function _getPointAxisXIndex(point) {
    return this._getPointAxisIndex(this.axisX, point.pointData().x);
  };
  HeatmapPlotArea2.prototype._getPointAxisYIndex = function _getPointAxisYIndex(point) {
    return this._getPointAxisIndex(this.axisY, point.pointData().y);
  };
  HeatmapPlotArea2.prototype._getPointAxisIndex = function _getPointAxisIndex(axis, pointValue) {
    return axis.children.findIndex(function(axisItem) {
      return compareValues(pointValue, axisItem.value);
    });
  };
  return HeatmapPlotArea2;
}(plotarea_base_default);
function compareValues(a, b) {
  if (a instanceof Date && b instanceof Date) {
    return dateEquals(a, b);
  }
  return a === b;
}
function updateAxisOptions3(targetOptions, axisIndex, vertical, options) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA].concat(TRENDLINE_SERIES));
plotarea_factory_default.current.register(xy_plotarea_default, [SCATTER, SCATTER_LINE, BUBBLE].concat(TRENDLINE_SERIES));
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL, PYRAMID]);
plotarea_factory_default.current.register(polar_plotarea_default, [POLAR_AREA, POLAR_LINE, POLAR_SCATTER].concat(TRENDLINE_SERIES));
plotarea_factory_default.current.register(radar_plotarea_default, [RADAR_AREA, RADAR_COLUMN, RADAR_LINE].concat(TRENDLINE_SERIES));
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register([BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA], [VALUE], [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD]);
series_binder_default.current.register([RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA], [FROM, TO], [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]);
series_binder_default.current.register([WATERFALL, HORIZONTAL_WATERFALL], [VALUE], [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD]);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR, DRILLDOWN_FIELD]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [CATEGORY, COLOR, DRILLDOWN_FIELD]);
series_binder_default.current.register([FUNNEL, PYRAMID], [VALUE], [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD]);
default_aggregates_default.current.register([BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL], {
  value: MAX,
  color: FIRST,
  noteText: FIRST,
  errorLow: MIN,
  errorHigh: MAX
});
default_aggregates_default.current.register([RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA], {
  from: MIN,
  to: MAX,
  color: FIRST,
  noteText: FIRST
});
default_aggregates_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], {
  value: MAX,
  color: FIRST
});
series_binder_default.current.register([SCATTER, SCATTER_LINE, BUBBLE], [X, Y], [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]);
series_binder_default.current.register([BUBBLE], [X, Y, "size"], [COLOR, CATEGORY, NOTE_TEXT]);
series_binder_default.current.register([HEATMAP], [X, Y, VALUE], [COLOR, NOTE_TEXT]);
series_binder_default.current.register([CANDLESTICK, OHLC], ["open", "high", "low", "close"], [CATEGORY, COLOR, "downColor", NOTE_TEXT]);
default_aggregates_default.current.register([CANDLESTICK, OHLC], {
  open: MAX,
  high: MAX,
  low: MIN,
  close: MAX,
  color: FIRST,
  downColor: FIRST,
  noteText: FIRST
});
series_binder_default.current.register([BOX_PLOT, VERTICAL_BOX_PLOT], ["lower", "q1", "median", "q3", "upper", "mean", "outliers"], [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]);
default_aggregates_default.current.register([BOX_PLOT, VERTICAL_BOX_PLOT], {
  lower: MAX,
  q1: MAX,
  median: MAX,
  q3: MAX,
  upper: MAX,
  mean: MAX,
  outliers: FIRST,
  color: FIRST,
  noteText: FIRST
});
series_binder_default.current.register([BULLET, VERTICAL_BULLET], ["current", "target"], [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD]);
default_aggregates_default.current.register([BULLET, VERTICAL_BULLET], {
  current: MAX,
  target: MAX,
  color: FIRST,
  noteText: FIRST
});
series_binder_default.current.register([PIE, DONUT], [VALUE], [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD]);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEDOWN = "mousedown";
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var KEYDOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var MOUSEMOVE_DELAY = 20;
var Chart = function(Class) {
  function Chart2(element, userOptions, themeOptions, context) {
    var this$1 = this;
    if (context === void 0) context = {};
    Class.call(this);
    this.observers = [];
    this.addObserver(context.observer);
    this.chartService = new chart_service_default(this, context);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    var options = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options);
    this._theme = themeOptions;
    this._initTheme(options, themeOptions);
    this._focusState = {};
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, function() {
      this$1.fontLoaded = true;
      if (!this$1._destroyed) {
        this$1.trigger("init");
        this$1._redraw();
        this$1._attachEvents();
      }
    });
  }
  if (Class) Chart2.__proto__ = Class;
  Chart2.prototype = Object.create(Class && Class.prototype);
  Chart2.prototype.constructor = Chart2;
  Chart2.prototype._initElement = function _initElement(element) {
    this._setElementClass(element);
    element.style.position = "relative";
    element.tabIndex = element.getAttribute("tabindex") ? element.getAttribute("tabindex") : 0;
    element.setAttribute("role", "graphics-document document");
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    this.element = element;
  };
  Chart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart");
  };
  Chart2.prototype._initTheme = function _initTheme(options, themeOptions) {
    var seriesCopies = [];
    var series = options.series || [];
    for (var i = 0; i < series.length; i++) {
      seriesCopies.push(Object.assign({}, series[i]));
    }
    options.series = seriesCopies;
    resolveAxisAliases(options);
    this.applyDefaults(options, themeOptions);
    if (options.seriesColors === null) {
      delete options.seriesColors;
    }
    if (isString(options.title)) {
      options.title = {
        text: options.title
      };
    }
    this.options = deepExtend({}, themeOptions, options);
    this.applySeriesColors();
  };
  Chart2.prototype.getSize = function getSize() {
    var chartArea = this.options.chartArea || {};
    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  };
  Chart2.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this._size;
    var hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, function(s) {
      return !s.visible;
    })) {
      this._destroySelections();
      this._setupSelection();
    }
  };
  Chart2.prototype._resize = function _resize() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.redraw = function redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      var plotArea = this._model._plotArea;
      var pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  };
  Chart2.prototype.getAxis = function getAxis(name2) {
    return findAxisByName(name2, this._plotArea.axes);
  };
  Chart2.prototype.findAxisByName = function findAxisByName2(name2) {
    return this.getAxis(name2);
  };
  Chart2.prototype.findPaneByName = function findPaneByName(name2) {
    var panes = this._plotArea.panes;
    for (var idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name2) {
        return new chart_pane_default(panes[idx]);
      }
    }
  };
  Chart2.prototype.findPaneByIndex = function findPaneByIndex(idx) {
    var panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  };
  Chart2.prototype.plotArea = function plotArea() {
    return new chart_plotarea_default(this._plotArea);
  };
  Chart2.prototype.toggleHighlight = function toggleHighlight(show2, filter) {
    var plotArea = this._plotArea;
    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    var points;
    if (isFunction(filter)) {
      points = plotArea.filterPoints(filter);
    } else {
      var seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (inArray(firstSeries.type, [PIE, FUNNEL, PYRAMID])) {
        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points) {
      this.togglePointsHighlight(show2, points);
    }
  };
  Chart2.prototype.togglePointsHighlight = function togglePointsHighlight(show2, points) {
    var highlight = this._highlight;
    for (var idx = 0; idx < points.length; idx++) {
      highlight.togglePointHighlight(points[idx], show2);
    }
  };
  Chart2.prototype.showTooltip = function showTooltip(filter) {
    var shared = this._sharedTooltip();
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var plotArea = ref2._plotArea;
    var point, categoryIndex;
    if (isFunction(filter)) {
      point = plotArea.findPoint(filter);
      if (point && shared) {
        categoryIndex = point.categoryIx;
      }
    } else if (shared && defined(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        var points = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points);
      }
    } else if (point) {
      tooltip.show(point);
    }
  };
  Chart2.prototype.hideTooltip = function hideTooltip() {
    this._tooltip.hide();
  };
  Chart2.prototype._initSurface = function _initSurface() {
    var surface = this.surface;
    var wrap = this._surfaceWrap();
    var chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize(wrap, {
        width: chartArea.width
      });
    }
    if (chartArea.height) {
      elementSize(wrap, {
        height: chartArea.height
      });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = drawing_exports.Surface.create(wrap, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Chart2.prototype._surfaceWrap = function _surfaceWrap() {
    return this.element;
  };
  Chart2.prototype._redraw = function _redraw() {
    var model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._setElementAccessibilityAttributes();
    this._model = model;
    this._plotArea = model._plotArea;
    this._legend = model._legend;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
    this._redrawFocusHighlight();
  };
  Chart2.prototype._redrawFocusHighlight = function _redrawFocusHighlight() {
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var preserveHighlight = ref_focusState.preserveHighlight;
    if (legendInFocus && preserveHighlight) {
      this._focusElement(this._getFocusedLegendItem(), false);
      this._focusState.preserveHighlight = false;
    }
  };
  Chart2.prototype._setElementAccessibilityAttributes = function _setElementAccessibilityAttributes() {
    var titleOptions = this.options.title;
    var title2 = isString(titleOptions) ? titleOptions : titleOptions.description || titleOptions.text;
    if (title2) {
      this.element.setAttribute("aria-roledescription", title2);
    }
  };
  Chart2.prototype.exportVisual = function exportVisual(exportOptions) {
    var visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      var currentOptions = this.options;
      var options = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options);
      this.options = deepExtend({}, this._originalOptions, options);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      var model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  };
  Chart2.prototype._sharedTooltip = function _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  };
  Chart2.prototype._createPannable = function _createPannable() {
    var options = this.options;
    if (options.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options.pannable);
    }
  };
  Chart2.prototype._createZoomSelection = function _createZoomSelection() {
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  };
  Chart2.prototype._createMousewheelZoom = function _createMousewheelZoom() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  };
  Chart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    var pannable = this.options.pannable;
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    var mousewheel = (zoomable || {}).mousewheel;
    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    var element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  };
  Chart2.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {
    var domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  };
  Chart2.prototype._createTooltip = function _createTooltip() {
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  };
  Chart2.prototype._createSharedTooltip = function _createSharedTooltip(options) {
    return new shared_tooltip_default(this._plotArea, options);
  };
  Chart2.prototype.applyDefaults = function applyDefaults2(options, themeOptions) {
    applyAxisDefaults(options, themeOptions);
    applySeriesDefaults(options, themeOptions);
  };
  Chart2.prototype.applySeriesColors = function applySeriesColors() {
    var options = this.options;
    var series = options.series;
    var colors = options.seriesColors || [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var seriesColor = colors[i % colors.length];
      var defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  };
  Chart2.prototype._getModel = function _getModel() {
    var options = this.options;
    var plotArea = this._createPlotArea();
    var model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    var title2 = title_default.buildTitle(options.title);
    var subtitle2 = title_default.buildTitle(options.subtitle, {
      align: options.title.align,
      position: options.title.position
    });
    model.append.apply(model, title_default.orderTitles([title2, subtitle2]));
    if (options.legend && options.legend.visible) {
      var legend2 = new legend_default(plotArea.options.legend, this.chartService);
      model.append(legend2);
      model._legend = legend2;
    }
    model.append(plotArea);
    model.reflow();
    return model;
  };
  Chart2.prototype._modelOptions = function _modelOptions() {
    var options = this.options;
    var size = this.getSize();
    return deepExtend({
      transitions: options.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options.chartArea);
  };
  Chart2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var options = this.options;
    var plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options.series, options, this.chartService);
    return plotArea;
  };
  Chart2.prototype._setupSelection = function _setupSelection() {
    var this$1 = this;
    var ref2 = this;
    var axes = ref2._plotArea.axes;
    var selections = this._selections = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var options = axis.options;
      if (axis instanceof category_axis_default && options.select && !options.vertical) {
        var range = axis.range();
        var selection = new selection_default(this$1, axis, deepExtend({
          min: range.min,
          max: range.max
        }, options.select));
        selections.push(selection);
      }
    }
  };
  Chart2.prototype._selectStart = function _selectStart(e) {
    return this.trigger(SELECT_START, e);
  };
  Chart2.prototype._select = function _select(e) {
    return this.trigger(SELECT2, e);
  };
  Chart2.prototype._selectEnd = function _selectEnd(e) {
    return this.trigger(SELECT_END, e);
  };
  Chart2.prototype._initHandlers = function _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._mousedownHandler = this._mousedown.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemove = throttle(this._mousemove.bind(this), MOUSEMOVE_DELAY);
  };
  Chart2.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Chart2.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Chart2.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Chart2.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    if (name2 === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name2 === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name2 === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name2 === SERIES_CLICK) {
      this._focusPoint(args.point);
      this._startDrilldown(args.point);
    } else if (name2 === LEGEND_ITEM_CLICK) {
      this._focusLegendItem(args);
    }
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Chart2.prototype._attachEvents = function _attachEvents() {
    var obj, obj$1;
    var element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[MOUSEDOWN] = this._mousedownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  };
  Chart2.prototype._mouseleave = function _mouseleave(e) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
    if (this._hasInactiveOpacity() && this._activeChartInstance) {
      this._applySeriesOpacity(this._activeChartInstance.children, null, true);
      this._updateSeriesOpacity(null, true);
    }
  };
  Chart2.prototype._cancelDomEvents = function _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  };
  Chart2.prototype._gesturestart = function _gesturestart(e) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {
      this._gestureDistance = e.distance;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this.surface.suspendTracking();
    }
  };
  Chart2.prototype._gestureend = function _gestureend(e) {
    if (this._zooming && !this._stopChartHandlers(e)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  };
  Chart2.prototype._gesturechange = function _gesturechange(e) {
    var mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e)) {
      e.preventDefault();
      var previousGestureDistance = this._gestureDistance;
      var scaleDelta = -e.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e.distance;
        var args = {
          delta: scaleDelta,
          axisRanges: axisRanges(this._plotArea.axes),
          originalEvent: e
        };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          var coords = this._eventCoordinates(e);
          if (!this._zooming) {
            this._zooming = true;
          }
          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  };
  Chart2.prototype._mouseout = function _mouseout(e) {
    if (e.element) {
      var element = this._drawingChartElement(e.element, e);
      if (element && element.leave) {
        element.leave(this, e.originalEvent);
      }
    }
  };
  Chart2.prototype._start = function _start(e) {
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e)) {
        this.trigger(ZOOM_START, {
          axisRanges: axisRanges(this._plotArea.axes),
          originalEvent: e
        });
      }
    }
  };
  Chart2.prototype._move = function _move(e) {
    var ref2 = this;
    var state = ref2._navState;
    var pannable = ref2._pannable;
    if (this._stopChartHandlers(e)) {
      return;
    }
    if (pannable) {
      var ranges = pannable.move(e);
      if (ranges && !this.trigger(DRAG, {
        axisRanges: ranges,
        originalEvent: e
      })) {
        pannable.pan();
      }
    } else if (state) {
      var ranges$1 = {};
      var axes = state.axes;
      for (var i = 0; i < axes.length; i++) {
        var currentAxis = axes[i];
        var axisName = currentAxis.options.name;
        if (axisName) {
          var axis = currentAxis.options.vertical ? e.y : e.x;
          var delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges$1;
      this.trigger(DRAG, {
        axisRanges: ranges$1,
        originalEvent: e
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e);
    }
  };
  Chart2.prototype._end = function _end(e) {
    if (this._stopChartHandlers(e)) {
      return;
    }
    var pannable = this._pannable;
    if (pannable && pannable.end(e)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e, DRAG_END);
    }
    if (this._zoomSelection) {
      var ranges = this._zoomSelection.end(e);
      if (ranges && !this.trigger(ZOOM, {
        axisRanges: ranges,
        originalEvent: e
      })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, {
          axisRanges: ranges,
          originalEvent: e
        });
      }
    }
  };
  Chart2.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (var idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  };
  Chart2.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  };
  Chart2.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    var mousewheelZoom = this._mousewheelZoom;
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      var args = {
        delta,
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e
      };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this._clearFocusedElement();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(function() {
          this$1.trigger(ZOOM_END, args);
          this$1._zooming = false;
          if (this$1.surface) {
            this$1.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      var state = this._navState;
      if (!state) {
        var prevented = this._startNavigation(e, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        var totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        var axes = this._navState.axes;
        var ranges = {};
        for (var i = 0; i < axes.length; i++) {
          var currentAxis = axes[i];
          var axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(function() {
          this$1._endNavigation(e, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  };
  Chart2.prototype._startNavigation = function _startNavigation(e, coords, chartEvent) {
    var plotArea = this._model._plotArea;
    var pane = plotArea.findPointPane(coords);
    var axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    var ranges = axisRanges(axes);
    var prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  };
  Chart2.prototype._endNavigation = function _endNavigation(e, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e
      });
      this._suppressHover = false;
      this._navState = null;
    }
  };
  Chart2.prototype._getChartElement = function _getChartElement(e, match) {
    var element = this.surface.eventTarget(e);
    if (element) {
      return this._drawingChartElement(element, e, match);
    }
  };
  Chart2.prototype._drawingChartElement = function _drawingChartElement(element, e, match) {
    var current4 = element;
    var chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  };
  Chart2.prototype._eventCoordinates = function _eventCoordinates(e) {
    var coordinates = eventCoordinates(e);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  };
  Chart2.prototype._elementPadding = function _elementPadding() {
    if (!this._padding) {
      var ref2 = elementStyles(this.element, ["paddingLeft", "paddingTop"]);
      var paddingLeft = ref2.paddingLeft;
      var paddingTop = ref2.paddingTop;
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  };
  Chart2.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {
    var padding = this._elementPadding();
    var offset = elementOffset(this.element);
    return {
      left: round(point.x + padding.left + offset.left),
      top: round(point.y + padding.top + offset.top)
    };
  };
  Chart2.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {
    var element = this.element;
    var offset = elementOffset(element);
    var padding = this._elementPadding();
    var inverseTransform = elementScale(element).invert();
    var point = new geometry_exports.Point(clientX - offset.left - padding.left, clientY - offset.top - padding.top).transform(inverseTransform);
    return new point_default(point.x, point.y);
  };
  Chart2.prototype._tap = function _tap(e) {
    var this$1 = this;
    var drawingElement = this.surface.eventTarget(e);
    var element = this._drawingChartElement(drawingElement, e);
    var sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e), e, true);
    }
    this._propagateClick(element, e);
    this.handlingTap = true;
    setTimeout(function() {
      this$1.handlingTap = false;
    }, 0);
  };
  Chart2.prototype._click = function _click(e) {
    var element = this._getChartElement(e);
    this._propagateClick(element, e);
  };
  Chart2.prototype._propagateClick = function _propagateClick(element, e) {
    var this$1 = this;
    var current4 = element;
    while (current4) {
      if (current4.click) {
        current4.click(this$1, e);
      }
      current4 = current4.parent;
    }
  };
  Chart2.prototype._isLegendBeforeChart = function _isLegendBeforeChart() {
    var ref2 = this;
    var legendPosition = ref2.options.legend.position;
    var legend2 = ref2._legend;
    return legend2 && legend2.hasItems() && (legendPosition === TOP || legendPosition === LEFT);
  };
  Chart2.prototype._focus = function _focus() {
    if (!this._preventInitialPointFocus) {
      if (this._isLegendBeforeChart()) {
        this._focusFirstLegendItem();
      } else {
        this._focusFirstPoint();
      }
    }
    this._preventInitialPointFocus = false;
  };
  Chart2.prototype._keydown = function _keydown(e) {
    var ref2 = this;
    var ref_focusState = ref2._focusState;
    var legendInFocus = ref_focusState.legendInFocus;
    var focusedElement = ref_focusState.focusedElement;
    var legend2 = ref2._legend;
    if (e.key === TAB) {
      this._clearFocusedElement();
      var isLegendBeforeChart = this._isLegendBeforeChart();
      if (legendInFocus && isLegendBeforeChart !== e.shiftKey) {
        this._navigatePoints(e);
      } else if (!legendInFocus && isLegendBeforeChart === e.shiftKey && legend2.hasItems()) {
        this._navigateLegend(e);
      }
    } else if (e.key === ESCAPE) {
      if (focusedElement) {
        e.stopPropagation();
      }
      if (this._tooltip && this._tooltip.visible) {
        this._hideTooltip();
      } else {
        this._blur();
      }
    } else if (e.key === ENTER) {
      if (focusedElement) {
        this._focusState.preserveHighlight = true;
        this._propagateClick(focusedElement, e);
        this._focusElement(focusedElement);
      }
    } else if (!legendInFocus) {
      this._navigatePoints(e);
    } else {
      this._navigateLegend(e);
    }
  };
  Chart2.prototype._navigatePoints = function _navigatePoints(e) {
    var this$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var plotArea = ref2._plotArea;
    focusState.legendInFocus = false;
    if (!focusState.focusedElement) {
      this._focusFirstPoint();
      e.preventDefault();
      return;
    }
    var moveFocus = function(point) {
      focusState.focusedPoint = point;
      this$1._focusElement(focusState.focusedPoint);
      this$1._displayTooltip(point);
      e.preventDefault();
    };
    switch (e.key) {
      case ARROW_RIGHT:
        moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));
        break;
      case ARROW_LEFT:
        moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));
        break;
      case ARROW_DOWN:
        moveFocus(plotArea.getPointBelow(focusState.focusedPoint));
        break;
      case ARROW_UP:
        moveFocus(plotArea.getPointAbove(focusState.focusedPoint));
        break;
      default:
        break;
    }
  };
  Chart2.prototype._navigateLegend = function _navigateLegend(e) {
    var this$1 = this;
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    var rtl = ref2.chartService.rtl;
    focusState.legendInFocus = true;
    if (!focusState.focusedElement) {
      this._focusFirstLegendItem();
      e.preventDefault();
      return;
    }
    var itemsLength = legend2.getItems().length;
    var moveFocus = function(cycleFunc) {
      focusState.focusedLegendItemIndex = cycleFunc(focusState.focusedLegendItemIndex, itemsLength);
      this$1._focusElement(this$1._getFocusedLegendItem());
      e.preventDefault();
    };
    switch (e.key) {
      case ARROW_UP:
      case ARROW_LEFT:
        moveFocus(rtl ? cycleUp : cycleDown);
        break;
      case ARROW_DOWN:
      case ARROW_RIGHT:
        moveFocus(rtl ? cycleDown : cycleUp);
        break;
      default:
        break;
    }
  };
  Chart2.prototype._focusFirstPoint = function _focusFirstPoint() {
    var point = this._focusState.focusedPoint = this._plotArea.getFirstPoint();
    if (point) {
      this._focusElement(point);
      this._displayTooltip(point);
    }
  };
  Chart2.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Chart2.prototype._mousedown = function _mousedown() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
    }
  };
  Chart2.prototype._focusChart = function _focusChart() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
      this.element.focus();
    }
  };
  Chart2.prototype._focusPoint = function _focusPoint(point) {
    this._focusState.focusedPoint = point;
    this._focusChart();
    this._focusElement(point, true);
  };
  Chart2.prototype._focusFirstLegendItem = function _focusFirstLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = 0;
    this._focusElement(this._getFocusedLegendItem());
    focusState.legendInFocus = true;
    this._hideTooltip();
  };
  Chart2.prototype._focusLegendItem = function _focusLegendItem(args) {
    var ref2 = this;
    var focusState = ref2._focusState;
    focusState.focusedLegendItemIndex = this._legend.getItems().findIndex(function(x) {
      return x.options.series.index === args.seriesIndex && x.options.pointIndex === args.pointIndex;
    });
    focusState.legendInFocus = true;
    this._focusChart();
    this._focusElement(this._getFocusedLegendItem(), true);
  };
  Chart2.prototype._getFocusedLegendItem = function _getFocusedLegendItem() {
    var ref2 = this;
    var focusState = ref2._focusState;
    var legend2 = ref2._legend;
    return legend2.getItems()[focusState.focusedLegendItemIndex];
  };
  Chart2.prototype._focusElement = function _focusElement(element, omitHighlight) {
    var ref2 = this;
    var focusState = ref2._focusState;
    this._clearFocusedElement();
    if (!element) {
      return;
    }
    focusState.focusedElement = element;
    this._setElementActiveDescendant(element);
    if (!omitHighlight) {
      element.focusVisual();
      if (focusState.legendInFocus) {
        var options = element.options;
        this._showSeriesInactiveOpacity(options.series.index, options.pointIndex);
      } else {
        this._showInactiveOpacity(element);
      }
    }
  };
  Chart2.prototype._clearFocusedElement = function _clearFocusedElement() {
    var ref2 = this;
    var focusState = ref2._focusState;
    if (!focusState) {
      return;
    }
    if (focusState.focusedElement) {
      focusState.focusedElement.clearFocusFromVisual();
      this._clearElementActiveDescendant();
    }
    focusState.focusedElement = null;
  };
  Chart2.prototype._setElementActiveDescendant = function _setElementActiveDescendant(element) {
    if (this.options.renderAs === "canvas") {
      this._pseudoFocusedElement = this._createPseudoFocusedElement(element);
      this.element.append(this._pseudoFocusedElement);
    }
    this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, element._id);
  };
  Chart2.prototype._clearElementActiveDescendant = function _clearElementActiveDescendant() {
    if (this._pseudoFocusedElement) {
      this._pseudoFocusedElement.remove();
      this._pseudoFocusedElement = null;
    }
    this.element.removeAttribute(ARIA_ACTIVE_DESCENDANT);
  };
  Chart2.prototype._createPseudoFocusedElement = function _createPseudoFocusedElement(element) {
    var pseudoElement = document.createElement("div");
    var accessibilityOptions = element.options.accessibility;
    pseudoElement.id = element._id;
    pseudoElement.setAttribute("aria-label", element.getAriaLabelText());
    pseudoElement.setAttribute("role", accessibilityOptions.role);
    pseudoElement.setAttribute("aria-roledescription", accessibilityOptions.ariaRoleDescription);
    var checked = accessibilityOptions.ariaChecked;
    if (defined(checked)) {
      pseudoElement.setAttribute("aria-checked", checked);
    }
    return pseudoElement;
  };
  Chart2.prototype._blur = function _blur() {
    this._focusState.legendInFocus = false;
    this._clearFocusedElement();
    this._hideInactiveOpacity();
  };
  Chart2.prototype._startHover = function _startHover(element, e) {
    if (this._suppressHover) {
      return false;
    }
    var point = this._drawingChartElement(element, e, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof plotarea_base_default);
    });
    var activePoint = this._activePoint;
    this._updateHoveredPoint(point, e);
    if (point && activePoint !== point && point.hover) {
      this._activePoint = point;
      if (!this._sharedTooltip() && !point.hover(this, e)) {
        this._displayTooltip(point);
        this._showInactiveOpacity(point);
      }
    }
    return point;
  };
  Chart2.prototype._displayTooltip = function _displayTooltip(point) {
    var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);
    if (tooltipOptions.visible) {
      this._tooltip.show(point);
    }
  };
  Chart2.prototype._hideTooltip = function _hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Chart2.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      var inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  };
  Chart2.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {
    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter(function(point) {
      return point !== activePoint;
    });
  };
  Chart2.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {
    var this$1 = this;
    var points = [];
    for (var i = 0; i < container.children.length; i++) {
      var element = container.children[i];
      if (element.constructor === type) {
        points.push(element);
      } else if (element.children && element.children.length) {
        points = points.concat(this$1._getAllPointsOfType(element, type));
      }
    }
    return points;
  };
  Chart2.prototype._updateHoveredPoint = function _updateHoveredPoint(point, e) {
    var hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point) {
      hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (point && hoveredPoint !== point && point.over) {
      this._hoveredPoint = point;
      point.over(this, e);
    }
  };
  Chart2.prototype._updateDrilldownPoint = function _updateDrilldownPoint(point) {
    if (!point || !point.series) {
      return;
    }
    var ref2 = series_binder_default.current.bindPoint(point.series, null, point.dataItem);
    var fields = ref2.fields;
    if (fields.drilldown) {
      this._drilldownState = {
        cursor: this.element.style.cursor
      };
      this.element.style.cursor = "pointer";
    }
  };
  Chart2.prototype._resetDrilldownPoint = function _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  };
  Chart2.prototype._startDrilldown = function _startDrilldown(point) {
    if (!point || !point.series) {
      return;
    }
    var series = point.series;
    var ref2 = series_binder_default.current.bindPoint(series, null, point.dataItem);
    var fields = ref2.fields;
    var value2 = fields.drilldown;
    if (value2) {
      var args = {
        series,
        point,
        value: value2,
        sender: this
      };
      this.trigger(DRILLDOWN, args);
    }
  };
  Chart2.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point, resetOpacity) {
    var this$1 = this;
    var plotArea = this._plotArea;
    var length = plotArea.series.length;
    for (var i = 0; i < length; i++) {
      var currSeries = plotArea.series[i];
      var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);
      var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  };
  Chart2.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var currSeries = element.series || series;
      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        var opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  };
  Chart2.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point) {
    var chartInstance = point.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  };
  Chart2.prototype._showInactiveOpacity = function _showInactiveOpacity(point) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      this._displayInactiveOpacity(point, multipleSeries);
    } else {
      this._highlight.show(point);
    }
  };
  Chart2.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  };
  Chart2.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {
    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    var hasInactiveOpacity = this.options.series.filter(function(s) {
      return s.highlight.inactiveOpacity !== void 0;
    }).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  };
  Chart2.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {
    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    var seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._mouseover = function _mouseover(e) {
    var obj;
    var point = this._startHover(e.element, e.originalEvent);
    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
    }
  };
  Chart2.prototype._mouseMoveTracking = function _mouseMoveTracking(e) {
    var obj;
    var ref2 = this;
    var options = ref2.options;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    var point = ref2._activePoint;
    var coords = this._eventCoordinates(e);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {
        var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);
        if (seriesPoint && seriesPoint !== point) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e)) {
            var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point);
    }
  };
  Chart2.prototype._mousemove = function _mousemove(e) {
    var coords = this._eventCoordinates(e);
    var plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      var overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e);
    }
  };
  Chart2.prototype._trackCrosshairs = function _trackCrosshairs(coords) {
    var crosshairs = this._plotArea.crosshairs;
    for (var i = 0; i < crosshairs.length; i++) {
      var current4 = crosshairs[i];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  };
  Chart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e, toggle2) {
    if (this._suppressHover) {
      return;
    }
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var plotArea = ref2._plotArea;
    var categoryAxis = ref2._plotArea.categoryAxis;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    if (plotArea.backgroundContainsPoint(coords)) {
      var index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle2) {
        var points = plotArea.pointsByCategoryIndex(index);
        var pointArgs = points.map(function(point) {
          return point.eventArgs(e);
        });
        var hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points, coords);
          }
          highlight.show(points);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle2 && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  };
  Chart2.prototype.hideElements = function hideElements(options) {
    var plotArea = this._plotArea;
    this._mousemove.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options);
  };
  Chart2.prototype._unsetActivePoint = function _unsetActivePoint(options) {
    var ref2 = this;
    var highlight = ref2._highlight;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (!options || !options.keepTooltipOpen) {
      this._hideTooltip();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  };
  Chart2.prototype._deferRedraw = function _deferRedraw() {
    this._redraw();
  };
  Chart2.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  };
  Chart2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var options = this.options;
    var definitions = [].concat(options.categoryAxis);
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this$1.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  };
  Chart2.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {
    var this$1 = this;
    var uniqueCategories = /* @__PURE__ */ new Set();
    var seriesOnAxis = this.options.series.filter(function(series) {
      return series.categoryAxis === axis.name || !series.categoryAxis && axisIx === 0;
    });
    var hasCategoryBinding = seriesOnAxis.some(function(series) {
      return Boolean(series.categoryField);
    });
    var seriesWithData = seriesOnAxis.filter(function(series) {
      return series.data && series.data.length > 0;
    });
    var categorySamples = seriesWithData.map(function(series) {
      return series_binder_default.current.bindPoint(series, 0).fields.category;
    });
    var dateAxis = categorySamples.reduce(function(result, firstCategory) {
      return result || isDateAxis(axis, firstCategory);
    }, false);
    var seriesWithBinding = seriesWithData.filter(function(series, seriesIx) {
      return series.categoryField || defined(categorySamples[seriesIx]);
    });
    seriesWithBinding.forEach(function(series) {
      return series.data.forEach(function(row, index) {
        var category = series_binder_default.current.bindPoint(series, index).fields.category;
        if (dateAxis) {
          var date = parseDateCategory(category, row, this$1.chartService.intl);
          category = date ? date.getTime() : void 0;
        }
        uniqueCategories.add(category);
      });
    });
    if (uniqueCategories.size > 0) {
      var categories = Array.from(uniqueCategories.values());
      if (dateAxis) {
        categories = categories.sort().map(function(time) {
          return time && new Date(time);
        });
      }
      axis.categories = categories;
    } else if (hasCategoryBinding) {
      axis.categories = [];
    }
  };
  Chart2.prototype._isBindable = function _isBindable(series) {
    var valueFields = series_binder_default.current.valueFields(series);
    var result = true;
    for (var i = 0; i < valueFields.length; i++) {
      var field = valueFields[i];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  };
  Chart2.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {
    var options = this.options;
    var transitionsState;
    if (options.transitions !== false) {
      options.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options.transitions = true;
    }
  };
  Chart2.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {
    this._showSeriesInactiveOpacity(seriesIndex, pointIndex);
  };
  Chart2.prototype._showSeriesInactiveOpacity = function _showSeriesInactiveOpacity(seriesIndex, pointIndex) {
    var ref2 = this;
    var plotArea = ref2._plotArea;
    var highlight = ref2._highlight;
    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    var items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL, PYRAMID])) {
      items = plotArea.findPoint(function(point2) {
        return point2.series.index === seriesIndex && point2.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      var multipleSeries = plotArea.series.length > 1;
      var point = items.length ? items[0] : items;
      this._displayInactiveOpacity(point, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  };
  Chart2.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  };
  Chart2.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {
    var obj, obj$1;
    unbindEvents(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
  };
  Chart2.prototype.applyOptions = function applyOptions(options, theme) {
    clearMissingValues(this._originalOptions, options);
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  };
  Chart2.prototype.setOptions = function setOptions(options, theme) {
    this.applyOptions(options, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
  };
  Chart2.prototype.setDirection = function setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  };
  Chart2.prototype.setIntlService = function setIntlService(intl) {
    this.chartService.intl = intl;
  };
  Chart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.destroy = function destroy() {
    var obj, obj$1;
    this._destroyed = true;
    unbindEvents(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj[KEYDOWN] = this._keydownHandler, obj[FOCUS] = this._focusHandler, obj[BLUR] = this._blurHandler, obj));
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));
    }
    this._focusState = null;
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  };
  Chart2.prototype._destroySurface = function _destroySurface() {
    var surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  };
  Chart2.prototype._destroySelections = function _destroySelections() {
    var selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  };
  Chart2.prototype._destroyView = function _destroyView() {
    var model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._clearFocusedElement();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  };
  return Chart2;
}(class_default);
function resolveAxisAliases(options) {
  var aliases = AXIS_NAMES;
  for (var idx = 0; idx < aliases.length; idx++) {
    var alias = aliases[idx] + "Axes";
    if (options[alias]) {
      options[aliases[idx] + "Axis"] = options[alias];
      delete options[alias];
    }
  }
}
function pointByCategoryName(points, name2) {
  if (points) {
    for (var idx = 0; idx < points.length; idx++) {
      if (points[idx].category === name2) {
        return [points[idx]];
      }
    }
  }
}
function applyAxisDefaults(options, themeOptions) {
  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  var axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    var axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    var result = deepExtend({}, themeAxisDefaults, themeAxisDefaults[axisName], axisDefaults2, axisDefaults2[axisName], {
      line: {
        color: axisColor
      },
      labels: {
        color: axisColor
      },
      title: {
        color: axisColor
      }
    }, axisOptions2);
    delete result[axisName];
    return result;
  }
  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options.axisDefaults || {};
    axes = [].concat(options[axisName]);
    axes = axes.map(mapAxisOptions);
    options[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options, themeOptions) {
  var series = options.series;
  var seriesLength = series.length;
  var seriesDefaults2 = options.seriesDefaults;
  var commonDefaults = deepExtend({}, options.seriesDefaults);
  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (var i = 0; i < seriesLength; i++) {
    var seriesType = series[i].type || options.seriesDefaults.type;
    var baseOptions = deepExtend({
      data: []
    }, commonThemeDefaults, themeSeriesDefaults[seriesType], {
      tooltip: options.tooltip
    }, commonDefaults, seriesDefaults2[seriesType]);
    series[i]._defaults = baseOptions;
    series[i] = deepExtend({}, baseOptions, series[i]);
    series[i].data = series[i].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  var ranges = {};
  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    var axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options) {
  for (var field in options) {
    if (!inArray(field, DATA_FIELDS) && hasOwnProperty(options, field)) {
      var fieldValue = options[field];
      var originalValue = originalOptions[field];
      if (defined(originalValue)) {
        var nullValue = fieldValue === null;
        if (nullValue || !defined(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (var idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {},
    accessibility: {
      highlight: {
        border: {
          opacity: 1,
          color: BLACK,
          width: 2
        }
      }
    }
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    },
    accessibility: {
      highlight: {
        border: {
          opacity: 1,
          width: 2
        },
        zIndex: 200
      }
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {},
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = function(ChartSharedTooltip) {
  function SharedTooltip3() {
    ChartSharedTooltip.apply(this, arguments);
  }
  if (ChartSharedTooltip) SharedTooltip3.__proto__ = ChartSharedTooltip;
  SharedTooltip3.prototype = Object.create(ChartSharedTooltip && ChartSharedTooltip.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(coords, slot) {
    var axis = this.plotArea.categoryAxis;
    var vertical = axis.options.vertical;
    var align = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    var point;
    if (vertical) {
      point = new point_default(this.plotArea.box.x2, slot.center().y);
    } else {
      point = new point_default(slot.center().x, TOP_OFFSET);
    }
    return {
      point,
      align
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point, slot) {
    return this._slotAnchor({}, slot);
  };
  return SharedTooltip3;
}(shared_tooltip_default);
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  var state = [];
  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (var idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value2) {
  return isNumber(value2) ? [value2] : value2;
}
var Sparkline = function(Chart2) {
  function Sparkline2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2) Sparkline2.__proto__ = Chart2;
  Sparkline2.prototype = Object.create(Chart2 && Chart2.prototype);
  Sparkline2.prototype.constructor = Sparkline2;
  Sparkline2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-sparkline");
  };
  Sparkline2.prototype._initElement = function _initElement(element) {
    Chart2.prototype._initElement.call(this, element);
    this._initialWidth = Math.floor(elementSize(element).width);
  };
  Sparkline2.prototype._resize = function _resize() {
    var element = this.element;
    var state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize(element).width);
    show(element.childNodes, state);
    Chart2.prototype._resize.call(this);
  };
  Sparkline2.prototype._modelOptions = function _modelOptions() {
    var chartOptions = this.options;
    var stage = this._surfaceWrap();
    var displayState = hide(stage.childNodes);
    var space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    var options = deepExtend({
      width: this._autoWidth,
      height: elementSize(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize(stage, {
      width: options.width,
      height: options.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options;
  };
  Sparkline2.prototype._surfaceWrap = function _surfaceWrap() {
    if (!this.stage) {
      var stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  };
  Sparkline2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var plotArea = Chart2.prototype._createPlotArea.call(this, skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  };
  Sparkline2.prototype._calculateWidth = function _calculateWidth(plotArea) {
    var options = this.options;
    var margin = getSpacing(options.chartArea.margin);
    var charts = plotArea.charts;
    var stage = this._surfaceWrap();
    var total3 = 0;
    for (var i = 0; i < charts.length; i++) {
      var currentChart = charts[i];
      var firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize(stage).height;
      }
      var categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        var pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total3 = Math.max(total3, pointsCount);
      }
    }
    var size = total3 * options.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  };
  Sparkline2.prototype._createSharedTooltip = function _createSharedTooltip(options) {
    return new shared_tooltip_default2(this._plotArea, options);
  };
  Sparkline2.normalizeOptions = function normalizeOptions(userOptions) {
    var options = wrapNumber(userOptions);
    if (isArray(options)) {
      options = {
        seriesDefaults: {
          data: options
        }
      };
    } else {
      options = deepExtend({}, options);
    }
    if (!options.series) {
      options.series = [{
        data: wrapNumber(options.data)
      }];
    }
    deepExtend(options, {
      seriesDefaults: {
        type: options.type
      }
    });
    if (inArray(options.series[0].type, NO_CROSSHAIR) || inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {
      options = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options);
    }
    return options;
  };
  return Sparkline2;
}(chart_default);
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{
    clip: false
  }]
});
var sparkline_default = Sparkline;

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = function(superclass) {
  function FadeOutAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) FadeOutAnimation2.__proto__ = superclass;
  FadeOutAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeOutAnimation2.prototype.constructor = FadeOutAnimation2;
  FadeOutAnimation2.prototype.setup = function setup() {
    this._initialOpacity = parseFloat(elementStyles(this.element, "opacity").opacity);
  };
  FadeOutAnimation2.prototype.step = function step(pos) {
    elementStyles(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  };
  FadeOutAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  };
  FadeOutAnimation2.prototype.cancel = function cancel() {
    superclass.prototype.abort.call(this);
    elementStyles(this.element, {
      opacity: String(this._initialOpacity)
    });
  };
  return FadeOutAnimation2;
}(drawing_exports.Animation);
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  var div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = function(Class) {
  function NavigatorHint2(container, chartService, options) {
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.container = container;
    this.chartService = chartService;
    var padding = elementStyles(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  if (Class) NavigatorHint2.__proto__ = Class;
  NavigatorHint2.prototype = Object.create(Class && Class.prototype);
  NavigatorHint2.prototype.constructor = NavigatorHint2;
  NavigatorHint2.prototype.createElements = function createElements() {
    var element = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    var tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    var scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  };
  NavigatorHint2.prototype.show = function show2(from, to, bbox) {
    var ref2 = this;
    var element = ref2.element;
    var options = ref2.options;
    var scroll = ref2.scroll;
    var tooltip = ref2.tooltip;
    var middle = toDate(toTime(from) + toTime(to - from) / 2);
    var scrollWidth = bbox.width() * 0.4;
    var minPos = bbox.center().x - scrollWidth;
    var maxPos = bbox.center().x;
    var posRange = maxPos - minPos;
    var range = options.max - options.min;
    var scale = posRange / range;
    var offset = middle - options.min;
    var text = this.chartService.intl.format(options.format, from, to);
    var template2 = getTemplate(options);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template2) {
      text = template2({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    var tooltipStyle = elementStyles(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles(scroll, {
      width: scrollWidth,
      left: minPos + offset * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles(element, {
      visibility: "visible"
    });
  };
  NavigatorHint2.prototype.clearHideTimeout = function clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  };
  NavigatorHint2.prototype.hide = function hide2() {
    var this$1 = this;
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(function() {
      this$1._visible = false;
      this$1._hideAnimation = new fade_out_animation_default(this$1.element);
      this$1._hideAnimation.setup();
      this$1._hideAnimation.play();
    }, this.options.hideDelay);
  };
  NavigatorHint2.prototype.destroy = function destroy() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  };
  return NavigatorHint2;
}(class_default);
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = function(Class) {
  function Navigator3(chart) {
    var obj;
    Class.call(this);
    this.chart = chart;
    var options = this.options = deepExtend({}, this.options, chart.options.navigator);
    var select = options.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined(options.hint.visible)) {
      options.hint.visible = options.visible;
    }
    this.chartObserver = new instance_observer_default(this, (obj = {}, obj[DRAG] = "_drag", obj[DRAG_END] = "_dragEnd", obj[ZOOM] = "_zoom", obj[ZOOM_END] = "_zoomEnd", obj));
    chart.addObserver(this.chartObserver);
  }
  if (Class) Navigator3.__proto__ = Class;
  Navigator3.prototype = Object.create(Class && Class.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.parseDate = function parseDate$1(value2) {
    return parseDate(this.chart.chartService.intl, value2);
  };
  Navigator3.prototype.clean = function clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  };
  Navigator3.prototype.destroy = function destroy() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  };
  Navigator3.prototype.redraw = function redraw() {
    this._redrawSelf();
    this.initSelection();
  };
  Navigator3.prototype.initSelection = function initSelection() {
    var ref2 = this;
    var chart = ref2.chart;
    var options = ref2.options;
    var axis = this.mainAxis();
    var ref$1 = axis.roundedRange();
    var min4 = ref$1.min;
    var max3 = ref$1.max;
    var ref$2 = options.select;
    var from = ref$2.from;
    var to = ref$2.to;
    var mousewheel = ref$2.mousewheel;
    var axisClone = clone2(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min4,
      max: max3,
      from: from || min4,
      to: to || max3,
      mousewheel: valueOrDefault(mousewheel, {
        zoom: "left"
      }),
      visible: options.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min4,
        max: max3,
        template: getTemplate(options.hint),
        format: options.hint.format
      });
    }
  };
  Navigator3.prototype.setRange = function setRange() {
    var plotArea = this.chart._createPlotArea(true);
    var axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    var ref2 = axis.roundedRange();
    var min4 = ref2.min;
    var max3 = ref2.max;
    var select = this.options.select || {};
    var from = select.from || min4;
    if (from < min4) {
      from = min4;
    }
    var to = select.to || max3;
    if (to > max3) {
      to = max3;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  };
  Navigator3.prototype._redrawSelf = function _redrawSelf(silent) {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last(plotArea.panes), silent);
    }
  };
  Navigator3.prototype.redrawSlaves = function redrawSlaves() {
    var chart = this.chart;
    var plotArea = chart._plotArea;
    var slavePanes = plotArea.panes.filter(function(pane) {
      return pane.options.name !== NAVIGATOR_PANE;
    });
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  };
  Navigator3.prototype._drag = function _drag(e) {
    var ref2 = this;
    var chart = ref2.chart;
    var selection = ref2.selection;
    var coords = chart._eventCoordinates(e.originalEvent);
    var navigatorAxis = this.mainAxis();
    var naviRange = navigatorAxis.roundedRange();
    var inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    var axis = chart._plotArea.categoryAxis;
    var range = e.axisRanges[axis.options.name];
    var select = this.options.select;
    var duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    var from = toDate(limitValue(toTime(range.min), naviRange.min, toTime(naviRange.max) - duration2));
    var to = toDate(limitValue(toTime(from) + duration2, toTime(naviRange.min) + duration2, naviRange.max));
    this.options.select = {
      from,
      to
    };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  };
  Navigator3.prototype._dragEnd = function _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  };
  Navigator3.prototype.readSelection = function readSelection() {
    var ref2 = this;
    var ref_selection_options = ref2.selection.options;
    var from = ref_selection_options.from;
    var to = ref_selection_options.to;
    var select = ref2.options.select;
    select.from = from;
    select.to = to;
  };
  Navigator3.prototype.filterAxes = function filterAxes() {
    var ref2 = this;
    var select = ref2.options.select;
    if (select === void 0) select = {};
    var chart = ref2.chart;
    var allAxes = chart.options.categoryAxis;
    var from = select.from;
    var to = select.to;
    for (var idx = 0; idx < allAxes.length; idx++) {
      var axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  };
  Navigator3.prototype.filter = function filter() {
    var ref2 = this;
    var chart = ref2.chart;
    var select = ref2.options.select;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    var mainAxis = this.mainAxis();
    var args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      var axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  };
  Navigator3.prototype._zoom = function _zoom(e) {
    var ref2 = this;
    var axis = ref2.chart._plotArea.categoryAxis;
    var selection = ref2.selection;
    var ref_options = ref2.options;
    var select = ref_options.select;
    var liveDrag = ref_options.liveDrag;
    var mainAxis = this.mainAxis();
    var delta = e.delta;
    if (!selection) {
      return;
    }
    var fromIx = mainAxis.categoryIndex(selection.options.from);
    var toIx = mainAxis.categoryIndex(selection.options.to);
    var coords = this.chart._eventCoordinates(e.originalEvent);
    e.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  };
  Navigator3.prototype._zoomEnd = function _zoomEnd(e) {
    this._dragEnd(e);
  };
  Navigator3.prototype.showHint = function showHint(from, to) {
    var plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  };
  Navigator3.prototype._selectStart = function _selectStart(e) {
    return this.chart._selectStart(e);
  };
  Navigator3.prototype._select = function _select(e) {
    this.showHint(e.from, e.to);
    return this.chart._select(e);
  };
  Navigator3.prototype._selectEnd = function _selectEnd(e) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e);
  };
  Navigator3.prototype.mainAxis = function mainAxis() {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  };
  Navigator3.prototype.select = function select(from, to) {
    var select2 = this.options.select;
    if (from && to) {
      select2.from = this.parseDate(from);
      select2.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select2.from,
      to: select2.to
    };
  };
  Navigator3.setup = function setup(options, themeOptions) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (options.__navi) {
      return;
    }
    options.__navi = true;
    var naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);
    var panes = options.panes = [].concat(options.panes);
    var paneOptions = deepExtend({}, naviOptions.pane, {
      name: NAVIGATOR_PANE
    });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach(function(pane) {
      pane.name = pane.name || DEFAULT_PANE;
    });
    Navigator3.attachAxes(options, naviOptions);
    Navigator3.attachSeries(options, naviOptions, themeOptions);
  };
  Navigator3.attachAxes = function attachAxes(options, naviOptions) {
    var series = naviOptions.series || [];
    var categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);
    var valueAxes = options.valueAxis = [].concat(options.valueAxis);
    var allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach(function(axis) {
      axis.pane = axis.pane || DEFAULT_PANE;
    });
    var equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    var justifyAxis = equallySpacedSeries.length === 0;
    var base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: {
        visible: true
      },
      tooltip: {
        visible: false
      },
      labels: {
        step: 1
      },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    var user = naviOptions.categoryAxis;
    categoryAxes.push(deepExtend({}, base, {
      maxDateGroups: 200
    }, user, {
      name: NAVIGATOR_AXIS,
      title: null,
      baseUnit: "fit",
      baseUnitStep: "auto",
      labels: {
        visible: false
      },
      majorTicks: {
        visible: false
      }
    }), deepExtend({}, base, user, {
      name: NAVIGATOR_AXIS + "_labels",
      maxDateGroups: 20,
      baseUnitStep: "auto",
      labels: {
        position: ""
      },
      plotBands: [],
      autoBaseUnitSteps: {
        minutes: []
      },
      _overlap: true
    }), deepExtend({}, base, user, {
      name: NAVIGATOR_AXIS + "_ticks",
      maxDateGroups: 200,
      majorTicks: {
        width: 0.5
      },
      plotBands: [],
      title: null,
      labels: {
        visible: false,
        mirror: true
      },
      _overlap: true
    }));
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  };
  Navigator3.attachSeries = function attachSeries(options, naviOptions, themeOptions) {
    var series = options.series = options.series || [];
    var navigatorSeries = [].concat(naviOptions.series || []);
    var seriesColors = themeOptions.seriesColors;
    var defaults = naviOptions.seriesDefaults;
    for (var idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(deepExtend({
        color: seriesColors[idx % seriesColors.length],
        categoryField: naviOptions.dateField,
        visibleInLegend: false,
        tooltip: {
          visible: false
        }
      }, defaults, navigatorSeries[idx], {
        axis: NAVIGATOR_AXIS,
        categoryAxis: NAVIGATOR_AXIS,
        autoBind: naviOptions.autoBindElements
      }));
    }
  };
  return Navigator3;
}(class_default);
function ClonedObject() {
}
function clone2(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = function(Chart2) {
  function StockChart2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2) StockChart2.__proto__ = Chart2;
  StockChart2.prototype = Object.create(Chart2 && Chart2.prototype);
  StockChart2.prototype.constructor = StockChart2;
  StockChart2.prototype.applyDefaults = function applyDefaults2(options, themeOptions) {
    var width = elementSize(this.element).width || DEFAULT_WIDTH;
    var theme = themeOptions;
    var stockDefaults = {
      seriesDefaults: {
        categoryField: options.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options, theme);
    Chart2.prototype.applyDefaults.call(this, options, theme);
  };
  StockChart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart k-stockchart");
  };
  StockChart2.prototype.setOptions = function setOptions(options) {
    this.destroyNavigator();
    Chart2.prototype.setOptions.call(this, options);
  };
  StockChart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  };
  StockChart2.prototype._resize = function _resize() {
    this.noTransitionsRedraw();
  };
  StockChart2.prototype._redraw = function _redraw() {
    var navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  };
  StockChart2.prototype._dirty = function _dirty() {
    var options = this.options;
    var series = [].concat(options.series, options.navigator.series);
    var seriesCount = grep(series, function(s) {
      return s && s.visible;
    }).length;
    var dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  };
  StockChart2.prototype._fullRedraw = function _fullRedraw() {
    var navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", {
        navigator: navigator2
      });
    }
    navigator2.clean();
    navigator2.setRange();
    Chart2.prototype._redraw.call(this);
    navigator2.initSelection();
  };
  StockChart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords) {
    var plotArea = this._plotArea;
    var pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      Chart2.prototype._trackSharedTooltip.call(this, coords);
    }
  };
  StockChart2.prototype.bindCategories = function bindCategories() {
    Chart2.prototype.bindCategories.call(this);
    this.copyNavigatorCategories();
  };
  StockChart2.prototype.copyNavigatorCategories = function copyNavigatorCategories() {
    var definitions = [].concat(this.options.categoryAxis);
    var categories;
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  };
  StockChart2.prototype.destroyNavigator = function destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  };
  StockChart2.prototype.destroy = function destroy() {
    this.destroyNavigator();
    Chart2.prototype.destroy.call(this);
  };
  StockChart2.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    return Chart2.prototype._stopChartHandlers.call(this, e) || pane && pane.options.name === NAVIGATOR_PANE;
  };
  StockChart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  };
  return StockChart2;
}(chart_default);
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});
var stock_chart_default = StockChart;

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad(bbox, value2) {
  var origin = bbox.getOrigin();
  var size = bbox.getSize();
  var spacing = getSpacing(value2);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var Group = drawing_exports.Group;
var Path = drawing_exports.Path;
var Text2 = drawing_exports.Text;
function buildLabelElement(label, options) {
  var labelBox = label.box;
  var textBox = label.children[0].box;
  var border = options.border || {};
  var background = options.background || "";
  var wrapper2 = Path.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  var text = new Text2(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options.font,
    fill: {
      color: options.color
    }
  });
  var styleGeometry = pad(text.bbox().clone(), options.padding);
  var styleBox = Path.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  var elements = new Group();
  elements.append(wrapper2);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min4, max3) {
  var from = defined(range.from) ? range.from : MIN_VALUE;
  var to = defined(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min4);
  range.to = Math.min(Math.max(to, from), max3);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value2) {
  var spacing = getSpacing(value2);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var Path2 = drawing_exports.Path;
var Surface = drawing_exports.Surface;
var Gauge = function(Class) {
  function Gauge2(element, userOptions, theme, context) {
    if (context === void 0) context = {};
    Class.call(this);
    this.element = element;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  if (Class) Gauge2.__proto__ = Class;
  Gauge2.prototype = Object.create(Class && Class.prototype);
  Gauge2.prototype.constructor = Gauge2;
  Gauge2.prototype.destroy = function destroy() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  };
  Gauge2.prototype.value = function value2(pointerValue) {
    var pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  };
  Gauge2.prototype._draw = function _draw() {
    var surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  };
  Gauge2.prototype.exportVisual = function exportVisual() {
    return this._visuals;
  };
  Gauge2.prototype.allValues = function allValues(values5) {
    var pointers = this.pointers;
    var allValues2 = [];
    if (arguments.length === 0) {
      for (var i = 0; i < pointers.length; i++) {
        allValues2.push(pointers[i].value());
      }
      return allValues2;
    }
    if (isArray(values5)) {
      for (var i$1 = 0; i$1 < values5.length; i$1++) {
        if (isNumber(values5[i$1])) {
          pointers[i$1].value(values5[i$1]);
        }
      }
    }
    this._setValueOptions(values5);
  };
  Gauge2.prototype._setValueOptions = function _setValueOptions(values5) {
    var pointers = [].concat(this.options.pointer);
    var arrayValues = [].concat(values5);
    for (var i = 0; i < arrayValues.length; i++) {
      pointers[i].value = arrayValues[i];
    }
  };
  Gauge2.prototype.resize = function resize() {
    this.noTransitionsRedraw();
  };
  Gauge2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  };
  Gauge2.prototype.redraw = function redraw() {
    var size = this._surfaceSize();
    var wrapper2 = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    var bbox = unpad(wrapper2.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  };
  Gauge2.prototype.setOptions = function setOptions(options, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  };
  Gauge2.prototype.setDirection = function setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  };
  Gauge2.prototype.setIntlService = function setIntlService(intl) {
    this.contextService.intl = intl;
  };
  Gauge2.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    var options = this.options;
    var pointer = options.pointer;
    if (isArray(pointer)) {
      var pointers = [];
      for (var i = 0; i < pointer.length; i++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));
      }
      options.pointer = pointers;
    }
  };
  Gauge2.prototype._createGaugeArea = function _createGaugeArea() {
    var options = this.options.gaugeArea;
    var size = this.surface.size();
    var border = options.border || {};
    var areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    var gaugeArea = Path2.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options.background
      }
    });
    return gaugeArea;
  };
  Gauge2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    var element = this._surfaceElement();
    var size = this._surfaceSize();
    elementSize(element, size);
    if (!surface || surface.options.type !== options.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface.create(element, {
        type: options.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Gauge2.prototype._surfaceSize = function _surfaceSize() {
    var options = this.options;
    var size = this._getSize();
    if (options.gaugeArea) {
      deepExtend(size, options.gaugeArea);
    }
    return size;
  };
  Gauge2.prototype._surfaceElement = function _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  };
  Gauge2.prototype.getSize = function getSize() {
    return this._getSize();
  };
  Gauge2.prototype._getSize = function _getSize() {
    var element = this.element;
    var defaultSize = this._defaultSize();
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return {
      width,
      height
    };
  };
  Gauge2.prototype._defaultSize = function _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  };
  Gauge2.prototype._toggleTransitions = function _toggleTransitions(value2) {
    var this$1 = this;
    this.options.transitions = value2;
    for (var i = 0; i < this.pointers.length; i++) {
      this$1.pointers[i].options.animation.transitions = value2;
    }
  };
  return Gauge2;
}(class_default);
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var Path3 = drawing_exports.Path;
var Group2 = drawing_exports.Group;
var Point2 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  var position = tickRenderOptions.position;
  var tickX = tickRenderOptions.tickX;
  var tickY = tickRenderOptions.tickY;
  var start, end;
  if (tickRenderOptions.vertical) {
    start = new Point2(tickX, position);
    end = new Point2(tickX + tickOptions.size, position);
  } else {
    start = new Point2(position, tickY);
    end = new Point2(position, tickY + tickOptions.size);
  }
  var tickPath = new Path3({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  var count = tickPositions.length;
  if (tickOptions.visible) {
    var mirror = tickRenderOptions.mirror;
    var lineBox = tickRenderOptions.lineBox;
    for (var i = tickOptions.skip; i < count; i += tickOptions.step) {
      if (i % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = function(NumericAxis2) {
  function LinearScale2(options, service) {
    var scaleOptions = options || {};
    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    NumericAxis2.call(this, 0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  if (NumericAxis2) LinearScale2.__proto__ = NumericAxis2;
  LinearScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  LinearScale2.prototype.constructor = LinearScale2;
  LinearScale2.prototype.initUserOptions = function initUserOptions(options) {
    var scaleOptions = deepExtend({}, this.options, options);
    scaleOptions = deepExtend({}, scaleOptions, {
      labels: {
        mirror: scaleOptions.mirror
      }
    });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  };
  LinearScale2.prototype.initFields = function initFields() {
  };
  LinearScale2.prototype.render = function render() {
    var elements = this.elements = new Group2();
    var labels = this.renderLabels();
    var scaleLine = this.renderLine();
    var scaleTicks = this.renderTicks();
    var ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  };
  LinearScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var options = this.options;
    var min4 = options.min;
    var max3 = options.max;
    var vertical = options.vertical;
    var mirror = options.labels.mirror;
    var ranges = options.ranges || [];
    var elements = new Group2();
    var count = ranges.length;
    var rangeSize = options.rangeSize || options.minorTicks.size / 2;
    for (var i = 0; i < count; i++) {
      var range = getRange(ranges[i], min4, max3);
      var slot = this$1.getSlot(range.from, range.to);
      var slotX = vertical ? this$1.lineBox() : slot;
      var slotY = vertical ? slot : this$1.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path3.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: {
          color: range.color,
          opacity: range.opacity
        },
        stroke: {}
      }));
    }
    return elements;
  };
  LinearScale2.prototype.renderLabels = function renderLabels() {
    var ref2 = this;
    var labels = ref2.labels;
    var options = ref2.options;
    var elements = new Group2();
    for (var i = 0; i < labels.length; i++) {
      elements.append(buildLabelElement(labels[i], options.labels));
    }
    return elements;
  };
  LinearScale2.prototype.renderLine = function renderLine() {
    var line = this.options.line;
    var lineBox = this.lineBox();
    var elements = new Group2();
    if (line.width > 0 && line.visible) {
      var linePath = new Path3({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  };
  LinearScale2.prototype.renderTicks = function renderTicks$1() {
    var ticks = new Group2();
    var options = this.options;
    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    var tickRenderOptions = {
      vertical: options.vertical,
      mirror: options.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options.minorUnit
    }, options.minorTicks));
    return ticks;
  };
  return LinearScale2;
}(numeric_axis_default);
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = function(Class) {
  function Pointer2(scale, userOptions) {
    Class.call(this);
    var ref2 = scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var options = this.options = deepExtend({}, this.options, userOptions);
    options.fill = options.color;
    this.scale = scale;
    if (defined(options.value)) {
      options.value = limitValue(options.value, min4, max3);
    } else {
      options.value = min4;
    }
  }
  if (Class) Pointer2.__proto__ = Class;
  Pointer2.prototype = Object.create(Class && Class.prototype);
  Pointer2.prototype.constructor = Pointer2;
  Pointer2.prototype.value = function value2(newValue) {
    var options = this.options;
    var value3 = options.value;
    if (arguments.length === 0) {
      return value3;
    }
    var ref2 = this.scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    options._oldValue = defined(options._oldValue) ? options.value : min4;
    options.value = limitValue(newValue, min4, max3);
    if (this.elements) {
      this.repaint();
    }
  };
  return Pointer2;
}(class_default);
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = function(Pointer2) {
  function LinearPointer2(scale, options) {
    Pointer2.call(this, scale, options);
    this.options = deepExtend({
      track: {
        visible: defined(options.track)
      }
    }, this.options);
  }
  if (Pointer2) LinearPointer2.__proto__ = Pointer2;
  LinearPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  LinearPointer2.prototype.constructor = LinearPointer2;
  LinearPointer2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options = ref2.options;
    var scale = ref2.scale;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var scaleLine = scale.lineBox();
    var trackSize = options.track.size || options.size;
    var pointerHalfSize = options.size / 2;
    var margin = getSpacing(options.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    var pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(scaleLine.x1 + space, scaleLine.y1, scaleLine.x1 + space, scaleLine.y2);
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize, scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize);
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(scaleLine.x1, scaleLine.y1 - space, scaleLine.x2, scaleLine.y1 - space);
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space, scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space);
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options.border.width);
  };
  LinearPointer2.prototype.getElementOptions = function getElementOptions() {
    var options = this.options;
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: defined(options.border) ? {
        color: options.border.width ? options.border.color || options.color : "",
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: options.opacity
      } : null
    };
  };
  LinearPointer2.prototype._margin = function _margin() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var margin = getSpacing(options.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  };
  return LinearPointer2;
}(pointer_default);
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = function(superclass) {
  function ArrowLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) ArrowLinearPointerAnimation2.__proto__ = superclass;
  ArrowLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ArrowLinearPointerAnimation2.prototype.constructor = ArrowLinearPointerAnimation2;
  ArrowLinearPointerAnimation2.prototype.setup = function setup() {
    var options = this.options;
    var margin = options.margin;
    var from = options.from;
    var to = options.to;
    var vertical = options.vertical;
    var axis = vertical ? "x1" : "y1";
    if (options.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    var fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    var toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options.duration !== 0) {
      options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1e3, 1);
    }
  };
  ArrowLinearPointerAnimation2.prototype.step = function step(pos) {
    var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  };
  return ArrowLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point3 = geometry_exports.Point;
var Path4 = drawing_exports.Path;
var ArrowLinearPointer = function(LinearPointer2) {
  function ArrowLinearPointer2(scale, options) {
    LinearPointer2.call(this, scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  if (LinearPointer2) ArrowLinearPointer2.__proto__ = LinearPointer2;
  ArrowLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  ArrowLinearPointer2.prototype.constructor = ArrowLinearPointer2;
  ArrowLinearPointer2.prototype.pointerShape = function pointerShape() {
    var ref2 = this;
    var scale = ref2.scale;
    var size = ref2.options.size;
    var halfSize = size / 2;
    var sign = scale.options.mirror ? -1 : 1;
    var shape;
    if (scale.options.vertical) {
      shape = [new Point3(0, 0 - halfSize), new Point3(0 - sign * size, 0), new Point3(0, 0 + halfSize)];
    } else {
      shape = [new Point3(0 - halfSize, 0), new Point3(0, 0 + sign * size), new Point3(0 + halfSize, 0)];
    }
    return shape;
  };
  ArrowLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options.margin),
      from: scale.getSlot(options._oldValue),
      to: scale.getSlot(options.value)
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  ArrowLinearPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var elementOptions = this.getElementOptions();
    var shape = this.pointerShape(options.value);
    options.animation.type = ARROW_POINTER;
    var elements = new Path4({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();
    var slot = scale.getSlot(options.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  };
  return ArrowLinearPointer2;
}(linear_pointer_default);
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = function(superclass) {
  function BarLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass) BarLinearPointerAnimation2.__proto__ = superclass;
  BarLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarLinearPointerAnimation2.prototype.constructor = BarLinearPointerAnimation2;
  BarLinearPointerAnimation2.prototype.setup = function setup() {
    var options = this.options;
    var axis = this.axis = options.vertical ? Y : X;
    var to = this.to = options.newPoints[0][axis];
    var from = this.from = options.oldPoints[0][axis];
    if (options.duration !== 0) {
      options.duration = Math.max(Math.abs(to - from) / options.speed * 1e3, 1);
    }
    this._set(from);
  };
  BarLinearPointerAnimation2.prototype.step = function step(pos) {
    var value2 = interpolateValue(this.from, this.to, pos);
    this._set(value2);
  };
  BarLinearPointerAnimation2.prototype._set = function _set(value2) {
    var setter = "set" + this.axis.toUpperCase();
    var points = this.options.newPoints;
    points[0][setter](value2);
    points[1][setter](value2);
  };
  return BarLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var Group3 = drawing_exports.Group;
var Path5 = drawing_exports.Path;
var BarLinearPointer = function(LinearPointer2) {
  function BarLinearPointer2(scale, options) {
    LinearPointer2.call(this, scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  if (LinearPointer2) BarLinearPointer2.__proto__ = LinearPointer2;
  BarLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  BarLinearPointer2.prototype.constructor = BarLinearPointer2;
  BarLinearPointer2.prototype.pointerShape = function pointerShape(value2) {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var dir = mirror === vertical ? -1 : 1;
    var size = options.size * dir;
    var minSlot = scale.getSlot(scale.options.min);
    var slot = scale.getSlot(value2);
    var axis = vertical ? Y : X;
    var sizeAxis = vertical ? X : Y;
    var margin = this._margin() * dir;
    var p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    var p2 = new geometry_exports.Point();
    p2[axis] = slot[axis + "1"];
    p2[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p2.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p2.translate(0, margin);
    }
    var p3 = p2.clone();
    var p4 = p1.clone();
    if (vertical) {
      p3.translate(size, 0);
      p4.translate(size, 0);
    } else {
      p3.translate(0, size);
      p4.translate(0, size);
    }
    return [p1, p2, p3, p4];
  };
  BarLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var shape = this.pointerShape(options.value);
    var pointerPath = this.pointerPath;
    var oldShape = this.pointerShape(options._oldValue);
    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();
    var animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape[1], shape[2]]
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  BarLinearPointer2.prototype.render = function render() {
    var group = new Group3();
    var elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    var pointer = this.pointerPath = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  };
  BarLinearPointer2.prototype.renderTrack = function renderTrack() {
    var trackOptions = this.options.track;
    var border = trackOptions.border || {};
    var trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path5.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  };
  return BarLinearPointer2;
}(linear_pointer_default);
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group4 = drawing_exports.Group;
var LinearGauge = function(Gauge2) {
  function LinearGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2) LinearGauge2.__proto__ = Gauge2;
  LinearGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  LinearGauge2.prototype.constructor = LinearGauge2;
  LinearGauge2.prototype.reflow = function reflow(bbox) {
    var pointers = this.pointers;
    var bboxX = bbox.origin.x;
    var bboxY = bbox.origin.y;
    var box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  };
  LinearGauge2.prototype._buildVisual = function _buildVisual() {
    var visuals = new Group4();
    var scaleElements = this.scale.render();
    var pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  };
  LinearGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options = this.options;
    var scale = this.scale = new linear_scale_default(options.scale, this.contextService);
    this.pointers = [];
    var pointers = options.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointers.length; i++) {
      var currentOptions = deepExtend({}, pointers[i], {
        animation: {
          transitions: options.transitions
        }
      });
      var pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this$1.pointers.push(new pointerType(scale, currentOptions));
    }
  };
  LinearGauge2.prototype._defaultSize = function _defaultSize() {
    var vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  };
  LinearGauge2.prototype._getBox = function _getBox(box) {
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var boxCenter = box.center();
    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (var i = 0; i < pointers.length; i++) {
      plotAreaBox.wrap(pointers[i].box.clone());
    }
    var size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(boxCenter.x - size, box.y1, boxCenter.x + size, box.y2);
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(box.x1, boxCenter.y - size, box.x2, boxCenter.y + size);
    }
    return plotAreaBox;
  };
  LinearGauge2.prototype._alignElements = function _alignElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box;
    var box = pointers[0].box.clone().wrap(scale.box);
    var plotAreaBox = this.bbox;
    for (var i = 0; i < pointers.length; i++) {
      box.wrap(pointers[i].box.clone());
    }
    var diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(scaleBox.x1 + diff, plotAreaBox.y1, scaleBox.x2 + diff, plotAreaBox.y2));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(scaleBox.x1, scaleBox.y1 + diff, scaleBox.x2, scaleBox.y2 + diff));
    }
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  LinearGauge2.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {
    var ref2 = this;
    var scale = ref2.scale;
    if (!scale.options.vertical) {
      var overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  };
  LinearGauge2.prototype._shrinkElements = function _shrinkElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box.clone();
    var pos = scale.options.vertical ? "y" : "x";
    var pointerBox = pointers[0].box;
    for (var i = 0; i < pointers.length; i++) {
      pointerBox.wrap(pointers[i].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  return LinearGauge2;
}(gauge_default);
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var Arc = drawing_exports.Arc;
var Path6 = drawing_exports.Path;
var Group5 = drawing_exports.Group;
function drawTicks(arc, tickAngles, unit2, tickOptions) {
  var ticks = new Group5();
  var center = arc.center;
  var radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (var i = 0; i < tickAngles.length; i++) {
      var tickStart = arc.pointAt(tickAngles[i]);
      var tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);
      ticks.append(new Path6({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return {
    from,
    to,
    color,
    opacity
  };
}
var RadialScale = function(NumericAxis2) {
  function RadialScale2(options, service) {
    NumericAxis2.call(this, 0, 1, options, service);
  }
  if (NumericAxis2) RadialScale2.__proto__ = NumericAxis2;
  RadialScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadialScale2.prototype.constructor = RadialScale2;
  RadialScale2.prototype.initUserOptions = function initUserOptions(options) {
    var scaleOptions = deepExtend({}, this.options, options);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  };
  RadialScale2.prototype.initFields = function initFields() {
  };
  RadialScale2.prototype.render = function render(center, radius) {
    var arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  };
  RadialScale2.prototype.reflow = function reflow(bbox) {
    var center = bbox.center();
    var radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  };
  RadialScale2.prototype.slotAngle = function slotAngle(value2) {
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var reverse = ref2.reverse;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var angle = endAngle - startAngle;
    var result;
    if (reverse) {
      result = endAngle - (value2 - min4) / (max3 - min4) * angle;
    } else {
      result = (value2 - min4) / (max3 - min4) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  };
  RadialScale2.prototype.hasRanges = function hasRanges() {
    var ranges = this.options.ranges;
    return ranges && ranges.length;
  };
  RadialScale2.prototype.ticksSize = function ticksSize() {
    var ref2 = this.options;
    var majorTicks = ref2.majorTicks;
    var minorTicks = ref2.minorTicks;
    var size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  };
  RadialScale2.prototype.labelsCount = function labelsCount() {
    var count = NumericAxis2.prototype.labelsCount.call(this);
    var options = this.options;
    var angle = options.endAngle - options.startAngle;
    if (angle >= 360 && options.max % options.majorUnit === 0) {
      count -= 1;
    }
    return count;
  };
  RadialScale2.prototype.renderLabels = function renderLabels() {
    var this$1 = this;
    var options = this.options;
    var arc = this.arc.clone();
    var radius = arc.getRadiusX();
    var tickAngles = this.tickAngles(arc, options.majorUnit);
    var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;
    var labelsGroup = new Group5();
    var rangeDistance = radius * 0.05;
    if (defined(options.rangeDistance)) {
      rangeDistance = options.rangeDistance;
    } else {
      options.rangeDistance = rangeDistance;
    }
    var labelsOptions = options.labels;
    var isInside = labelsOptions.position === INSIDE2;
    var hasLabelElements = defined(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    var labels = this.labels;
    var count = labels.length;
    var padding = getSpacing(labelsOptions.padding);
    var paddingWidth = (padding.left + padding.right) / 2;
    var paddingHeight = (padding.top + padding.bottom) / 2;
    for (var i = 0; i < count; i++) {
      var label = labels[i];
      var halfWidth = label.box.width() / 2;
      var halfHeight = label.box.height() / 2;
      var angle = tickAngles[i];
      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      var lp = arc.pointAt(angle);
      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      var labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      var labelElement = void 0;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this$1.labelElements.children[i];
        var prevLabelPos = labelElement.bbox().origin;
        var labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this$1.bbox = geometry_exports.Rect.union(this$1.bbox, labelElement.bbox());
    }
    return labelsGroup;
  };
  RadialScale2.prototype.repositionRanges = function repositionRanges() {
    var ranges = this.ranges.children;
    if (ranges.length > 0) {
      var ref2 = this.options;
      var rangeDistance = ref2.rangeDistance;
      var rangeSize = ref2.rangeSize;
      var rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      var newRadius = rangeRadius + rangeSize / 2;
      for (var i = 0; i < ranges.length; i++) {
        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  };
  RadialScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var segments = this.rangeSegments();
    var segmentsCount = segments.length;
    var result = new Group5();
    if (segmentsCount) {
      var ref2 = this.options;
      var rangeSize = ref2.rangeSize;
      var reverse = ref2.reverse;
      var rangeDistance = ref2.rangeDistance;
      var rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (var i = 0; i < segmentsCount; i++) {
        var segment = segments[i];
        var from = this$1.slotAngle(segment[reverse ? "to" : "from"]);
        var to = this$1.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this$1.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  };
  RadialScale2.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options) {
    var rangeSize = this.options.rangeSize;
    var rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options.color,
        opacity: options.opacity,
        lineCap: options.lineCap
      }
    });
  };
  RadialScale2.prototype.rangeSegments = function rangeSegments() {
    var options = this.options;
    var ranges = options.ranges || [];
    var count = ranges.length;
    var segments = [];
    if (count) {
      var min4 = options.min;
      var max3 = options.max;
      var defaultColor = options.rangePlaceholderColor;
      segments.push(rangeSegment(min4, max3, defaultColor));
      for (var i = 0; i < count; i++) {
        var range = getRange(ranges[i], min4, max3);
        var segmentsCount = segments.length;
        for (var j = 0; j < segmentsCount; j++) {
          var segment = segments[j];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  };
  RadialScale2.prototype.getRangeRadius = function getRangeRadius() {
    var ref2 = this;
    var arc = ref2.arc;
    var options = ref2.options;
    var rangeSize = options.rangeSize;
    var rangeDistance = options.rangeDistance;
    var majorTickSize = options.majorTicks.size;
    var radius;
    if (options.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  };
  RadialScale2.prototype.renderArc = function renderArc(center, radius) {
    var options = this.options;
    var arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  };
  RadialScale2.prototype.renderTicks = function renderTicks2() {
    var ref2 = this;
    var arc = ref2.arc;
    var options = ref2.options;
    var tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);
    var allTicks = new Group5();
    allTicks.append(this.majorTicks);
    var majorTickSize = options.majorTicks.size;
    var minorTickSize = options.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options.labels.position === OUTSIDE2) {
      var radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  };
  RadialScale2.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {
    var options = this.options;
    var skip = options.majorUnit / options.minorUnit;
    for (var i = angles.length - 1; i >= 0; i--) {
      if (i % skip === 0) {
        angles.splice(i, 1);
      }
    }
    return angles;
  };
  RadialScale2.prototype.tickAngles = function tickAngles(ring, stepValue) {
    var options = this.options;
    var reverse = options.reverse;
    var range = options.max - options.min;
    var angle = ring.endAngle - ring.startAngle;
    var tickCount = range / stepValue;
    var pos = ring.startAngle;
    var step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options.max % stepValue === 0) {
      tickCount -= 1;
    }
    var positions = [];
    for (var i = 0; i < tickCount; i++) {
      positions.push(round(pos, COORD_PRECISION));
      pos += step;
    }
    if (round(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  };
  RadialScale2.prototype.radius = function radius(value2) {
    if (value2) {
      this.arc.setRadiusX(value2).setRadiusY(value2);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  };
  RadialScale2.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {
    var diff = minor ? this._tickDifference || 0 : 0;
    var tickArc = this.arc;
    var radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (var i = 0; i < ticks.length; i++) {
      var newPoint = tickArc.pointAt(tickAngles[i]);
      var segments = ticks[i].segments;
      var xDiff = newPoint.x - segments[0].anchor().x;
      var yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  };
  return RadialScale2;
}(numeric_axis_default);
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = function(superclass) {
  function RadialPointerAnimation2(element, options) {
    superclass.call(this, element, options);
    var animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  if (superclass) RadialPointerAnimation2.__proto__ = superclass;
  RadialPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RadialPointerAnimation2.prototype.constructor = RadialPointerAnimation2;
  RadialPointerAnimation2.prototype.step = function step(pos) {
    var options = this.options;
    var angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options.center));
  };
  return RadialPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var Circle = drawing_exports.Circle;
var Group6 = drawing_exports.Group;
var Path7 = drawing_exports.Path;
var RadialPointer = function(Pointer2) {
  function RadialPointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2) RadialPointer2.__proto__ = Pointer2;
  RadialPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RadialPointer2.prototype.constructor = RadialPointer2;
  RadialPointer2.prototype.setAngle = function setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  };
  RadialPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var oldAngle = scale.slotAngle(options._oldValue);
    var newAngle = scale.slotAngle(options.value);
    if (options.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  };
  RadialPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var elements = new Group6();
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  };
  RadialPointer2.prototype.reflow = function reflow(arc) {
    var center = this.center = arc.center;
    var length = limitValue(this.options.length || 1, 0.1, 1.5);
    var radius = this.radius = arc.getRadiusX() * length;
    var capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(new geometry_exports.Point(center.x - capSize, center.y - capSize), new geometry_exports.Point(center.x + capSize, center.y + capSize));
  };
  RadialPointer2.prototype._renderNeedle = function _renderNeedle() {
    var minorTickSize = this.scale.options.minorTicks.size;
    var center = this.center;
    var needleColor = this.options.color;
    var needlePath = new Path7({
      fill: {
        color: needleColor
      },
      stroke: {
        color: needleColor,
        width: DEFAULT_LINE_WIDTH
      }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  };
  RadialPointer2.prototype._renderCap = function _renderCap() {
    var options = this.options;
    var capColor = options.cap.color || options.color;
    var circle = new geometry_exports.Circle(this.center, this.capSize);
    var cap = new Circle(circle, {
      fill: {
        color: capColor
      },
      stroke: {
        color: capColor
      }
    });
    return cap;
  };
  return RadialPointer2;
}(pointer_default);
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group7 = drawing_exports.Group;
var RadialGauge = function(Gauge2) {
  function RadialGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2) RadialGauge2.__proto__ = Gauge2;
  RadialGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  RadialGauge2.prototype.constructor = RadialGauge2;
  RadialGauge2.prototype.reflow = function reflow(bbox) {
    var this$1 = this;
    var pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this$1.scale.arc);
      this$1._initialPlotArea = geometry_exports.Rect.union(this$1._initialPlotArea, pointers[i].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  };
  RadialGauge2.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {
    var visuals = this._visuals = new Group7();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  };
  RadialGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    var this$1 = this;
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      this$1._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  };
  RadialGauge2.prototype.fitScale = function fitScale(bbox) {
    var this$1 = this;
    var arc = this.scale.arc;
    var plotAreaBox = this._initialPlotArea;
    var step = Math.abs(this.getDiff(plotAreaBox, bbox));
    var min4 = round(step, COORD_PRECISION);
    var max3 = round(-step, COORD_PRECISION);
    var minDiff, midDiff, maxDiff, mid, oldDiff;
    var staleFlag = 0;
    var i = 0;
    while (i++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min4 !== mid) {
        minDiff = this$1.getPlotBox(min4, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max3 !== mid) {
        maxDiff = this$1.getPlotBox(max3, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min4 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max3 * 2;
      } else {
        mid = round((min4 + max3) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this$1.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max3 = mid;
        maxDiff = midDiff;
      } else {
        min4 = mid;
        minDiff = midDiff;
      }
    }
  };
  RadialGauge2.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {
    var this$1 = this;
    var scale = this.scale;
    var pointers = this.pointers;
    var radius = arc.getRadiusX();
    var scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scaleArc);
      this$1.plotBbox = geometry_exports.Rect.union(this$1.plotBbox, pointers[i].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  };
  RadialGauge2.prototype.getDiff = function getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  };
  RadialGauge2.prototype.alignScale = function alignScale(bbox) {
    var this$1 = this;
    var plotBoxCenter = this.plotBbox.center();
    var boxCenter = bbox.center();
    var paddingX = plotBoxCenter.x - boxCenter.x;
    var paddingY = plotBoxCenter.y - boxCenter.y;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scale.arc);
      this$1.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i].bbox);
    }
  };
  RadialGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options = this.options;
    var pointers = options.pointer;
    var scale = this.scale = new radial_scale_default(options.scale, this.contextService);
    this.pointers = [];
    var pointersArr = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointersArr.length; i++) {
      var current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i], {
        animation: {
          transitions: options.transitions
        }
      }));
      this$1.pointers.push(current4);
    }
  };
  return RadialGauge2;
}(gauge_default);
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var radial_gauge_default = RadialGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = function(RadialScale2) {
  function ArcScale2() {
    RadialScale2.apply(this, arguments);
  }
  if (RadialScale2) ArcScale2.__proto__ = RadialScale2;
  ArcScale2.prototype = Object.create(RadialScale2 && RadialScale2.prototype);
  ArcScale2.prototype.constructor = ArcScale2;
  ArcScale2.prototype.rangeSegments = function rangeSegments() {
    var ref2 = this.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var rangePlaceholderColor = ref2.rangePlaceholderColor;
    var rangeLineCap = ref2.rangeLineCap;
    return [{
      from: min4,
      to: max3,
      color: rangePlaceholderColor,
      lineCap: rangeLineCap
    }];
  };
  ArcScale2.prototype.hasRanges = function hasRanges() {
    return true;
  };
  ArcScale2.prototype.placeholderRangeAngle = function placeholderRangeAngle(angle) {
    var geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  };
  ArcScale2.prototype.addRange = function addRange(from, to, options) {
    var reverse = this.options.reverse;
    var startAngle = this.slotAngle(reverse ? to : from);
    var endAngle = this.slotAngle(reverse ? from : to);
    var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);
    this.ranges.append(range);
    return range;
  };
  return ArcScale2;
}(radial_scale_default);
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var arc_scale_default = ArcScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = function(superclass) {
  function RangePointerAnimation2(element, options) {
    superclass.call(this, element, options);
    var animationOptions = this.options;
    var duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue(duration2, ANGULAR_SPEED, MAX_DURATION);
    var startColor = element.elements.options.get("stroke.color");
    var color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  if (superclass) RangePointerAnimation2.__proto__ = superclass;
  RangePointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RangePointerAnimation2.prototype.constructor = RangePointerAnimation2;
  RangePointerAnimation2.prototype.step = function step(pos) {
    var ref2 = this;
    var options = ref2.options;
    var startColor = ref2.startColor;
    var color = ref2.color;
    var angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      var r = round(interpolateValue(startColor.r, color.r, pos));
      var g = round(interpolateValue(startColor.g, color.g, pos));
      var b = round(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r, g, b).toHex());
    }
  };
  return RangePointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = function(Pointer2) {
  function RangePointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2) RangePointer2.__proto__ = Pointer2;
  RangePointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RangePointer2.prototype.constructor = RangePointer2;
  RangePointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    var oldAngle = scale.slotAngle(options._oldValue);
    var newAngle = scale.slotAngle(options.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  };
  RangePointer2.prototype.angle = function angle(value2) {
    var geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value2);
    } else {
      geometry.setEndAngle(value2);
    }
    this.scale.placeholderRangeAngle(value2);
  };
  RangePointer2.prototype.stroke = function stroke(value2) {
    this.elements.stroke(value2);
  };
  RangePointer2.prototype.render = function render() {
    if (this.elements) {
      return;
    }
    var ref2 = this;
    var scale = ref2.scale;
    var options = ref2.options;
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options.opacity,
      lineCap: scale.options.rangeLineCap
    });
  };
  RangePointer2.prototype.currentColor = function currentColor() {
    var ref2 = this.scale.options;
    var min4 = ref2.min;
    var max3 = ref2.max;
    var ref$1 = this.options;
    var colors = ref$1.colors;
    var color = ref$1.color;
    var value2 = ref$1.value;
    var currentValue = isNumber(value2) ? value2 : min4;
    if (colors) {
      for (var idx = 0; idx < colors.length; idx++) {
        var ref$2 = colors[idx];
        var rangeColor = ref$2.color;
        var from = ref$2.from;
        if (from === void 0) from = min4;
        var to = ref$2.to;
        if (to === void 0) to = max3;
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  };
  RangePointer2.prototype.reflow = function reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  };
  return RangePointer2;
}(pointer_default);
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var range_pointer_default = RangePointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-gauge.js
var ArcGauge = function(RadialGauge2) {
  function ArcGauge2() {
    RadialGauge2.apply(this, arguments);
  }
  if (RadialGauge2) ArcGauge2.__proto__ = RadialGauge2;
  ArcGauge2.prototype = Object.create(RadialGauge2 && RadialGauge2.prototype);
  ArcGauge2.prototype.constructor = ArcGauge2;
  ArcGauge2.prototype._initTheme = function _initTheme(theme) {
    RadialGauge2.prototype._initTheme.call(this, theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  };
  ArcGauge2.prototype._createModel = function _createModel() {
    var options = this.options;
    var scale = this.scale = new arc_scale_default(options.scale, this.contextService);
    var pointer = new range_pointer_default(scale, deepExtend({}, {
      colors: options.colors,
      color: options.color,
      value: options.value,
      opacity: options.opacity,
      animation: {
        transitions: options.transitions
      }
    }));
    this.pointers = [pointer];
  };
  ArcGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      current4.value(current4.options.value);
    }
  };
  ArcGauge2.prototype._setValueOptions = function _setValueOptions(value2) {
    this.options.value = value2;
  };
  ArcGauge2.prototype.currentColor = function currentColor() {
    var pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  };
  ArcGauge2.prototype.centerLabelPosition = function centerLabelPosition(width, height) {
    var size = this.getSize();
    var center = this.scale.arc.center;
    var left = center.x - width / 2;
    var top = center.y - height / 2;
    if (width < size.width) {
      var right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      var bbox = this.scale.bbox;
      var yLimit = bbox.bottomRight().y;
      var bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  };
  return ArcGauge2;
}(radial_gauge_default);
var arc_gauge_default = ArcGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/circular/circular-gauge.js
var defaultStartAngle = 90;
var CircularGauge = function(ArcGauge2) {
  function CircularGauge2() {
    ArcGauge2.apply(this, arguments);
  }
  if (ArcGauge2) CircularGauge2.__proto__ = ArcGauge2;
  CircularGauge2.prototype = Object.create(ArcGauge2 && ArcGauge2.prototype);
  CircularGauge2.prototype.constructor = CircularGauge2;
  CircularGauge2.prototype._createModel = function _createModel() {
    var scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    ArcGauge2.prototype._createModel.call(this);
  };
  return CircularGauge2;
}(arc_gauge_default);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = function(Class) {
  function Encoding2(options) {
    Class.call(this);
    this.setOptions(options);
    this.initProperties();
  }
  if (Class) Encoding2.__proto__ = Class;
  Encoding2.prototype = Object.create(Class && Class.prototype);
  Encoding2.prototype.constructor = Encoding2;
  Encoding2.prototype.initProperties = function initProperties() {
  };
  Encoding2.prototype.setOptions = function setOptions(options) {
    this.options = Object.assign({}, this.options, options);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  };
  Encoding2.prototype.encode = function encode(value2, width, height) {
    var convertedValue = defined(value2) ? String(value2) : value2;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  };
  Encoding2.prototype.initValue = function initValue() {
  };
  Encoding2.prototype.addQuietZone = function addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  };
  Encoding2.prototype.addData = function addData() {
  };
  Encoding2.prototype.invalidCharacterError = function invalidCharacterError(character) {
    throw new Error('Character "' + character + '" is not valid for symbology ' + this.name + ".");
  };
  return Encoding2;
}(class_default);
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend2 = Object.assign;
var Code11 = function(Encoding2) {
  function Code112() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Code112.__proto__ = Encoding2;
  Code112.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code112.prototype.constructor = Code112;
  Code112.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend2(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  };
  Code112.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.totalUnits = 0;
  };
  Code112.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value2.length; i++) {
      this$1.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  Code112.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code112.prototype.addCheckSum = function addCheckSum() {
    var value2 = this.value;
    var length = value2.length;
    var cValue = this.getWeightedSum(value2, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      var kValue = (cValue + this.getWeightedSum(value2, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  };
  Code112.prototype.getWeightedSum = function getWeightedSum(value2, length, total3) {
    var this$1 = this;
    var weightedSum = 0;
    for (var i = 0; i < value2.length; i++) {
      weightedSum += this$1.weightedValue(this$1.getValue(value2.charAt(i)), length, i, total3);
    }
    return weightedSum;
  };
  Code112.prototype.weightedValue = function weightedValue(value2, length, index, total3) {
    var weight = (length - index) % total3 || total3;
    return weight * value2;
  };
  Code112.prototype.getValue = function getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  };
  Code112.prototype.addCharacter = function addCharacter2(character) {
    var value2 = this.getValue(character);
    var pattern = this.characterMap[value2];
    this.addPattern(pattern);
  };
  Code112.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value2;
    for (var i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value2);
      this$1.totalUnits += value2;
    }
  };
  return Code112;
}(Encoding);
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend3 = Object.assign;
var Code39Base = function(Encoding2) {
  function Code39Base2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Code39Base2.__proto__ = Encoding2;
  Code39Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code39Base2.prototype.constructor = Code39Base2;
  Code39Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend3(this, {
      minBaseUnitLength: 0.7
    });
  };
  Code39Base2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addStart();
    for (var idx = 0; idx < value2.length; idx++) {
      this$1.addCharacter(value2.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  };
  Code39Base2.prototype.addCharacter = function addCharacter2(character) {
    var characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  };
  Code39Base2.prototype.addBase = function addBase() {
  };
  return Code39Base2;
}(Encoding);
var Code39 = function(Code39Base2) {
  function Code392() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2) Code392.__proto__ = Code39Base2;
  Code392.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code392.prototype.constructor = Code392;
  Code392.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend3(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": {
          "pattern": "bwbWBwBwb",
          "value": 0
        },
        "1": {
          "pattern": "BwbWbwbwB",
          "value": 1
        },
        "2": {
          "pattern": "bwBWbwbwB",
          "value": 2
        },
        "3": {
          "pattern": "BwBWbwbwb",
          "value": 3
        },
        "4": {
          "pattern": "bwbWBwbwB",
          "value": 4
        },
        "5": {
          "pattern": "BwbWBwbwb",
          "value": 5
        },
        "6": {
          "pattern": "bwBWBwbwb",
          "value": 6
        },
        "7": {
          "pattern": "bwbWbwBwB",
          "value": 7
        },
        "8": {
          "pattern": "BwbWbwBwb",
          "value": 8
        },
        "9": {
          "pattern": "bwBWbwBwb",
          "value": 9
        },
        "A": {
          "pattern": "BwbwbWbwB",
          "value": 10
        },
        "B": {
          "pattern": "bwBwbWbwB",
          "value": 11
        },
        "C": {
          "pattern": "BwBwbWbwb",
          "value": 12
        },
        "D": {
          "pattern": "bwbwBWbwB",
          "value": 13
        },
        "E": {
          "pattern": "BwbwBWbwb",
          "value": 14
        },
        "F": {
          "pattern": "bwBwBWbwb",
          "value": 15
        },
        "G": {
          "pattern": "bwbwbWBwB",
          "value": 16
        },
        "H": {
          "pattern": "BwbwbWBwb",
          "value": 17
        },
        "I": {
          "pattern": "bwBwbWBwb",
          "value": 18
        },
        "J": {
          "pattern": "bwbwBWBwb",
          "value": 19
        },
        "K": {
          "pattern": "BwbwbwbWB",
          "value": 20
        },
        "L": {
          "pattern": "bwBwbwbWB",
          "value": 21
        },
        "M": {
          "pattern": "BwBwbwbWb",
          "value": 22
        },
        "N": {
          "pattern": "bwbwBwbWB",
          "value": 23
        },
        "O": {
          "pattern": "BwbwBwbWb",
          "value": 24
        },
        "P": {
          "pattern": "bwBwBwbWb",
          "value": 25
        },
        "Q": {
          "pattern": "bwbwbwBWB",
          "value": 26
        },
        "R": {
          "pattern": "BwbwbwBWb",
          "value": 27
        },
        "S": {
          "pattern": "bwBwbwBWb",
          "value": 28
        },
        "T": {
          "pattern": "bwbwBwBWb",
          "value": 29
        },
        "U": {
          "pattern": "BWbwbwbwB",
          "value": 30
        },
        "V": {
          "pattern": "bWBwbwbwB",
          "value": 31
        },
        "W": {
          "pattern": "BWBwbwbwb",
          "value": 32
        },
        "X": {
          "pattern": "bWbwBwbwB",
          "value": 33
        },
        "Y": {
          "pattern": "BWbwBwbwb",
          "value": 34
        },
        "Z": {
          "pattern": "bWBwBwbwb",
          "value": 35
        },
        "-": {
          "pattern": "bWbwbwBwB",
          "value": 36
        },
        ".": {
          "pattern": "BWbwbwBwb",
          "value": 37
        },
        " ": {
          "pattern": "bWBwbwBwb",
          "value": 38
        },
        "$": {
          "pattern": "bWbWbWbwb",
          "value": 39
        },
        "/": {
          "pattern": "bWbWbwbWb",
          "value": 40
        },
        "+": {
          "pattern": "bWbwbWbWb",
          "value": 41
        },
        "%": {
          "pattern": "bwbWbWbWb",
          "value": 42
        },
        START: {
          pattern: "bWbwBwBwb"
        }
      }
    });
  };
  Code392.prototype.initValue = function initValue(value2, width, height) {
    this.width = width;
    this.height = height;
    this.value = value2;
    this.dataLength = value2.length;
    this.pattern = [];
    this.patternString = "";
  };
  Code392.prototype.prepareValues = function prepareValues() {
    var this$1 = this;
    var minBaseUnit = this.minBaseUnitLength;
    var minRatio = this.minRatio;
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    var baseUnit;
    var ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code39 encoding: the current height is " + this.height + "px and the minimum height is " + minHeight + "px.");
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this$1.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      var minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error("Insufficient width for Code39 encoding: the current width is " + this.width + 'px and the minimum width for value "' + this.value + '" is ' + minWidth + "px.");
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  };
  Code392.prototype.getBaseUnit = function getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  };
  Code392.prototype.getBaseWidth = function getBaseWidth(ratio) {
    var characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  };
  Code392.prototype.addStart = function addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addBase = function addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addStop = function addStop() {
    this.addPattern(this.characterMap.START.pattern);
  };
  Code392.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.patternString += this$1.patternMappings[pattern.charAt(i)];
    }
  };
  Code392.prototype.addCharacterGap = function addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  };
  return Code392;
}(Code39Base);
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter: function addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended: function addExtended(code) {
    var this$1 = this;
    var patterns;
    for (var i = 0; i < this.extendedMappings.length; i++) {
      patterns = this$1.extendedMappings[i].call(this$1, code);
      if (patterns) {
        for (var patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          var pattern = patterns[patternIndex];
          this$1.addBase(pattern);
        }
        this$1.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [function(code) {
    if (97 <= code && code <= 122) {
      return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
    }
  }, function(code) {
    if (33 <= code && code <= 58) {
      return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
    }
  }, function(code) {
    if (1 <= code && code <= 26) {
      return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
    }
  }, function(code) {
    var this$1 = this;
    var result;
    var dataCharacter;
    if (!this.specialAsciiCodes[code]) {
      dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
      result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
    } else {
      result = [];
      for (var i = 0; i < this.specialAsciiCodes[code].length; i++) {
        result.push(this$1.characterMap[this$1.shiftCharacters[3]]);
        result.push(this$1.characterMap[this$1.specialAsciiCodes[code][i]]);
      }
    }
    return result;
  }],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = function(Code392) {
  function Code39Extended2() {
    Code392.apply(this, arguments);
  }
  if (Code392) Code39Extended2.__proto__ = Code392;
  Code39Extended2.prototype = Object.create(Code392 && Code392.prototype);
  Code39Extended2.prototype.constructor = Code39Extended2;
  Code39Extended2.prototype.initProperties = function initProperties() {
    Code392.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: {
          "pattern": "bWbwbWbWb",
          "value": 41
        },
        SHIFT1: {
          "pattern": "bWbWbwbWb",
          "value": 40
        },
        SHIFT2: {
          "pattern": "bWbWbWbwb",
          "value": 39
        },
        SHIFT3: {
          "pattern": "bwbWbWbWb",
          "value": 42
        }
      }
    });
  };
  return Code39Extended2;
}(Code39);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend4 = Object.assign;
var Code93 = function(Code39Base2) {
  function Code932() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2) Code932.__proto__ = Code39Base2;
  Code932.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code932.prototype.constructor = Code932;
  Code932.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend4(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": {
          "pattern": "131112",
          "value": 0
        },
        "1": {
          "pattern": "111213",
          "value": 1
        },
        "2": {
          "pattern": "111312",
          "value": 2
        },
        "3": {
          "pattern": "111411",
          "value": 3
        },
        "4": {
          "pattern": "121113",
          "value": 4
        },
        "5": {
          "pattern": "121212",
          "value": 5
        },
        "6": {
          "pattern": "121311",
          "value": 6
        },
        "7": {
          "pattern": "111114",
          "value": 7
        },
        "8": {
          "pattern": "131211",
          "value": 8
        },
        "9": {
          "pattern": "141111",
          "value": 9
        },
        "A": {
          "pattern": "211113",
          "value": 10
        },
        "B": {
          "pattern": "211212",
          "value": 11
        },
        "C": {
          "pattern": "211311",
          "value": 12
        },
        "D": {
          "pattern": "221112",
          "value": 13
        },
        "E": {
          "pattern": "221211",
          "value": 14
        },
        "F": {
          "pattern": "231111",
          "value": 15
        },
        "G": {
          "pattern": "112113",
          "value": 16
        },
        "H": {
          "pattern": "112212",
          "value": 17
        },
        "I": {
          "pattern": "112311",
          "value": 18
        },
        "J": {
          "pattern": "122112",
          "value": 19
        },
        "K": {
          "pattern": "132111",
          "value": 20
        },
        "L": {
          "pattern": "111123",
          "value": 21
        },
        "M": {
          "pattern": "111222",
          "value": 22
        },
        "N": {
          "pattern": "111321",
          "value": 23
        },
        "O": {
          "pattern": "121122",
          "value": 24
        },
        "P": {
          "pattern": "131121",
          "value": 25
        },
        "Q": {
          "pattern": "212112",
          "value": 26
        },
        "R": {
          "pattern": "212211",
          "value": 27
        },
        "S": {
          "pattern": "211122",
          "value": 28
        },
        "T": {
          "pattern": "211221",
          "value": 29
        },
        "U": {
          "pattern": "221121",
          "value": 30
        },
        "V": {
          "pattern": "222111",
          "value": 31
        },
        "W": {
          "pattern": "112122",
          "value": 32
        },
        "X": {
          "pattern": "112221",
          "value": 33
        },
        "Y": {
          "pattern": "122121",
          "value": 34
        },
        "Z": {
          "pattern": "123111",
          "value": 35
        },
        "-": {
          "pattern": "121131",
          "value": 36
        },
        ".": {
          "pattern": "311112",
          "value": 37
        },
        " ": {
          "pattern": "311211",
          "value": 38
        },
        "$": {
          "pattern": "321111",
          "value": 39
        },
        "/": {
          "pattern": "112131",
          "value": 40
        },
        "+": {
          "pattern": "113121",
          "value": 41
        },
        "%": {
          "pattern": "211131",
          "value": 42
        },
        SHIFT0: {
          "pattern": "122211",
          "value": 46
        },
        SHIFT1: {
          "pattern": "311121",
          "value": 45
        },
        SHIFT2: {
          "pattern": "121221",
          "value": 43
        },
        SHIFT3: {
          "pattern": "312111",
          "value": 44
        },
        START: {
          "pattern": "111141"
        },
        TERMINATION_BAR: "1"
      }
    });
  };
  Code932.prototype.initValue = function initValue(value2, width, height) {
    this.value = value2;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value2.length;
  };
  Code932.prototype.prepareValues = function prepareValues() {
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code93 encoding: the current height is " + this.height + "px, the minimum required height is " + minHeight + "px.");
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      var minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error("Insufficient width for Code93 encoding: the current width is " + this.width + 'px and the minimum required width for value "' + this.value + '" is ' + minWidth + "px.");
    }
  };
  Code932.prototype.setBaseUnit = function setBaseUnit() {
    var checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  };
  Code932.prototype.addStart = function addStart() {
    var pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  };
  Code932.prototype.addStop = function addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  };
  Code932.prototype.addBase = function addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  };
  Code932.prototype.pushCheckSum = function pushCheckSum() {
    var this$1 = this;
    var checkValues = this._getCheckValues();
    var charData;
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      charData = this$1.characterMap[this$1._findCharacterByValue(checkValues[i])];
      this$1.addPattern(charData.pattern);
    }
  };
  Code932.prototype._getCheckValues = function _getCheckValues() {
    var this$1 = this;
    var values5 = this.values;
    var length = values5.length;
    var wightedSum = 0;
    var cValue;
    var kValue;
    var idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx, this$1.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx + 1, this$1.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  };
  Code932.prototype._findCharacterByValue = function _findCharacterByValue(value2) {
    var this$1 = this;
    for (var character in this$1.characterMap) {
      if (this$1.characterMap[character].value === value2) {
        return character;
      }
    }
  };
  Code932.prototype.weightedValue = function weightedValue(value2, index, total3) {
    return (index % total3 || total3) * value2;
  };
  Code932.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value2;
    for (var i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value2);
    }
  };
  return Code932;
}(Code39Base);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = function(Code932) {
  function Code93Extended2() {
    Code932.apply(this, arguments);
  }
  if (Code932) Code93Extended2.__proto__ = Code932;
  Code93Extended2.prototype = Object.create(Code932 && Code932.prototype);
  Code93Extended2.prototype.constructor = Code93Extended2;
  Code93Extended2.prototype.initProperties = function initProperties() {
    Code932.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        var this$1 = this;
        var checkValues = this._getCheckValues();
        var value2;
        this.checksum = checkValues.join("");
        for (var i = 0; i < checkValues.length; i++) {
          value2 = checkValues[i];
          if (this$1.shiftValuesAsciiCodes[value2]) {
            this$1.addExtended(this$1.shiftValuesAsciiCodes[value2]);
          } else {
            var characterByValue = this$1._findCharacterByValue(value2);
            this$1.addPattern(this$1.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  };
  return Code93Extended2;
}(Code93);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex = /^\d+$/;
var extend5 = Object.assign;
var Postnet = function(Encoding2) {
  function Postnet2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Postnet2.__proto__ = Encoding2;
  Postnet2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Postnet2.prototype.constructor = Postnet2;
  Postnet2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  };
  Postnet2.prototype.initValue = function initValue(value2, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value2.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  };
  Postnet2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value2.length; i++) {
      this$1.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  };
  Postnet2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  };
  Postnet2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  };
  Postnet2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  };
  Postnet2.prototype.validate = function validate(value2) {
    if (!numberRegex.test(value2)) {
      this.invalidCharacterError(value2.match(/[^0-9]/)[0]);
    }
    if (!inArray(value2.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  };
  Postnet2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var y1;
    for (var i = 0; i < pattern.length; i++) {
      y1 = this$1.height - this$1.baseHeight * pattern.charAt(i);
      this$1.pattern.push({
        width: 1,
        y1,
        y2: this$1.height
      });
      this$1.pattern.push(1);
    }
  };
  return Postnet2;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex2 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend6 = Object.assign;
var State128 = function(Class) {
  function State1282(encoding) {
    Class.call(this);
    this.encoding = encoding;
    this.initProperties();
  }
  if (Class) State1282.__proto__ = Class;
  State1282.prototype = Object.create(Class && Class.prototype);
  State1282.prototype.constructor = State1282;
  State1282.prototype.initProperties = function initProperties() {
  };
  State1282.prototype.addStart = function addStart() {
  };
  State1282.prototype.is = function is() {
  };
  State1282.prototype.isCode = function isCode() {
    return false;
  };
  State1282.prototype.move = function move() {
  };
  State1282.prototype.pushState = function pushState() {
  };
  return State1282;
}(class_default);
var State128AB = function(State1282) {
  function State128AB2(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
    this._initMoves(states);
  }
  if (State1282) State128AB2.__proto__ = State1282;
  State128AB2.prototype = Object.create(State1282 && State1282.prototype);
  State128AB2.prototype.constructor = State128AB2;
  State128AB2.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  };
  State128AB2.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128AB2.prototype.is = function is(value2, index) {
    var code = value2.charCodeAt(index);
    return this.isCode(code);
  };
  State128AB2.prototype.move = function move(encodingState) {
    var idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  };
  State128AB2.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var states = this.states, value2 = encodingState.value, maxLength = value2.length, code;
    if (inArray("C", states)) {
      var numberMatch = value2.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value2.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this$1.encoding.addPattern(this$1.getValue(code));
      encodingState.index++;
    }
  };
  State128AB2.prototype._initMoves = function _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  };
  State128AB2.prototype._moveFNC = function _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  };
  State128AB2.prototype._shiftState = function _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  };
  State128AB2.prototype._moveState = function _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  };
  return State128AB2;
}(State128);
var states128 = {};
states128.A = function(State128AB2) {
  function State128A() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2) State128A.__proto__ = State128AB2;
  State128A.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128A.prototype.constructor = State128A;
  State128A.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend6(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  };
  State128A.prototype.isCode = function isCode(code) {
    return 0 <= code && code < 96;
  };
  State128A.prototype.getValue = function getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  };
  return State128A;
}(State128AB);
states128.B = function(State128AB2) {
  function State128B() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2) State128B.__proto__ = State128AB2;
  State128B.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128B.prototype.constructor = State128B;
  State128B.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend6(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  };
  State128B.prototype.isCode = function isCode(code) {
    return 32 <= code && code < 128;
  };
  State128B.prototype.getValue = function getValue(code) {
    return code - 32;
  };
  return State128B;
}(State128AB);
states128.C = function(State1282) {
  function State128C() {
    State1282.apply(this, arguments);
  }
  if (State1282) State128C.__proto__ = State1282;
  State128C.prototype = Object.create(State1282 && State1282.prototype);
  State128C.prototype.constructor = State128C;
  State128C.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  };
  State128C.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128C.prototype.is = function is(value2, index) {
    var next4 = getSubstring(value2, index, 4);
    return (index + 4 <= value2.length || value2.length === 2) && numberRegex2.test(next4);
  };
  State128C.prototype.move = function move() {
    this.encoding.addPattern(this.MOVE);
  };
  State128C.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex2.test(code) && code.length === 2) {
      this$1.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  };
  State128C.prototype.getValue = function getValue(code) {
    return code;
  };
  return State128C;
}(State128);
states128.FNC4 = function(State1282) {
  function State128FNC4(encoding, states) {
    State1282.call(this, encoding);
    this._initSubStates(states);
  }
  if (State1282) State128FNC4.__proto__ = State1282;
  State128FNC4.prototype = Object.create(State1282 && State1282.prototype);
  State128FNC4.prototype.constructor = State128FNC4;
  State128FNC4.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  };
  State128FNC4.prototype.addStart = function addStart(encodingState) {
    var code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  };
  State128FNC4.prototype.is = function is(value2, index) {
    var code = value2.charCodeAt(index);
    return this.isCode(code);
  };
  State128FNC4.prototype.isCode = function isCode(code) {
    return 128 <= code && code < 256;
  };
  State128FNC4.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    var code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this$1._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  };
  State128FNC4.prototype._pushStart = function _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  };
  State128FNC4.prototype._initSubState = function _initSubState(encodingState) {
    var subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  };
  State128FNC4.prototype._initSubStates = function _initSubStates(states) {
    var this$1 = this;
    this.subStates = [];
    for (var i = 0; i < states.length; i++) {
      if (inArray(states[i], this$1.dependentStates)) {
        this$1.subStates.push(states[i]);
      }
    }
  };
  State128FNC4.prototype._getSubState = function _getSubState(code) {
    var this$1 = this;
    for (var i = 0; i < this.subStates.length; i++) {
      if (this$1.encoding[this$1.subStates[i]].isCode(code)) {
        return this$1.subStates[i];
      }
    }
  };
  State128FNC4.prototype._getAll = function _getAll(value2, index) {
    var code;
    var result = "";
    var i = index;
    while ((code = value2.charCodeAt(i++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  };
  return State128FNC4;
}(State128);
states128.FNC1 = function(State1282) {
  function States128FNC1(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
  }
  if (State1282) States128FNC1.__proto__ = State1282;
  States128FNC1.prototype = Object.create(State1282 && State1282.prototype);
  States128FNC1.prototype.constructor = States128FNC1;
  States128FNC1.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend6(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": {
          max: 29,
          type: "alphanumeric"
        },
        "402": {
          length: 17
        },
        "7004": {
          max: 4,
          type: "alphanumeric"
        },
        "242": {
          max: 6,
          type: "alphanumeric"
        },
        "8020": {
          max: 25,
          type: "alphanumeric"
        },
        "703": {
          min: 3,
          max: 30,
          type: "alphanumeric"
        },
        "8008": {
          min: 8,
          max: 12,
          type: "alphanumeric"
        },
        "253": {
          min: 13,
          max: 17,
          type: "alphanumeric"
        },
        "8003": {
          min: 14,
          max: 30,
          type: "alphanumeric"
        },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [[11, 13], [310, 316], [320, 336], [340, 369]],
          type: {
            length: 6
          }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: {
            max: 30,
            type: "alphanumeric"
          }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: {
            length: 13
          }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: {
            max: 20,
            type: "alphanumeric"
          }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: {
            length: 18
          }
        }, {
          ids: ["01", "02", "8001"],
          type: {
            length: 14
          }
        }, {
          ids: ["422"],
          ranges: [[424, 426]],
          type: {
            length: 3
          }
        }, {
          ids: ["20", "8102"],
          type: {
            length: 2
          }
        }, {
          ids: ["30", "37"],
          type: {
            max: 8,
            type: "alphanumeric"
          }
        }, {
          ids: ["390", "392"],
          type: {
            max: 15,
            type: "alphanumeric"
          }
        }, {
          ids: ["421", "423"],
          type: {
            min: 3,
            max: 15,
            type: "alphanumeric"
          }
        }, {
          ids: ["391", "393"],
          type: {
            min: 3,
            max: 18,
            type: "alphanumeric"
          }
        }, {
          ids: ["7003", "8101"],
          type: {
            length: 10
          }
        }]
      },
      START: 102
    });
  };
  States128FNC1.prototype.addStart = function addStart() {
    this.encoding[this.startState].addStart();
  };
  States128FNC1.prototype.is = function is() {
    return inArray(this.key, this.states);
  };
  States128FNC1.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var encoding = this.encoding, value2 = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    var trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value2.charAt(index) === this$1.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this$1.getBySeparator(value2, index) : this$1.getByLength(value2, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value2.indexOf(this$1.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value2.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value2.length;
        }
      }
      subState.value = value2.substring(index, nextStart).replace(regexSeparators, "");
      this$1.validate(current4, subState.value);
      encoding.pushData(subState, this$1.dependentStates);
      if (nextStart >= value2.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this$1.startState) {
        encoding[this$1.startState].move(subState);
        subState.state = this$1.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this$1.START);
      }
    }
    encodingState.index = encodingState.value.length;
  };
  States128FNC1.prototype.validate = function validate(current4, value2) {
    var code = value2.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex2.test(code)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  };
  States128FNC1.prototype.getByLength = function getByLength(value2, index) {
    var this$1 = this;
    var id;
    var applicationIdentifier;
    for (var i = 2; i <= 4; i++) {
      id = getSubstring(value2, index, i);
      applicationIdentifier = this$1.getApplicationIdentifier(id) || this$1.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  };
  States128FNC1.prototype.unsupportedAIError = function unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  };
  States128FNC1.prototype.getBySeparator = function getBySeparator(value2, index) {
    var start = value2.indexOf(this.startAI, index), end = value2.indexOf(this.endAI, start), id = value2.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  };
  States128FNC1.prototype.getApplicationIdentifier = function getApplicationIdentifier(id) {
    var applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (var i = 0; i < multiKey.length; i++) {
      if (multiKey[i].ids && inArray(id, multiKey[i].ids)) {
        return multiKey[i].type;
      } else if (multiKey[i].ranges) {
        var ranges = multiKey[i].ranges;
        for (var j = 0; j < ranges.length; j++) {
          if (ranges[j][0] <= id && id <= ranges[j][1]) {
            return multiKey[i].type;
          }
        }
      }
    }
  };
  return States128FNC1;
}(State128);
var Code128Base = function(Encoding2) {
  function Code128Base2(options) {
    Encoding2.call(this, options);
    this._initStates();
  }
  if (Encoding2) Code128Base2.__proto__ = Encoding2;
  Code128Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code128Base2.prototype.constructor = Code128Base2;
  Code128Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend6(this, {
      characterMap: [212222, 222122, 222221, 121223, 121322, 131222, 122213, 122312, 132212, 221213, 221312, 231212, 112232, 122132, 122231, 113222, 123122, 123221, 223211, 221132, 221231, 213212, 223112, 312131, 311222, 321122, 321221, 312212, 322112, 322211, 212123, 212321, 232121, 111323, 131123, 131321, 112313, 132113, 132311, 211313, 231113, 231311, 112133, 112331, 132131, 113123, 113321, 133121, 313121, 211331, 231131, 213113, 213311, 213131, 311123, 311321, 331121, 312113, 312311, 332111, 314111, 221411, 431111, 111224, 111422, 121124, 121421, 141122, 141221, 112214, 112412, 122114, 122411, 142112, 142211, 241211, 221114, 413111, 241112, 134111, 111242, 121142, 121241, 114212, 124112, 124211, 411212, 421112, 421211, 212141, 214121, 412121, 111143, 111341, 131141, 114113, 114311, 411113, 411311, 113141, 114131, 311141, 411131, 211412, 211214, 211232, 2331112],
      STOP: 106
    });
  };
  Code128Base2.prototype._initStates = function _initStates() {
    var this$1 = this;
    for (var i = 0; i < this.states.length; i++) {
      this$1[this$1.states[i]] = new states128[this$1.states[i]](this$1, this$1.states);
    }
  };
  Code128Base2.prototype.initValue = function initValue(value2, width, height) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  };
  Code128Base2.prototype.addData = function addData() {
    var encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  };
  Code128Base2.prototype.pushData = function pushData(encodingState, states) {
    var this$1 = this;
    var trueCondition = true;
    while (trueCondition) {
      this$1[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this$1.getNextState(encodingState, states);
        this$1[encodingState.state].move(encodingState);
      } else {
        var temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  };
  Code128Base2.prototype.addStart = function addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  };
  Code128Base2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  };
  Code128Base2.prototype.addStop = function addStop() {
    this.addPattern(this.STOP);
  };
  Code128Base2.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code128Base2.prototype.addPattern = function addPattern(code) {
    var this$1 = this;
    var pattern = this.characterMap[code].toString();
    var value2;
    for (var i = 0; i < pattern.length; i++) {
      value2 = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value2);
      this$1.totalUnits += value2;
    }
    this.checkSum += code * this.position++;
  };
  Code128Base2.prototype.getNextState = function getNextState(encodingState, states) {
    var this$1 = this;
    for (var i = 0; i < states.length; i++) {
      if (this$1[states[i]].is(encodingState.value, encodingState.index)) {
        return states[i];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  };
  return Code128Base2;
}(Encoding);
var Code128a = function(Code128Base2) {
  function Code128a2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128a2.__proto__ = Code128Base2;
  Code128a2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128a2.prototype.constructor = Code128a2;
  Code128a2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  };
  return Code128a2;
}(Code128Base);
var Code128b = function(Code128Base2) {
  function Code128b2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128b2.__proto__ = Code128Base2;
  Code128b2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128b2.prototype.constructor = Code128b2;
  Code128b2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  };
  return Code128b2;
}(Code128Base);
var Code128c = function(Code128Base2) {
  function Code128c2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code128c2.__proto__ = Code128Base2;
  Code128c2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128c2.prototype.constructor = Code128c2;
  Code128c2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  };
  return Code128c2;
}(Code128Base);
var Code128 = function(Code128Base2) {
  function Code1282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) Code1282.__proto__ = Code128Base2;
  Code1282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code1282.prototype.constructor = Code1282;
  Code1282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  };
  return Code1282;
}(Code128Base);
var CodeGS1128 = function(Code128Base2) {
  function CodeGS11282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2) CodeGS11282.__proto__ = Code128Base2;
  CodeGS11282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  CodeGS11282.prototype.constructor = CodeGS11282;
  CodeGS11282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend6(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  };
  return CodeGS11282;
}(Code128Base);
function getSubstring(value2, index, count) {
  return value2.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend7 = Object.assign;
var MsiBase = function(Encoding2) {
  function MsiBase2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) MsiBase2.__proto__ = Encoding2;
  MsiBase2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  MsiBase2.prototype.constructor = MsiBase2;
  MsiBase2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend7(this, {
      characterMap: ["12121212", "12121221", "12122112", "12122121", "12211212", "12211221", "12212112", "12212121", "21121212", "21121221"],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  };
  MsiBase2.prototype.initValue = function initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.checkSumLength = 0;
    this.width = width;
  };
  MsiBase2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  };
  MsiBase2.prototype.addData = function addData() {
    var this$1 = this;
    var value2 = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value2.length; i++) {
      this$1.addCharacter(value2.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  MsiBase2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  };
  MsiBase2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.pattern.push(parseInt(pattern.charAt(i), 10));
    }
  };
  MsiBase2.prototype.addCheckSum = function addCheckSum() {
    var this$1 = this;
    var checkSumFunction = this.checkSums[this.checkSumType];
    var checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      this$1.checkSumLength++;
      this$1.addPattern(this$1.characterMap[checkValues[i]]);
    }
  };
  return MsiBase2;
}(Encoding);
var MsiMod10 = function(MsiBase2) {
  function MsiMod102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod102.__proto__ = MsiBase2;
  MsiMod102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod102.prototype.constructor = MsiMod102;
  MsiMod102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  };
  return MsiMod102;
}(MsiBase);
var MsiMod11 = function(MsiBase2) {
  function MsiMod112() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod112.__proto__ = MsiBase2;
  MsiMod112.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod112.prototype.constructor = MsiMod112;
  MsiMod112.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  };
  return MsiMod112;
}(MsiBase);
var MsiMod1010 = function(MsiBase2) {
  function MsiMod10102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod10102.__proto__ = MsiBase2;
  MsiMod10102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod10102.prototype.constructor = MsiMod10102;
  MsiMod10102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  };
  return MsiMod10102;
}(MsiBase);
var MsiMod1110 = function(MsiBase2) {
  function MsiMod11102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2) MsiMod11102.__proto__ = MsiBase2;
  MsiMod11102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod11102.prototype.constructor = MsiMod11102;
  MsiMod11102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend7(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  };
  return MsiMod11102;
}(MsiBase);
var checkSums = {
  Modulo10: function Modulo10(value2) {
    var checkValues = [0, ""], odd = value2.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value2.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value2.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11: function Modulo11(value2) {
    var weightedSum = 0, mod = 11, length = value2.length, weight, checkValue;
    for (var i = 0; i < length; i++) {
      weight = ((length - i) % 6 || 6) + 1;
      weightedSum += weight * value2.charAt(i);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10: function Modulo11Modulo10(value2) {
    var checkValues = this.Modulo11(value2), mod11Value;
    mod11Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10: function Modulo10Modulo10(value2) {
    var checkValues = this.Modulo10(value2), mod10Value;
    mod10Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend8 = Object.assign;
var Ean13 = function(Encoding2) {
  function Ean132() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2) Ean132.__proto__ = Encoding2;
  Ean132.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Ean132.prototype.constructor = Ean132;
  Ean132.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend8(this, {
      name: "EAN 13",
      keyTable: ["000000", "001011", "001101", "001110", "010011", "011001", "011100", "010101", "010110", "011010"],
      characterMap: {
        digits: [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2]],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  };
  Ean132.prototype.initValue = function initValue(value2, width, height) {
    var valueAsString = String(value2);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  };
  Ean132.prototype.addData = function addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  };
  Ean132.prototype.addSide = function addSide(leftPart, key) {
    var this$1 = this;
    for (var i = 0; i < leftPart.length; i++) {
      if (key && parseInt(this$1.keyTable[key].charAt(i), 10)) {
        this$1.addPieces(Array.prototype.slice.call(this$1.characterMap.digits[leftPart.charAt(i)]).reverse(), true);
      } else {
        this$1.addPieces(this$1.characterMap.digits[leftPart.charAt(i)], true);
      }
    }
  };
  Ean132.prototype.addPieces = function addPieces(arrToAdd, limitedHeight) {
    var this$1 = this;
    for (var i = 0; i < arrToAdd.length; i++) {
      if (limitedHeight) {
        this$1.pattern.push({
          y1: 0,
          y2: this$1.options.height * 0.95,
          width: arrToAdd[i]
        });
      } else {
        this$1.pattern.push(arrToAdd[i]);
      }
    }
  };
  Ean132.prototype.calculateChecksum = function calculateChecksum() {
    var odd = 0, even = 0, value2 = this.value.split("").reverse().join("");
    for (var i = 0; i < value2.length; i++) {
      if (i % 2) {
        even += parseInt(value2.charAt(i), 10);
      } else {
        odd += parseInt(value2.charAt(i), 10);
      }
    }
    var checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  };
  return Ean132;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend9 = Object.assign;
var Ean8 = function(Ean132) {
  function Ean82() {
    Ean132.apply(this, arguments);
  }
  if (Ean132) Ean82.__proto__ = Ean132;
  Ean82.prototype = Object.create(Ean132 && Ean132.prototype);
  Ean82.prototype.constructor = Ean82;
  Ean82.prototype.initProperties = function initProperties() {
    Ean132.prototype.initProperties.call(this);
    extend9(this, {
      name: "EAN 8"
    });
  };
  Ean82.prototype.initValue = function initValue(value2, width, height) {
    if (value2.length !== 7 || /\D/.test(value2)) {
      throw new Error("Invalid value provided");
    }
    this.value = value2;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  };
  return Ean82;
}(Ean13);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c
};
Encodings["gs1-128"] = CodeGS1128;
Encodings.msimod10 = MsiMod10;
Encodings.msimod11 = MsiMod11;
Encodings.msimod1010 = MsiMod1010;
Encodings.msimod1110 = MsiMod1110;
Encodings.postnet = Postnet;
Encodings.ean8 = Ean8;
Encodings.ean13 = Ean13;

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element, surfaceType) {
  var display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  var size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = function(Class) {
  function Barcode2(element, options, errorHandler) {
    if (errorHandler === void 0) errorHandler = defaultErrorHandler;
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options);
    if (options && defined(options.value)) {
      this.redraw();
    }
  }
  if (Class) Barcode2.__proto__ = Class;
  Barcode2.prototype = Object.create(Class && Class.prototype);
  Barcode2.prototype.constructor = Barcode2;
  Barcode2.prototype.destroy = function destroy() {
    this._destroySurface();
  };
  Barcode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-barcode");
  };
  Barcode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Barcode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  Barcode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Barcode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  Barcode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Barcode2.prototype.setOptions = function setOptions(options) {
    this._setOptions(options);
    this._initSurface();
    this.redraw();
  };
  Barcode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Barcode2.prototype.getSize = function getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  };
  Barcode2.prototype._resize = function _resize() {
    this.redraw();
  };
  Barcode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Barcode2.prototype._render = function _render() {
    var options = this.options;
    var value2 = options.value;
    var textOptions = options.text;
    var textMargin = getSpacing(textOptions.margin);
    var size = this._getSize();
    var border = options.border || {};
    var encoding = this.encoding;
    var contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options.padding);
    var barHeight = contentBox.height();
    var encodedValue;
    var textToDisplay;
    var textHeight;
    var visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value2, {
        font: textOptions.font
      }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value2, contentBox.width(), barHeight);
    } catch (error) {
      this.onError(error);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value2;
      if (options.checksum && defined(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  };
  Barcode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  Barcode2.prototype._getSize = function _getSize() {
    var element = this.element;
    var elementSize2 = surfaceSize(element, this.options.renderAs);
    var size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize2.width > 0) {
      size.width = elementSize2.width;
    }
    if (elementSize2.height > 0) {
      size.height = elementSize2.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  };
  Barcode2.prototype.value = function value2(value$1) {
    if (!defined(value$1)) {
      return this.options.value;
    }
    this.options.value = String(value$1);
    this.redraw();
  };
  Barcode2.prototype._getBands = function _getBands(pattern, baseUnit) {
    var this$1 = this;
    var contentBox = this.contentBox;
    var offsetX = contentBox.x1;
    var stepX;
    var patternItem;
    var group = new drawing_exports.Group();
    for (var i = 0; i < pattern.length; i++) {
      patternItem = isObject(pattern[i]) ? pattern[i] : {
        width: pattern[i],
        y1: 0,
        y2: this$1.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i % 2) {
        var rect = geometry_exports.Rect.fromPoints(new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1), new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1));
        var path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this$1.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  };
  Barcode2.prototype._getBackground = function _getBackground(size) {
    var options = this.options;
    var border = options.border || {};
    var box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    var path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  };
  Barcode2.prototype._getText = function _getText(value2) {
    var textOptions = this.options.text;
    var text = this._textbox = new text_box_default(value2, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  };
  Barcode2.prototype._setOptions = function _setOptions(options) {
    this.type = (options.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options.value = "0" + options.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options.value = "0" + options.value;
    }
    if (!Encodings[this.type]) {
      throw new Error("Encoding '" + this.type + "' is not supported.");
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options);
  };
  return Barcode2;
}(class_default);
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend10 = Object.assign;
function splitInto(str, chunkLength) {
  var result = [];
  var idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value2, length) {
  var bitString = Number(value2).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value2) {
  return parseInt(value2, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = function(Class) {
  function FreeCellVisitor2(matrix) {
    Class.call(this);
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  if (Class) FreeCellVisitor2.__proto__ = Class;
  FreeCellVisitor2.prototype = Object.create(Class && Class.prototype);
  FreeCellVisitor2.prototype.constructor = FreeCellVisitor2;
  FreeCellVisitor2.prototype.move = function move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  };
  FreeCellVisitor2.prototype.getNextCell = function getNextCell() {
    var this$1 = this;
    while (this.matrix[this.row][this.column] !== void 0) {
      this$1.move();
      if (this$1.row < 0 || this$1.row >= this$1.matrix.length) {
        this$1.dir = -this$1.dir;
        this$1.startColumn -= this$1.startColumn !== 8 ? 2 : 3;
        this$1.column = this$1.startColumn;
        this$1.row = this$1.dir < 0 ? this$1.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  };
  FreeCellVisitor2.prototype.getNextRemainderCell = function getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  };
  return FreeCellVisitor2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = function(Class) {
  function EncodingResult2(dataString, version) {
    Class.call(this);
    this.dataString = dataString;
    this.version = version;
  }
  if (Class) EncodingResult2.__proto__ = Class;
  EncodingResult2.prototype = Object.create(Class && Class.prototype);
  EncodingResult2.prototype.constructor = EncodingResult2;
  return EncodingResult2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = function(Class) {
  function IsoEncoder2() {
    Class.apply(this, arguments);
  }
  if (Class) IsoEncoder2.__proto__ = Class;
  IsoEncoder2.prototype = Object.create(Class && Class.prototype);
  IsoEncoder2.prototype.constructor = IsoEncoder2;
  IsoEncoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  };
  return IsoEncoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = function(Class) {
  function QRDataMode2() {
    Class.call(this);
    this.initProperties();
  }
  if (Class) QRDataMode2.__proto__ = Class;
  QRDataMode2.prototype = Object.create(Class && Class.prototype);
  QRDataMode2.prototype.constructor = QRDataMode2;
  QRDataMode2.prototype.initProperties = function initProperties() {
    extend10(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  };
  QRDataMode2.prototype.getVersionIndex = function getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  };
  QRDataMode2.prototype.getBitsCharacterCount = function getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  };
  QRDataMode2.prototype.getModeCountString = function getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  };
  QRDataMode2.prototype.encode = function encode() {
  };
  QRDataMode2.prototype.getStringBitsLength = function getStringBitsLength() {
  };
  QRDataMode2.prototype.getValue = function getValue() {
  };
  return QRDataMode2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = function(QRDataMode2) {
  function NumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) NumericQRDataMode2.__proto__ = QRDataMode2;
  NumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  NumericQRDataMode2.prototype.constructor = NumericQRDataMode2;
  NumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  };
  NumericQRDataMode2.prototype.getValue = function getValue(character) {
    return parseInt(character, 10);
  };
  NumericQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      result += toBitsString(parts[i], 10);
    }
    return result + toBitsString(parts[i], 1 + 3 * parts[i].length);
  };
  NumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    var mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  };
  return NumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = function(QRDataMode2) {
  function AlphaNumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) AlphaNumericQRDataMode2.__proto__ = QRDataMode2;
  AlphaNumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  AlphaNumericQRDataMode2.prototype.constructor = AlphaNumericQRDataMode2;
  AlphaNumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  };
  AlphaNumericQRDataMode2.prototype.getValue = function getValue(character) {
    return this.characters[character];
  };
  AlphaNumericQRDataMode2.prototype.encode = function encode(str, version) {
    var this$1 = this;
    var parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value2;
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      value2 = 45 * this$1.getValue(parts[i].charAt(0)) + this$1.getValue(parts[i].charAt(1));
      result += toBitsString(value2, 11);
    }
    value2 = parts[i].length === 2 ? 45 * this.getValue(parts[i].charAt(0)) + this.getValue(parts[i].charAt(1)) : this.getValue(parts[i].charAt(0));
    return result + toBitsString(value2, 1 + 5 * parts[i].length);
  };
  AlphaNumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  };
  return AlphaNumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = function(QRDataMode2) {
  function ByteQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2) ByteQRDataMode2.__proto__ = QRDataMode2;
  ByteQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  ByteQRDataMode2.prototype.constructor = ByteQRDataMode2;
  ByteQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend10(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  };
  ByteQRDataMode2.prototype.getValue = function getValue(character) {
    var code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error('Unsupported character in QR Code: "' + character + '".');
  };
  ByteQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, result = mode.getModeCountString(str.length, version);
    for (var i = 0; i < str.length; i++) {
      result += toBitsString(mode.getValue(str.charAt(i)), 8);
    }
    return result;
  };
  ByteQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  };
  return ByteQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var DataModeInstances = {};
DataModeInstances[NUMERIC] = new NumericQRDataMode();
DataModeInstances[ALPHA_NUMERIC] = new AlphaNumericQRDataMode();
DataModeInstances[BYTE] = new ByteQRDataMode();

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE2 = "byte";
var Utf8Encoder = function(Class) {
  function Utf8Encoder2() {
    Class.call(this);
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  if (Class) Utf8Encoder2.__proto__ = Class;
  Utf8Encoder2.prototype = Object.create(Class && Class.prototype);
  Utf8Encoder2.prototype.constructor = Utf8Encoder2;
  Utf8Encoder2.prototype.initProperties = function initProperties() {
    extend10(this, {
      encodingMode: BYTE2,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  };
  Utf8Encoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  };
  Utf8Encoder2.prototype.getDataCodewordsCount = function getDataCodewordsCount2(data) {
    var dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  };
  Utf8Encoder2.prototype.encode = function encode(str) {
    var this$1 = this;
    var result = this.utfBOM;
    for (var i = 0; i < str.length; i++) {
      result += this$1.encodeCharacter(str.charCodeAt(i));
    }
    return result;
  };
  Utf8Encoder2.prototype.encodeCharacter = function encodeCharacter(code) {
    var bytesCount = this.getBytesCount(code), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      var significantOnes = 8 - bytesCount;
      for (var i = 0; i < bc; i++) {
        result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  };
  Utf8Encoder2.prototype.getBytesCount = function getBytesCount(code) {
    var ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      if (code < ranges[i]) {
        return i + 1;
      }
    }
  };
  return Utf8Encoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [[1, 19]],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [[1, 16]],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [[1, 13]],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [[1, 9]],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [[1, 34]],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [[1, 28]],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [[1, 22]],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [[1, 16]],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[1, 55]],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [[1, 44]],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[2, 17]],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [[2, 13]],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [[1, 80]],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [[2, 32]],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [[2, 24]],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [[4, 9]],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [[1, 108]],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [[2, 43]],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [[2, 15], [2, 16]],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [[2, 11], [2, 12]],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [[2, 68]],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [[4, 27]],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [[4, 19]],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [[4, 15]],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[2, 78]],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [[4, 31]],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [[2, 14], [4, 15]],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [[4, 13], [1, 14]],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [[2, 97]],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [[2, 38], [2, 39]],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [[4, 18], [2, 19]],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [[4, 14], [2, 15]],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [[2, 116]],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[3, 36], [2, 37]],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [[4, 16], [4, 17]],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [[4, 12], [4, 13]],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [[2, 68], [2, 69]],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [[4, 43], [1, 44]],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[6, 19], [2, 20]],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [[6, 15], [2, 16]],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[4, 81]],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [[1, 50], [4, 51]],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [[4, 22], [4, 23]],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [[3, 12], [8, 13]],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [[2, 92], [2, 93]],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [[6, 36], [2, 37]],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [[4, 20], [6, 21]],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [[7, 14], [4, 15]],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[4, 107]],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [[8, 37], [1, 38]],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [[8, 20], [4, 21]],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [[12, 11], [4, 12]],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [[3, 115], [1, 116]],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[4, 40], [5, 41]],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [[11, 16], [5, 17]],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [[11, 12], [5, 13]],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [[5, 87], [1, 88]],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [[5, 41], [5, 42]],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [[5, 24], [7, 25]],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[11, 12], [7, 13]],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [[5, 98], [1, 99]],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [[7, 45], [3, 46]],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[15, 19], [2, 20]],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [[3, 15], [13, 16]],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[1, 107], [5, 108]],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[10, 46], [1, 47]],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[1, 22], [15, 23]],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [[2, 14], [17, 15]],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[5, 120], [1, 121]],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[9, 43], [4, 44]],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[17, 22], [1, 23]],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [[2, 14], [19, 15]],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[3, 113], [4, 114]],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[3, 44], [11, 45]],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[17, 21], [4, 22]],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [[9, 13], [16, 14]],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [[3, 107], [5, 108]],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[3, 41], [13, 42]],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[15, 24], [5, 25]],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[15, 15], [10, 16]],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [[4, 116], [4, 117]],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[17, 42]],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [[17, 22], [6, 23]],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [[19, 16], [6, 17]],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[2, 111], [7, 112]],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[17, 46]],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[7, 24], [16, 25]],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[34, 13]],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [[4, 121], [5, 122]],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[4, 47], [14, 48]],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[11, 24], [14, 25]],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[16, 15], [14, 16]],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[6, 117], [4, 118]],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[6, 45], [14, 46]],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[11, 24], [16, 25]],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[30, 16], [2, 17]],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[8, 106], [4, 107]],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [[8, 47], [13, 48]],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[7, 24], [22, 25]],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[22, 15], [13, 16]],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[10, 114], [2, 115]],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [[19, 46], [4, 47]],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[28, 22], [6, 23]],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [[33, 16], [4, 17]],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[8, 122], [4, 123]],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[22, 45], [3, 46]],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[8, 23], [26, 24]],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[12, 15], [28, 16]],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[3, 117], [10, 118]],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[3, 45], [23, 46]],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[4, 24], [31, 25]],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[11, 15], [31, 16]],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[7, 116], [7, 117]],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[21, 45], [7, 46]],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[1, 23], [37, 24]],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[19, 15], [26, 16]],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[5, 115], [10, 116]],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[19, 47], [10, 48]],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[15, 24], [25, 25]],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[23, 15], [25, 16]],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[13, 115], [3, 116]],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[2, 46], [29, 47]],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[42, 24], [1, 25]],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[23, 15], [28, 16]],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[17, 115]],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[10, 46], [23, 47]],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[10, 24], [35, 25]],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[19, 15], [35, 16]],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[17, 115], [1, 116]],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[14, 46], [21, 47]],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[29, 24], [19, 25]],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[11, 15], [46, 16]],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[13, 115], [6, 116]],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[14, 46], [23, 47]],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[44, 24], [7, 25]],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[59, 16], [1, 17]],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[12, 121], [7, 122]],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[12, 47], [26, 48]],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[39, 24], [14, 25]],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[22, 15], [41, 16]],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[6, 121], [14, 122]],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[6, 47], [34, 48]],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[46, 24], [10, 25]],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[2, 15], [64, 16]],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[17, 122], [4, 123]],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[29, 46], [14, 47]],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[49, 24], [10, 25]],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[24, 15], [46, 16]],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[4, 122], [18, 123]],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[13, 46], [32, 47]],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[48, 24], [14, 25]],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[42, 15], [32, 16]],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[20, 117], [4, 118]],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[40, 47], [7, 48]],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[43, 24], [22, 25]],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[10, 15], [67, 16]],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [[19, 118], [6, 119]],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [[18, 47], [31, 48]],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [[34, 24], [34, 25]],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [[20, 15], [61, 16]],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE3 = "byte";
var powersOfTwo = {
  "1": 0
};
var powersOfTwoResult = {
  "0": 1
};
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = {
  L: "01",
  M: "00",
  Q: "11",
  H: "10"
};
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [function(row, column) {
  return (row + column) % 2 === 0;
}, function(row, column) {
  return row % 2 === 0;
}, function(row, column) {
  return column % 3 === 0;
}, function(row, column) {
  return (row + column) % 3 === 0;
}, function(row, column) {
  return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
}, function(row, column) {
  return row * column % 2 + row * column % 3 === 0;
}, function(row, column) {
  return (row * column % 2 + row * column % 3) % 2 === 0;
}, function(row, column) {
  return ((row + column) % 2 + row * column % 3) % 2 === 0;
}];
var numberRegex3 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x, y) {
  for (var i = 0; i < matrices.length; i++) {
    matrices[i][x][y] = bit;
  }
}
function fillDataCell(matrices, bit, x, y) {
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  var cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (var i = 0; i < block.length; i++) {
        for (var j = 0; j < 8; j++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  var dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  var dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  var result;
  var power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x, y) {
  var result = [], idx = x.length - 2;
  for (var i = idx; i >= 0; i--) {
    result[i] = x[i] ^ y[i];
  }
  return result;
}
function multiplyPolynomials(x, y) {
  var result = [];
  for (var i = 0; i < x.length; i++) {
    for (var j = 0; j < y.length; j++) {
      if (result[i + j] === void 0) {
        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;
      } else {
        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  var maxErrorCorrectionCodeWordsCount = 68;
  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    var firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  var result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  var generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  var codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(messagePolynomial, versionCodewordsInformation.errorCodewordsPerBlock));
    }
  }
  return [dataBlocks, errorBlocks];
}
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  var numeric = numberRegex3.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC2;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC2)) {
    mode = ALPHA_NUMERIC2;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE3;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}
function getModes(inputString) {
  var modes = [], previousMode, idx = 0;
  var str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}
function getDataCodewordsCount(modes) {
  var length = 0, mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    length += mode.getStringBitsLength(modes[i].modeString.length);
  }
  return Math.ceil(length / 8);
}
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  var x = 0, y = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y = version;
    } else {
      x = version;
    }
    version = x + Math.floor((y - x) / 2);
  } while (y - x > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y + 1;
}
function getDataString(modes, version) {
  var dataString = "", mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    dataString += mode.encode(modes[i].modeString, version);
  }
  return dataString;
}
function encodeFormatInformation(format) {
  var formatNumber = toDecimal(format), encodedString, result = "";
  if (formatNumber === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);
  for (var i = 0; i < encodedString.length; i++) {
    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);
  }
  return result;
}
function encodeBCH(value2, generatorPolynomial, codeLength) {
  var generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value2 << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value2, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  var yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  var x = numberX;
  do {
    x ^= numberY << xLength - yLength;
    xLength = x.toString(2).length;
  } while (xLength >= yLength);
  return x;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  var matrices = [], modules = 17 + 4 * version;
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i] = new Array(modules);
    for (var j = 0; j < modules; j++) {
      matrices[i][j] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString) {
  var matrix = matrices[0], x, y, idx = 0, length = formatString.length;
  for (x = 0, y = 8; x <= 8; x++) {
    if (x !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
    }
  }
  for (x = 8, y = 7; y >= 0; y--) {
    if (y !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
    }
  }
  idx = 0;
  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  var matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x2 = modules - 11, y2 = 0, quotient, mod, value2;
  for (var idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value2 = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value2, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value2, x2 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x, y) {
  var size = pattern.length + 2, length = pattern.length + 1, value2;
  for (var i = 0; i < pattern.length; i++) {
    for (var j = i; j < size - i; j++) {
      value2 = pattern[i];
      fillFunctionCell(matrices, value2, x + j, y + i);
      fillFunctionCell(matrices, value2, x + i, y + j);
      fillFunctionCell(matrices, value2, x + length - j, y + length - i);
      fillFunctionCell(matrices, value2, x + length - i, y + length - j);
    }
  }
}
function addFinderSeparator(matrices, direction, x, y) {
  var nextX = x, nextY = y, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y);
    fillFunctionCell(matrices, 0, x, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  var modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  var matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points.push(points[idx++] + startDistance);
  while (points[idx] + distance < modules) {
    points.push(points[idx++] + distance);
  }
  for (var i = 0; i < points.length; i++) {
    for (var j = 0; j < points.length; j++) {
      if (matrix[points[i]][points[j]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  var row = 6, column = 6, value2 = 1, modules = matrices[0].length;
  for (var i = 8; i < modules - 8; i++) {
    fillFunctionCell(matrices, value2, row, i);
    fillFunctionCell(matrices, value2, i, column);
    value2 ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  var scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i = 0; i < matrices.length; i++) {
    scores[i] = 0;
    darkModules[i] = 0;
    adjacentSameBits[i] = [0, 0];
    patterns[i] = [0, 0];
    previousBits[i] = [];
  }
  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  var total3 = modulesLength * modulesLength, minIdx, min4 = Number.MAX_VALUE;
  for (i = 0; i < scores.length; i++) {
    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total3);
    if (scores[i] < min4) {
      min4 = scores[i];
      minIdx = i;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total3) {
  var percent = Math.floor(darkModules / total3 * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  var encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  var minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round2 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = function(Class) {
  function QRCode2(element, options, errorHandler) {
    if (errorHandler === void 0) errorHandler = defaultErrorHandler;
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options);
  }
  if (Class) QRCode2.__proto__ = Class;
  QRCode2.prototype = Object.create(Class && Class.prototype);
  QRCode2.prototype.constructor = QRCode2;
  QRCode2.prototype.destroy = function destroy() {
    this._destroySurface();
  };
  QRCode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-qrcode");
  };
  QRCode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  QRCode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  QRCode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  QRCode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  QRCode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  QRCode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  QRCode2.prototype.getSize = function getSize() {
    var element = this.element;
    var elementWidth = element.clientWidth;
    var elementHeight = element.clientHeight;
    var size = {
      width: 0,
      height: 0
    };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  };
  QRCode2.prototype._resize = function _resize() {
    this.redraw();
  };
  QRCode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  QRCode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  QRCode2.prototype._render = function _render() {
    var value2 = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    var visual = new drawing_exports.Group();
    try {
      if (value2) {
        matrix = encodeData(value2, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error) {
      this.onError(error);
    }
    return visual;
  };
  QRCode2.prototype._renderLogo = function _renderLogo(qrSize, baseUnit) {
    var image;
    var imageRect;
    var center = round2(qrSize / 2);
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    var logoUrl = this.options.overlay.imageUrl;
    var position = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(new geometry_exports.Point(position.x, position.y), new geometry_exports.Size(logoSize.width, logoSize.height));
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  };
  QRCode2.prototype._renderSwissCode = function _renderSwissCode(qrSize, baseUnit) {
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    var crossSize = logoSize / 4;
    var crossOffset = crossSize / 2;
    var center = qrSize / 2;
    var start = {};
    var visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  };
  QRCode2.prototype._renderShape = function _renderShape(start, step, pattern, color) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (var i = 0; i < pattern.length; i++) {
      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);
    }
    path.close();
    return path;
  };
  QRCode2.prototype._getSize = function _getSize() {
    var size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      var element = this.element;
      var elementSize2 = surfaceSize(element, this.options.renderAs);
      var min4 = Math.min(elementSize2.width, elementSize2.height);
      if (min4 > 0) {
        size = min4;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  };
  QRCode2.prototype._calculateBaseUnit = function _calculateBaseUnit(size, matrixSize) {
    var baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      var minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error("Insufficient size for QR Code: the current size is " + size + "px and the minimum size is " + minSize + "px."));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  };
  QRCode2.prototype._renderMatrix = function _renderMatrix(matrix, baseUnit, quietZoneSize) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (var row = 0; row < matrix.length; row++) {
      var y = quietZoneSize + row * baseUnit;
      var column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          var x = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          var x1 = round2(quietZoneSize + x * baseUnit);
          var y1 = round2(y);
          var x2 = round2(quietZoneSize + column * baseUnit);
          var y2 = round2(y + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();
        }
      }
    }
    return path;
  };
  QRCode2.prototype._renderBackground = function _renderBackground(size, border) {
    var box = new box_default(0, 0, size, size).unpad(border.width / 2);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  };
  QRCode2.prototype.setOptions = function setOptions(options) {
    var newOptions = options || {};
    this.options = extend10(this.options, newOptions);
    if (options.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  };
  QRCode2.prototype.value = function value2(value$1) {
    if (value$1 === void 0) {
      return this._value;
    }
    this._value = String(value$1);
    this.redraw();
  };
  QRCode2.prototype._hasCustomLogo = function _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  };
  QRCode2.prototype._isSwiss = function _isSwiss() {
    return this.options.overlay.type === "swiss";
  };
  QRCode2.prototype._getLogoSize = function _getLogoSize(defautLogoSize) {
    var width = this.options.overlay.width;
    var height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  };
  return QRCode2;
}(class_default);
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value2) {
  return value2 * value2;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = function(Class) {
  function Location2(lat, lng) {
    Class.call(this);
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  if (Class) Location2.__proto__ = Class;
  Location2.prototype = Object.create(Class && Class.prototype);
  Location2.prototype.constructor = Location2;
  Location2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  };
  Location2.prototype.toArray = function toArray() {
    return [this.lat, this.lng];
  };
  Location2.prototype.equals = function equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  };
  Location2.prototype.clone = function clone3() {
    return new Location2(this.lat, this.lng);
  };
  Location2.prototype.round = function round$1(precision) {
    this.lng = round(this.lng, precision);
    this.lat = round(this.lat, precision);
    return this;
  };
  Location2.prototype.wrap = function wrap() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  };
  Location2.prototype.distanceTo = function distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  };
  Location2.prototype.destination = function destination(distance, initialBearing, initialDatum) {
    var bearing = rad(initialBearing);
    var datum = initialDatum || datums.WGS84;
    var fromLat = rad(this.lat);
    var fromLng = rad(this.lng);
    var dToR = distance / datum.a;
    var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new Location2(deg(lat), deg(lng));
  };
  Location2.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {
    var this$1 = this;
    var dest = Location2.create(dest);
    var datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    var a = datum.a;
    var b = datum.b;
    var f = datum.f;
    var L = rad(dest.lng - this.lng);
    var U1 = atan((1 - f) * tan(rad(this.lat)));
    var sinU1 = sin(U1);
    var cosU1 = cos(U1);
    var U2 = atan((1 - f) * tan(rad(dest.lat)));
    var sinU2 = sin(U2);
    var cosU2 = cos(U2);
    var lambda = L;
    var prevLambda;
    var i = this.DISTANCE_ITERATIONS;
    var converged = false;
    var sinLambda;
    var cosLambda;
    var sino;
    var cosA2;
    var coso;
    var cos2om;
    var sigma;
    while (!converged && i-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      var sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));
      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this$1.DISTANCE_CONVERGENCE;
    }
    var u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);
    var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
    var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
    var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg(azimuthFrom),
      azimuthTo: deg(azimuthTo)
    };
  };
  Location2.prototype.toString = function toString() {
    return String(this.lat) + "," + String(this.lng);
  };
  Location2.fromLngLat = function fromLngLat(lngAndLat) {
    return new Location2(lngAndLat[1], lngAndLat[0]);
  };
  Location2.fromLatLng = function fromLatLng(lngAndLat) {
    return new Location2(lngAndLat[0], lngAndLat[1]);
  };
  Location2.create = function create2(a, b) {
    if (defined(a)) {
      if (a instanceof Location2) {
        return a.clone();
      } else if (arguments.length === 1 && a.length === 2) {
        return Location2.fromLatLng(a);
      }
      return new Location2(a, b);
    }
  };
  return Location2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point4 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_2 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = function(Class) {
  function Mercator2(options) {
    Class.call(this);
    this.initProperties();
    this._initOptions(options);
  }
  if (Class) Mercator2.__proto__ = Class;
  Mercator2.prototype = Object.create(Class && Class.prototype);
  Mercator2.prototype.constructor = Mercator2;
  Mercator2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Mercator2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  };
  Mercator2.prototype.forward = function forward(loc, clamp) {
    var proj = this, options = proj.options, datum = options.datum, r = datum.a, lng0 = options.centralMeridian, lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x = rad(lng - lng0) * r, y = proj._projectLat(lat);
    return new Point4(x, y);
  };
  Mercator2.prototype._projectLat = function _projectLat(lat) {
    var datum = this.options.datum, ecc = datum.e, r = datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2), con = ecc * sin2(y), p = pow((1 - con) / (1 + con), ecc / 2);
    return r * log2(ts * p);
  };
  Mercator2.prototype.inverse = function inverse2(point, clamp) {
    var proj = this, options = proj.options, datum = options.datum, r = datum.a, lng0 = options.centralMeridian, lng = point.x / (DEG_TO_RAD * r) + lng0, lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  };
  Mercator2.prototype._inverseY = function _inverseY(y) {
    var proj = this, datum = proj.options.datum, r = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y / r), phi = PI_DIV_2 - 2 * atan3(ts), i;
    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {
      var con = ecc * sin2(phi), p = pow((1 - con) / (1 + con), ecch), dphi = PI_DIV_2 - 2 * atan3(ts * p) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg(phi);
  };
  return Mercator2;
}(class_default);
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = function(Mercator2) {
  function SphericalMercator2() {
    Mercator2.apply(this, arguments);
  }
  if (Mercator2) SphericalMercator2.__proto__ = Mercator2;
  SphericalMercator2.prototype = Object.create(Mercator2 && Mercator2.prototype);
  SphericalMercator2.prototype.constructor = SphericalMercator2;
  SphericalMercator2.prototype.initProperties = function initProperties() {
    Mercator2.prototype.initProperties.call(this);
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  };
  SphericalMercator2.prototype._projectLat = function _projectLat(lat) {
    var r = this.options.datum.a, y = rad(lat), ts = tan2(PI_DIV_4 + y / 2);
    return r * log2(ts);
  };
  SphericalMercator2.prototype._inverseY = function _inverseY(y) {
    var r = this.options.datum.a, ts = exp(-y / r);
    return deg(PI_DIV_2 - 2 * atan3(ts));
  };
  return SphericalMercator2;
}(Mercator);
var Equirectangular = function(Class) {
  function Equirectangular2() {
    Class.apply(this, arguments);
  }
  if (Class) Equirectangular2.__proto__ = Class;
  Equirectangular2.prototype = Object.create(Class && Class.prototype);
  Equirectangular2.prototype.constructor = Equirectangular2;
  Equirectangular2.prototype.forward = function forward(loc) {
    return new Point4(loc.lng, loc.lat);
  };
  Equirectangular2.prototype.inverse = function inverse2(point) {
    return new Location(point.y, point.x);
  };
  return Equirectangular2;
}(class_default);
var EPSG3857 = function(Class) {
  function EPSG38572() {
    Class.call(this);
    var crs = this, proj = crs._proj = new SphericalMercator();
    var c = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);
    this._itm = geometry_exports.transform().scale(c, -c).translate(-0.5, -0.5);
  }
  if (Class) EPSG38572.__proto__ = Class;
  EPSG38572.prototype = Object.create(Class && Class.prototype);
  EPSG38572.prototype.constructor = EPSG38572;
  EPSG38572.prototype.toPoint = function toPoint(loc, scale, clamp) {
    var point = this._proj.forward(loc, clamp);
    return point.transform(this._tm).scale(scale || 1);
  };
  EPSG38572.prototype.toLocation = function toLocation(point, scale, clamp) {
    var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  };
  return EPSG38572;
}(class_default);
var EPSG3395 = function(Class) {
  function EPSG33952() {
    Class.call(this);
    this._proj = new Mercator();
  }
  if (Class) EPSG33952.__proto__ = Class;
  EPSG33952.prototype = Object.create(Class && Class.prototype);
  EPSG33952.prototype.constructor = EPSG33952;
  EPSG33952.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG33952.prototype.toLocation = function toLocation(point) {
    return this._proj.inverse(point);
  };
  return EPSG33952;
}(class_default);
var EPSG4326 = function(Class) {
  function EPSG43262() {
    Class.call(this);
    this._proj = new Equirectangular();
  }
  if (Class) EPSG43262.__proto__ = Class;
  EPSG43262.prototype = Object.create(Class && Class.prototype);
  EPSG43262.prototype.constructor = EPSG43262;
  EPSG43262.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG43262.prototype.toLocation = function toLocation(point) {
    return this._proj.inverse(point);
  };
  return EPSG43262;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var proxy = function(method, context) {
  return method.bind(context);
};
var convertToHtml = function(html2) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  return div.firstChild;
};
var appendHtml = function(html2, element) {
  var div = document.createElement("div");
  div.innerHTML = html2;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = function(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = function(element, originElement) {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = function(parent, wrapper2) {
  parent.appendChild(wrapper2);
  while (parent.firstChild !== wrapper2) {
    wrapper2.appendChild(parent.firstChild);
  }
};
var toHyphens = function(str) {
  var result = str.replace(/([a-z][A-Z])/g, function(g) {
    return g.charAt(0) + "-" + g.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = function(value2) {
  var result;
  if (value2 && String(value2).endsWith("px")) {
    result = value2;
  } else {
    result = String(value2) + "px";
  }
  return result;
};
var hasNativeScrolling = function(userAgent) {
  var ref2 = getSupportedFeatures(userAgent);
  var mobileOS = ref2.mobileOS;
  return mobileOS.ios || mobileOS.android;
};
var setDefaultEvents = function(type, events) {
  var proto = type.prototype;
  if (proto.events) {
    events.forEach(function(event) {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events;
  }
};
var wheelDeltaY = function(e) {
  var deltaY = e.wheelDeltaY;
  var delta;
  if (e.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e.wheelDelta;
    }
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    delta = -e.detail * 10;
  }
  return delta;
};
var renderPos = function(pos) {
  var result = [];
  if (pos) {
    var parts = toHyphens(pos).split("-");
    for (var i = 0; i < parts.length; i++) {
      result.push("k-pos-" + parts[i]);
    }
  }
  return result.join(" ");
};

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = function(Observable2) {
  function Attribution2(element, options) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  if (Observable2) Attribution2.__proto__ = Observable2;
  Attribution2.prototype = Object.create(Observable2 && Observable2.prototype);
  Attribution2.prototype.constructor = Attribution2;
  Attribution2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Attribution2.prototype.filter = function filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  };
  Attribution2.prototype.add = function add3(item) {
    var newItem = item;
    if (defined(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  };
  Attribution2.prototype.remove = function remove(text) {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  };
  Attribution2.prototype.clear = function clear3() {
    this.items = [];
    removeChildren(this.element);
  };
  Attribution2.prototype._render = function _render() {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      var text = this$1._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      var html2 = result.join(this.options.separator);
      appendHtml(html2, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  };
  Attribution2.prototype.hideElement = function hideElement() {
    this.element.style.display = "none";
  };
  Attribution2.prototype.showElement = function showElement() {
    this.element.style.display = "";
  };
  Attribution2.prototype._itemText = function _itemText(item) {
    var text = "";
    var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    var inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  };
  Attribution2.prototype._inZoomLevel = function _inZoomLevel(min4, max3) {
    var result = true;
    var newMin = valueOrDefault(min4, -Number.MAX_VALUE);
    var newMax = valueOrDefault(max3, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  };
  Attribution2.prototype._inArea = function _inArea(area) {
    var result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  };
  return Attribution2;
}(observable_default);
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction, iconOptions) {
  var html2 = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '">' + renderIcon({
    icon: "caret-alt-" + direction,
    iconClass: "k-button-icon",
    svgIcons: iconOptions.svgIcons,
    type: iconOptions.type
  }) + "</button>";
  return convertToHtml(html2);
}
var Navigator2 = function(Observable2) {
  function Navigator3(element, options) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    var navigateUpButton = createButton("up", options.icons);
    var navigateRightlButton = createButton("right", options.icons);
    var navigateDownButton = createButton("down", options.icons);
    var navigateLeftButton = createButton("left", options.icons);
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2) Navigator3.__proto__ = Observable2;
  Navigator3.prototype = Object.create(Observable2 && Observable2.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.destroy = function destroy() {
    this.dispose();
  };
  Navigator3.prototype.dispose = function dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  };
  Navigator3.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  Navigator3.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Navigator3.prototype._pan = function _pan(x, y) {
    var panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x * panStep,
      y: y * panStep
    });
  };
  Navigator3.prototype._click = function _click(e) {
    var x = 0;
    var y = 0;
    var button = e.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y = 1;
    } else if (button.matches(".k-navigator-s")) {
      y = -1;
    } else if (button.matches(".k-navigator-e")) {
      x = 1;
    } else if (button.matches(".k-navigator-w")) {
      x = -1;
    }
    this._pan(x, y);
    e.preventDefault();
  };
  Navigator3.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e.preventDefault();
        break;
      default:
        break;
    }
  };
  return Navigator3;
}(observable_default);
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [PAN]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, icon, iconOptions) {
  var html2 = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '">' + renderIcon({
    icon,
    iconClass: "k-button-icon",
    svgIcons: iconOptions.svgIcons,
    type: iconOptions.type
  }) + "</button>";
  return convertToHtml(html2);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = function(Observable2) {
  function ZoomControl2(element, options, iconOptions) {
    Observable2.call(this);
    this.element = element;
    this._initOptions(options);
    var zoomInButton = createButton2("in", "plus", iconOptions);
    var zoomOutButton = createButton2("out", "minus", iconOptions);
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    this.element.setAttribute("role", "group");
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable2) ZoomControl2.__proto__ = Observable2;
  ZoomControl2.prototype = Object.create(Observable2 && Observable2.prototype);
  ZoomControl2.prototype.constructor = ZoomControl2;
  ZoomControl2.prototype.destroy = function destroy() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  };
  ZoomControl2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  ZoomControl2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  ZoomControl2.prototype._change = function _change(direction) {
    var zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, {
      delta: direction * zoomStep
    });
  };
  ZoomControl2.prototype._click = function _click(e) {
    var button = e.currentTarget;
    var direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e.preventDefault();
  };
  ZoomControl2.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  };
  return ZoomControl2;
}(observable_default);
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [CHANGE]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max = math3.max;
var min = math3.min;
var Extent = function(Class) {
  function Extent2(initialNw, initialSe) {
    Class.call(this);
    var nw = Location.create(initialNw);
    var se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  if (Class) Extent2.__proto__ = Class;
  Extent2.prototype = Object.create(Class && Class.prototype);
  Extent2.prototype.constructor = Extent2;
  var staticAccessors2 = {
    World: {
      configurable: true
    }
  };
  Extent2.prototype.contains = function contains(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  };
  Extent2.prototype.center = function center() {
    var nw = this.nw;
    var se = this.se;
    var lng = nw.lng + (se.lng - nw.lng) / 2;
    var lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  };
  Extent2.prototype.containsAny = function containsAny(locs) {
    var this$1 = this;
    var result = false;
    for (var i = 0; i < locs.length; i++) {
      result = result || this$1.contains(locs[i]);
    }
    return result;
  };
  Extent2.prototype.include = function include(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    nw.lng = min(nw.lng, lng);
    nw.lat = max(nw.lat, lat);
    se.lng = max(se.lng, lng);
    se.lat = min(se.lat, lat);
  };
  Extent2.prototype.includeAll = function includeAll(locs) {
    var this$1 = this;
    for (var i = 0; i < locs.length; i++) {
      this$1.include(locs[i]);
    }
  };
  Extent2.prototype.edges = function edges() {
    var nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  };
  Extent2.prototype.toArray = function toArray() {
    var nw = this.nw, se = this.se;
    return [nw, new Location(nw.lat, se.lng), se, new Location(se.lat, nw.lng)];
  };
  Extent2.prototype.overlaps = function overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  };
  Extent2.create = function create2(a, b) {
    if (a instanceof Extent2) {
      return a;
    } else if (a && b) {
      return new Extent2(a, b);
    } else if (a && a.length === 4 && !b) {
      return new Extent2([a[0], a[1]], [a[2], a[3]]);
    }
  };
  staticAccessors2.World.get = function() {
    return new Extent2([90, -180], [-90, 180]);
  };
  Object.defineProperties(Extent2, staticAccessors2);
  return Extent2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = function(Class) {
  function Tooltip3(widgetService, options) {
    Class.call(this);
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options);
    this.offset = {
      x: 0,
      y: 0
    };
  }
  if (Class) Tooltip3.__proto__ = Class;
  Tooltip3.prototype = Object.create(Class && Class.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  var prototypeAccessors4 = {
    anchor: {
      configurable: true
    }
  };
  Tooltip3.prototype.show = function show2(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(SHOW_TOOLTIP2, Object.assign({
      anchor: this.anchor
    }, args));
    this.visible = true;
  };
  Tooltip3.prototype.hide = function hide2() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  };
  prototypeAccessors4.anchor.get = function() {
    return this._anchor;
  };
  prototypeAccessors4.anchor.set = function(anchor) {
    var documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  };
  Tooltip3.prototype.destroy = function destroy() {
    this.widgetService = null;
  };
  Object.defineProperties(Tooltip3.prototype, prototypeAccessors4);
  return Tooltip3;
}(class_default);
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = function(Class) {
  function Layer2(map3, options) {
    Class.call(this);
    this.support = getSupportedFeatures();
    this._initOptions(options);
    this.map = map3;
    var element = document.createElement("div");
    addClass(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map3.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  if (Class) Layer2.__proto__ = Class;
  Layer2.prototype = Object.create(Class && Class.prototype);
  Layer2.prototype.constructor = Layer2;
  Layer2.prototype.destroy = function destroy() {
    this._deactivate();
  };
  Layer2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Layer2.prototype.show = function show2() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  };
  Layer2.prototype.hide = function hide2() {
    this._deactivate();
    this._setVisibility(false);
  };
  Layer2.prototype.reset = function reset() {
    this._beforeReset();
    this._reset();
  };
  Layer2.prototype._reset = function _reset() {
    this._applyExtent();
  };
  Layer2.prototype._beforeReset = function _beforeReset() {
  };
  Layer2.prototype._resize = function _resize() {
  };
  Layer2.prototype._panEnd = function _panEnd() {
    this._applyExtent();
  };
  Layer2.prototype._applyExtent = function _applyExtent() {
    var options = this.options;
    var zoom = this.map.zoom();
    var matchMinZoom = !defined(options.minZoom) || zoom >= options.minZoom;
    var matchMaxZoom = !defined(options.maxZoom) || zoom <= options.maxZoom;
    var extent = Extent.create(options.extent);
    var inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  };
  Layer2.prototype._setVisibility = function _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  };
  Layer2.prototype._activate = function _activate() {
    var map3 = this.map;
    this._deactivate();
    map3.bind("beforeReset", this._beforeReset);
    map3.bind("reset", this._reset);
    map3.bind("resize", this._resize);
    map3.bind("panEnd", this._panEnd);
  };
  Layer2.prototype._deactivate = function _deactivate() {
    var map3 = this.map;
    map3.unbind("beforeReset", this._beforeReset);
    map3.unbind("reset", this._reset);
    map3.unbind("resize", this._resize);
    map3.unbind("panEnd", this._panEnd);
  };
  Layer2.prototype._updateAttribution = function _updateAttribution() {
    var attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  };
  Layer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  Layer2.prototype._hasData = function _hasData() {
    return this._data && this._data.length > 0;
  };
  Layer2.prototype._layerIndex = function _layerIndex() {
    var layers = this.map.layers || [];
    return layers.indexOf(this);
  };
  return Layer2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point5 = geometry_exports.Point;
function compileTemplate(template2) {
  if (isFunction(template2)) {
    return template2;
  }
  return template_service_default.compile(template2);
}
function roundPoint(point) {
  return new Point5(round(point.x), round(point.y));
}
function renderSize(size) {
  var newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = function(Layer2) {
  function TileLayer2(map3, options) {
    Layer2.call(this, map3, options);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    var viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  if (Layer2) TileLayer2.__proto__ = Layer2;
  TileLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  TileLayer2.prototype.constructor = TileLayer2;
  TileLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    this._view.destroy();
    this._view = null;
  };
  TileLayer2.prototype._beforeReset = function _beforeReset() {
    var map3 = this.map;
    var origin = map3.locationToLayer(map3.extent().nw).round();
    this._view.viewOrigin(origin);
  };
  TileLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._updateView();
    this._view.reset();
  };
  TileLayer2.prototype._viewType = function _viewType() {
    return TileView;
  };
  TileLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  };
  TileLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  };
  TileLayer2.prototype._updateView = function _updateView() {
    var view = this._view, map3 = this.map, extent = map3.extent(), extentToPoint = {
      nw: map3.locationToLayer(extent.nw).round(),
      se: map3.locationToLayer(extent.se).round()
    };
    view.center(map3.locationToLayer(map3.center()));
    view.extent(extentToPoint);
    view.zoom(map3.zoom());
  };
  TileLayer2.prototype._resize = function _resize() {
    this._render();
  };
  TileLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._render();
  };
  TileLayer2.prototype._render = function _render() {
    this._updateView();
    this._view.render();
  };
  return TileLayer2;
}(Layer);
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = function(Class) {
  function TileView2(element, options) {
    Class.call(this);
    this.element = element;
    this._initOptions(options);
    this.pool = new TilePool();
  }
  if (Class) TileView2.__proto__ = Class;
  TileView2.prototype = Object.create(Class && Class.prototype);
  TileView2.prototype.constructor = TileView2;
  TileView2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  TileView2.prototype.center = function center(center$1) {
    this._center = center$1;
  };
  TileView2.prototype.extent = function extent(extent$1) {
    this._extent = extent$1;
  };
  TileView2.prototype.viewOrigin = function viewOrigin(origin) {
    this._viewOrigin = origin;
  };
  TileView2.prototype.zoom = function zoom(zoom$1) {
    this._zoom = zoom$1;
  };
  TileView2.prototype.pointToTileIndex = function pointToTileIndex(point) {
    return new Point5(math4.floor(point.x / this.options.tileSize), math4.floor(point.y / this.options.tileSize));
  };
  TileView2.prototype.tileCount = function tileCount() {
    var size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point.y) + size.height) / this.options.tileSize)
    };
  };
  TileView2.prototype.size = function size() {
    var nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  };
  TileView2.prototype.indexToPoint = function indexToPoint(index) {
    var x = index.x, y = index.y;
    return new Point5(x * this.options.tileSize, y * this.options.tileSize);
  };
  TileView2.prototype.subdomainText = function subdomainText() {
    var subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  };
  TileView2.prototype.destroy = function destroy() {
    removeChildren(this.element);
    this.pool.empty();
  };
  TileView2.prototype.reset = function reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  };
  TileView2.prototype.render = function render() {
    var this$1 = this;
    var size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x, y;
    for (x = 0; x < size.x; x++) {
      for (y = 0; y < size.y; y++) {
        tile = this$1.createTile({
          x: firstTileIndex.x + x,
          y: firstTileIndex.y + y
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  };
  TileView2.prototype.createTile = function createTile(currentIndex) {
    var options = this.tileOptions(currentIndex);
    var tile = this.pool.get(this._center, options);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  };
  TileView2.prototype.tileOptions = function tileOptions(currentIndex) {
    var index = this.wrapIndex(currentIndex), point = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset = point.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point,
      offset: roundPoint(offset),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  };
  TileView2.prototype.wrapIndex = function wrapIndex(index) {
    var boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue(index.y, 0, boundary - 1)
    };
  };
  TileView2.prototype.wrapValue = function wrapValue(value2, boundary) {
    var remainder = math4.abs(value2) % boundary;
    var wrappedValue = value2;
    if (value2 >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  };
  return TileView2;
}(class_default);
var ImageTile = function(Class) {
  function ImageTile2(id, options) {
    Class.call(this);
    this.id = id;
    this.visible = true;
    this._initOptions(options);
    this.createElement();
    this.show();
  }
  if (Class) ImageTile2.__proto__ = Class;
  ImageTile2.prototype = Object.create(Class && Class.prototype);
  ImageTile2.prototype.constructor = ImageTile2;
  ImageTile2.prototype.destroy = function destroy() {
    var element = this.element;
    var parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  };
  ImageTile2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  ImageTile2.prototype.createElement = function createElement() {
    var el = document.createElement("img");
    var size = this.options.size + "px";
    el.setAttribute("alt", "");
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  };
  ImageTile2.prototype.show = function show2() {
    var element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    var url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  };
  ImageTile2.prototype.hide = function hide2() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  };
  ImageTile2.prototype.url = function url() {
    var urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.errorUrl = function errorUrl() {
    var urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.urlOptions = function urlOptions() {
    var options = this.options;
    return {
      zoom: options.zoom,
      subdomain: options.subdomain,
      z: options.zoom,
      x: options.index.x,
      y: options.index.y,
      s: options.subdomain,
      quadkey: options.quadkey,
      q: options.quadkey,
      culture: options.culture,
      c: options.culture
    };
  };
  return ImageTile2;
}(class_default);
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = function(Class) {
  function TilePool2() {
    Class.call(this);
    this._items = [];
  }
  if (Class) TilePool2.__proto__ = Class;
  TilePool2.prototype = Object.create(Class && Class.prototype);
  TilePool2.prototype.constructor = TilePool2;
  TilePool2.prototype.get = function get3(center, options) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options);
  };
  TilePool2.prototype.empty = function empty() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].destroy();
    }
    this._items = [];
  };
  TilePool2.prototype.reset = function reset() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].hide();
    }
  };
  TilePool2.prototype._create = function _create(options) {
    var items = this._items;
    var tile;
    var id = hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);
    for (var i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        tile = items[i];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options);
      this._items.push(tile);
    }
    return tile;
  };
  TilePool2.prototype._remove = function _remove(center) {
    var items = this._items;
    var maxDist = -1;
    var index = -1;
    for (var i = 0; i < items.length; i++) {
      var dist = items[i].options.point.distanceTo(center);
      if (dist > maxDist && !items[i].visible) {
        index = i;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  };
  return TilePool2;
}(class_default);
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend11 = Object.assign;
var CHANGE2 = "change";
var TapCapture = function(Observable2) {
  function TapCapture2(element, options) {
    Observable2.call(this);
    var that = this, domElement = element[0] || element;
    that.capture = false;
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind(["press", "release"], options || {});
  }
  if (Observable2) TapCapture2.__proto__ = Observable2;
  TapCapture2.prototype = Object.create(Observable2 && Observable2.prototype);
  TapCapture2.prototype.constructor = TapCapture2;
  TapCapture2.prototype.captureNext = function captureNext() {
    this.capture = true;
  };
  TapCapture2.prototype.cancelCapture = function cancelCapture() {
    this.capture = false;
  };
  TapCapture2.prototype._press = function _press(e) {
    var that = this;
    that.trigger("press");
    if (that.capture) {
      e.preventDefault();
    }
  };
  TapCapture2.prototype._release = function _release(e) {
    var that = this;
    that.trigger("release");
    if (that.capture) {
      e.preventDefault();
      that.cancelCapture();
    }
  };
  return TapCapture2;
}(observable_default);
var PaneDimension = function(Observable2) {
  function PaneDimension2(options) {
    Observable2.call(this);
    var that = this;
    that.forcedEnabled = false;
    extend11(that, options);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  if (Observable2) PaneDimension2.__proto__ = Observable2;
  PaneDimension2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimension2.prototype.constructor = PaneDimension2;
  PaneDimension2.prototype.makeVirtual = function makeVirtual() {
    extend11(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  };
  PaneDimension2.prototype.virtualSize = function virtualSize(min4, max3) {
    if (this._virtualMin !== min4 || this._virtualMax !== max3) {
      this._virtualMin = min4;
      this._virtualMax = max3;
      this.update();
    }
  };
  PaneDimension2.prototype.outOfBounds = function outOfBounds(offset) {
    return offset > this.max || offset < this.min;
  };
  PaneDimension2.prototype.forceEnabled = function forceEnabled() {
    this.forcedEnabled = true;
  };
  PaneDimension2.prototype.getSize = function getSize() {
    return this.container[this.measure];
  };
  PaneDimension2.prototype.getTotal = function getTotal() {
    return this.element[this.scrollSize];
  };
  PaneDimension2.prototype.rescale = function rescale(scale) {
    this.scale = scale;
  };
  PaneDimension2.prototype.update = function update(silent) {
    var that = this, total3 = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total3 * that.scale, size = that.getSize();
    if (total3 === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total3;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  };
  return PaneDimension2;
}(observable_default);
var PaneDimensions = function(Observable2) {
  function PaneDimensions2(options) {
    Observable2.call(this);
    var that = this;
    that.x = new PaneDimension(extend11({
      horizontal: true
    }, options));
    that.y = new PaneDimension(extend11({
      horizontal: false
    }, options));
    that.container = options.container;
    that.forcedMinScale = options.minScale;
    that.maxScale = options.maxScale || 100;
    that.bind(CHANGE2, options);
  }
  if (Observable2) PaneDimensions2.__proto__ = Observable2;
  PaneDimensions2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneDimensions2.prototype.constructor = PaneDimensions2;
  PaneDimensions2.prototype.rescale = function rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  };
  PaneDimensions2.prototype.centerCoordinates = function centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  };
  PaneDimensions2.prototype.refresh = function refresh() {
    var that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  };
  return PaneDimensions2;
}(observable_default);
var PaneAxis = function(Observable2) {
  function PaneAxis2(options) {
    Observable2.call(this);
    extend11(this, options);
  }
  if (Observable2) PaneAxis2.__proto__ = Observable2;
  PaneAxis2.prototype = Object.create(Observable2 && Observable2.prototype);
  PaneAxis2.prototype.constructor = PaneAxis2;
  PaneAxis2.prototype.outOfBounds = function outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  };
  PaneAxis2.prototype.dragMove = function dragMove(delta) {
    var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    var dragDelta = delta;
    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  };
  return PaneAxis2;
}(observable_default);
var Pane2 = function(Class) {
  function Pane3(options) {
    Class.call(this);
    var that = this, x, y, resistance, movable;
    extend11(that, {
      elastic: true
    }, options);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind(["press", "move", "end", "gesturestart", "gesturechange"], {
      gesturestart: function gesturestart(e) {
        that.gesture = e;
        that.offset = elementOffset(that.dimensions.container);
      },
      press: function press(e) {
        var closestAnchor = e.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e.sender.cancel();
        }
      },
      gesturechange: function gesturechange(e) {
        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e.center, scaleDelta = e.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x.dragMove(coordinates.x);
        y.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e;
        e.preventDefault();
      },
      move: function move(e) {
        if (e.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x.dimension.enabled || y.dimension.enabled) {
          x.dragMove(e.x.delta);
          y.dragMove(e.y.delta);
          e.preventDefault();
        } else {
          e.touch.skip();
        }
      },
      end: function end(e) {
        e.preventDefault();
      }
    });
  }
  if (Class) Pane3.__proto__ = Class;
  Pane3.prototype = Object.create(Class && Class.prototype);
  Pane3.prototype.constructor = Pane3;
  return Pane3;
}(class_default);
var translate = function(x, y, scale) {
  return "translate3d(" + x + "px," + y + "px,0) scale(" + scale + ")";
};
var Movable = function(Observable2) {
  function Movable2(element) {
    Observable2.call(this);
    var that = this;
    that.element = element;
    that.element.style.transformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    var coordinates = translate(that.x, that.y, that.scale);
    that.element.style.transform = coordinates;
    that._saveCoordinates(coordinates);
  }
  if (Observable2) Movable2.__proto__ = Observable2;
  Movable2.prototype = Object.create(Observable2 && Observable2.prototype);
  Movable2.prototype.constructor = Movable2;
  Movable2.prototype.translateAxis = function translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  };
  Movable2.prototype.scaleTo = function scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  };
  Movable2.prototype.scaleWith = function scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  };
  Movable2.prototype.translate = function translate2(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  };
  Movable2.prototype.moveAxis = function moveAxis(axis, value2) {
    this[axis] = value2;
    this.refresh();
  };
  Movable2.prototype.moveTo = function moveTo(coordinates) {
    extend11(this, coordinates);
    this.refresh();
  };
  Movable2.prototype.refresh = function refresh() {
    var that = this, x = that.x, y = that.y, newCoordinates;
    if (that.round) {
      x = Math.round(x);
      y = Math.round(y);
    }
    newCoordinates = translate(x, y, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style.transform = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  };
  Movable2.prototype._saveCoordinates = function _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  };
  return Movable2;
}(observable_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group8 = drawing_exports.Group;
var ShapeLayer = function(Layer2) {
  function ShapeLayer2(map3, options) {
    Layer2.call(this, map3, options);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map3.scrollElement.clientWidth,
      height: map3.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  if (Layer2) ShapeLayer2.__proto__ = Layer2;
  ShapeLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  ShapeLayer2.prototype.constructor = ShapeLayer2;
  ShapeLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    this.surface.destroy();
  };
  ShapeLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  };
  ShapeLayer2.prototype._initRoot = function _initRoot() {
    this._root = new Group8();
    this.surface.draw(this._root);
  };
  ShapeLayer2.prototype._beforeReset = function _beforeReset() {
    this.surface.clear();
    this._initRoot();
  };
  ShapeLayer2.prototype._resize = function _resize() {
    this.surface.size(this.map.size());
  };
  ShapeLayer2.prototype._readData = function _readData() {
    var data = Layer2.prototype._readData.call(this);
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  };
  ShapeLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    var container = new Group8();
    for (var i = 0; i < data.length; i++) {
      var shape = this$1._loader.parse(data[i]);
      if (shape) {
        container.append(shape);
      }
    }
    this._root.clear();
    this._root.append(container);
  };
  ShapeLayer2.prototype.shapeCreated = function shapeCreated(shape) {
    var cancelled = false;
    if (shape instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined(this._createMarker(shape));
    }
    if (!cancelled) {
      var args = {
        layer: this,
        shape
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  };
  ShapeLayer2.prototype.featureCreated = function featureCreated(e) {
    e.layer = this;
    this.map.trigger("shapeFeatureCreated", e);
  };
  ShapeLayer2.prototype._createMarker = function _createMarker(shape) {
    var marker = this.map.markers.bind({
      location: shape.location
    }, shape.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  };
  ShapeLayer2.prototype._clearMarkers = function _clearMarkers() {
    var this$1 = this;
    for (var i = 0; i < this._markers.length; i++) {
      this$1.map.markers.remove(this$1._markers[i]);
    }
    this._markers = [];
  };
  ShapeLayer2.prototype._pan = function _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  };
  ShapeLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  };
  ShapeLayer2.prototype._translateSurface = function _translateSurface() {
    var map3 = this.map;
    var nw = map3.locationToView(map3.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  };
  ShapeLayer2.prototype._eventArgs = function _eventArgs(e) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e.element,
      shapeIndex: (this._data || []).indexOf(e.element.dataItem),
      originalEvent: e.originalEvent
    };
  };
  ShapeLayer2.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      if (e.element) {
        this$1.map.trigger(eventName, this$1._eventArgs(e));
      }
    };
  };
  ShapeLayer2.prototype._mouseenter = function _mouseenter(e) {
    if (!e.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e));
    var shape = e.element;
    var anchor = this._tooltipAnchor(e);
    this.map._tooltip.show(anchor, this._tooltipContext(shape));
  };
  ShapeLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape.dataItem,
      location: shape.location
    };
  };
  ShapeLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var cursor = this.map.eventOffset(e.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  };
  ShapeLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  };
  ShapeLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    this.map.unbind("pan", this._panHandler);
  };
  return ShapeLayer2;
}(Layer);
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = function(Class) {
  function GeoJsonLoader2(locator, defaultStyle, observer) {
    Class.call(this);
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  if (Class) GeoJsonLoader2.__proto__ = Class;
  GeoJsonLoader2.prototype = Object.create(Class && Class.prototype);
  GeoJsonLoader2.prototype.constructor = GeoJsonLoader2;
  GeoJsonLoader2.prototype.parse = function parse(item) {
    var root = new Group8();
    var unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  };
  GeoJsonLoader2.prototype._shapeCreated = function _shapeCreated(shape) {
    var cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape);
    }
    return cancelled;
  };
  GeoJsonLoader2.prototype._featureCreated = function _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  };
  GeoJsonLoader2.prototype._loadGeometryTo = function _loadGeometryTo(container, geometry, dataItem) {
    var this$1 = this;
    var coords = geometry.coordinates;
    var i;
    var path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i = 0; i < coords.length; i++) {
          path = this$1._loadPolygon(container, [coords[i]], dataItem);
          this$1._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPolygon(container, coords[i], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPoint(container, coords[i], dataItem);
        }
        break;
      default:
        break;
    }
  };
  GeoJsonLoader2.prototype._setLineFill = function _setLineFill(path) {
    var segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {
      path.options.fill = null;
    }
  };
  GeoJsonLoader2.prototype._loadShape = function _loadShape(container, shape) {
    if (!this._shapeCreated(shape)) {
      container.append(shape);
    }
    return shape;
  };
  GeoJsonLoader2.prototype._loadPolygon = function _loadPolygon(container, rings, dataItem) {
    var shape = this._buildPolygon(rings);
    shape.dataItem = dataItem;
    shape.location = this.locator.viewToLocation(shape.bbox().center());
    return this._loadShape(container, shape);
  };
  GeoJsonLoader2.prototype._buildPolygon = function _buildPolygon(rings) {
    var this$1 = this;
    var type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    var path = new type(this.style);
    for (var i = 0; i < rings.length; i++) {
      for (var j = 0; j < rings[i].length; j++) {
        var point = this$1.locator.locationToView(Location.fromLngLat(rings[i][j]));
        if (j === 0) {
          path.moveTo(point.x, point.y);
        } else {
          path.lineTo(point.x, point.y);
        }
      }
    }
    return path;
  };
  GeoJsonLoader2.prototype._loadPoint = function _loadPoint(container, coords, dataItem) {
    var location = Location.fromLngLat(coords);
    var point = this.locator.locationToView(location);
    var circle = new geometry_exports.Circle(point, 10);
    var shape = new drawing_exports.Circle(circle, this.style);
    shape.dataItem = dataItem;
    shape.location = location;
    return this._loadShape(container, shape);
  };
  return GeoJsonLoader2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = function(ShapeLayer2) {
  function BubbleLayer2() {
    ShapeLayer2.apply(this, arguments);
  }
  if (ShapeLayer2) BubbleLayer2.__proto__ = ShapeLayer2;
  BubbleLayer2.prototype = Object.create(ShapeLayer2 && ShapeLayer2.prototype);
  BubbleLayer2.prototype.constructor = BubbleLayer2;
  BubbleLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  BubbleLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    var options = this.options;
    var getValue = getter2(options.valueField);
    var newData = data.slice(0);
    newData.sort(function(a, b) {
      return getValue(b) - getValue(a);
    });
    var scaleType = this._scaleType();
    var scale;
    var getLocation = getter2(this.options.locationField);
    for (var i = 0; i < newData.length; i++) {
      var dataItem = newData[i];
      var location = getLocation(dataItem);
      var value2 = getValue(dataItem);
      if (defined(location) && defined(value2)) {
        if (!scale) {
          scale = new scaleType([0, value2], [options.minSize, options.maxSize]);
        }
        location = Location.create(location);
        var center = this$1.map.locationToView(location);
        var size = scale.map(value2);
        var symbol = this$1._createSymbol({
          center,
          size,
          style: options.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value2;
        this$1._drawSymbol(symbol);
      }
    }
  };
  BubbleLayer2.prototype._scaleType = function _scaleType() {
    var scale = this.options.scale;
    if (isFunction(scale)) {
      return scale;
    }
    return Scales[scale];
  };
  BubbleLayer2.prototype._createSymbol = function _createSymbol(args) {
    var symbol = this.options.symbol;
    if (!isFunction(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  };
  BubbleLayer2.prototype._drawSymbol = function _drawSymbol(shape) {
    var args = {
      layer: this,
      shape
    };
    var cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape);
    }
  };
  BubbleLayer2.prototype._tooltipContext = function _tooltipContext(shape) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape.dataItem,
      location: shape.location,
      value: shape.value
    };
  };
  BubbleLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var shape = e.element;
    var center = shape.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  };
  return BubbleLayer2;
}(ShapeLayer);
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = function(Class) {
  function SqrtScale2(domain, range) {
    Class.call(this);
    this._domain = domain;
    this._range = range;
    var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    var outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  if (Class) SqrtScale2.__proto__ = Class;
  SqrtScale2.prototype = Object.create(Class && Class.prototype);
  SqrtScale2.prototype.constructor = SqrtScale2;
  SqrtScale2.prototype.map = function map3(value2) {
    var rel = (Math.sqrt(value2) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  };
  return SqrtScale2;
}(class_default);
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    var geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    var path = new drawing_exports.Path(args.style);
    var halfSize = args.size / 2;
    var center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend12 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = function(Layer2) {
  function MarkerLayer2(map3, options) {
    Layer2.call(this, map3, options);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  if (Layer2) MarkerLayer2.__proto__ = Layer2;
  MarkerLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  MarkerLayer2.prototype.constructor = MarkerLayer2;
  MarkerLayer2.prototype.destroy = function destroy() {
    Layer2.prototype.destroy.call(this);
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  };
  MarkerLayer2.prototype.add = function add3(args) {
    var this$1 = this;
    if (isArray(args)) {
      for (var i = 0; i < args.length; i++) {
        this$1._addOne(args[i]);
      }
    } else {
      return this._addOne(args);
    }
  };
  MarkerLayer2.prototype.remove = function remove(marker) {
    marker.destroy();
    var index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  };
  MarkerLayer2.prototype.clear = function clear3() {
    var this$1 = this;
    for (var i = 0; i < this.items.length; i++) {
      this$1.items[i].destroy();
    }
    this.items = [];
  };
  MarkerLayer2.prototype.update = function update(marker) {
    var location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      var args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  };
  MarkerLayer2.prototype._reset = function _reset() {
    var this$1 = this;
    Layer2.prototype._reset.call(this);
    var items = this.items;
    for (var i = 0; i < items.length; i++) {
      this$1.update(items[i]);
    }
  };
  MarkerLayer2.prototype.bind = function bind(options, dataItem) {
    var marker = Marker.create(options, this.options);
    marker.dataItem = dataItem;
    var args = {
      marker,
      layer: this
    };
    var cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  };
  MarkerLayer2.prototype._addOne = function _addOne(arg) {
    var marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  };
  MarkerLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  MarkerLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.clear();
    var getLocation = getter2(this.options.locationField);
    var getTitle = getter2(this.options.titleField);
    for (var i = 0; i < data.length; i++) {
      var dataItem = data[i];
      this$1.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  };
  MarkerLayer2.prototype._markerClick = function _markerClick(e) {
    var marker = e.currentTarget._kendoNode;
    var args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e
    };
    this.map.trigger("markerClick", args);
  };
  MarkerLayer2.prototype._markerMouseEnter = function _markerMouseEnter(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseEnter", args);
  };
  MarkerLayer2.prototype._markerMouseLeave = function _markerMouseLeave(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseLeave", args);
  };
  MarkerLayer2.prototype._createMarkerEventArgs = function _createMarkerEventArgs(e) {
    var marker = e.marker;
    var args = extend12({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e);
    return args;
  };
  return MarkerLayer2;
}(Layer);
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = function(Class) {
  function Marker2(options) {
    Class.call(this);
    this.options = options || {};
  }
  if (Class) Marker2.__proto__ = Class;
  Marker2.prototype = Object.create(Class && Class.prototype);
  Marker2.prototype.constructor = Marker2;
  Marker2.prototype.destroy = function destroy() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  };
  Marker2.prototype.addTo = function addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  };
  Marker2.prototype.location = function location(value2) {
    if (value2) {
      this.options.location = Location.create(value2).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  };
  Marker2.prototype.showAt = function showAt(point) {
    this.render();
    this._anchor = {
      left: Math.round(point.x),
      top: Math.round(point.y)
    };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  };
  Marker2.prototype.hide = function hide2() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  };
  Marker2.prototype.bindEvents = function bindEvents2() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  };
  Marker2.prototype.unbindEvents = function unbindEvents2() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  };
  Marker2.prototype.render = function render() {
    if (!this.element) {
      var options = this.options;
      var layer = this.layer;
      var element = document.createElement("span");
      addClass(element, MARKER_CLASS_NAME);
      if (this.options.template) {
        var templateFn = this._compileTemplate(this.options.template);
        var templateHtml = templateFn(this.dataItem);
        var templateElement = convertToHtml(templateHtml);
        element.appendChild(templateElement);
      } else if (options.svgIcon) {
        renderIcon(element, {
          icon: options.svgIcon,
          iconClass: "k-icon-xxl",
          svgIcons: this.options.icons.svgIcons,
          type: "svg"
        });
      } else {
        var iconOptions = {
          icon: "map-marker",
          iconClass: "k-icon-xxl",
          svgIcons: this.options.icons.svgIcons,
          type: this.options.icons.type
        };
        if (options.shape) {
          if (options.shape === "pinTarget") {
            iconOptions.icon = "map-marker-target";
            renderIcon(element, iconOptions);
          } else if (options.shape === "pin") {
            renderIcon(element, iconOptions);
          } else {
            addClass(element, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options.shape || "pin"));
          }
        } else {
          renderIcon(element, iconOptions);
        }
      }
      if (options.title) {
        element.setAttribute("title", options.title);
      }
      var attributes = options.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element.setAttribute(key, attributes[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  };
  Marker2.prototype._mouseEnter = function _mouseEnter(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  };
  Marker2.prototype._tooltipContext = function _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  };
  Marker2.prototype._mouseLeave = function _mouseLeave(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseLeave(args);
  };
  Marker2.prototype._createEventArgs = function _createEventArgs(e) {
    var args = {
      marker: this,
      originalEvent: e
    };
    return args;
  };
  Marker2.prototype._compileTemplate = function _compileTemplate(template2) {
    return template_service_default.compile(template2, {
      paramName: "dataItem",
      useWithBlock: false
    });
  };
  Marker2.create = function create2(arg, defaults) {
    if (arg instanceof Marker2) {
      return arg;
    }
    return new Marker2(deepExtend({}, defaults, arg));
  };
  return Marker2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend13 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation = function(Class) {
  function Animation2() {
    Class.call(this);
    var that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  if (Class) Animation2.__proto__ = Class;
  Animation2.prototype = Object.create(Class && Class.prototype);
  Animation2.prototype.constructor = Animation2;
  Animation2.prototype.tick = function tick() {
  };
  Animation2.prototype.done = function done() {
  };
  Animation2.prototype.onEnd = function onEnd() {
  };
  Animation2.prototype.onCancel = function onCancel() {
  };
  Animation2.prototype.start = function start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  };
  Animation2.prototype.enabled = function enabled() {
    return true;
  };
  Animation2.prototype.cancel = function cancel() {
    this._started = false;
    this.onCancel();
  };
  Animation2.prototype._tick = function _tick() {
    var that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  };
  return Animation2;
}(class_default);
var Transition = function(Animation2) {
  function Transition2(options) {
    Animation2.call(this);
    extend13(this, options);
  }
  if (Animation2) Transition2.__proto__ = Animation2;
  Transition2.prototype = Object.create(Animation2 && Animation2.prototype);
  Transition2.prototype.constructor = Transition2;
  Transition2.prototype.done = function done() {
    return this.timePassed() >= this.duration;
  };
  Transition2.prototype.timePassed = function timePassed() {
    return Math.min(this.duration, now() - this.startDate);
  };
  Transition2.prototype.moveTo = function moveTo(options) {
    var that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options.location - that.initial;
    that.duration = typeof options.duration === "number" ? options.duration : 300;
    that.tick = that._easeProxy(options.ease);
    that.startDate = now();
    that.start();
  };
  Transition2.prototype._easeProxy = function _easeProxy(ease) {
    var that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  };
  Transition2.easeOutExpo = function easeOutExpo(t, b, c, d) {
    return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  };
  return Transition2;
}(Animation);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = function(Animation2) {
  function ZoomSnapBack2(options) {
    Animation2.call(this, options);
    var that = this;
    extend14(that, options);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  if (Animation2) ZoomSnapBack2.__proto__ = Animation2;
  ZoomSnapBack2.prototype = Object.create(Animation2 && Animation2.prototype);
  ZoomSnapBack2.prototype.constructor = ZoomSnapBack2;
  ZoomSnapBack2.prototype.enabled = function enabled() {
    return this.movable.scale < this.dimensions.minScale;
  };
  ZoomSnapBack2.prototype.done = function done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  };
  ZoomSnapBack2.prototype.tick = function tick() {
    var movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  };
  ZoomSnapBack2.prototype.onEnd = function onEnd() {
    var movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  };
  return ZoomSnapBack2;
}(Animation);
var DragInertia = function(Animation2) {
  function DragInertia2(options) {
    Animation2.call(this);
    var that = this;
    extend14(that, options, {
      transition: new Transition({
        axis: options.axis,
        movable: options.movable,
        onEnd: function onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  if (Animation2) DragInertia2.__proto__ = Animation2;
  DragInertia2.prototype = Object.create(Animation2 && Animation2.prototype);
  DragInertia2.prototype.constructor = DragInertia2;
  DragInertia2.prototype.onCancel = function onCancel() {
    this.transition.cancel();
  };
  DragInertia2.prototype.freeze = function freeze(location) {
    var that = this;
    that.cancel();
    that._moveTo(location);
  };
  DragInertia2.prototype.onEnd = function onEnd() {
    var that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  };
  DragInertia2.prototype.done = function done() {
    return abs2(this.velocity) < 1;
  };
  DragInertia2.prototype.start = function start(e) {
    var that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        Animation2.prototype.start.call(this);
      } else {
        that._snapBack();
      }
    } else {
      velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      Animation2.prototype.start.call(this);
    }
  };
  DragInertia2.prototype.tick = function tick() {
    var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  };
  DragInertia2.prototype._end = function _end() {
    this.tapCapture.cancelCapture();
    this.end();
  };
  DragInertia2.prototype._snapBack = function _snapBack() {
    var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  };
  DragInertia2.prototype._moveTo = function _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  };
  return DragInertia2;
}(Animation);
var AnimatedScroller = function(Animation2) {
  function AnimatedScroller2(options) {
    Animation2.call(this, options);
    var that = this;
    extend14(that, options, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  if (Animation2) AnimatedScroller2.__proto__ = Animation2;
  AnimatedScroller2.prototype = Object.create(Animation2 && Animation2.prototype);
  AnimatedScroller2.prototype.constructor = AnimatedScroller2;
  AnimatedScroller2.prototype.tick = function tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  };
  AnimatedScroller2.prototype.done = function done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  };
  AnimatedScroller2.prototype.onEnd = function onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  };
  AnimatedScroller2.prototype.setCoordinates = function setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  };
  AnimatedScroller2.prototype.setCallback = function setCallback(callback) {
    if (callback && isFunction(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  };
  AnimatedScroller2.prototype._updateCoordinates = function _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  };
  return AnimatedScroller2;
}(Animation);
var ScrollBar = function(Class) {
  function ScrollBar2(options) {
    Class.call(this);
    var that = this, horizontal = options.axis === "x";
    var orientation = horizontal ? "horizontal" : "vertical";
    var element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options.movable,
      alwaysVisible: options.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options.alwaysVisible) {
      that.show();
    }
  }
  if (Class) ScrollBar2.__proto__ = Class;
  ScrollBar2.prototype = Object.create(Class && Class.prototype);
  ScrollBar2.prototype.constructor = ScrollBar2;
  ScrollBar2.prototype.refresh = function refresh() {
    var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position + size > paneSize) {
      size = paneSize - position;
    } else if (position < 0) {
      size += position;
      position = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position);
  };
  ScrollBar2.prototype.show = function show2() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  };
  ScrollBar2.prototype.hide = function hide2() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  };
  return ScrollBar2;
}(class_default);
var Scroller = function(Observable2) {
  function Scroller2(element, options) {
    Observable2.call(this);
    var that = this;
    this.element = element;
    this._initOptions(options);
    var hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    var scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend14(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass(element, "km-scroll-wrapper");
    var scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    var inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling2 = this.options.avoidScrolling, userEvents = new user_events_default(element, {
      touchAction: "none",
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start: function start(e) {
        dimensions.refresh();
        var velocityX = abs2(e.x.velocity), velocityY = abs2(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = that.fixedContainer.contains(e.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling2(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo: function moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "wheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  if (Observable2) Scroller2.__proto__ = Observable2;
  Scroller2.prototype = Object.create(Observable2 && Observable2.prototype);
  Scroller2.prototype.constructor = Scroller2;
  Scroller2.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Scroller2.prototype._wheelScroll = function _wheelScroll(e) {
    if (e.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    var delta = wheelDeltaY(e);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e.preventDefault();
  };
  Scroller2.prototype.makeVirtual = function makeVirtual() {
    this.dimensions.y.makeVirtual();
  };
  Scroller2.prototype.virtualSize = function virtualSize(min4, max3) {
    this.dimensions.y.virtualSize(min4, max3);
  };
  Scroller2.prototype.height = function height() {
    return this.dimensions.y.size;
  };
  Scroller2.prototype.scrollHeight = function scrollHeight() {
    return this.scrollElement.scrollHeight;
  };
  Scroller2.prototype.scrollWidth = function scrollWidth() {
    return this.scrollElement.scrollWidth;
  };
  Scroller2.prototype._resize = function _resize() {
    if (!this._native) {
      this.contentResized();
    }
  };
  Scroller2.prototype.setOptions = function setOptions(options) {
    var that = this;
    this._initOptions(options);
    if (options.pullToRefresh) {
      that._initPullToRefresh();
    }
  };
  Scroller2.prototype.reset = function reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  };
  Scroller2.prototype.contentResized = function contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  };
  Scroller2.prototype.zoomOut = function zoomOut() {
    var dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  };
  Scroller2.prototype.enable = function enable() {
    this.enabled = true;
  };
  Scroller2.prototype.disable = function disable() {
    this.enabled = false;
  };
  Scroller2.prototype.scrollTo = function scrollTo(x, y) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x));
      this.scrollElement.scrollTop(abs2(y));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x,
        y
      });
    }
  };
  Scroller2.prototype.animatedScrollTo = function animatedScrollTo(x, y, callback) {
    var from, to;
    if (this._native) {
      this.scrollTo(x, y);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x,
        y
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  };
  Scroller2.prototype.pullHandled = function pullHandled() {
  };
  Scroller2.prototype.destroy = function destroy() {
    var element = this.element;
    off(element, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  };
  Scroller2.prototype._scale = function _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  };
  Scroller2.prototype._initPullToRefresh = function _initPullToRefresh() {
  };
  Scroller2.prototype._dragEnd = function _dragEnd() {
  };
  Scroller2.prototype._paneChange = function _paneChange() {
  };
  Scroller2.prototype._initAxis = function _initAxis(axis) {
    var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end: function end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  };
  return Scroller2;
}(observable_default);
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling: function avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [PULL, SCROLL, RESIZE]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = function MapService2(widget, context) {
  if (context === void 0) context = {};
  this.sender = context.sender || widget;
  this.widget = widget;
  this.rtl = Boolean(context.rtl);
};
MapService.prototype.notify = function notify2(name2, args) {
  if (this.widget) {
    this.widget.trigger(name2, args);
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min2 = math5.min;
var pow2 = math5.pow;
var Point6 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "wheel";
var MOUSEWHEEL_THROTTLE = 50;
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer
};
layersMap[MARKER] = MarkerLayer;
var Map2 = function(Observable2) {
  function Map3(element, options, themeOptions, context) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (context === void 0) context = {};
    Observable2.call(this);
    this._init(element, options, themeOptions, context);
  }
  if (Observable2) Map3.__proto__ = Observable2;
  Map3.prototype = Object.create(Observable2 && Observable2.prototype);
  Map3.prototype.constructor = Map3;
  Map3.prototype.destroy = function destroy() {
    var this$1 = this;
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach(function(markerLayer) {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (var i = 0; i < this.layers.length; i++) {
      this$1.layers[i].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    Observable2.prototype.destroy.call(this);
  };
  Map3.prototype._init = function _init(element, options, themeOptions, context) {
    if (options === void 0) options = {};
    if (themeOptions === void 0) themeOptions = {};
    if (context === void 0) context = {};
    this.support = getSupportedFeatures();
    this.context = context;
    this.initObserver(context);
    this.initServices(context);
    this._notifyObserver(INIT);
    this._initOptions(options);
    this._setEvents(options);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    var mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = function(e) {
      e.preventDefault();
      mousewheelThrottled(e);
    };
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  };
  Map3.prototype._initOptions = function _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  Map3.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    var div = convertToHtml("<div />");
    this.element.appendChild(div);
  };
  Map3.prototype.initServices = function initServices(context) {
    if (context === void 0) context = {};
    this.widgetService = new map_service_default(this, context);
  };
  Map3.prototype.initObserver = function initObserver(context) {
    if (context === void 0) context = {};
    this.observers = [];
    this.addObserver(context.observer);
  };
  Map3.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Map3.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Map3.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Map3.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    if (!isDefaultPrevented2) {
      Observable2.prototype.trigger.call(this, name2, args);
    }
    return isDefaultPrevented2;
  };
  Map3.prototype._notifyObserver = function _notifyObserver(name2, args) {
    if (args === void 0) args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented2 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  };
  Map3.prototype.zoom = function zoom(level) {
    var options = this.options;
    var result;
    if (defined(level)) {
      var zoomLevel = math5.round(limitValue(level, options.minZoom, options.maxZoom));
      if (options.zoom !== zoomLevel) {
        options.zoom = zoomLevel;
        this.widgetService.notify(ZOOM_CHANGE, {
          zoom: options.zoom
        });
        this._reset();
      }
      result = this;
    } else {
      result = options.zoom;
    }
    return result;
  };
  Map3.prototype.center = function center(center$1) {
    var result;
    if (center$1) {
      var current4 = Location.create(center$1);
      var previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, {
          center: this.options.center
        });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  };
  Map3.prototype.extent = function extent(extent$1) {
    var result;
    if (extent$1) {
      this._setExtent(extent$1);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  };
  Map3.prototype.setOptions = function setOptions(options) {
    if (options === void 0) options = {};
    var element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options, {}, this.context);
    this._reset();
  };
  Map3.prototype.locationToLayer = function locationToLayer(location, zoom) {
    var clamp = !this.options.wraparound;
    var locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.layerToLocation = function layerToLocation(point, zoom) {
    var clamp = !this.options.wraparound;
    var pointObject = Point6.create(point);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.locationToView = function locationToView(location) {
    var locationObject = Location.create(location);
    var origin = this.locationToLayer(this._viewOrigin);
    var point = this.locationToLayer(locationObject);
    return point.translateWith(origin.scale(-1));
  };
  Map3.prototype.viewToLocation = function viewToLocation(point, zoom) {
    var origin = this.locationToLayer(this._getOrigin(), zoom);
    var pointObject = Point6.create(point);
    var pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  };
  Map3.prototype.eventOffset = function eventOffset(e) {
    var x;
    var y;
    var offset = elementOffset(this.element);
    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {
      x = e.x[LOCATION] - offset.left;
      y = e.y[LOCATION] - offset.top;
    } else {
      var event = e.originalEvent || e;
      x = valueOrDefault(event.pageX, event.clientX) - offset.left;
      y = valueOrDefault(event.pageY, event.clientY) - offset.top;
    }
    var point = new geometry_exports.Point(x, y);
    return point;
  };
  Map3.prototype.eventToView = function eventToView(e) {
    var cursor = this.eventOffset(e);
    return this.locationToView(this.viewToLocation(cursor));
  };
  Map3.prototype.eventToLayer = function eventToLayer(e) {
    return this.locationToLayer(this.eventToLocation(e));
  };
  Map3.prototype.eventToLocation = function eventToLocation(e) {
    var cursor = this.eventOffset(e);
    return this.viewToLocation(cursor);
  };
  Map3.prototype.viewSize = function viewSize() {
    var element = this.element;
    var scale = this._layerSize();
    var width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min2(scale, width);
    }
    return {
      width,
      height: min2(scale, element.clientHeight)
    };
  };
  Map3.prototype.exportVisual = function exportVisual() {
    this._reset();
    return false;
  };
  Map3.prototype.hideTooltip = function hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Map3.prototype._setOrigin = function _setOrigin(origin, zoom) {
    var size = this.viewSize(), topLeft;
    var originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, {
      center: this.options.center
    });
    return this;
  };
  Map3.prototype._getOrigin = function _getOrigin(invalidate) {
    var size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  };
  Map3.prototype._setExtent = function _setExtent(newExtent) {
    var this$1 = this;
    var raw = Extent.create(newExtent);
    var se = raw.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    var extent = new Extent(raw.nw, se);
    this.center(extent.center());
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    var zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      var topLeft = this$1.locationToLayer(extent.nw, zoom);
      var bottomRight = this$1.locationToLayer(extent.se, zoom);
      var layerWidth = math5.abs(bottomRight.x - topLeft.x);
      var layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  };
  Map3.prototype._getExtent = function _getExtent() {
    var nw = this._getOrigin();
    var bottomRight = this.locationToLayer(nw);
    var size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    var se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  };
  Map3.prototype._zoomAround = function _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  };
  Map3.prototype._initControls = function _initControls() {
    var controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  };
  Map3.prototype._createControlElement = function _createControlElement(options, defaultPosition) {
    var pos = options.position || defaultPosition;
    var posSelector = "." + renderPos(pos).replace(" ", ".");
    var wrap = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap.length === 0) {
      var div$1 = document.createElement("div");
      addClass(div$1, "k-map-controls " + renderPos(pos));
      wrap = div$1;
      this.element.appendChild(wrap);
    }
    var div = document.createElement("div");
    wrap.appendChild(div);
    return div;
  };
  Map3.prototype._createAttribution = function _createAttribution(options) {
    var element = this._createControlElement(options, "bottomRight");
    this.attribution = new Attribution(element, options);
  };
  Map3.prototype._createNavigator = function _createNavigator(options) {
    var element = this._createControlElement(options, "topLeft");
    var navigator2 = this.navigator = new Navigator2(element, deepExtend({}, options, {
      icons: this.options.icons
    }));
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  };
  Map3.prototype._navigatorPan = function _navigatorPan(e) {
    var scroller = this.scroller;
    var x = scroller.scrollLeft + e.x;
    var y = scroller.scrollTop - e.y;
    var bounds = this._virtualSize;
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    x = limitValue(x, bounds.x.min, bounds.x.max - width);
    y = limitValue(y, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x, -y);
  };
  Map3.prototype._navigatorCenter = function _navigatorCenter() {
    this.center(this.options.center);
  };
  Map3.prototype._createZoomControl = function _createZoomControl(options) {
    var element = this._createControlElement(options, "topLeft");
    var zoomControl = this.zoomControl = new ZoomControl(element, options, this.options.icons);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  };
  Map3.prototype._zoomControlChange = function _zoomControlChange(e) {
    if (!this.trigger("zoomStart", {
      originalEvent: e
    })) {
      this.zoom(this.zoom() + e.delta);
      this.trigger("zoomEnd", {
        originalEvent: e
      });
    }
  };
  Map3.prototype._initScroller = function _initScroller() {
    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    var zoomable = this.options.zoomable !== false;
    var scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  };
  Map3.prototype._initLayers = function _initLayers() {
    var this$1 = this;
    var defs = this.options.layers, layers = this.layers = [];
    for (var i = 0; i < defs.length; i++) {
      var options = defs[i];
      var layer = this$1._createLayer(options);
      layers.push(layer);
    }
  };
  Map3.prototype._createLayer = function _createLayer(options) {
    var type = options.type || "shape";
    var layerDefaults = this.options.layerDefaults[type];
    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options, {
      icons: this.options.icons
    }) : deepExtend({}, layerDefaults, options);
    var layerConstructor = layersMap[type];
    var layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  };
  Map3.prototype._createTooltip = function _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  };
  Map3.prototype._initMarkers = function _initMarkers() {
    var markerLayers = (this.options.layers || []).filter(function(x) {
      return x && x.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, deepExtend({}, this.options.markerDefaults, {
      icons: this.options.icons
    }));
    this.markers.add(this.options.markers);
  };
  Map3.prototype._scroll = function _scroll(e) {
    var origin = this.locationToLayer(this._viewOrigin).round();
    var movable = e.sender.movable;
    var offset = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset.x;
    origin.y += offset.y;
    this._scrollOffset = offset;
    this._tooltip.offset = offset;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._scrollEnd = function _scrollEnd(e) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now();
    this.trigger("panEnd", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._panComplete = function _panComplete() {
    return now() - (this._panEndTimestamp || 0) > 50;
  };
  Map3.prototype._scaleStart = function _scaleStart(e) {
    if (this.trigger("zoomStart", {
      originalEvent: e
    })) {
      var touch = e.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  };
  Map3.prototype._scale = function _scale(e) {
    var scale = this.scroller.movable.scale;
    var zoom = this._scaleToZoom(scale);
    var gestureCenter = new geometry_exports.Point(e.center.x, e.center.y);
    var centerLocation = this.viewToLocation(gestureCenter, zoom);
    var centerPoint = this.locationToLayer(centerLocation, zoom);
    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e
    });
  };
  Map3.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {
    var scale = this._layerSize() * scaleDelta;
    var tiles = scale / this.options.minSize;
    var zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  };
  Map3.prototype._reset = function _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  };
  Map3.prototype._resetScroller = function _resetScroller() {
    var scroller = this.scroller;
    var x = scroller.dimensions.x;
    var y = scroller.dimensions.y;
    var scale = this._layerSize();
    var nw = this.extent().nw;
    var topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    var zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow2(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow2(2, this.options.maxZoom - zoom);
    var xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    var yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      var viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x.makeVirtual();
    y.makeVirtual();
    x.virtualSize(xBounds.min, xBounds.max);
    y.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  };
  Map3.prototype._renderLayers = function _renderLayers() {
  };
  Map3.prototype._layerSize = function _layerSize(zoom) {
    var newZoom = valueOrDefault(zoom, this.options.zoom);
    return this.options.minSize * pow2(2, newZoom);
  };
  Map3.prototype._tap = function _tap(e) {
    if (!this._panComplete()) {
      return;
    }
    var cursor = this.eventOffset(e);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e,
      location: this.viewToLocation(cursor)
    });
  };
  Map3.prototype._doubleTap = function _doubleTap(e) {
    var options = this.options;
    if (options.zoomable !== false) {
      if (!this.trigger("zoomStart", {
        originalEvent: e
      })) {
        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._mousewheel = function _mousewheel(e) {
    var delta = mousewheelDelta(e) > 0 ? -1 : 1;
    var options = this.options;
    var fromZoom = this.zoom();
    var toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);
    if (options.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", {
        originalEvent: e
      })) {
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {
    var offset = elementOffset(this.element);
    return {
      left: round(point.x + offset.left),
      top: round(point.y + offset.top)
    };
  };
  return Map3;
}(observable_default);
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [0, 0],
  icons: {
    type: "font",
    svgIcons: {}
  },
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/sankey/calculation.js
var max2 = function(array, mapFn) {
  return Math.max.apply(null, array.map(mapFn));
};
var min3 = function(array, mapFn) {
  return Math.min.apply(null, array.map(mapFn));
};
var sum = function(array, mapFn) {
  return array.map(mapFn).reduce(function(acc, curr) {
    return acc + curr;
  }, 0);
};
var sortAsc = function(a, b) {
  return a.y0 === b.y0 ? a.index - b.index : a.y0 + a.y1 - b.y0 - b.y1;
};
var sortSource = function(a, b) {
  return sortAsc(a.source, b.source);
};
var sortTarget = function(a, b) {
  return sortAsc(a.target, b.target);
};
var value = function(node) {
  return node.value;
};
function sortLinks(nodes) {
  nodes.forEach(function(node) {
    node.targetLinks.forEach(function(link) {
      link.source.sourceLinks.sort(sortTarget);
    });
    node.sourceLinks.forEach(function(link) {
      link.target.targetLinks.sort(sortSource);
    });
  });
}
var calcLayer = function(node, maxDepth) {
  if (node.align === "left") {
    return node.depth;
  }
  if (node.align === "right") {
    return maxDepth - node.height;
  }
  return node.sourceLinks.length ? node.depth : maxDepth;
};
var Sankey = function Sankey2(options) {
  var ref2 = options.nodesOptions;
  var offset = ref2.offset;
  if (offset === void 0) offset = {};
  var align = ref2.align;
  this.data = {
    nodes: options.nodes.map(function(node) {
      return deepExtend({}, {
        offset,
        align
      }, node);
    }),
    links: options.links.map(function(link) {
      return deepExtend({}, link);
    })
  };
  this.width = options.width;
  this.height = options.height;
  this.offsetX = options.offsetX || 0;
  this.offsetY = options.offsetY || 0;
  this.nodeWidth = options.nodesOptions.width;
  this.nodePadding = options.nodesOptions.padding;
  this.reverse = options.reverse;
  this.targetColumnIndex = options.targetColumnIndex;
  this.loops = options.loops;
  this.autoLayout = options.autoLayout;
};
Sankey.prototype.calculate = function calculate() {
  var ref2 = this.data;
  var nodes = ref2.nodes;
  var links = ref2.links;
  this.connectLinksToNodes(nodes, links);
  this.calculateNodeValues(nodes);
  var circularLinks = this.calculateNodeHeights(nodes);
  if (circularLinks) {
    return {
      nodes: [],
      links: [],
      columns: [],
      circularLinks
    };
  }
  this.calculateNodeDepths(nodes);
  var columns = this.calculateNodeColumns(nodes);
  this.calculateNodeBreadths(columns);
  this.applyNodesOffset(nodes);
  this.calculateLinkBreadths(nodes);
  return Object.assign({}, this.data, {
    columns
  });
};
Sankey.prototype.connectLinksToNodes = function connectLinksToNodes(nodes, links) {
  var nodesMap = /* @__PURE__ */ new Map();
  nodes.forEach(function(node, i) {
    node.index = i;
    node.sourceLinks = [];
    node.targetLinks = [];
    node.id = node.id !== void 0 ? node.id : node.label.text;
    nodesMap.set(node.id, node);
  });
  links.forEach(function(link) {
    link.source = nodesMap.get(link.sourceId);
    link.target = nodesMap.get(link.targetId);
    link.source.sourceLinks.push(link);
    link.target.targetLinks.push(link);
  });
};
Sankey.prototype.calculateNodeValues = function calculateNodeValues(nodes) {
  nodes.forEach(function(node) {
    node.value = Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value));
  });
};
Sankey.prototype.calculateNodeDepths = function calculateNodeDepths(nodes) {
  var current4 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currDepth = 0;
  while (current4.size) {
    var currentNodes = Array.from(current4);
    for (var n = 0; n < currentNodes.length; n++) {
      var node = currentNodes[n];
      node.depth = currDepth;
      for (var l = 0; l < node.sourceLinks.length; l++) {
        var link = node.sourceLinks[l];
        next.add(link.target);
      }
    }
    currDepth++;
    current4 = next;
    next = /* @__PURE__ */ new Set();
  }
};
Sankey.prototype.calculateNodeHeights = function calculateNodeHeights(nodes) {
  var nodesLength = nodes.length;
  var current4 = new Set(nodes);
  var next = /* @__PURE__ */ new Set();
  var currentHeight = 0;
  var eachNode = function(node) {
    node.height = currentHeight;
    node.targetLinks.forEach(function(link) {
      next.add(link.source);
    });
  };
  while (current4.size) {
    current4.forEach(eachNode);
    currentHeight++;
    if (currentHeight > nodesLength) {
      return true;
    }
    current4 = next;
    next = /* @__PURE__ */ new Set();
  }
  return false;
};
Sankey.prototype.calculateNodeColumns = function calculateNodeColumns(nodes) {
  var this$1 = this;
  var maxDepth = max2(nodes, function(d) {
    return d.depth;
  });
  var columnWidth = (this.width - this.offsetX - this.nodeWidth) / maxDepth;
  var columns = new Array(maxDepth + 1);
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    var layer = Math.max(0, Math.min(maxDepth, calcLayer(node, maxDepth)));
    node.x0 = this$1.offsetX + layer * columnWidth;
    node.x1 = node.x0 + this$1.nodeWidth;
    node.layer = layer;
    columns[layer] = columns[layer] || [];
    columns[layer].push(node);
  }
  return columns;
};
Sankey.prototype.calculateNodeBreadths = function calculateNodeBreadths(columns) {
  var this$1 = this;
  var kSize = min3(columns, function(c) {
    return (this$1.height - this$1.offsetY - (c.length - 1) * this$1.nodePadding) / sum(c, value);
  });
  columns.forEach(function(nodes) {
    var y = this$1.offsetY;
    nodes.forEach(function(node) {
      node.y0 = y;
      node.y1 = y + node.value * kSize;
      y = node.y1 + this$1.nodePadding;
      node.sourceLinks.forEach(function(link) {
        link.width = link.value * kSize;
      });
    });
    y = (this$1.height - y + this$1.nodePadding) / (nodes.length + 1);
    nodes.forEach(function(node, i2) {
      node.y0 += y * (i2 + 1);
      node.y1 += y * (i2 + 1);
    });
  });
  if (this.autoLayout !== false) {
    var loops = this.loops !== void 0 ? this.loops : columns.length - 1;
    var targetColumnIndex = this.targetColumnIndex || 1;
    for (var i = 0; i < loops; i++) {
      if (!this$1.reverse) {
        this$1.uncurlLinksToLeft(columns, targetColumnIndex);
        this$1.uncurlLinksToRight(columns, targetColumnIndex);
      } else {
        this$1.uncurlLinksToRight(columns, targetColumnIndex);
        this$1.uncurlLinksToLeft(columns, targetColumnIndex);
      }
    }
  }
  columns.forEach(sortLinks);
};
Sankey.prototype.applyNodesOffset = function applyNodesOffset(nodes) {
  nodes.forEach(function(node) {
    var offsetX = (node.offset ? node.offset.left : 0) || 0;
    var offsetY = (node.offset ? node.offset.top : 0) || 0;
    node.x0 += offsetX;
    node.x1 += offsetX;
    node.y0 += offsetY;
    node.y1 += offsetY;
  });
};
Sankey.prototype.calculateLinkBreadths = function calculateLinkBreadths(nodes) {
  nodes.forEach(function(node) {
    var sourceLinks = node.sourceLinks;
    var targetLinks = node.targetLinks;
    var y = node.y0;
    var y1 = y;
    sourceLinks.forEach(function(link) {
      link.x0 = link.source.x1;
      link.y0 = y + link.width / 2;
      y += link.width;
    });
    targetLinks.forEach(function(link) {
      link.x1 = link.target.x0;
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    });
  });
};
Sankey.prototype.uncurlLinksToRight = function uncurlLinksToRight(columns, targetColumnIndex) {
  var this$1 = this;
  var n = columns.length;
  for (var i = targetColumnIndex; i < n; i++) {
    var column = columns[i];
    column.forEach(function(target) {
      var y = 0;
      var sum2 = 0;
      target.targetLinks.forEach(function(link) {
        var kValue = link.value * (target.layer - link.source.layer);
        y += this$1.targetTopPos(link.source, target) * kValue;
        sum2 += kValue;
      });
      var dy = y === 0 ? 0 : y / sum2 - target.y0;
      target.y0 += dy;
      target.y1 += dy;
      sortLinks([target]);
    });
    column.sort(sortAsc);
    this$1.arrangeNodesVertically(column);
  }
};
Sankey.prototype.uncurlLinksToLeft = function uncurlLinksToLeft(columns, targetColumnIndex) {
  var this$1 = this;
  var l = columns.length;
  var startIndex = l - 1 - targetColumnIndex;
  for (var i = startIndex; i >= 0; i--) {
    var column = columns[i];
    var loop = function(j2) {
      var source = column[j2];
      var y = 0;
      var sum2 = 0;
      source.sourceLinks.forEach(function(link) {
        var kValue = link.value * (link.target.layer - source.layer);
        y += this$1.sourceTopPos(source, link.target) * kValue;
        sum2 += kValue;
      });
      var dy = y === 0 ? 0 : y / sum2 - source.y0;
      source.y0 += dy;
      source.y1 += dy;
      sortLinks([source]);
    };
    for (var j = 0; j < column.length; j++) loop(j);
    column.sort(sortAsc);
    this$1.arrangeNodesVertically(column);
  }
};
Sankey.prototype.arrangeNodesVertically = function arrangeNodesVertically(nodes) {
  var startIndex = 0;
  var endIndex = nodes.length - 1;
  this.arrangeUp(nodes, this.height, endIndex);
  this.arrangeDown(nodes, this.offsetY, startIndex);
};
Sankey.prototype.arrangeDown = function arrangeDown(nodes, yPos, index) {
  var this$1 = this;
  var currentY = yPos;
  for (var i = index; i < nodes.length; i++) {
    var node = nodes[i];
    var dy = Math.max(0, currentY - node.y0);
    node.y0 += dy;
    node.y1 += dy;
    currentY = node.y1 + this$1.nodePadding;
  }
};
Sankey.prototype.arrangeUp = function arrangeUp(nodes, yPos, index) {
  var this$1 = this;
  var currentY = yPos;
  for (var i = index; i >= 0; --i) {
    var node = nodes[i];
    var dy = Math.max(0, node.y1 - currentY);
    node.y0 -= dy;
    node.y1 -= dy;
    currentY = node.y0 - this$1.nodePadding;
  }
};
Sankey.prototype.sourceTopPos = function sourceTopPos(source, target) {
  var this$1 = this;
  var y = target.y0 - (target.targetLinks.length - 1) * this.nodePadding / 2;
  for (var i = 0; i < target.targetLinks.length; i++) {
    var link = target.targetLinks[i];
    if (link.source === source) {
      break;
    }
    y += link.width + this$1.nodePadding;
  }
  for (var i$1 = 0; i$1 < source.sourceLinks.length; i$1++) {
    var link$1 = source.sourceLinks[i$1];
    if (link$1.target === target) {
      break;
    }
    y -= link$1.width;
  }
  return y;
};
Sankey.prototype.targetTopPos = function targetTopPos(source, target) {
  var this$1 = this;
  var y = source.y0 - (source.sourceLinks.length - 1) * this.nodePadding / 2;
  for (var i = 0; i < source.sourceLinks.length; i++) {
    var link = source.sourceLinks[i];
    if (link.target === target) {
      break;
    }
    y += link.width + this$1.nodePadding;
  }
  for (var i$1 = 0; i$1 < target.targetLinks.length; i$1++) {
    var link$1 = target.targetLinks[i$1];
    if (link$1.source === source) {
      break;
    }
    y -= link$1.width;
  }
  return y;
};
var calculateSankey = function(options) {
  return new Sankey(options).calculate();
};
var crossesValue = function(links) {
  var value2 = 0;
  var linksLength = links.length;
  for (var i = 0; i < linksLength; i++) {
    var link = links[i];
    for (var lNext = i + 1; lNext < linksLength; lNext++) {
      var nextLink = links[lNext];
      if (intersect(link, nextLink)) {
        value2 += Math.min(link.value, nextLink.value);
      }
    }
  }
  return value2;
};
function rotationDirection(p1x, p1y, p2x, p2y, p3x, p3y) {
  var expression1 = (p3y - p1y) * (p2x - p1x);
  var expression2 = (p2y - p1y) * (p3x - p1x);
  if (expression1 > expression2) {
    return 1;
  } else if (expression1 === expression2) {
    return 0;
  }
  return -1;
}
function intersect(link1, link2) {
  var f1 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x1, link2.y1);
  var f2 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x0, link2.y0);
  var f3 = rotationDirection(link1.x0, link1.y0, link2.x0, link2.y0, link2.x1, link2.y1);
  var f4 = rotationDirection(link1.x1, link1.y1, link2.x0, link2.y0, link2.x1, link2.y1);
  return f1 !== f2 && f3 !== f4;
}

// node_modules/@progress/kendo-charts/dist/es/sankey/element.js
var SankeyElement = function(Class) {
  function SankeyElement2(options) {
    Class.call(this);
    this.options = deepExtend({}, this.options, options);
    this.createVisual();
  }
  if (Class) SankeyElement2.__proto__ = Class;
  SankeyElement2.prototype = Object.create(Class && Class.prototype);
  SankeyElement2.prototype.constructor = SankeyElement2;
  SankeyElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
  };
  SankeyElement2.prototype.exportVisual = function exportVisual() {
    return this.visual;
  };
  SankeyElement2.prototype.createElement = function createElement() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var visual;
    if (customVisual) {
      visual = customVisual({
        sender: this.getSender(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  SankeyElement2.prototype.getSender = function getSender() {
    return this;
  };
  return SankeyElement2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/sankey/node.js
var Node = function(SankeyElement2) {
  function Node2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Node2.__proto__ = SankeyElement2;
  Node2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Node2.prototype.constructor = Node2;
  Node2.prototype.getElement = function getElement() {
    return drawing_exports.Path.fromRect(this.getRect(), this.visualOptions());
  };
  Node2.prototype.getRect = function getRect() {
    var node = this.options.node;
    return new geometry_exports.Rect([node.x0, node.y0], [node.x1 - node.x0, node.y1 - node.y0]);
  };
  Node2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({
        node: options.node
      });
    }
  };
  Node2.prototype.visualOptions = function visualOptions() {
    var options = deepExtend({}, this.options, this.options.node);
    var ariaLabel = this.getLabelText(options);
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: {
        width: 0
      },
      className: "k-sankey-node",
      role: "graphics-symbol",
      ariaRoleDescription: "Node",
      ariaLabel
    };
  };
  Node2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    this._highlight = drawing_exports.Path.fromRect(this.getRect(), {
      stroke: this.options.focusHighlight,
      visible: false
    });
    return this._highlight;
  };
  Node2.prototype.focus = function focus(options) {
    if (this._highlight) {
      var ref2 = options || {};
      var highlight = ref2.highlight;
      if (highlight === void 0) highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id = this.options.node.id;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  };
  Node2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Node2;
}(SankeyElement);
var nodeColor = function(node, nodeColors, index) {
  return node.color || nodeColors[index % nodeColors.length];
};
var resolveNodeOptions = function(node, options, nodeColors, index) {
  var nodeOptions = deepExtend({}, options, options.node);
  return deepExtend({}, {
    color: nodeColor(node, nodeColors, index)
  }, nodeOptions, {
    node
  }, {
    visual: node.visual,
    opacity: node.opacity,
    offset: node.offset,
    color: node.color
  });
};

// node_modules/@progress/kendo-charts/dist/es/sankey/link.js
var distanceToLine = function(line, point) {
  var ref2 = line[0];
  var x1 = ref2[0];
  var y1 = ref2[1];
  var ref$1 = line[1];
  var x2 = ref$1[0];
  var y2 = ref$1[1];
  var x3 = point[0];
  var y3 = point[1];
  return Math.abs((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
};
var bezierPoint = function(p1, p2, p3, p4, t) {
  var t1 = 1 - t;
  var t1t1 = t1 * t1;
  var tt = t * t;
  return p1 * t1t1 * t1 + 3 * p2 * t * t1t1 + 3 * p3 * tt * t1 + p4 * tt * t;
};
var angelBetweenTwoLines = function(line1, line2) {
  var ref2 = line1[0];
  var x1 = ref2[0];
  var y1 = ref2[1];
  var ref$1 = line1[1];
  var x2 = ref$1[0];
  var y2 = ref$1[1];
  var ref$2 = line2[0];
  var x3 = ref$2[0];
  var y3 = ref$2[1];
  var ref$3 = line2[1];
  var x4 = ref$3[0];
  var y4 = ref$3[1];
  var a1 = Math.atan2(y2 - y1, x2 - x1);
  var a2 = Math.atan2(y4 - y3, x4 - x3);
  return Math.abs(a1 - a2);
};
var calculateControlPointsOffsetX = function(link, rtl) {
  var x0 = link.x0;
  var x1 = link.x1;
  var y0 = link.y0;
  var y1 = link.y1;
  var xC = (x0 + x1) / 2;
  var width = link.width;
  var halfWidth = width / 2;
  var upperCurveMiddleLine = [[(x0 + xC) / 2, y0 - halfWidth], [(x1 + xC) / 2, y1 - halfWidth]];
  var lowerCurveMiddlePoint = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];
  var actualWidth = distanceToLine(upperCurveMiddleLine, lowerCurveMiddlePoint);
  var upperNarrowness = (width - actualWidth) / 2;
  var alpha = angelBetweenTwoLines(upperCurveMiddleLine, [[x0, y0 - halfWidth], [xC, y0 - halfWidth]]);
  var a = upperNarrowness;
  var b = Math.sin(alpha) * a;
  var offset = Math.sqrt(a * a + b * b);
  var sign = y0 - y1 > 0 ? -1 : 1;
  if (rtl) {
    sign = -sign;
  }
  return sign * offset;
};
var Link = function(SankeyElement2) {
  function Link2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Link2.__proto__ = SankeyElement2;
  Link2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Link2.prototype.constructor = Link2;
  Link2.prototype.getElement = function getElement() {
    var link = this.options.link;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    return new drawing_exports.Path(this.visualOptions()).moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
  };
  Link2.prototype.getLabelText = function getLabelText(options) {
    var labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({
        link: options.link
      });
    }
  };
  Link2.prototype.visualOptions = function visualOptions() {
    var options = this.options;
    var link = this.options.link;
    var ariaLabel = this.getLabelText(options);
    return {
      stroke: {
        width: options.link.width,
        color: link.color || options.color,
        opacity: defined(link.opacity) ? link.opacity : options.opacity
      },
      role: "graphics-symbol",
      ariaRoleDescription: "Link",
      ariaLabel
    };
  };
  Link2.prototype.createFocusHighlight = function createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    var ref2 = this.options;
    var link = ref2.link;
    var rtl = ref2.rtl;
    var x0 = link.x0;
    var x1 = link.x1;
    var y0 = link.y0;
    var y1 = link.y1;
    var xC = (x0 + x1) / 2;
    var halfWidth = link.width / 2;
    var offset = calculateControlPointsOffsetX(link, rtl);
    this._highlight = new drawing_exports.Path({
      stroke: this.options.focusHighlight,
      visible: false
    }).moveTo(x0, y0 + halfWidth).lineTo(x0, y0 - halfWidth).curveTo([xC + offset, y0 - halfWidth], [xC + offset, y1 - halfWidth], [x1, y1 - halfWidth]).lineTo(x1, y1 + halfWidth).curveTo([xC - offset, y1 + halfWidth], [xC - offset, y0 + halfWidth], [x0, y0 + halfWidth]);
  };
  Link2.prototype.focus = function focus(options) {
    if (this._highlight) {
      var ref2 = options || {};
      var highlight = ref2.highlight;
      if (highlight === void 0) highlight = true;
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      var id = this.options.link.sourceId + "->" + this.options.link.targetId;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  };
  Link2.prototype.blur = function blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  };
  return Link2;
}(SankeyElement);
var resolveLinkOptions = function(link, options, sourceNode, targetNode) {
  var linkOptions = deepExtend({}, options, {
    link,
    opacity: link.opacity,
    color: link.color,
    colorType: link.colorType,
    visual: link.visual,
    highlight: link.highlight
  });
  if (linkOptions.colorType === "source") {
    linkOptions.color = sourceNode.options.fill.color;
  } else if (linkOptions.colorType === "target") {
    linkOptions.color = targetNode.options.fill.color;
  }
  return linkOptions;
};

// node_modules/@progress/kendo-charts/dist/es/sankey/label.js
var INSIDE3 = "inside";
var BEFORE = "before";
var AFTER = "after";
var Label = function(SankeyElement2) {
  function Label2() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Label2.__proto__ = SankeyElement2;
  Label2.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Label2.prototype.constructor = Label2;
  Label2.prototype.getElement = function getElement() {
    var options = deepExtend({}, this.options, this.options.node.label);
    var node = options.node;
    var diagramMinX = options.diagramMinX;
    var diagramMaxX = options.diagramMaxX;
    var text = options.text;
    var offset = options.offset;
    var rtl = options.rtl;
    var position = options.position;
    if (rtl && position !== INSIDE3) {
      position = position === BEFORE ? AFTER : BEFORE;
    }
    if (!options.visible || !text) {
      return null;
    }
    var nodeBox = new box_default(node.x0, node.y0, node.x1, node.y1);
    var visualOptions = this.visualOptions();
    if (rtl && !visualOptions.align) {
      visualOptions.align = "right";
    }
    var textbox = new text_box_default(text, visualOptions);
    textbox.reflow(new box_default());
    var textSizeBox = textbox.box;
    var textY = nodeBox.center().y - textSizeBox.height() / 2;
    var labelAfterLastNode = node.x1 + textSizeBox.width() > diagramMaxX;
    var labelBeforeFirstNode = node.x0 - textSizeBox.width() < diagramMinX;
    var side = position === BEFORE || position === INSIDE3 && labelAfterLastNode ? BEFORE : AFTER;
    if (rtl) {
      side = position === AFTER || position === INSIDE3 && labelBeforeFirstNode ? AFTER : BEFORE;
    }
    var textOrigin = [side === BEFORE ? node.x0 - textSizeBox.width() : node.x1, textY];
    var textRect = new box_default(textOrigin[0], textOrigin[1], textOrigin[0] + textSizeBox.width(), textOrigin[1] + textSizeBox.height());
    textRect.translate(offset.left || 0, offset.top || 0);
    textbox.reflow(textRect);
    textbox.renderVisual();
    return textbox.visual;
  };
  Label2.prototype.visualOptions = function visualOptions() {
    var options = deepExtend({}, this.options, this.options.node.label);
    return {
      color: options.color,
      font: options.font,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      align: options.align,
      paintOrder: options.paintOrder,
      stroke: options.stroke
    };
  };
  return Label2;
}(SankeyElement);
setDefaultOptions(Label, {
  position: INSIDE3
  // inside, before, after
});
var resolveLabelOptions = function(node, options, rtl, diagramMinX, diagramMaxX) {
  return deepExtend({}, options, {
    node,
    diagramMinX,
    diagramMaxX,
    rtl,
    visual: node.label.visual,
    visible: node.label.visible,
    margin: node.label.margin,
    padding: node.label.padding,
    border: node.label.border,
    align: node.label.align,
    offset: node.label.offset
  });
};

// node_modules/@progress/kendo-charts/dist/es/sankey/title.js
var Title2 = function(SankeyElement2) {
  function Title3() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Title3.__proto__ = SankeyElement2;
  Title3.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Title3.prototype.constructor = Title3;
  Title3.prototype.getElement = function getElement() {
    var options = this.options;
    var drawingRect = options.drawingRect;
    var text = options.text;
    if (options.visible === false || !text) {
      return null;
    }
    var title2 = title_default.buildTitle(text, options);
    title2.reflow(drawingRect);
    title2.renderVisual();
    return title2.visual;
  };
  Title3.prototype.createElement = function createElement() {
    return this.getElement();
  };
  return Title3;
}(SankeyElement);
setDefaultOptions(Title2, {
  align: CENTER,
  // 'left', 'right', 'center'
  border: {
    width: 0
  },
  margin: getSpacing(5),
  padding: getSpacing(5)
});

// node_modules/@progress/kendo-charts/dist/es/sankey/legend.js
var sortData = function(a, b) {
  if (a.node.x0 - b.node.x0 !== 0) {
    return a.node.x0 - b.node.x0;
  }
  return a.node.y0 - b.node.y0;
};
var sortDataRTL = function(a, b) {
  if (a.node.x1 - b.node.x1 !== 0) {
    return a.node.x1 - b.node.x1;
  }
  return b.node.y0 - a.node.y0;
};
var sort = function(rtl) {
  return rtl ? sortDataRTL : sortData;
};
var Legend2 = function(SankeyElement2) {
  function Legend3() {
    SankeyElement2.apply(this, arguments);
  }
  if (SankeyElement2) Legend3.__proto__ = SankeyElement2;
  Legend3.prototype = Object.create(SankeyElement2 && SankeyElement2.prototype);
  Legend3.prototype.constructor = Legend3;
  Legend3.prototype.getElement = function getElement() {
    var options = this.options;
    var drawingRect = options.drawingRect;
    var rtl = options.rtl;
    var nodes = options.nodes;
    if (nodes === void 0) nodes = [];
    var item = options.item;
    var position = options.position;
    if (options.visible === false || !nodes.length) {
      return null;
    }
    var data = nodes.map(function(node) {
      return {
        text: node.label && node.label.text || "",
        area: {
          background: item.areaBackground !== void 0 ? item.areaBackground : node.color,
          opacity: item.areaOpacity !== void 0 ? item.areaOpacity : node.opacity
        },
        node
      };
    });
    data.sort(sort(rtl));
    var reverse = rtl && position !== LEFT && position !== RIGHT;
    var legend2 = new legend_default(Object.assign({}, options, {
      data,
      reverse
    }), {
      rtl
    });
    legend2.reflow(drawingRect);
    legend2.renderVisual();
    return legend2.visual;
  };
  Legend3.prototype.createElement = function createElement() {
    return this.getElement();
  };
  return Legend3;
}(SankeyElement);
setDefaultOptions(Legend2, {
  markers: {
    visible: false
  },
  item: {
    type: AREA,
    cursor: POINTER,
    opacity: 1
  },
  position: BOTTOM,
  align: CENTER,
  accessibility: {
    role: "presentation",
    ariaLabel: null,
    ariaRoleDescription: null
  },
  border: {
    width: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/sankey.js
var LINK = "link";
var NODE = "node";
var toRtl = function(sankey) {
  var nodes = sankey.nodes;
  var links = sankey.links;
  var startX = Math.min.apply(Math, nodes.map(function(node) {
    return node.x0;
  }));
  var endX = Math.max.apply(Math, nodes.map(function(node) {
    return node.x1;
  }));
  var width = endX - startX;
  nodes.forEach(function(node) {
    var x0 = width - (node.x1 - 2 * startX);
    var x1 = width - (node.x0 - 2 * startX);
    node.x0 = x0;
    node.x1 = x1;
  });
  links.forEach(function(link) {
    var x0 = width - (link.x1 - 2 * startX);
    var x1 = width - (link.x0 - 2 * startX);
    link.x1 = x0;
    link.x0 = x1;
  });
};
var Sankey3 = function(Observable2) {
  function Sankey4(element, options, theme) {
    Observable2.call(this);
    this._initTheme(theme);
    this._setOptions(options);
    this._initElement(element);
    this._initSurface();
    if (options && options.data) {
      this._redraw();
      this._initResizeObserver();
      this._initNavigation(element);
    }
  }
  if (Observable2) Sankey4.__proto__ = Observable2;
  Sankey4.prototype = Object.create(Observable2 && Observable2.prototype);
  Sankey4.prototype.constructor = Sankey4;
  Sankey4.prototype.destroy = function destroy() {
    this.unbind();
    this._destroySurface();
    this._destroyResizeObserver();
    if (this.element) {
      this.element.removeEventListener("keydown", this._keydownHandler);
      this.element.removeEventListener("focus", this._focusHandler);
      this.element.removeEventListener("mousedown", this._onDownHandler);
      this.element.removeEventListener("touchstart", this._onDownHandler);
      this.element.removeEventListener("pointerdown", this._onDownHandler);
    }
    this._focusState = null;
    this.element = null;
  };
  Sankey4.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass(element, ["k-chart", "k-sankey"]);
    element.setAttribute("role", "graphics-document");
    var ref2 = this.options;
    var title2 = ref2.title;
    if (title2.text) {
      element.setAttribute("aria-label", title2.text);
    }
    if (title2.description) {
      element.setAttribute("aria-roledescription", title2.description);
    }
  };
  Sankey4.prototype._initSurface = function _initSurface() {
    if (!this.surface) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Sankey4.prototype._initNavigation = function _initNavigation(element) {
    element.tabIndex = element.getAttribute("tabindex") || 0;
    if (this.options.disableKeyboardNavigation) {
      return;
    }
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._onDownHandler = this._onDown.bind(this);
    element.addEventListener("keydown", this._keydownHandler);
    element.addEventListener("focus", this._focusHandler);
    element.addEventListener("blur", this._blurHandler);
    element.addEventListener("mousedown", this._onDownHandler);
    element.addEventListener("touchstart", this._onDownHandler);
    element.addEventListener("pointerdown", this._onDownHandler);
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
  };
  Sankey4.prototype.firstFocusableNode = function firstFocusableNode() {
    return this.columns[0][0];
  };
  Sankey4.prototype._initResizeObserver = function _initResizeObserver() {
    var this$1 = this;
    var observer = new ResizeObserver(function(entries) {
      entries.forEach(function(entry) {
        var ref2 = entry.contentRect;
        var width = ref2.width;
        var height = ref2.height;
        if (entry.target !== this$1.element || this$1.size && this$1.size.width === width && this$1.size.height === height) {
          return;
        }
        this$1.size = {
          width,
          height
        };
        this$1.surface.setSize(this$1.size);
        this$1.resize = true;
        this$1._redraw();
      });
    });
    this._resizeObserver = observer;
    observer.observe(this.element);
  };
  Sankey4.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      mouseenter: this._mouseenter.bind(this),
      mouseleave: this._mouseleave.bind(this),
      mousemove: this._mousemove.bind(this),
      click: this._click.bind(this)
    });
  };
  Sankey4.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
  };
  Sankey4.prototype.setLinksOpacity = function setLinksOpacity(opacity) {
    var this$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1.setOpacity(link, opacity, link.linkOptions.opacity);
    });
  };
  Sankey4.prototype.setLinksInactivityOpacity = function setLinksInactivityOpacity(inactiveOpacity) {
    var this$1 = this;
    this.linksVisuals.forEach(function(link) {
      this$1.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
    });
  };
  Sankey4.prototype.setOpacity = function setOpacity(link, opacity, linkValue) {
    link.options.set("stroke", Object.assign({}, link.options.stroke, {
      opacity: defined(linkValue) ? linkValue : opacity
    }));
  };
  Sankey4.prototype.trigger = function trigger2(name2, ev) {
    var dataItem = ev.element.dataItem;
    var targetType = ev.element.type;
    var event = Object.assign({}, ev, {
      type: name2,
      targetType,
      dataItem
    });
    return Observable2.prototype.trigger.call(this, name2, event);
  };
  Sankey4.prototype._mouseenter = function _mouseenter(ev) {
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    if (isLink && this.trigger("linkEnter", ev) || isNode && this.trigger("nodeEnter", ev)) {
      return;
    }
    var ref2 = this.options.links;
    var highlight = ref2.highlight;
    if (isLink) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
    } else if (isNode) {
      this.highlightLinks(element, highlight);
    } else if (isLegendItem) {
      var nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
      this.highlightLinks(nodeVisual, highlight);
    }
  };
  Sankey4.prototype._mouseleave = function _mouseleave(ev) {
    var this$1 = this;
    var element = ev.element;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    var target = ev.originalEvent.relatedTarget;
    if (isLink && target && target.nodeName === "text") {
      return;
    }
    if (isLink || isNode) {
      if (this.tooltipTimeOut) {
        clearTimeout(this.tooltipTimeOut);
        this.tooltipTimeOut = null;
      }
      this.tooltipShown = false;
      this.trigger("tooltipHide", ev);
    }
    if (isLink && this.trigger("linkLeave", ev) || isNode && this.trigger("nodeLeave", ev)) {
      return;
    }
    if (isLink || isNode || isLegendItem) {
      this.linksVisuals.forEach(function(link) {
        this$1.setOpacity(link, this$1.options.links.opacity, link.linkOptions.opacity);
      });
    }
  };
  Sankey4.prototype._mousemove = function _mousemove(ev) {
    var this$1 = this;
    var ref2 = this.options.tooltip;
    var followPointer = ref2.followPointer;
    var delay = ref2.delay;
    var element = ev.element;
    var tooltipElType = element.type;
    if (tooltipElType !== LINK && tooltipElType !== NODE || this.tooltipShown && !followPointer) {
      return;
    }
    var mouseEvent = ev.originalEvent;
    var rect = this.element.getBoundingClientRect();
    var isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
    var isTop = mouseEvent.clientY - rect.top < rect.height / 2;
    ev.tooltipData = {
      popupOffset: {
        left: mouseEvent.pageX,
        top: mouseEvent.pageY
      },
      popupAlign: {
        horizontal: isLeft ? "left" : "right",
        vertical: isTop ? "top" : "bottom"
      }
    };
    if (tooltipElType === NODE) {
      var ref$1 = element.dataItem;
      var sourceLinks = ref$1.sourceLinks;
      var targetLinks = ref$1.targetLinks;
      var links = targetLinks.length ? targetLinks : sourceLinks;
      ev.nodeValue = links.reduce(function(acc, link) {
        return acc + link.value;
      }, 0);
    }
    if (this.tooltipTimeOut) {
      clearTimeout(this.tooltipTimeOut);
      this.tooltipTimeOut = null;
    }
    var nextDelay = followPointer && this.tooltipShown ? 0 : delay;
    this.tooltipTimeOut = setTimeout(function() {
      this$1.trigger("tooltipShow", ev);
      this$1.tooltipShown = true;
      this$1.tooltipTimeOut = null;
    }, nextDelay);
  };
  Sankey4.prototype._click = function _click(ev) {
    var element = ev.element;
    var dataItem = element.dataItem;
    var isLink = element.type === LINK;
    var isNode = element.type === NODE;
    var focusState = this._focusState || {};
    if (isNode) {
      var focusedNodeClicked = !focusState.link && this.sameNode(focusState.node, dataItem);
      if (!focusedNodeClicked) {
        this._focusState = {
          node: dataItem,
          link: null
        };
        this._focusNode({
          highlight: false
        });
      }
      this.trigger("nodeClick", ev);
    } else if (isLink) {
      var link = {
        sourceId: dataItem.source.id,
        targetId: dataItem.target.id,
        value: dataItem.value
      };
      var focusedLinkClicked = this.sameLink(focusState.link, link);
      if (!focusedLinkClicked) {
        this._focusState = {
          node: dataItem.source,
          link
        };
        this._focusLink({
          highlight: false
        });
      }
      this.trigger("linkClick", ev);
    }
  };
  Sankey4.prototype.sameNode = function sameNode(node1, node2) {
    return node1 && node2 && node1.id === node2.id;
  };
  Sankey4.prototype.sameLink = function sameLink(link1, link2) {
    return link1 && link2 && link1.sourceId === link2.sourceId && link1.targetId === link2.targetId;
  };
  Sankey4.prototype._focusNode = function _focusNode(options) {
    this._cleanFocusHighlight();
    var nodeData = this._focusState.node;
    var node = this.models.map.get(nodeData.id);
    node.focus(options);
  };
  Sankey4.prototype._focusLink = function _focusLink(options) {
    this._cleanFocusHighlight();
    var linkData = this._focusState.link;
    var link = this.models.map.get(linkData.sourceId + "-" + linkData.targetId);
    link.focus(options);
  };
  Sankey4.prototype._focusNextNode = function _focusNextNode(direction) {
    if (direction === void 0) direction = 1;
    var current4 = this._focusState.node;
    var columnIndex = this.columns.findIndex(function(column) {
      return column.find(function(n) {
        return n.id === current4.id;
      });
    });
    var columnNodes = this.columns[columnIndex];
    var nodeIndex = columnNodes.findIndex(function(n) {
      return n.id === current4.id;
    });
    var nextNode = columnNodes[nodeIndex + direction];
    if (nextNode) {
      this._focusState.node = nextNode;
      this._focusNode();
    }
  };
  Sankey4.prototype._focusNextLink = function _focusNextLink(direction) {
    if (direction === void 0) direction = 1;
    var node = this._focusState.node;
    var link = this._focusState.link;
    var sourceLinkIndex = node.sourceLinks.findIndex(function(l) {
      return l.sourceId === link.sourceId && l.targetId === link.targetId;
    });
    var targetLinkIndex = node.targetLinks.findIndex(function(l) {
      return l.sourceId === link.sourceId && l.targetId === link.targetId;
    });
    if (sourceLinkIndex !== -1) {
      var nextLink = node.sourceLinks[sourceLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    } else if (targetLinkIndex !== -1) {
      var nextLink$1 = node.targetLinks[targetLinkIndex + direction];
      if (nextLink$1) {
        this._focusState.link = nextLink$1;
        this._focusLink();
      }
    }
  };
  Sankey4.prototype._focusSourceNode = function _focusSourceNode() {
    var linkData = this._focusState.link;
    var sourceNode = this.models.map.get(linkData.sourceId);
    this._focusState = {
      node: sourceNode.options.node,
      link: null
    };
    this._focusNode();
  };
  Sankey4.prototype._focusTargetNode = function _focusTargetNode() {
    var linkData = this._focusState.link;
    var targetNode = this.models.map.get(linkData.targetId);
    this._focusState = {
      node: targetNode.options.node,
      link: null
    };
    this._focusNode();
  };
  Sankey4.prototype._focusSourceLink = function _focusSourceLink() {
    var nodeData = this._focusState.node;
    var sourceLinks = nodeData.sourceLinks;
    var linkData = sourceLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey4.prototype._focusTargetLink = function _focusTargetLink() {
    var nodeData = this._focusState.node;
    var targetLinks = nodeData.targetLinks;
    var linkData = targetLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  };
  Sankey4.prototype._focus = function _focus() {
    if (!this._skipFocusHighlight) {
      if (this._focusState.link) {
        this._focusLink();
      } else {
        this._focusNode();
      }
    }
    this._skipFocusHighlight = false;
  };
  Sankey4.prototype._blur = function _blur() {
    this._cleanFocusHighlight();
  };
  Sankey4.prototype._onDown = function _onDown() {
    if (!this._hasFocus()) {
      this._skipFocusHighlight = true;
    }
  };
  Sankey4.prototype._hasFocus = function _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  };
  Sankey4.prototype._cleanFocusHighlight = function _cleanFocusHighlight() {
    this.models.nodes.forEach(function(node) {
      return node.blur();
    });
    this.models.links.forEach(function(link) {
      return link.blur();
    });
  };
  Sankey4.prototype._keydown = function _keydown(ev) {
    var handler = this["on" + ev.key];
    var rtl = this.options.rtl;
    if (rtl && ev.key === "ArrowLeft") {
      handler = this.onArrowRight;
    } else if (rtl && ev.key === "ArrowRight") {
      handler = this.onArrowLeft;
    }
    if (handler) {
      handler.call(this, ev);
    }
  };
  Sankey4.prototype.onEscape = function onEscape(ev) {
    ev.preventDefault();
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
    this._focusNode();
  };
  Sankey4.prototype.onArrowDown = function onArrowDown(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(1);
    } else {
      this._focusNextNode(1);
    }
  };
  Sankey4.prototype.onArrowUp = function onArrowUp(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(-1);
    } else {
      this._focusNextNode(-1);
    }
  };
  Sankey4.prototype.onArrowLeft = function onArrowLeft(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusSourceNode();
    } else {
      this._focusTargetLink();
    }
  };
  Sankey4.prototype.onArrowRight = function onArrowRight(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusTargetNode();
    } else {
      this._focusSourceLink();
    }
  };
  Sankey4.prototype.highlightLinks = function highlightLinks(node, highlight) {
    var this$1 = this;
    if (node) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      node.links.forEach(function(link) {
        this$1.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
      });
    }
  };
  Sankey4.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Sankey4.prototype._destroyResizeObserver = function _destroyResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  };
  Sankey4.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
  };
  Sankey4.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Sankey4.prototype.setOptions = function setOptions(options, theme) {
    this._setOptions(options);
    this._initTheme(theme);
    this._initSurface();
    this._redraw();
  };
  Sankey4.prototype._redraw = function _redraw() {
    this.surface.clear();
    var ref2 = this._getSize();
    var width = ref2.width;
    var height = ref2.height;
    this.size = {
      width,
      height
    };
    this.surface.setSize(this.size);
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Sankey4.prototype._getSize = function _getSize() {
    return this.element.getBoundingClientRect();
  };
  Sankey4.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Sankey4.prototype.titleBox = function titleBox(title2, drawingRect) {
    if (!title2 || title2.visible === false || !title2.text) {
      return null;
    }
    var titleElement = new Title2(Object.assign({}, {
      drawingRect
    }, title2));
    var titleVisual = titleElement.exportVisual();
    return titleVisual.chartElement.box;
  };
  Sankey4.prototype.legendBox = function legendBox(options, nodes, drawingRect) {
    if (!options || options.visible === false) {
      return null;
    }
    var legend2 = new Legend2(Object.assign({}, {
      nodes
    }, options, {
      drawingRect
    }));
    var legendVisual = legend2.exportVisual();
    return legendVisual.chartElement.box;
  };
  Sankey4.prototype.calculateSankey = function calculateSankey$1(calcOptions, sankeyOptions) {
    var title2 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var data = sankeyOptions.data;
    var nodes = sankeyOptions.nodes;
    var labels = sankeyOptions.labels;
    var nodeColors = sankeyOptions.nodeColors;
    var disableAutoLayout = sankeyOptions.disableAutoLayout;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var rtl = sankeyOptions.rtl;
    var autoLayout = !disableAutoLayout;
    var padding = disableKeyboardNavigation ? 0 : highlightOptions.width / 2;
    var sankeyBox = new box_default(0, 0, calcOptions.width, calcOptions.height);
    sankeyBox.unpad(padding);
    var titleBox = this.titleBox(title2, sankeyBox);
    var legendArea = sankeyBox.clone();
    if (titleBox) {
      var titleHeight = titleBox.height();
      if (title2.position === TOP) {
        sankeyBox.unpad({
          top: titleHeight
        });
        legendArea = new box_default(0, titleHeight, calcOptions.width, calcOptions.height);
      } else {
        sankeyBox.shrink(0, titleHeight);
        legendArea = new box_default(0, 0, calcOptions.width, calcOptions.height - titleHeight);
      }
    }
    var legendBox = this.legendBox(legend2, data.nodes, legendArea);
    var legendPosition = legend2 && legend2.position || Legend2.prototype.options.position;
    if (legendBox) {
      if (legendPosition === LEFT) {
        sankeyBox.unpad({
          left: legendBox.width()
        });
      }
      if (legendPosition === RIGHT) {
        sankeyBox.shrink(legendBox.width(), 0);
      }
      if (legendPosition === TOP) {
        sankeyBox.unpad({
          top: legendBox.height()
        });
      }
      if (legendPosition === BOTTOM) {
        sankeyBox.shrink(0, legendBox.height());
      }
    }
    var ref2 = calculateSankey(Object.assign({}, calcOptions, {
      offsetX: 0,
      offsetY: 0,
      width: sankeyBox.width(),
      height: sankeyBox.height()
    }));
    var calculatedNodes = ref2.nodes;
    var circularLinks = ref2.circularLinks;
    if (circularLinks) {
      console.warn("Circular links detected. Kendo Sankey diagram does not support circular links.");
      return {
        sankey: {
          nodes: [],
          links: [],
          columns: [[]],
          circularLinks
        },
        legendBox,
        titleBox
      };
    }
    var box = new box_default();
    var diagramMinX = calculatedNodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = calculatedNodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    calculatedNodes.forEach(function(nodeEl, i) {
      if (rtl) {
        var x0 = nodeEl.x0;
        var x1 = nodeEl.x1;
        nodeEl.x0 = diagramMaxX - x1;
        nodeEl.x1 = diagramMaxX - x0;
      }
      var nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i);
      var nodeInstance = new Node(nodeOps);
      box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));
      var labelInstance = new Label(resolveLabelOptions(nodeEl, labels, rtl, diagramMinX, diagramMaxX));
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        box.wrap(rectToBox(labelVisual.rawBBox()));
      }
    });
    var offsetX = sankeyBox.x1;
    var offsetY = sankeyBox.y1;
    var width = sankeyBox.width() + offsetX;
    var height = sankeyBox.height() + offsetY;
    width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
    height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;
    offsetX += box.x1 < 0 ? -box.x1 : 0;
    offsetY += box.y1 < 0 ? -box.y1 : 0;
    if (autoLayout === false) {
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, {
          offsetX,
          offsetY,
          width,
          height,
          autoLayout: false
        })),
        legendBox,
        titleBox
      };
    }
    if (this.resize && autoLayout && this.permutation) {
      this.resize = false;
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, {
          offsetX,
          offsetY,
          width,
          height
        }, this.permutation)),
        legendBox,
        titleBox
      };
    }
    var startColumn = 1;
    var loops = 2;
    var columnsLength = calculateSankey(Object.assign({}, calcOptions, {
      offsetX,
      offsetY,
      width,
      height,
      autoLayout: false
    })).columns.length;
    var results = [];
    var permutation = function(targetColumnIndex, reverse) {
      var currPerm = calculateSankey(Object.assign({}, calcOptions, {
        offsetX,
        offsetY,
        width,
        height,
        loops,
        targetColumnIndex,
        reverse
      }));
      var crosses = crossesValue(currPerm.links);
      results.push({
        crosses,
        reverse,
        targetColumnIndex
      });
      return crosses === 0;
    };
    for (var index = startColumn; index <= columnsLength - 1; index++) {
      if (permutation(index, false) || permutation(index, true)) {
        break;
      }
    }
    var minCrosses = Math.min.apply(null, results.map(function(r) {
      return r.crosses;
    }));
    var bestResult = results.find(function(r) {
      return r.crosses === minCrosses;
    });
    this.permutation = {
      targetColumnIndex: bestResult.targetColumnIndex,
      reverse: bestResult.reverse
    };
    var result = calculateSankey(Object.assign({}, calcOptions, {
      offsetX,
      offsetY,
      width,
      height
    }, this.permutation));
    return {
      sankey: result,
      legendBox,
      titleBox
    };
  };
  Sankey4.prototype._render = function _render(options, context) {
    var sankeyOptions = options || this.options;
    var sankeyContext = context || this;
    var labelOptions = sankeyOptions.labels;
    var nodesOptions = sankeyOptions.nodes;
    var linkOptions = sankeyOptions.links;
    var nodeColors = sankeyOptions.nodeColors;
    var title2 = sankeyOptions.title;
    var legend2 = sankeyOptions.legend;
    var rtl = sankeyOptions.rtl;
    var disableKeyboardNavigation = sankeyOptions.disableKeyboardNavigation;
    var data = sankeyOptions.data;
    var ref2 = sankeyContext.size;
    var width = ref2.width;
    var height = ref2.height;
    var calcOptions = Object.assign({}, data, {
      width,
      height,
      nodesOptions,
      title: title2,
      legend: legend2
    });
    var ref$1 = this.calculateSankey(calcOptions, sankeyOptions);
    var sankey = ref$1.sankey;
    var titleBox = ref$1.titleBox;
    var legendBox = ref$1.legendBox;
    if (rtl) {
      toRtl(sankey);
    }
    var nodes = sankey.nodes;
    var links = sankey.links;
    var columns = sankey.columns;
    sankeyContext.columns = columns.map(function(column) {
      var newColumn = column.slice();
      newColumn.sort(function(a, b) {
        return a.y0 - b.y0;
      });
      return newColumn;
    });
    var visual = new drawing_exports.Group({
      clip: drawing_exports.Path.fromRect(new geometry_exports.Rect([0, 0], [width, height]))
    });
    if (titleBox) {
      var titleElement = new Title2(Object.assign({}, title2, {
        drawingRect: titleBox
      }));
      var titleVisual = titleElement.exportVisual();
      visual.append(titleVisual);
    }
    if (sankey.circularLinks) {
      return visual;
    }
    var visualNodes = /* @__PURE__ */ new Map();
    sankeyContext.nodesVisuals = visualNodes;
    var models = {
      nodes: [],
      links: [],
      map: /* @__PURE__ */ new Map()
    };
    sankeyContext.models = models;
    var focusHighlights = [];
    nodes.forEach(function(node, i) {
      var nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i);
      nodeOps.root = function() {
        return sankeyContext.element;
      };
      nodeOps.navigatable = disableKeyboardNavigation !== true;
      var nodeInstance = new Node(nodeOps);
      var nodeVisual = nodeInstance.exportVisual();
      nodeVisual.links = [];
      nodeVisual.type = NODE;
      node.color = nodeOps.color;
      node.opacity = nodeOps.opacity;
      nodeVisual.dataItem = Object.assign({}, data.nodes[i], {
        color: nodeOps.color,
        opacity: nodeOps.opacity,
        sourceLinks: node.sourceLinks.map(function(link) {
          return {
            sourceId: link.sourceId,
            targetId: link.targetId,
            value: link.value
          };
        }),
        targetLinks: node.targetLinks.map(function(link) {
          return {
            sourceId: link.sourceId,
            targetId: link.targetId,
            value: link.value
          };
        })
      });
      visualNodes.set(node.id, nodeVisual);
      models.nodes.push(nodeInstance);
      models.map.set(node.id, nodeInstance);
      visual.append(nodeVisual);
      nodeInstance.createFocusHighlight();
      if (nodeInstance._highlight) {
        focusHighlights.push(nodeInstance._highlight);
      }
    });
    var sortedLinks = links.slice().sort(function(a, b) {
      return b.value - a.value;
    });
    var linksVisuals = [];
    sankeyContext.linksVisuals = linksVisuals;
    sortedLinks.forEach(function(link) {
      var source = link.source;
      var target = link.target;
      var sourceNode = visualNodes.get(source.id);
      var targetNode = visualNodes.get(target.id);
      var resolvedOptions = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
      resolvedOptions.root = function() {
        return sankeyContext.element;
      };
      resolvedOptions.navigatable = disableKeyboardNavigation !== true;
      resolvedOptions.rtl = rtl;
      var linkInstance = new Link(resolvedOptions);
      var linkVisual = linkInstance.exportVisual();
      linkVisual.type = LINK;
      linkVisual.dataItem = {
        source: Object.assign({}, sourceNode.dataItem),
        target: Object.assign({}, targetNode.dataItem),
        value: link.value
      };
      linkVisual.linkOptions = resolvedOptions;
      linksVisuals.push(linkVisual);
      sourceNode.links.push(linkVisual);
      targetNode.links.push(linkVisual);
      models.links.push(linkInstance);
      models.map.set(source.id + "-" + target.id, linkInstance);
      linkInstance.createFocusHighlight();
      if (linkInstance._highlight) {
        focusHighlights.push(linkInstance._highlight);
      }
      visual.append(linkVisual);
    });
    var diagramMinX = nodes.reduce(function(acc, node) {
      return Math.min(acc, node.x0);
    }, Infinity);
    var diagramMaxX = nodes.reduce(function(acc, node) {
      return Math.max(acc, node.x1);
    }, 0);
    nodes.forEach(function(node) {
      var textOps = resolveLabelOptions(node, labelOptions, rtl, diagramMinX, diagramMaxX);
      var labelInstance = new Label(textOps);
      var labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        visual.append(labelVisual);
      }
    });
    if (legendBox) {
      var legendElement = new Legend2(Object.assign({}, legend2, {
        rtl,
        drawingRect: legendBox,
        nodes
      }));
      var legendVisual = legendElement.exportVisual();
      visual.append(legendVisual);
    }
    if (focusHighlights.length !== 0) {
      var focusHighlight = new drawing_exports.Group();
      focusHighlight.append.apply(focusHighlight, focusHighlights);
      visual.append(focusHighlight);
    }
    return visual;
  };
  Sankey4.prototype.exportVisual = function exportVisual(exportOptions) {
    var options = exportOptions && exportOptions.options ? deepExtend({}, this.options, exportOptions.options) : this.options;
    var context = {
      size: {
        width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
        height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
      }
    };
    return this._render(options, context);
  };
  Sankey4.prototype._setOptions = function _setOptions(options) {
    this.options = deepExtend({}, this.options, options);
  };
  return Sankey4;
}(observable_default);
var highlightOptions = {
  opacity: 1,
  width: 2,
  color: BLACK
};
setDefaultOptions(Sankey3, {
  title: {
    position: TOP
    // 'top', 'bottom'
  },
  labels: {
    visible: true,
    margin: {
      left: 8,
      right: 8
    },
    padding: 0,
    border: {
      width: 0
    },
    paintOrder: "stroke",
    stroke: {
      lineJoin: "round",
      width: 1
    },
    offset: {
      left: 0,
      top: 0
    }
  },
  nodes: {
    width: 24,
    padding: 16,
    opacity: 1,
    align: "stretch",
    // 'left', 'right', 'stretch'
    offset: {
      left: 0,
      top: 0
    },
    focusHighlight: Object.assign({}, highlightOptions),
    labels: {
      ariaTemplate: function(ref2) {
        var node = ref2.node;
        return node.label.text;
      }
    }
  },
  links: {
    colorType: "static",
    // 'source', 'target', 'static'
    opacity: 0.4,
    highlight: {
      opacity: 0.8,
      inactiveOpacity: 0.2
    },
    focusHighlight: Object.assign({}, highlightOptions),
    labels: {
      ariaTemplate: function(ref2) {
        var link = ref2.link;
        return link.source.label.text + " to " + link.target.label.text;
      }
    }
  },
  tooltip: {
    followPointer: false,
    delay: 200
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/utils.js
var createSankeyData = function(data, dimensions, measure) {
  var nodes = /* @__PURE__ */ new Set();
  var links = /* @__PURE__ */ new Map();
  var linksMap = /* @__PURE__ */ new Map();
  data.forEach(function(row) {
    dimensions.forEach(function(dimension) {
      nodes.add(dimension.value(row));
    });
    for (var i = 0; i < dimensions.length - 1; i++) {
      var source = dimensions[i].value(row);
      var target = dimensions[i + 1].value(row);
      var key = source + "_" + target;
      var value2 = measure.value(row);
      var existingValue = links.get(key);
      if (existingValue !== void 0) {
        links.set(key, existingValue + value2);
      } else {
        links.set(key, value2);
        linksMap.set(key, {
          source,
          target
        });
      }
    }
  });
  var nodesId = /* @__PURE__ */ new Map();
  var nodesArray = Array.from(nodes).map(function(node, index) {
    nodesId.set(node, index);
    return {
      id: index,
      label: {
        text: String(node)
      }
    };
  });
  var linksArray = Array.from(links).map(function(ref2) {
    var key = ref2[0];
    var value2 = ref2[1];
    var ref$1 = linksMap.get(key);
    var source = ref$1.source;
    var target = ref$1.target;
    return {
      sourceId: nodesId.get(source),
      targetId: nodesId.get(target),
      value: value2
    };
  });
  return {
    nodes: nodesArray,
    links: linksArray
  };
};

// node_modules/@progress/kendo-charts/dist/es/chart/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var lineSeriesLegendItem = {
  type: LINE
};
var areaSeriesLegendItem = {
  type: AREA
};
var areaNoMarkersSeriesLegendItem = Object.assign({}, areaSeriesLegendItem, {
  markers: {
    visible: false
  },
  highlight: {
    visible: false
  }
});
var notes = function() {
  return {
    icon: {
      border: {
        width: 1
      }
    },
    label: {
      font: SANS12,
      padding: 3
    },
    line: {
      length: 10,
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    visible: true
  };
};
var axisDefaults = function() {
  return {
    labels: {
      font: SANS12
    },
    notes: notes(),
    title: {
      font: SANS16,
      margin: 5
    }
  };
};
var areaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var rangeAreaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.4
  };
};
var barSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var boxPlotSeries = function() {
  return {
    outliersField: "",
    meanField: "",
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      whiskers: {
        width: 3
      },
      mean: {
        width: 2
      },
      median: {
        width: 2
      }
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    },
    spacing: 0.3,
    whiskers: {
      width: 2
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var bubbleSeries = function() {
  return {
    border: {
      width: 0
    },
    labels: {
      background: TRANSPARENT
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    opacity: 0.6
  };
};
var bulletSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    target: {
      color: "#ff0000"
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var candlestickSeries = function() {
  return {
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      line: {
        width: 2
      }
    },
    line: {
      color: BLACK2,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var columnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var radarColumnSeries = function() {
  return {
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var polarScatterSeries = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var scatterSeries = function() {
  return {
    legendItem: lineSeriesLegendItem
  };
};
var donutSeries = function() {
  return {
    margin: 1,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var lineSeries = function() {
  return {
    width: 2,
    legendItem: lineSeriesLegendItem
  };
};
var ohlcSeries = function() {
  return {
    gap: 1,
    highlight: {
      line: {
        opacity: 1,
        width: 3
      }
    },
    line: {
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: 0.3
  };
};
var radarAreaSeries = function() {
  return {
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    legendItem: areaSeriesLegendItem,
    opacity: 0.5
  };
};
var radarLineSeries = function() {
  return {
    markers: {
      visible: false
    },
    legendItem: lineSeriesLegendItem,
    width: 2
  };
};
var rangeBarSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var rangeColumnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var scatterLineSeries = function() {
  return {
    width: 1,
    legendItem: lineSeriesLegendItem
  };
};
var waterfallSeries = function() {
  return {
    gap: 0.5,
    line: {
      color: BLACK2,
      width: 1
    },
    legendItem: areaNoMarkersSeriesLegendItem,
    spacing: BAR_SPACING
  };
};
var pieSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var funnelSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var pyramidSeries = funnelSeries;
var heatmapSeries = function() {
  return {
    labels: {
      color: "",
      background: TRANSPARENT,
      visible: true
    },
    highlight: {
      border: {
        width: 0
      }
    },
    legendItem: areaNoMarkersSeriesLegendItem
  };
};
var trendlineSeriesDefaults = function(options) {
  return Object.assign({
    color: INHERIT,
    trendline: {},
    markers: {
      visible: false
    },
    width: 1,
    dashType: "longDash",
    legendItem: lineSeriesLegendItem
  }, options);
};
var seriesDefaults = function(options) {
  return {
    visible: true,
    labels: {
      font: SANS11
    },
    overlay: options.gradients ? {} : {
      gradient: "none"
    },
    area: areaSeries(),
    rangeArea: rangeAreaSeries(),
    verticalRangeArea: rangeAreaSeries(),
    bar: barSeries(),
    boxPlot: boxPlotSeries(),
    bubble: bubbleSeries(),
    bullet: bulletSeries(),
    candlestick: candlestickSeries(),
    column: columnSeries(),
    heatmap: heatmapSeries(),
    pie: pieSeries(),
    donut: donutSeries(),
    funnel: funnelSeries(),
    pyramid: pyramidSeries(),
    horizontalWaterfall: waterfallSeries(),
    line: lineSeries(),
    notes: notes(),
    ohlc: ohlcSeries(),
    radarArea: radarAreaSeries(),
    radarLine: radarLineSeries(),
    radarColumn: radarColumnSeries(),
    polarArea: radarAreaSeries(),
    polarLine: radarLineSeries(),
    polarScatter: polarScatterSeries(),
    rangeBar: rangeBarSeries(),
    rangeColumn: rangeColumnSeries(),
    scatter: scatterSeries(),
    scatterLine: scatterLineSeries(),
    verticalArea: areaSeries(),
    verticalBoxPlot: boxPlotSeries(),
    verticalBullet: bulletSeries(),
    verticalLine: lineSeries(),
    waterfall: waterfallSeries(),
    linearTrendline: trendlineSeriesDefaults(),
    exponentialTrendline: trendlineSeriesDefaults({
      style: "smooth"
    }),
    logarithmicTrendline: trendlineSeriesDefaults({
      style: "smooth"
    }),
    polynomialTrendline: trendlineSeriesDefaults({
      style: "smooth"
    }),
    powerTrendline: trendlineSeriesDefaults({
      style: "smooth"
    }),
    movingAverageTrendline: trendlineSeriesDefaults()
  };
};
var title = function() {
  return {
    font: SANS16
  };
};
var subtitle = function() {
  return {
    font: SANS12
  };
};
var legend = function() {
  return {
    labels: {
      font: SANS12
    }
  };
};
var baseTheme = function(options) {
  if (options === void 0) options = {};
  return {
    axisDefaults: axisDefaults(),
    categoryAxis: {
      majorGridLines: {
        visible: true
      }
    },
    navigator: {
      pane: {
        height: 90,
        margin: {
          top: 10
        }
      }
    },
    seriesDefaults: seriesDefaults(options),
    title: title(),
    subtitle: subtitle(),
    legend: legend()
  };
};

// node_modules/@progress/kendo-angular-charts/fesm2015/progress-kendo-angular-charts.mjs
var import_rxjs = __toESM(require_cjs(), 1);
var import_operators = __toESM(require_operators(), 1);

// node_modules/@progress/kendo-angular-charts/node_modules/@progress/kendo-svg-icons/dist/index.es.js
var arrowRightIcon = {
  name: "arrow-right",
  content: '<path d="M224 384v-96H96v-64h128v-96l192 128z" />',
  viewBox: "0 0 512 512"
};
var homeIcon = {
  name: "home",
  content: '<path d="M480 256c0 17.7-14.3 32-32 32-9.1 0-17.4-3.8-23.2-10l-8.8-8.7V416c0 17.7-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32v-96h-64v96c0 17.7-14.3 32-32 32h-64c-17.7 0-32-14.3-32-32V268.6l-8.3 8.9C81.8 284 73.4 288 64 288c-17.7 0-32-14.3-32-32 0-8.5 3.3-16.1 8.6-21.9l.2-.2 1-1 191-191.3 1-1c5.8-5.5 13.6-8.9 22.2-8.9 9.1 0 17.3 3.8 23.1 9.9L470.3 233l.7.7.3.3c5.4 5.8 8.7 13.5 8.7 22" />',
  viewBox: "0 0 512 512"
};

// node_modules/@progress/kendo-angular-charts/fesm2015/progress-kendo-angular-charts.mjs
var _c0 = ["content"];
function CrosshairTooltipComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r0.style);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.value, " ");
  }
}
function CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-chart-crosshair-tooltip", 1);
  }
  if (rf & 2) {
    const key_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("key", key_r1)("popupSettings", ctx_r1.popupSettings);
  }
}
function TooltipPopupComponent_ng_template_0_1_ng_template_0_Template(rf, ctx) {
}
function TooltipPopupComponent_ng_template_0_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.seriesTooltipTemplateRef)("ngTemplateOutletContext", ctx_r0.seriesTooltipContext);
  }
}
function TooltipPopupComponent_ng_template_0_2_ng_template_0_Template(rf, ctx) {
}
function TooltipPopupComponent_ng_template_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.seriesSharedTooltipTemplateRef)("ngTemplateOutletContext", ctx_r0.seriesSharedTooltipContext);
  }
}
function TooltipPopupComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, TooltipPopupComponent_ng_template_0_1_Template, 1, 2, null, 4)(2, TooltipPopupComponent_ng_template_0_2_Template, 1, 2, null, 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.popupClasses)("ngStyle", ctx_r0.style);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.shared);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.shared);
  }
}
function TooltipPopupComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 6);
  }
  if (rf & 2) {
    const formattedValue_r2 = ctx.formattedValue;
    ɵɵproperty("innerHTML", formattedValue_r2, ɵɵsanitizeHtml);
  }
}
function TooltipPopupComponent_ng_template_3_tr_4_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td");
    ɵɵelement(1, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const point_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵstyleProp("background-color", point_r3.series.color);
  }
}
function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const point_r3 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(point_r3.series.name);
  }
}
function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1, " ");
    ɵɵelementContainerEnd();
  }
}
function TooltipPopupComponent_ng_template_3_tr_4_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td");
    ɵɵtemplate(1, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template, 2, 1, "ng-container", 4)(2, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template, 2, 0, "ng-container", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const point_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", point_r3.series.name !== void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", point_r3.series.name === void 0);
  }
}
function TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template(rf, ctx) {
}
function TooltipPopupComponent_ng_template_3_tr_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr");
    ɵɵtemplate(1, TooltipPopupComponent_ng_template_3_tr_4_td_1_Template, 2, 2, "td", 4)(2, TooltipPopupComponent_ng_template_3_tr_4_td_2_Template, 3, 2, "td", 4);
    ɵɵelementStart(3, "td");
    ɵɵtemplate(4, TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template, 0, 0, "ng-template", 5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const point_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext();
    const colorMarker_r5 = ctx_r3.colorMarker;
    const nameColumn_r6 = ctx_r3.nameColumn;
    ɵɵadvance();
    ɵɵproperty("ngIf", colorMarker_r5);
    ɵɵadvance();
    ɵɵproperty("ngIf", nameColumn_r6);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", point_r3.template)("ngTemplateOutletContext", point_r3);
  }
}
function TooltipPopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "table")(1, "tr")(2, "th");
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵtemplate(4, TooltipPopupComponent_ng_template_3_tr_4_Template, 5, 4, "tr", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const points_r7 = ctx.points;
    const categoryText_r8 = ctx.categoryText;
    const colspan_r9 = ctx.colspan;
    ɵɵadvance(2);
    ɵɵattribute("colspan", colspan_r9);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", categoryText_r8, " ");
    ɵɵadvance();
    ɵɵproperty("ngForOf", points_r7);
  }
}
var _c1 = ["surface"];
function ChartComponent_div_5_ng_template_1_Template(rf, ctx) {
}
function ChartComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, ChartComponent_div_5_ng_template_1_Template, 0, 0, "ng-template", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r1.donutCenterStyle);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.donutCenterTemplate.templateRef);
  }
}
function ChartComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 9);
  }
}
var _c2 = ["breadcrumb"];
function StockChartComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
}
function SparklineComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
}
function SankeyTooltipPopupComponent_ng_template_0_2_ng_template_0_Template(rf, ctx) {
}
function SankeyTooltipPopupComponent_ng_template_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SankeyTooltipPopupComponent_ng_template_0_2_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.nodeTooltipTemplateRef)("ngTemplateOutletContext", ctx_r0.nodeTooltipContext);
  }
}
function SankeyTooltipPopupComponent_ng_template_0_3_ng_template_0_Template(rf, ctx) {
}
function SankeyTooltipPopupComponent_ng_template_0_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SankeyTooltipPopupComponent_ng_template_0_3_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.linkTooltipTemplateRef)("ngTemplateOutletContext", ctx_r0.linkTooltipContext);
  }
}
function SankeyTooltipPopupComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3)(1, "div", 4);
    ɵɵtemplate(2, SankeyTooltipPopupComponent_ng_template_0_2_Template, 1, 2, null, 5)(3, SankeyTooltipPopupComponent_ng_template_0_3_Template, 1, 2, null, 5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r0.style);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.isNode);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isLink);
  }
}
function SankeyTooltipPopupComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "div", 8);
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 7);
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const color_r2 = ctx.color;
    const label_r3 = ctx.label;
    const value_r4 = ctx.value;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r0.tooltipStyle);
    ɵɵadvance();
    ɵɵproperty("color", color_r2);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.textStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(label_r3.text);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.textStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.formatUnits(value_r4));
  }
}
function SankeyTooltipPopupComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵelement(1, "div", 8);
    ɵɵelementStart(2, "span", 7);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "kendo-icon-wrapper", 9);
    ɵɵelementStart(5, "span", 7);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelementStart(7, "span", 7);
    ɵɵtext(8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const source_r5 = ctx.source;
    const target_r6 = ctx.target;
    const value_r7 = ctx.value;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r0.tooltipStyle);
    ɵɵadvance();
    ɵɵproperty("color", source_r5.color);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.textStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(source_r5.label == null ? null : source_r5.label.text);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.arrowRightIcon);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.textStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(target_r6.label == null ? null : target_r6.label.text);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ctx_r0.textStyle);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.formatUnits(value_r7));
  }
}
var _c3 = ["instance"];
function SankeyComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
}
var dateCategoryAxisFormats = date_category_axis_default.prototype.options.labels.dateFormats;
var dateValueAxisFormats = date_value_axis_default.prototype.options.labels.dateFormats;
var dateFormats = {
  milliseconds: "HH:mm:ss.SSS",
  seconds: {
    time: "medium"
  },
  minutes: {
    time: "short"
  },
  hours: {
    time: "short"
  },
  days: {
    skeleton: "Md"
  },
  weeks: {
    skeleton: "Md"
  },
  months: {
    skeleton: "yyMMM"
  },
  years: {
    skeleton: "y"
  }
};
Object.assign(dateCategoryAxisFormats, dateFormats);
Object.assign(dateValueAxisFormats, dateFormats);
var DonutCenterTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
DonutCenterTemplateDirective.ɵfac = function DonutCenterTemplateDirective_Factory(t) {
  return new (t || DonutCenterTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
DonutCenterTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: DonutCenterTemplateDirective,
  selectors: [["", "kendoChartDonutCenterTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DonutCenterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChartDonutCenterTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ItemChange = class {
  constructor(sender, options) {
    this.sender = sender;
    this.options = options;
  }
};
var CollectionService = class {
  constructor() {
    this.source = new import_rxjs.Subject();
    this.onItemChange$ = this.source.asObservable();
  }
  notify(change) {
    this.source.next(change);
  }
};
CollectionService.ɵfac = function CollectionService_Factory(t) {
  return new (t || CollectionService)();
};
CollectionService.ɵprov = ɵɵdefineInjectable({
  token: CollectionService,
  factory: CollectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CollectionService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
function copyChanges(changes, options) {
  for (const propertyName in changes) {
    if (!Object.hasOwnProperty.call(changes, propertyName)) {
      continue;
    }
    const value2 = changes[propertyName].currentValue;
    if (value2 === void 0) {
      delete options[propertyName];
    } else {
      options[propertyName] = value2;
    }
  }
}
function toSimpleChanges(changes) {
  const result = {};
  for (const propertyName in changes) {
    if (!Object.hasOwnProperty.call(changes, propertyName)) {
      continue;
    }
    result[propertyName] = new SimpleChange(null, changes[propertyName], false);
  }
  return result;
}
var THROTTLE_MS = 1e3 / 60;
var Change = class {
  constructor(key, value2) {
    this.key = key;
    this.value = value2;
  }
};
var ConfigurationService = class {
  constructor(ngZone) {
    this.ngZone = ngZone;
    this.store = {};
    this.source = new import_rxjs.BehaviorSubject({});
    this.initSource();
  }
  initSource() {
    this.onFastChange$ = this.source.asObservable();
    this.onChange$ = this.onFastChange$.pipe((0, import_operators.auditTime)(THROTTLE_MS));
  }
  push(store) {
    this.store = store;
    this.next();
  }
  notify(change) {
    this.set(change.key, change.value);
    this.next();
  }
  set(field, value2) {
    let store = this.store;
    const parts = field.split(".");
    let key = parts.shift();
    while (parts.length > 0) {
      store = store[key] = store[key] || {};
      key = parts.shift();
    }
    store[key] = value2;
  }
  next() {
    this.ngZone.runOutsideAngular(() => {
      this.source.next(this.store);
    });
  }
};
ConfigurationService.ɵfac = function ConfigurationService_Factory(t) {
  return new (t || ConfigurationService)(ɵɵinject(NgZone));
};
ConfigurationService.ɵprov = ɵɵdefineInjectable({
  token: ConfigurationService,
  factory: ConfigurationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurationService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var CollectionItemComponent = class {
  constructor(configurationService, collectionService) {
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.options = {};
    this.hidden = false;
    this.subscription = configurationService.onFastChange$.subscribe((store) => {
      this.options = store;
      this.notify();
    });
  }
  ngOnChanges(changes) {
    const store = this.configurationService.store;
    copyChanges(changes, store);
    this.configurationService.push(store);
  }
  /**
   * Updates the component fields with the specified values and refreshes the Chart.
   *
   * Use this method when the configuration values cannot be set through the template.
   *
   * @example
   * ```ts-no-run
   * item.notifyChanges({ visible: true });
   * ```
   *
   * @param changes An object containing the updated input fields.
   */
  notifyChanges(changes) {
    this.ngOnChanges(toSimpleChanges(changes));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  notify() {
    if (!this.collectionService) {
      return;
    }
    this.collectionService.notify(new ItemChange(this, this.options));
  }
};
CollectionItemComponent.ɵfac = function CollectionItemComponent_Factory(t) {
  return new (t || CollectionItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
CollectionItemComponent.ɵdir = ɵɵdefineDirective({
  type: CollectionItemComponent,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CollectionItemComponent, [{
    type: Directive
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, null);
})();
var SettingsComponent = class {
  constructor(configKey, configurationService) {
    this.configKey = configKey;
    this.configurationService = configurationService;
    this.store = {};
    if (configKey === void 0) {
      throw new Error("Configuration key not set");
    }
  }
  ngOnDestroy() {
    this.store = void 0;
    this.notify();
  }
  ngOnChanges(changes) {
    copyChanges(changes, this.store);
    this.notify();
  }
  /**
   * Updates the component fields with the specified values and refreshes the Chart.
   *
   * Use this method when the configuration values cannot be set through the template.
   *
   * @example
   * ```ts-no-run
   * item.notifyChanges({ visible: true });
   * ```
   *
   * @param changes An object containing the updated input fields.
   */
  notifyChanges(changes) {
    this.ngOnChanges(toSimpleChanges(changes));
  }
  markAsVisible() {
    this.store.visible = true;
    this.notify();
  }
  notify() {
    this.configurationService.notify(new Change(this.configKey, this.store));
  }
};
SettingsComponent.ɵfac = function SettingsComponent_Factory(t) {
  ɵɵinvalidFactory();
};
SettingsComponent.ɵdir = ɵɵdefineDirective({
  type: SettingsComponent,
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SettingsComponent, [{
    type: Directive
  }], function() {
    return [{
      type: void 0
    }, {
      type: ConfigurationService
    }];
  }, null);
})();
var SeriesTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
  get seriesTooltipTemplateRef() {
    return this.seriesTooltipTemplate;
  }
};
SeriesTooltipComponent.ɵfac = function SeriesTooltipComponent_Factory(t) {
  return new (t || SeriesTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesTooltipComponent,
  selectors: [["kendo-chart-series-item-tooltip"]],
  contentQueries: function SeriesTooltipComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    }
  },
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: [TemplateRef, {
        static: false
      }]
    }]
  });
})();
var SeriesDrilldownTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
SeriesDrilldownTemplateDirective.ɵfac = function SeriesDrilldownTemplateDirective_Factory(t) {
  return new (t || SeriesDrilldownTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
SeriesDrilldownTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: SeriesDrilldownTemplateDirective,
  selectors: [["", "kendoChartDrilldownSeries", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDrilldownTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChartDrilldownSeries]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var toggle = (flag) => flag === void 0 ? false : !flag;
var SeriesItemComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
  /**
   * Toggles the series visibility and updates the parent Chart
   * without animated transitions.
   */
  toggleVisibility() {
    this.options.visible = toggle(this.options.visible);
    this.notify();
  }
  /**
   * Toggles the visibility of a point with the given index.
   * Applicable for the Pie, Donut, Funnel and Pyramid series.
   *
   * @param pointIndex - The zero-based index of the point to toggle.
   */
  togglePointVisibility(pointIndex) {
    const pv = this.options.pointVisibility = this.options.pointVisibility || {};
    pv[pointIndex] = toggle(pv[pointIndex]);
    this.notify();
  }
  get seriesTooltipTemplateRef() {
    if (this.seriesTooltip) {
      return this.seriesTooltip.seriesTooltipTemplateRef;
    }
  }
};
SeriesItemComponent.ɵfac = function SeriesItemComponent_Factory(t) {
  return new (t || SeriesItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
SeriesItemComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesItemComponent,
  selectors: [["kendo-chart-series-item"]],
  contentQueries: function SeriesItemComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SeriesTooltipComponent, 5);
      ɵɵcontentQuery(dirIndex, SeriesDrilldownTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.seriesTooltip = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.drilldownTemplate = _t.first);
    }
  },
  inputs: {
    aggregate: "aggregate",
    autoFit: "autoFit",
    axis: "axis",
    border: "border",
    categoryAxis: "categoryAxis",
    categoryField: "categoryField",
    closeField: "closeField",
    color: "color",
    colorField: "colorField",
    connectors: "connectors",
    currentField: "currentField",
    dashType: "dashType",
    data: "data",
    downColor: "downColor",
    downColorField: "downColorField",
    drilldownField: "drilldownField",
    dynamicHeight: "dynamicHeight",
    dynamicSlope: "dynamicSlope",
    errorHighField: "errorHighField",
    errorLowField: "errorLowField",
    explodeField: "explodeField",
    field: "field",
    fromField: "fromField",
    gap: "gap",
    highField: "highField",
    holeSize: "holeSize",
    line: "line",
    lowField: "lowField",
    lowerField: "lowerField",
    margin: "margin",
    maxSize: "maxSize",
    mean: "mean",
    meanField: "meanField",
    median: "median",
    medianField: "medianField",
    minSize: "minSize",
    missingValues: "missingValues",
    name: "name",
    neckRatio: "neckRatio",
    negativeColor: "negativeColor",
    negativeValues: "negativeValues",
    noteTextField: "noteTextField",
    opacity: "opacity",
    openField: "openField",
    outliersField: "outliersField",
    overlay: "overlay",
    padding: "padding",
    q1Field: "q1Field",
    q3Field: "q3Field",
    segmentSpacing: "segmentSpacing",
    size: "size",
    sizeField: "sizeField",
    spacing: "spacing",
    stack: "stack",
    startAngle: "startAngle",
    style: "style",
    summaryField: "summaryField",
    target: "target",
    toField: "toField",
    type: "type",
    upperField: "upperField",
    visible: "visible",
    visibleInLegend: "visibleInLegend",
    visibleInLegendField: "visibleInLegendField",
    visual: "visual",
    width: "width",
    whiskers: "whiskers",
    xAxis: "xAxis",
    xErrorHighField: "xErrorHighField",
    xErrorLowField: "xErrorLowField",
    xField: "xField",
    yAxis: "yAxis",
    yErrorHighField: "yErrorHighField",
    yErrorLowField: "yErrorLowField",
    yField: "yField",
    zIndex: "zIndex",
    trendline: "trendline",
    for: "for",
    legendItem: "legendItem",
    errorBars: "errorBars",
    extremes: "extremes",
    highlight: "highlight",
    labels: "labels",
    markers: "markers",
    notes: "notes",
    outliers: "outliers",
    tooltip: "tooltip"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-series-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    aggregate: [{
      type: Input
    }],
    autoFit: [{
      type: Input
    }],
    axis: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    categoryAxis: [{
      type: Input
    }],
    categoryField: [{
      type: Input
    }],
    closeField: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    colorField: [{
      type: Input
    }],
    connectors: [{
      type: Input
    }],
    currentField: [{
      type: Input
    }],
    dashType: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    downColor: [{
      type: Input
    }],
    downColorField: [{
      type: Input
    }],
    drilldownField: [{
      type: Input
    }],
    dynamicHeight: [{
      type: Input
    }],
    dynamicSlope: [{
      type: Input
    }],
    errorHighField: [{
      type: Input
    }],
    errorLowField: [{
      type: Input
    }],
    explodeField: [{
      type: Input
    }],
    field: [{
      type: Input
    }],
    fromField: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    highField: [{
      type: Input
    }],
    holeSize: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    lowField: [{
      type: Input
    }],
    lowerField: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    maxSize: [{
      type: Input
    }],
    mean: [{
      type: Input
    }],
    meanField: [{
      type: Input
    }],
    median: [{
      type: Input
    }],
    medianField: [{
      type: Input
    }],
    minSize: [{
      type: Input
    }],
    missingValues: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    neckRatio: [{
      type: Input
    }],
    negativeColor: [{
      type: Input
    }],
    negativeValues: [{
      type: Input
    }],
    noteTextField: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    openField: [{
      type: Input
    }],
    outliersField: [{
      type: Input
    }],
    overlay: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    q1Field: [{
      type: Input
    }],
    q3Field: [{
      type: Input
    }],
    segmentSpacing: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    sizeField: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    stack: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    summaryField: [{
      type: Input
    }],
    target: [{
      type: Input
    }],
    toField: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    upperField: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visibleInLegend: [{
      type: Input
    }],
    visibleInLegendField: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    whiskers: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    xErrorHighField: [{
      type: Input
    }],
    xErrorLowField: [{
      type: Input
    }],
    xField: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    yErrorHighField: [{
      type: Input
    }],
    yErrorLowField: [{
      type: Input
    }],
    yField: [{
      type: Input
    }],
    zIndex: [{
      type: Input
    }],
    trendline: [{
      type: Input
    }],
    for: [{
      type: Input
    }],
    legendItem: [{
      type: Input
    }],
    errorBars: [{
      type: Input
    }],
    extremes: [{
      type: Input
    }],
    highlight: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    outliers: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    seriesTooltip: [{
      type: ContentChild,
      args: [SeriesTooltipComponent, {
        static: false
      }]
    }],
    drilldownTemplate: [{
      type: ContentChild,
      args: [SeriesDrilldownTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var POSITION_MODE = "absolute";
var COLLISION = {
  horizontal: "fit",
  vertical: "fit"
};
var BaseTooltip2 = class {
  constructor(popupService, localizationService) {
    this.popupService = popupService;
    this.localizationService = localizationService;
    this.style = {};
    this.popupRef = null;
  }
  get active() {
    return this.popupRef !== null;
  }
  show(e) {
    const align = e.anchor.align;
    const offset = this.position(e.anchor.point);
    this.style = e.style;
    if (!this.popupRef) {
      this.popupRef = this.popupService.open(Object.assign({
        offset,
        popupAlign: align,
        animate: this.animate,
        content: this.templateRef,
        collision: COLLISION,
        positionMode: POSITION_MODE
      }, this.popupSettings));
      if (this.localizationService.rtl) {
        this.popupRef.popupElement.setAttribute("dir", "rtl");
      }
      this.onInit();
    } else {
      const popup = this.popupRef.popup.instance;
      popup.offset = offset;
      popup.popupAlign = align;
    }
  }
  onInit() {
  }
  hide() {
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  ngOnDestroy() {
    this.hide();
  }
  position(offset) {
    if (!this.popupSettings || !this.popupSettings.appendTo) {
      return offset;
    }
    const appendTo = this.popupSettings.appendTo.element.nativeElement;
    const bbox = appendTo.getBoundingClientRect();
    const {
      scrollLeft,
      scrollTop
    } = this.scrollOffset(appendTo);
    return {
      left: offset.left - bbox.left - scrollLeft,
      top: offset.top - bbox.top - scrollTop
    };
  }
  scrollOffset(element) {
    if (!element) {
      return null;
    }
    let scrollLeft = element.scrollLeft;
    let scrollTop = element.scrollTop;
    let parent = element.parentElement;
    while (parent) {
      scrollLeft += parent.scrollLeft;
      scrollTop += parent.scrollTop;
      parent = parent.parentElement;
    }
    return {
      scrollLeft,
      scrollTop
    };
  }
};
BaseTooltip2.ɵfac = function BaseTooltip_Factory(t) {
  return new (t || BaseTooltip2)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(LocalizationService));
};
BaseTooltip2.ɵdir = ɵɵdefineDirective({
  type: BaseTooltip2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseTooltip2, [{
    type: Directive
  }], function() {
    return [{
      type: PopupService
    }, {
      type: LocalizationService
    }];
  }, null);
})();
function bodyFactory() {
  if (isDocumentAvailable()) {
    return new ElementRef(document.body);
  }
}
var CrosshairTooltipComponent = class extends BaseTooltip2 {
  constructor(popupService, localizationService) {
    super(popupService, localizationService);
    this.animate = false;
  }
  show(e) {
    super.show(e);
    this.value = e.value;
    this.popupRef.popup.changeDetectorRef.detectChanges();
  }
};
CrosshairTooltipComponent.ɵfac = function CrosshairTooltipComponent_Factory(t) {
  return new (t || CrosshairTooltipComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(LocalizationService));
};
CrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: CrosshairTooltipComponent,
  selectors: [["kendo-chart-crosshair-tooltip"]],
  viewQuery: function CrosshairTooltipComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    key: "key",
    popupSettings: "popupSettings"
  },
  features: [ɵɵProvidersFeature([PopupService, {
    provide: POPUP_CONTAINER,
    useFactory: bodyFactory
  }]), ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [["content", ""], [1, "k-chart-tooltip", "k-chart-crosshair-tooltip", 3, "ngStyle"]],
  template: function CrosshairTooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CrosshairTooltipComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  dependencies: [NgStyle],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CrosshairTooltipComponent, [{
    type: Component,
    args: [{
      providers: [PopupService, {
        provide: POPUP_CONTAINER,
        useFactory: bodyFactory
      }],
      selector: "kendo-chart-crosshair-tooltip",
      template: `
        <ng-template #content>
            <div class="k-chart-tooltip k-chart-crosshair-tooltip" [ngStyle]="style">
                {{ value }}
            </div>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: LocalizationService
    }];
  }, {
    templateRef: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    key: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }]
  });
})();
var AXES = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
var CrosshairTooltipsContainerComponent = class {
  constructor() {
    this.tooltipKeys = [];
    this.tooltipsMap = {};
  }
  show(e) {
    const tooltipComponents = this.crossahirTooltipComponents.toArray();
    const axisName = e.axisName;
    const axisIndex = e.axisIndex;
    for (let idx = 0; idx < tooltipComponents.length; idx++) {
      if (tooltipComponents[idx].key === axisName + axisIndex) {
        tooltipComponents[idx].show(e);
        break;
      }
    }
  }
  hide() {
    const tooltipComponents = this.crossahirTooltipComponents.toArray();
    for (let idx = 0; idx < tooltipComponents.length; idx++) {
      tooltipComponents[idx].hide();
    }
  }
  get active() {
    return this.tooltipKeys.length > 0;
  }
  createCrosshairTooltips(options) {
    const newMap = this.mapTooltips(options);
    const map3 = this.tooltipsMap;
    for (const key in map3) {
      if (!newMap[key]) {
        this.removeTooltip(key);
        delete map3[key];
      }
    }
    for (const key in newMap) {
      if (!map3[key]) {
        map3[key] = newMap[key];
        this.tooltipKeys.push(key);
      }
    }
  }
  removeTooltip(key) {
    const keys2 = this.tooltipKeys;
    for (let idx = 0; idx < keys2.length; idx++) {
      if (keys2[idx] === key) {
        keys2.splice(idx, 1);
        break;
      }
    }
  }
  mapTooltips(options) {
    const map3 = {};
    for (let idx = 0; idx < AXES.length; idx++) {
      const tooltips = this.axesCrosshairTooltipOptions(options, AXES[idx]);
      for (let tooltipIdx = 0; tooltipIdx < tooltips.length; tooltipIdx++) {
        const tooltip = tooltips[tooltipIdx];
        map3[tooltip.name + tooltip.index] = tooltip;
      }
    }
    return map3;
  }
  axesCrosshairTooltipOptions(options, name2) {
    const result = [];
    if (options[name2]) {
      const axes = [].concat(options[name2]);
      for (let idx = 0; idx < axes.length; idx++) {
        const tooltip = (axes[idx].crosshair || {}).tooltip;
        if (tooltip && tooltip.visible) {
          result.push({
            index: idx,
            name: name2
          });
        }
      }
    }
    return result;
  }
};
CrosshairTooltipsContainerComponent.ɵfac = function CrosshairTooltipsContainerComponent_Factory(t) {
  return new (t || CrosshairTooltipsContainerComponent)();
};
CrosshairTooltipsContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: CrosshairTooltipsContainerComponent,
  selectors: [["kendo-chart-crosshair-tooltips-container"]],
  viewQuery: function CrosshairTooltipsContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CrosshairTooltipComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.crossahirTooltipComponents = _t);
    }
  },
  inputs: {
    popupSettings: "popupSettings"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "key", "popupSettings", 4, "ngFor", "ngForOf"], [3, "key", "popupSettings"]],
  template: function CrosshairTooltipsContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template, 1, 2, "kendo-chart-crosshair-tooltip", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.tooltipKeys);
    }
  },
  dependencies: [NgForOf, CrosshairTooltipComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CrosshairTooltipsContainerComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chart-crosshair-tooltips-container",
      template: `
        <kendo-chart-crosshair-tooltip *ngFor="let key of tooltipKeys" [key]="key" [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltip>
    `
    }]
  }], null, {
    popupSettings: [{
      type: Input
    }],
    crossahirTooltipComponents: [{
      type: ViewChildren,
      args: [CrosshairTooltipComponent]
    }]
  });
})();
var SeriesTooltipTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
SeriesTooltipTemplateDirective.ɵfac = function SeriesTooltipTemplateDirective_Factory(t) {
  return new (t || SeriesTooltipTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
SeriesTooltipTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: SeriesTooltipTemplateDirective,
  selectors: [["", "kendoChartSeriesTooltipTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesTooltipTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChartSeriesTooltipTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var SharedTooltipTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
SharedTooltipTemplateDirective.ɵfac = function SharedTooltipTemplateDirective_Factory(t) {
  return new (t || SharedTooltipTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
SharedTooltipTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: SharedTooltipTemplateDirective,
  selectors: [["", "kendoChartSharedTooltipTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedTooltipTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoChartSharedTooltipTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var TooltipTemplatePoint = class {
  /**
   * @hidden
   */
  constructor(point, format, template2) {
    this.value = point.value;
    this.category = point.category;
    this.categoryIndex = point.categoryIx;
    this.series = point.series;
    this.dataItem = point.dataItem;
    this.percentage = point.percentage;
    this.runningTotal = point.runningTotal;
    this.total = point.total;
    this.low = point.low;
    this.high = point.high;
    this.xLow = point.xLow;
    this.xHigh = point.xHigh;
    this.yLow = point.yLow;
    this.yHigh = point.yHigh;
    this.template = template2;
    this.point = point;
    this.format = format;
  }
  /**
   * @hidden
   */
  get formattedValue() {
    return this.format ? this.point.formatValue(this.format) : String(this.value);
  }
};
function hasParent(element, parent) {
  let current4 = element;
  while (current4 && current4 !== parent) {
    current4 = current4.parentNode;
  }
  return current4 ? true : false;
}
var TooltipTemplateService = class {
  setTemplate(template2) {
    this.template = template2;
  }
  getTemplate(seriesIndex) {
    if (this.seriesTemplates && this.seriesTemplates[seriesIndex]) {
      return this.seriesTemplates[seriesIndex];
    }
    return this.template;
  }
  setSeriesTemplates(seriesTemplates) {
    this.seriesTemplates = seriesTemplates;
  }
  setSharedTemplate(sharedTemplate) {
    this.sharedTemplate = sharedTemplate;
  }
  getSharedTemplate() {
    return this.sharedTemplate;
  }
};
TooltipTemplateService.ɵfac = function TooltipTemplateService_Factory(t) {
  return new (t || TooltipTemplateService)();
};
TooltipTemplateService.ɵprov = ɵɵdefineInjectable({
  token: TooltipTemplateService,
  factory: TooltipTemplateService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipTemplateService, [{
    type: Injectable
  }], null, null);
})();
var SHARED_TOOLTIP_CLASS = "k-chart-shared-tooltip";
var TOOLTIP_CLASS = "k-chart-tooltip";
var TooltipPopupComponent = class extends BaseTooltip2 {
  constructor(popupService, templateService, localizationService, ngZone) {
    super(popupService, localizationService);
    this.popupService = popupService;
    this.templateService = templateService;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.seriesTooltipContext = {};
    this.seriesSharedTooltipContext = {};
    this.animate = true;
    this.wrapperClass = "k-chart-tooltip-wrapper";
    this.leave = new EventEmitter();
    this.popupClasses = {};
  }
  show(e) {
    this.shared = e.shared;
    this.popupClasses = Object.assign({
      [SHARED_TOOLTIP_CLASS]: e.shared,
      [TOOLTIP_CLASS]: true,
      [e.className]: !!e.className
    }, this.classNames);
    if (!e.shared) {
      this.seriesTooltipContext = new TooltipTemplatePoint(e.point, e.format);
      this.seriesTooltipTemplateRef = this.pointTemplateRef(e.point);
    } else {
      this.seriesSharedTooltipTemplateRef = this.templateService.getSharedTemplate() || this.defaultSharedTooltipTemplate.templateRef;
      this.seriesSharedTooltipContext = this.sharedTemplateContext(e);
    }
    super.show(e);
  }
  containsElement(element) {
    if (this.popupRef) {
      return hasParent(element, this.popupRef.popupElement);
    }
  }
  sharedTemplateContext(e) {
    const points = e.points;
    const nameColumn = points.filter((point) => typeof point.series.name !== "undefined").length > 0;
    const colorMarker = e.series.length > 1;
    let colspan = 1;
    if (nameColumn) {
      colspan++;
    }
    if (colorMarker) {
      colspan++;
    }
    return {
      category: e.category,
      categoryText: e.categoryText,
      colorMarker,
      colspan,
      nameColumn,
      points: this.wrapPoints(e.points, e.format)
    };
  }
  pointTemplateRef(point) {
    return this.templateService.getTemplate(point.series.index) || this.defaultSeriesTooltipTemplate.templateRef;
  }
  wrapPoints(points, format) {
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      const template2 = this.pointTemplateRef(point);
      const pointFormat = ((point.options || {}).tooltip || {}).format || format;
      result.push(new TooltipTemplatePoint(point, pointFormat, template2));
    }
    return result;
  }
  onInit() {
    this.ngZone.runOutsideAngular(() => {
      this.mouseleaveSubscription = this.popupRef.popupElement.addEventListener("mouseleave", (args) => {
        this.leave.emit(args);
      });
    });
    this.popupRef.popupElement.className += ` ${this.wrapperClass}`;
  }
  hide() {
    if (this.mouseleaveSubscription) {
      this.mouseleaveSubscription();
      this.mouseleaveSubscription = null;
    }
    super.hide();
  }
};
TooltipPopupComponent.ɵfac = function TooltipPopupComponent_Factory(t) {
  return new (t || TooltipPopupComponent)(ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(TooltipTemplateService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
};
TooltipPopupComponent.ɵcmp = ɵɵdefineComponent({
  type: TooltipPopupComponent,
  selectors: [["kendo-chart-tooltip-popup"]],
  viewQuery: function TooltipPopupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(SeriesTooltipTemplateDirective, 5);
      ɵɵviewQuery(SharedTooltipTemplateDirective, 5);
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultSeriesTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultSharedTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    animate: "animate",
    classNames: "classNames",
    popupSettings: "popupSettings",
    wrapperClass: "wrapperClass"
  },
  outputs: {
    leave: "leave"
  },
  features: [ɵɵProvidersFeature([PopupService, {
    provide: POPUP_CONTAINER,
    useFactory: bodyFactory
  }]), ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 0,
  consts: [["content", ""], ["kendoChartSeriesTooltipTemplate", ""], ["kendoChartSharedTooltipTemplate", ""], [3, "ngClass", "ngStyle"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngFor", "ngForOf"], [1, "k-chart-shared-tooltip-marker"]],
  template: function TooltipPopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_Template, 3, 4, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, TooltipPopupComponent_ng_template_2_Template, 1, 1, "ng-template", 1)(3, TooltipPopupComponent_ng_template_3_Template, 5, 3, "ng-template", 2);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipPopupComponent, [{
    type: Component,
    args: [{
      providers: [PopupService, {
        provide: POPUP_CONTAINER,
        useFactory: bodyFactory
      }],
      selector: "kendo-chart-tooltip-popup",
      template: `
    <ng-template #content>
        <div [ngClass]="popupClasses" [ngStyle]="style">
          <ng-template [ngTemplateOutlet]="seriesTooltipTemplateRef" *ngIf="!shared"
                    [ngTemplateOutletContext]="seriesTooltipContext">
          </ng-template>
          <ng-template [ngTemplateOutlet]="seriesSharedTooltipTemplateRef" *ngIf="shared"
                    [ngTemplateOutletContext]="seriesSharedTooltipContext">
          </ng-template>
        </div>
    </ng-template>

    <ng-template kendoChartSeriesTooltipTemplate let-formattedValue="formattedValue">
        <span [innerHTML]="formattedValue"></span>
    </ng-template>
    <ng-template kendoChartSharedTooltipTemplate let-points="points" let-categoryText="categoryText" let-colspan="colspan" let-colorMarker="colorMarker" let-nameColumn="nameColumn" >
        <table>
            <tr><th [attr.colspan]='colspan'> {{ categoryText }} </th></tr>
            <tr *ngFor="let point of points">
                <td *ngIf="colorMarker"><span class='k-chart-shared-tooltip-marker' [style.background-color]='point.series.color'></span></td>
                <td *ngIf="nameColumn">
                    <ng-container *ngIf="point.series.name !== undefined">{{ point.series.name }}</ng-container>
                    <ng-container *ngIf="point.series.name === undefined">&nbsp;</ng-container>
                </td>
                <td>
                  <ng-template [ngTemplateOutlet]="point.template"
                            [ngTemplateOutletContext]="point">
                  </ng-template>
                </td>
            </tr>
        </table>
    </ng-template>
    `
    }]
  }], function() {
    return [{
      type: PopupService
    }, {
      type: TooltipTemplateService
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    defaultSeriesTooltipTemplate: [{
      type: ViewChild,
      args: [SeriesTooltipTemplateDirective, {
        static: false
      }]
    }],
    defaultSharedTooltipTemplate: [{
      type: ViewChild,
      args: [SharedTooltipTemplateDirective, {
        static: false
      }]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    animate: [{
      type: Input
    }],
    classNames: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    wrapperClass: [{
      type: Input
    }],
    leave: [{
      type: Output
    }]
  });
})();
var ChartInstanceObserver = class extends instance_observer_default {
  constructor(instance) {
    super(instance);
    this.handlerMap = {
      hideTooltip: "onHideTooltip",
      legendItemClick: "onLegendItemClick",
      render: "onRender",
      showTooltip: "onShowTooltip",
      init: "onInit"
    };
  }
};
var BaseEvent = class {
  /**
   * @hidden
   */
  constructor(sender) {
    this.sender = sender;
  }
};
BaseEvent.ɵfac = function BaseEvent_Factory(t) {
  ɵɵinvalidFactory();
};
BaseEvent.ɵdir = ɵɵdefineDirective({
  type: BaseEvent
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseEvent, [{
    type: Directive
  }], function() {
    return [{
      type: void 0
    }];
  }, null);
})();
var AxisLabelClickEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axis = e.axis;
    this.dataItem = e.dataItem;
    this.index = e.index;
    this.text = e.text;
    this.value = e.value;
  }
};
var PreventableEvent2 = class extends BaseEvent {
  constructor() {
    super(...arguments);
    this.prevented = false;
  }
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses
   * the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented
   * by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
PreventableEvent2.ɵfac = /* @__PURE__ */ (() => {
  let ɵPreventableEvent_BaseFactory;
  return function PreventableEvent_Factory(t) {
    return (ɵPreventableEvent_BaseFactory || (ɵPreventableEvent_BaseFactory = ɵɵgetInheritedFactory(PreventableEvent2)))(t || PreventableEvent2);
  };
})();
PreventableEvent2.ɵdir = ɵɵdefineDirective({
  type: PreventableEvent2,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreventableEvent2, [{
    type: Directive
  }], null, null);
})();
var DragEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.originalEvent = e.originalEvent;
  }
};
var DragEndEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.originalEvent = e.originalEvent;
  }
};
var DragStartEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.originalEvent = e.originalEvent;
  }
};
var LegendEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.series = e.series;
    this.seriesIndex = e.seriesIndex;
    this.pointIndex = e.pointIndex;
    this.text = e.text;
  }
};
var LegendItemHoverEvent = class extends LegendEvent {
  /**
   * If called, the series highlight is not shown as a result of hovering over the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};
var LegendItemLeaveEvent = class extends LegendEvent {
  /**
   * @hidden
   */
  preventDefault() {
  }
  /**
   * @hidden
   */
  isDefaultPrevented() {
    return false;
  }
};
var NoteEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.category = e.category;
    this.dataItem = e.dataItem;
    this.series = e.series;
    this.value = e.value;
    this.visual = e.visual;
  }
};
var NoteClickEvent = class extends NoteEvent {
};
var NoteHoverEvent = class extends NoteEvent {
};
var NoteLeaveEvent = class extends NoteEvent {
};
var PaneRenderEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(args, sender) {
    super(sender);
    Object.assign(this, args);
  }
};
var PlotAreaClickEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.category = e.category;
    this.originalEvent = e.originalEvent;
    this.value = e.value;
    this.x = e.x;
    this.y = e.y;
  }
};
var PlotAreaHoverEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.category = e.category;
    this.originalEvent = e.originalEvent;
    this.value = e.value;
    this.x = e.x;
    this.y = e.y;
  }
};
var PlotAreaLeaveEvent = class extends BaseEvent {
};
var RenderEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(_e, sender) {
    super(sender);
  }
};
var SelectEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axis = e.axis;
    this.from = e.from;
    this.to = e.to;
  }
};
var SelectEndEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axis = e.axis;
    this.from = e.from;
    this.to = e.to;
  }
};
var SelectStartEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axis = e.axis;
    this.from = e.from;
    this.to = e.to;
  }
};
var SeriesClickEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.category = e.category;
    this.dataItem = e.dataItem;
    this.originalEvent = e.originalEvent;
    this.percentage = e.percentage;
    this.point = e.point;
    this.series = e.series;
    this.stackValue = e.stackValue;
    this.value = e.value;
  }
};
var SeriesEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.category = e.category;
    this.dataItem = e.dataItem;
    this.originalEvent = e.originalEvent;
    this.percentage = e.percentage;
    this.point = e.point;
    this.series = e.series;
    this.stackValue = e.stackValue;
    this.value = e.value;
  }
};
var SeriesHoverEvent = class extends SeriesEvent {
};
var SeriesOverEvent = class extends SeriesEvent {
};
var SeriesLeaveEvent = class extends SeriesEvent {
};
var ZoomEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.delta = e.delta;
    this.originalEvent = e.originalEvent;
  }
};
var ZoomEndEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.originalEvent = e.originalEvent;
  }
};
var ZoomStartEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.axisRanges = e.axisRanges;
    this.originalEvent = e.originalEvent;
  }
};
var EVENT_MAP$2 = {
  axisLabelClick: AxisLabelClickEvent,
  drag: DragEvent,
  dragEnd: DragEndEvent,
  dragStart: DragStartEvent,
  legendItemHover: LegendItemHoverEvent,
  legendItemLeave: LegendItemLeaveEvent,
  noteClick: NoteClickEvent,
  noteHover: NoteHoverEvent,
  noteLeave: NoteLeaveEvent,
  paneRender: PaneRenderEvent,
  plotAreaClick: PlotAreaClickEvent,
  plotAreaHover: PlotAreaHoverEvent,
  plotAreaLeave: PlotAreaLeaveEvent,
  render: RenderEvent,
  select: SelectEvent,
  selectEnd: SelectEndEvent,
  selectStart: SelectStartEvent,
  seriesClick: SeriesClickEvent,
  seriesHover: SeriesHoverEvent,
  seriesOver: SeriesOverEvent,
  seriesLeave: SeriesLeaveEvent,
  zoom: ZoomEvent,
  zoomEnd: ZoomEndEvent,
  zoomStart: ZoomStartEvent
};
var InstanceEventService$1 = class InstanceEventService {
  create(name2, args, sender) {
    if (EVENT_MAP$2[name2]) {
      return new EVENT_MAP$2[name2](args, sender);
    }
  }
};
var LegendItemClickEvent = class extends LegendEvent {
  /**
   * If called, the series visibility is not toggled as a result of clicking the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};
var packageMetadata = {
  name: "@progress/kendo-angular-charts",
  productName: "Kendo UI for Angular",
  productCodes: ["KENDOUIANGULAR", "KENDOUICOMPLETE"],
  publishDate: 1720608203,
  version: "16.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var CollectionComponent = class {
  constructor(configKey, configurationService, collectionService) {
    this.configKey = configKey;
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.items = [];
    this.subscription = collectionService.onItemChange$.subscribe((changes) => this.processChanges(changes));
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  ngAfterContentInit() {
    this.readItems();
    this.children.changes.subscribe(() => this.readItems());
  }
  processChanges(changes) {
    if (!this.children) {
      return;
    }
    const index = this.children.toArray().filter((s) => !s.hidden).indexOf(changes.sender);
    if (index < 0) {
      return;
    }
    this.items[index] = changes.options;
    this.change();
  }
  readItems() {
    this.items = this.children.filter((s) => !s.hidden).map((s) => s.options);
    this.change();
  }
  change() {
    this.configurationService.notify(new Change(this.configKey, this.items.length === 0 ? void 0 : this.items));
  }
};
CollectionComponent.ɵfac = function CollectionComponent_Factory(t) {
  ɵɵinvalidFactory();
};
CollectionComponent.ɵdir = ɵɵdefineDirective({
  type: CollectionComponent
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CollectionComponent, [{
    type: Directive
  }], function() {
    return [{
      type: void 0
    }, {
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, null);
})();
var SeriesComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService, tooltipTemplateService, viewContainer) {
    super("series", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.tooltipTemplateService = tooltipTemplateService;
    this.viewContainer = viewContainer;
  }
  ngAfterContentChecked() {
    this.readTooltipTemplates();
  }
  readTooltipTemplates() {
    const templates = this.children.map((item) => item.seriesTooltipTemplateRef);
    this.tooltipTemplateService.setSeriesTemplates(templates);
  }
};
SeriesComponent.ɵfac = function SeriesComponent_Factory(t) {
  return new (t || SeriesComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService), ɵɵdirectiveInject(TooltipTemplateService), ɵɵdirectiveInject(ViewContainerRef));
};
SeriesComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesComponent,
  selectors: [["kendo-chart-series"]],
  contentQueries: function SeriesComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SeriesItemComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-series",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }, {
      type: TooltipTemplateService
    }, {
      type: ViewContainerRef
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [SeriesItemComponent, {
        descendants: true
      }]
    }]
  });
})();
var DrilldownEvent = class extends PreventableEvent2 {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.value = e.value;
    this.point = e.point;
    this.series = e.series;
  }
};
function hasObservers(emitter) {
  return emitter.observers.length > 0;
}
var chartDefaultTheme = () => Object.assign({}, baseTheme(), {
  axisDefaults: {
    crosshair: {
      color: "rgba(0, 0, 0, 0.5)"
    },
    labels: {
      color: "rgb(101, 101, 101)",
      font: "12px serif"
    },
    line: {
      color: "rgba(0, 0, 0, 0.08)"
    },
    majorGridLines: {
      color: "rgba(0, 0, 0, 0.08)"
    },
    minorGridLines: {
      color: "rgba(0, 0, 0, 0.04)"
    },
    notes: {
      icon: {
        background: "rgba(0, 0, 0, 0.5)",
        border: {
          color: "rgba(0, 0, 0, 0.5)"
        }
      },
      line: {
        color: "rgba(0, 0, 0, 0.5)"
      },
      label: {
        font: "14px serif"
      }
    },
    title: {
      color: "rgb(101, 101, 101)",
      font: "14px serif"
    }
  },
  chartArea: {
    background: "rgb(255, 255, 255)"
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "rgba(102, 102, 102, 0.5)"
      },
      markers: {
        color: "rgba(102, 102, 102, 0.5)"
      }
    },
    labels: {
      color: "rgb(101, 101, 101)",
      font: "14px serif"
    }
  },
  seriesDefaults: {
    boxPlot: {
      downColor: "rgba(0, 0, 0, 0.08)",
      mean: {
        color: "rgb(246, 246, 246)"
      },
      median: {
        color: "rgb(246, 246, 246)"
      },
      whiskers: {
        color: "rgb(255, 99, 88)"
      }
    },
    bullet: {
      target: {
        color: "rgb(101, 101, 101)"
      }
    },
    candlestick: {
      downColor: "rgb(101, 101, 101)",
      line: {
        color: "rgb(101, 101, 101)"
      }
    },
    errorBars: {
      color: "rgba(0, 0, 0, 0.5)"
    },
    horizontalWaterfall: {
      line: {
        color: "rgba(0, 0, 0, 0.08)"
      }
    },
    icon: {
      border: {
        color: "rgba(0, 0, 0, 0.08)"
      }
    },
    labels: {
      background: "rgb(255, 255, 255)",
      color: "rgb(101, 101, 101)",
      opacity: 0.8,
      font: "12px serif"
    },
    notes: {
      icon: {
        background: "rgba(0, 0, 0, 0.5)",
        border: {
          color: "rgba(0, 0, 0, 0.5)"
        }
      },
      line: {
        color: "rgba(0, 0, 0, 0.5)"
      },
      label: {
        font: "14px serif"
      }
    },
    overlay: {
      gradient: "none"
    },
    verticalBoxPlot: {
      downColor: "rgba(0, 0, 0, 0.08)",
      mean: {
        color: "rgb(246, 246, 246)"
      },
      median: {
        color: "rgb(246, 246, 246)"
      },
      whiskers: {
        color: "rgb(255, 99, 88)"
      }
    },
    verticalBullet: {
      target: {
        color: "rgb(101, 101, 101)"
      }
    },
    waterfall: {
      line: {
        color: "rgba(0, 0, 0, 0.08)"
      }
    },
    area: {
      opacity: 0.8
    }
  },
  title: {
    color: "rgb(101, 101, 101)",
    font: "16px serif"
  },
  seriesColors: ["rgb(255, 99, 88)", "rgb(255, 210, 70)", "rgb(120, 210, 55)", "rgb(40, 180, 200)", "rgb(45, 115, 245)", "rgb(170, 70, 190)"]
});
var font = (style) => `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
var computedBackgroundColor = (element) => window.getComputedStyle(element).backgroundColor;
var letterPos = (letter) => letter.toLowerCase().charCodeAt(0) - "a".charCodeAt(0);
var seriesPos = (name2) => {
  const alpha = name2.match(/series-([a-z])$/);
  if (alpha !== null) {
    return letterPos(alpha[1]);
  }
  const num = name2.split("--series-")[1];
  return parseInt(num, 10) - 1;
};
var SERIES_COLORS = 30;
var seriesTemplate = () => {
  let template2 = `
      <div class="k-var--series-a"></div>
      <div class="k-var--series-b"></div>
      <div class="k-var--series-c"></div>
      <div class="k-var--series-d"></div>
      <div class="k-var--series-e"></div>
      <div class="k-var--series-f"></div>
  `;
  for (let i = 0; i < SERIES_COLORS; i++) {
    template2 += `
      <div class="k-var--series-${i + 1}"></div>`;
  }
  return template2;
};
var template = () => `
    <div class="k-var--primary"></div>
    <div class="k-var--primary-contrast"></div>
    <div class="k-var--base"></div>
    <div class="k-var--background"></div>

    <div class="k-var--kendo-color-subtle"></div>

    <div class="k-var--normal-background"></div>
    <div class="k-var--normal-text-color"></div>
    <div class="k-var--hover-background"></div>
    <div class="k-var--hover-text-color"></div>
    <div class="k-var--selected-background"></div>
    <div class="k-var--selected-text-color"></div>
    <div class="k-var--chart-error-bars-background"></div>
    <div class="k-var--chart-notes-background"></div>
    <div class="k-var--chart-notes-border"></div>
    <div class="k-var--chart-notes-lines"></div>
    <div class="k-var--chart-crosshair-background"></div>

    <div class="k-var--chart-inactive"></div>
    <div class="k-var--chart-major-lines"></div>
    <div class="k-var--chart-minor-lines"></div>
    <div class="k-var--chart-area-opacity"></div>
    <div class="k-var--chart-area-inactive-opacity"></div>
    <div class="k-var--chart-line-inactive-opacity"></div>

    <div class="k-widget k-chart">
        <div class="k-var--chart-font"></div>
        <div class="k-var--chart-title-font"></div>
        <div class="k-var--chart-pane-title-font"></div>
        <div class="k-var--chart-label-font"></div>
    </div>

    <div class="k-var--series-unset"></div>
    <div class="k-var--series">
      ${seriesTemplate()}
    </div>
`;
var ThemeService = class extends ConfigurationService {
  constructor(ngZone) {
    super(ngZone);
    this.loaded = false;
  }
  loadTheme() {
    if (this.loaded || !isDocumentAvailable()) {
      return;
    }
    if (!this.readTheme()) {
      this.readDefaultTheme();
    }
    this.loaded = true;
    this.next();
  }
  reset() {
    this.store = {};
    this.loaded = false;
    this.loadTheme();
  }
  readTheme() {
    this.createElement();
    const available = this.queryColor("primary") !== this.queryColor("primary-contrast");
    try {
      if (available) {
        this.push(baseTheme());
        this.setColors();
        this.setFonts();
        this.setSeriesColors();
      }
    } finally {
      this.destroyElement();
    }
    return available;
  }
  readDefaultTheme() {
    this.push(chartDefaultTheme());
  }
  createElement() {
    const container = this.element = document.createElement("div");
    container.style.display = "none";
    container.innerHTML = template();
    document.body.appendChild(container);
  }
  destroyElement() {
    if (this.element) {
      document.body.removeChild(this.element);
      this.element = void 0;
    }
  }
  setStyle(key, value2) {
    this.set(key, value2);
  }
  setColors() {
    this.mapColor("axisDefaults.crosshair.color", "chart-crosshair-background");
    this.mapColor("axisDefaults.labels.color", "normal-text-color");
    this.mapColor("axisDefaults.line.color", "chart-major-lines");
    this.mapColor("axisDefaults.majorGridLines.color", "chart-major-lines");
    this.mapColor("axisDefaults.minorGridLines.color", "chart-minor-lines");
    this.mapColor("axisDefaults.notes.icon.background", "chart-notes-background");
    this.mapColor("axisDefaults.notes.icon.border.color", "chart-notes-border");
    this.mapColor("axisDefaults.notes.line.color", "chart-notes-lines");
    this.mapColor("axisDefaults.title.color", "normal-text-color");
    this.mapColor("chartArea.background", "background");
    this.mapColor("legend.inactiveItems.labels.color", "chart-inactive");
    this.mapColor("legend.inactiveItems.markers.color", "chart-inactive");
    this.mapColor("legend.labels.color", "normal-text-color");
    this.mapColor("legend.title.color", "normal-text-color");
    this.mapColor("seriesDefaults.boxPlot.downColor", "chart-major-lines");
    this.mapColor("seriesDefaults.boxPlot.mean.color", "base");
    this.mapColor("seriesDefaults.boxPlot.median.color", "base");
    this.mapColor("seriesDefaults.boxPlot.whiskers.color", "primary");
    this.mapColor("seriesDefaults.bullet.target.color", "normal-text-color");
    this.mapColor("seriesDefaults.candlestick.downColor", "normal-text-color");
    this.mapColor("seriesDefaults.candlestick.line.color", "normal-text-color");
    this.mapColor("seriesDefaults.errorBars.color", "chart-error-bars-background");
    this.mapColor("seriesDefaults.horizontalWaterfall.line.color", "chart-major-lines");
    this.mapColor("seriesDefaults.icon.border.color", "chart-major-lines");
    this.mapColor("seriesDefaults.labels.background", "background");
    this.mapColor("seriesDefaults.labels.color", "normal-text-color");
    this.mapColor("seriesDefaults.notes.icon.background", "chart-notes-background");
    this.mapColor("seriesDefaults.notes.icon.border.color", "chart-notes-border");
    this.mapColor("seriesDefaults.notes.line.color", "chart-notes-lines");
    this.mapColor("seriesDefaults.verticalBoxPlot.downColor", "chart-major-lines");
    this.mapColor("seriesDefaults.verticalBoxPlot.mean.color", "base");
    this.mapColor("seriesDefaults.verticalBoxPlot.median.color", "base");
    this.mapColor("seriesDefaults.verticalBoxPlot.whiskers.color", "primary");
    this.mapColor("seriesDefaults.verticalBullet.target.color", "normal-text-color");
    this.mapColor("seriesDefaults.waterfall.line.color", "chart-major-lines");
    this.mapColor("title.color", "normal-text-color");
    this.mapColor("subtitle.color", "normal-text-color");
    this.mapColor("labels.color", "normal-text-color");
    this.mapColor("labels.stroke.color", "background");
    const element = this.element.querySelector(".k-var--kendo-color-subtle");
    element.style.color = "var(--kendo-color-subtle)";
    this.mapColor("links.color", "kendo-color-subtle", "color");
    const opacity = parseFloat(this.queryStyle("chart-area-opacity").opacity);
    if (!isNaN(opacity)) {
      this.setStyle("seriesDefaults.area.opacity", opacity);
      this.setStyle("seriesDefaults.radarArea.opacity", opacity);
      this.setStyle("seriesDefaults.verticalArea.opacity", opacity);
      this.setStyle("seriesDefaults.labels.opacity", opacity);
    }
    this.setInactiveOpacity(["area", "verticalArea"], "chart-area-inactive-opacity");
    this.setInactiveOpacity(["line", "verticalLine"], "chart-line-inactive-opacity");
  }
  setInactiveOpacity(seriesTypes, selector) {
    const inactiveOpacity = parseFloat(this.queryStyle(selector).opacity);
    if (!isNaN(inactiveOpacity) && inactiveOpacity < 1) {
      seriesTypes.forEach((type) => this.setStyle(`seriesDefaults.${type}.highlight.inactiveOpacity`, inactiveOpacity));
    }
  }
  setFonts() {
    const defaultFont = font(this.queryStyle("chart-font"));
    const titleFont = font(this.queryStyle("chart-title-font"));
    const paneTitleFont = font(this.queryStyle("chart-pane-title-font"));
    const labelFont = font(this.queryStyle("chart-label-font"));
    this.setStyle("axisDefaults.labels.font", labelFont);
    this.setStyle("axisDefaults.notes.label.font", defaultFont);
    this.setStyle("axisDefaults.title.font", defaultFont);
    this.setStyle("legend.labels.font", defaultFont);
    this.setStyle("seriesDefaults.labels.font", labelFont);
    this.setStyle("seriesDefaults.notes.label.font", defaultFont);
    this.setStyle("title.font", titleFont);
    this.setStyle("subtitle.font", paneTitleFont);
    this.setStyle("paneDefaults.title.font", paneTitleFont);
    this.setStyle("labels.font", defaultFont);
  }
  setSeriesColors() {
    const element = this.element;
    const series = [].slice.call(element.querySelectorAll(".k-var--series div"));
    const unsetColor = computedBackgroundColor(element.querySelector(".k-var--series-unset"));
    const seriesColors = series.reduce(
      (arr, el) => {
        const pos = seriesPos(el.className);
        const color = computedBackgroundColor(el);
        if (color !== unsetColor) {
          arr[pos] = color;
        }
        return arr;
      },
      []
      // Will populate the series colors in this array
    );
    this.setStyle("seriesColors", seriesColors);
  }
  mapColor(key, varName, styleKey = "backgroundColor") {
    this.setStyle(key, this.queryStyle(varName)[styleKey]);
  }
  queryColor(varName) {
    return this.queryStyle(varName).backgroundColor;
  }
  queryStyle(varName) {
    const element = this.element.querySelector(`.k-var--${varName}`);
    return window.getComputedStyle(element);
  }
};
ThemeService.ɵfac = function ThemeService_Factory(t) {
  return new (t || ThemeService)(ɵɵinject(NgZone));
};
ThemeService.ɵprov = ɵɵdefineInjectable({
  token: ThemeService,
  factory: ThemeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemeService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var ChartComponent = class {
  constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
    this.configurationService = configurationService;
    this.themeService = themeService;
    this.element = element;
    this.intl = intl;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.instanceEventService = instanceEventService;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.axisLabelClick = new EventEmitter();
    this.drag = new EventEmitter();
    this.dragEnd = new EventEmitter();
    this.dragStart = new EventEmitter();
    this.legendItemHover = new EventEmitter();
    this.legendItemLeave = new EventEmitter();
    this.noteClick = new EventEmitter();
    this.noteHover = new EventEmitter();
    this.noteLeave = new EventEmitter();
    this.paneRender = new EventEmitter();
    this.plotAreaClick = new EventEmitter();
    this.plotAreaHover = new EventEmitter();
    this.plotAreaLeave = new EventEmitter();
    this.render = new EventEmitter();
    this.select = new EventEmitter();
    this.selectEnd = new EventEmitter();
    this.selectStart = new EventEmitter();
    this.seriesClick = new EventEmitter();
    this.drilldown = new EventEmitter();
    this.seriesHover = new EventEmitter();
    this.seriesOver = new EventEmitter();
    this.seriesLeave = new EventEmitter();
    this.zoom = new EventEmitter();
    this.zoomEnd = new EventEmitter();
    this.zoomStart = new EventEmitter();
    this.legendItemClick = new EventEmitter();
    this.drilldownLevelChange = new EventEmitter();
    this.resizeRateLimit = 10;
    this.showLicenseWatermark = false;
    this.theme = null;
    this.suppressTransitions = false;
    this.rtl = false;
    this.hostClasses = ["k-chart", "k-widget"];
    this.drilldownState = [];
    const isValid = validatePackage(packageMetadata);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.themeService.loadTheme();
    this.refreshWait();
  }
  /**
   * Gets or sets the current drill-down level for [Drilldown Charts](slug:drilldown_chart_charts).
   *
   * To return to a previous level, set the value to a number less than the current level.
   * To return to the root chart, set the value to 0.
   *
   * Setting the value to a number greater than the current level will have no effect.
   */
  get drilldownLevel() {
    return this.drilldownState.length;
  }
  set drilldownLevel(level) {
    const currentLevel = this.drilldownState.length;
    if (currentLevel <= level || !this.seriesComponents) {
      return;
    }
    const removed = this.drilldownState.slice(level);
    removed.forEach((view) => view.destroy());
    this.drilldownState = this.drilldownState.slice(0, currentLevel - removed.length);
    this.seriesComponents.toArray().slice(-removed.length - 1).forEach((series) => series.hidden = false);
    this.drilldownLevelChange.emit(level);
  }
  ngOnInit() {
    if (this.element) {
      this.hostClasses.forEach((name2) => {
        this.renderer.addClass(this.element.nativeElement, name2);
      });
      this.renderer.setStyle(this.element.nativeElement, "position", "relative");
    }
  }
  ngAfterViewInit() {
    if (this.canRender) {
      this.ngZone.runOutsideAngular(() => {
        const chartMouseleave = this.renderer.listen(this.surfaceElement.nativeElement, "mouseleave", this.chartMouseleave.bind(this));
        this.domSubscriptions = () => {
          chartMouseleave();
        };
      });
    }
    this.setDirection();
    this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
    this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)));
  }
  onDrilldown(e) {
    const args = new DrilldownEvent(e, this);
    this.run(() => this.drilldown.emit(args));
    if (args.isDefaultPrevented()) {
      return;
    }
    const seriesCollection = this.seriesCollectionComponent.first;
    const seriesComponent = this.seriesComponents.find((sc) => sc.name === e.series.name);
    if (seriesComponent.drilldownTemplate) {
      seriesComponent.hidden = true;
      const view = seriesCollection.viewContainer.createEmbeddedView(seriesComponent.drilldownTemplate.templateRef, {
        drilldownValue: e.value,
        point: e.point,
        series: e.series
      });
      view.markForCheck();
      this.drilldownState.push(view);
      this.drilldownLevelChange.emit(this.drilldownLevel);
    }
  }
  ngAfterViewChecked() {
    if (this.instance && this.autoResize) {
      this.ngZone.runOutsideAngular(() => {
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
          this.resize();
        }, 0);
      });
    }
  }
  ngOnChanges(changes) {
    const store = this.configurationService.store;
    copyChanges(changes, store);
    store.popupSettings = null;
    this.configurationService.push(store);
  }
  /**
   * Updates the component fields with the specified values and refreshes the Chart.
   *
   * Use this method when the configuration values cannot be set through the template.
   *
   * @example
   * ```ts-no-run
   * chart.notifyChanges({ title: { text: 'New Title' } });
   * ```
   *
   * @param changes An object containing the updated input fields.
   */
  notifyChanges(changes) {
    this.ngOnChanges(toSimpleChanges(changes));
  }
  ngOnDestroy() {
    this.destroyed = true;
    if (this.optionsChange) {
      this.optionsChange.unsubscribe();
    }
    if (this.domSubscriptions) {
      this.domSubscriptions();
      this.domSubscriptions = null;
    }
    if (this.instance) {
      this.instance.destroy();
      this.instance = null;
    }
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    clearTimeout(this.resizeTimeout);
    clearTimeout(this.redrawTimeout);
  }
  createInstance(element, observer) {
    this.instance = new chart_default(element, this.options, this.theme, {
      intlService: this.intl,
      observer,
      rtl: this.rtl,
      sender: this
    });
  }
  /**
   * Exports the Chart as an image. The export operation is asynchronous and returns a promise.
   *
   * @param {ImageExportOptions} options - The parameters for the exported image.
   * @returns {Promise<string>} - A promise that will be resolved with a PNG image encoded as a Data URI.
   */
  exportImage(options = {}) {
    return exportImage(this.exportVisual(options), options);
  }
  /**
   * Exports the Chart as an SVG document. The export operation is asynchronous and returns a promise.
   *
   * @param options - The parameters for the exported file.
   * @returns - A promise that will be resolved with an SVG document that is encoded as a Data URI.
   */
  exportSVG(options = {}) {
    return exportSVG(this.exportVisual(options), options);
  }
  /**
   * Exports the Chart as a Drawing `Scene`.
   *
   * @param options - The parameters for the export operation.
   * @returns - The root Group of the scene.
   */
  exportVisual(options = {}) {
    return this.instance.exportVisual(options);
  }
  /**
   * Returns the axis with the specified name.
   *
   * @param {string} name - The axis name.
   * @returns {ChartAxis} - The axis with a corresponding name.
   */
  findAxisByName(name2) {
    if (this.instance) {
      return this.instance.findAxisByName(name2);
    }
  }
  /**
   * Returns the pane at the specified index.
   *
   * @param {number} index - The pane index.
   * @returns {ChartPane} - The pane at the specified index.
   */
  findPaneByIndex(index) {
    if (this.instance) {
      return this.instance.findPaneByIndex(index);
    }
  }
  /**
   * Returns the pane with the specified name.
   *
   * @param {string} name - The name of the pane.
   * @returns {ChartPane} - The pane with the provided name.
   */
  findPaneByName(name2) {
    if (this.instance) {
      return this.instance.findPaneByName(name2);
    }
  }
  /**
   * Returns the plot area of the Chart.
   * @returns {ChartPlotArea} - The plot area of the Chart.
   */
  getPlotArea() {
    if (this.instance) {
      return this.instance.plotArea();
    }
  }
  /**
   * Highlights the series points or the segments of a Pie, Donut, Funnel or Pyramid charts.
   *
   * See [Series Highlight]({% slug serieshighlight_chart_charts %}) for more details (with an [example](slug:serieshighlight_chart_charts#toc-toggling-the-highlight-with-code)).
   * @param show - A Boolean value that indicates whether the highlight is shown or hidden.
   * @param filter - A string that represents the series or category name, an object with the series and category name, or a function which will be called for each point. The function should return `true` for the points for which the highlight is toggled.
   */
  toggleHighlight(show2, filter) {
    if (this.instance) {
      this.instance.toggleHighlight(show2, filter);
    }
  }
  /**
   * Hides the tooltip of the Chart.
   */
  hideTooltip() {
    if (this.instance) {
      this.instance.hideTooltip();
    }
  }
  /**
   * Shows the Chart tooltip of a specific point or the shared tooltip of a specific category.
   *
   * @param filter - The category for a shared tooltip or a function which will be called for each point until the function returns `true`.
   */
  showTooltip(filter) {
    if (this.instance) {
      this.instance.showTooltip(filter);
    }
  }
  init() {
    if (!this.canRender) {
      return;
    }
    const element = this.surfaceElement.nativeElement;
    const instanceObserver = new ChartInstanceObserver(this);
    this.createInstance(element, instanceObserver);
  }
  /**
   * Detects the size of the container and redraws the Chart.
   * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
   */
  resize() {
    if (this.instance) {
      this.instance.resize();
    }
  }
  /**
   * @hidden
   */
  onResize() {
    if (this.autoResize) {
      this.resize();
    }
  }
  /**
   * Reloads the Chart appearance settings from the current [Kendo UI Theme]({% slug themesandstyles %}).
   *
   * Call this method after loading a different theme stylesheet.
   */
  reloadTheme() {
    if (!this.instance) {
      return;
    }
    this.themeService.reset();
    this.instance.destroy();
    this.instance = null;
  }
  onLegendItemClick(e) {
    this.run(() => {
      const args = new LegendItemClickEvent(e, this);
      this.legendItemClick.emit(args);
      if (!args.isDefaultPrevented()) {
        const series = this.seriesComponents.toArray()[e.series.index];
        if (!series) {
          return;
        }
        if (e.pointIndex !== void 0) {
          series.togglePointVisibility(e.pointIndex);
        } else {
          series.toggleVisibility();
        }
        this.suppressTransitions = true;
      }
    }, hasObservers(this.legendItemClick), this.seriesComponents.length > 0);
  }
  onInit(e) {
    this.instance = e.sender;
  }
  onRender(e) {
    const donutCenterStyle = this.getDonutCenterStyle();
    this.run(() => {
      const args = new RenderEvent(e, this);
      this.surface = e.sender.surface;
      this.render.emit(args);
      this.donutCenterStyle = donutCenterStyle;
    }, hasObservers(this.render), this.donutCenterStyle !== donutCenterStyle);
  }
  onShowTooltip(e) {
    this.run(() => {
      if (!e.crosshair) {
        this.tooltipInstance.show(e);
      } else {
        this.crossahirTooltips.show(e);
      }
    }, !e.crosshair, true);
  }
  onHideTooltip(e) {
    if (!e.crosshair) {
      if (this.tooltipInstance.active) {
        this.tooltipInstance.hide();
        this.detectChanges();
      }
    } else if (this.crossahirTooltips.active) {
      this.crossahirTooltips.hide();
      this.detectChanges();
    }
  }
  trigger(name2, e) {
    if (name2 === "resize") {
      return;
    }
    if (name2 === "drilldown") {
      this.onDrilldown(e);
      return;
    }
    const emitter = this.activeEmitter(name2);
    if (emitter) {
      const args = this.instanceEventService.create(name2, e, this);
      this.run(() => {
        emitter.emit(args);
      });
      return args.isDefaultPrevented && args.isDefaultPrevented();
    }
  }
  requiresHandlers(names) {
    for (let idx = 0; idx < names.length; idx++) {
      if (this.activeEmitter(names[idx])) {
        return true;
      }
    }
    return false;
  }
  refresh() {
    clearTimeout(this.redrawTimeout);
    this.updateDirection();
    this.crossahirTooltips.createCrosshairTooltips(this.options);
    this.setChartAreaSize();
    if (!this.instance) {
      this.init();
      return;
    }
    const transitions = this.options.transitions;
    if (this.suppressTransitions) {
      this.options.transitions = false;
    }
    this.updateOptions();
    if (this.suppressTransitions) {
      this.options.transitions = transitions;
      this.suppressTransitions = false;
    }
  }
  setChartAreaSize() {
    if (!this.element) {
      return;
    }
    const element = this.element.nativeElement;
    const chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      element.style.width = `${chartArea.width}px`;
    }
    if (chartArea.height) {
      element.style.height = `${chartArea.height}px`;
    }
  }
  updateOptions() {
    this.instance.setOptions(this.options);
  }
  /**
   * @hidden
   */
  tooltipMouseleave(e) {
    const relatedTarget = e.relatedTarget;
    const chartElement = this.element.nativeElement;
    if (this.instance && (!relatedTarget || !hasParent(relatedTarget, chartElement))) {
      this.instance.hideElements();
    }
  }
  /**
   * @hidden
   */
  chartMouseleave(e) {
    const relatedTarget = e.relatedTarget;
    const chartElement = this.element.nativeElement;
    if (this.instance && (!relatedTarget || !(this.tooltipInstance.containsElement(relatedTarget) || hasParent(relatedTarget, chartElement))) && !this.instance.handlingTap) {
      this.instance.hideElements();
    }
  }
  get canRender() {
    return isDocumentAvailable() && Boolean(this.surfaceElement);
  }
  get autoResize() {
    return this.resizeRateLimit > 0;
  }
  activeEmitter(name2) {
    const emitter = this[name2];
    if (emitter && emitter.emit && hasObservers(emitter)) {
      return emitter;
    }
  }
  getDonutCenterStyle() {
    if (!this.instance || !this.options || !this.options.series) {
      return;
    }
    const firstSeries = this.options.series[0];
    const charts = this.instance._plotArea.charts;
    if (!firstSeries || firstSeries.type !== "donut" || !charts || charts[0].points.length === 0) {
      return;
    }
    const firstPoint = charts[0].points[0];
    const center = firstPoint.box.center();
    const radius = firstPoint.sector.innerRadius;
    const top = center.y - radius;
    const left = center.x - radius;
    const size = radius * 2;
    return {
      height: size + "px",
      left: left + "px",
      top: top + "px",
      width: size + "px"
    };
  }
  refreshWait() {
    this.ngZone.runOutsideAngular(() => {
      this.optionsChange = (0, import_rxjs.combineLatest)(this.configurationService.onChange$, this.themeService.onChange$).pipe((0, import_operators.tap)((result) => {
        this.options = result[0];
        this.theme = result[1];
      }), (0, import_operators.auditTime)(THROTTLE_MS)).subscribe(() => {
        this.refresh();
      });
    });
  }
  run(callback, inZone = true, detectChanges) {
    if (inZone) {
      if (detectChanges) {
        this.changeDetector.markForCheck();
      }
      this.ngZone.run(callback);
    } else {
      callback();
      if (detectChanges) {
        this.detectChanges();
      }
    }
  }
  detectChanges() {
    if (!this.destroyed) {
      this.changeDetector.detectChanges();
    }
  }
  intlChange() {
    if (this.instance) {
      this.deferredRedraw();
    }
  }
  rtlChange() {
    if (this.instance && this.rtl !== this.isRTL) {
      this.deferredRedraw();
    }
  }
  deferredRedraw() {
    this.ngZone.runOutsideAngular(() => {
      clearTimeout(this.redrawTimeout);
      this.redrawTimeout = setTimeout(() => {
        this.updateDirection();
        this.instance.noTransitionsRedraw();
      }, 0);
    });
  }
  updateDirection() {
    const current4 = this.isRTL;
    if (this.rtl !== current4) {
      this.setDirection();
      if (this.instance) {
        this.instance.setDirection(current4);
      }
    }
  }
  setDirection() {
    this.rtl = this.isRTL;
    if (this.element) {
      this.renderer.setAttribute(this.element.nativeElement, "dir", this.rtl ? "rtl" : "ltr");
    }
  }
  get isRTL() {
    return Boolean(this.localizationService.rtl);
  }
};
ChartComponent.ɵfac = function ChartComponent_Factory(t) {
  return new (t || ChartComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(ThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(InstanceEventService$1), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
};
ChartComponent.ɵcmp = ɵɵdefineComponent({
  type: ChartComponent,
  selectors: [["kendo-chart"]],
  contentQueries: function ChartComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DonutCenterTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, SeriesComponent, 4);
      ɵɵcontentQuery(dirIndex, SeriesItemComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.donutCenterTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.seriesCollectionComponent = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.seriesComponents = _t);
    }
  },
  viewQuery: function ChartComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TooltipPopupComponent, 7);
      ɵɵviewQuery(CrosshairTooltipsContainerComponent, 7);
      ɵɵviewQuery(_c1, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltipInstance = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.crossahirTooltips = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.surfaceElement = _t.first);
    }
  },
  inputs: {
    pannable: "pannable",
    renderAs: "renderAs",
    seriesColors: "seriesColors",
    subtitle: "subtitle",
    title: "title",
    transitions: "transitions",
    zoomable: "zoomable",
    axisDefaults: "axisDefaults",
    categoryAxis: "categoryAxis",
    chartArea: "chartArea",
    legend: "legend",
    panes: "panes",
    paneDefaults: "paneDefaults",
    plotArea: "plotArea",
    series: "series",
    seriesDefaults: "seriesDefaults",
    tooltip: "tooltip",
    valueAxis: "valueAxis",
    xAxis: "xAxis",
    yAxis: "yAxis",
    resizeRateLimit: "resizeRateLimit",
    popupSettings: "popupSettings",
    drilldownLevel: "drilldownLevel"
  },
  outputs: {
    axisLabelClick: "axisLabelClick",
    drag: "drag",
    dragEnd: "dragEnd",
    dragStart: "dragStart",
    legendItemHover: "legendItemHover",
    legendItemLeave: "legendItemLeave",
    noteClick: "noteClick",
    noteHover: "noteHover",
    noteLeave: "noteLeave",
    paneRender: "paneRender",
    plotAreaClick: "plotAreaClick",
    plotAreaHover: "plotAreaHover",
    plotAreaLeave: "plotAreaLeave",
    render: "render",
    select: "select",
    selectEnd: "selectEnd",
    selectStart: "selectStart",
    seriesClick: "seriesClick",
    drilldown: "drilldown",
    seriesHover: "seriesHover",
    seriesOver: "seriesOver",
    seriesLeave: "seriesLeave",
    zoom: "zoom",
    zoomEnd: "zoomEnd",
    zoomStart: "zoomStart",
    legendItemClick: "legendItemClick",
    drilldownLevelChange: "drilldownLevelChange"
  },
  exportAs: ["kendoChart"],
  features: [ɵɵProvidersFeature([ConfigurationService, TooltipTemplateService, InstanceEventService$1, LocalizationService, {
    provide: L10N_PREFIX,
    useValue: "kendo.chart"
  }]), ɵɵNgOnChangesFeature],
  decls: 7,
  vars: 5,
  consts: [["surface", ""], [1, "k-chart-surface"], [3, "popupSettings"], [3, "leave", "popupSettings"], [3, "resize", "rateLimit"], ["class", "k-chart-donut-center", 3, "ngStyle", 4, "ngIf"], ["kendoWatermarkOverlay", "", 4, "ngIf"], [1, "k-chart-donut-center", 3, "ngStyle"], [3, "ngTemplateOutlet"], ["kendoWatermarkOverlay", ""]],
  template: function ChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelement(0, "div", 1, 0)(2, "kendo-chart-crosshair-tooltips-container", 2);
      ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
      ɵɵlistener("leave", function ChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.tooltipMouseleave($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(4, "kendo-resize-sensor", 4);
      ɵɵlistener("resize", function ChartComponent_Template_kendo_resize_sensor_resize_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onResize());
      });
      ɵɵelementEnd();
      ɵɵtemplate(5, ChartComponent_div_5_Template, 2, 2, "div", 5)(6, ChartComponent_div_6_Template, 1, 0, "div", 6);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("popupSettings", ctx.popupSettings);
      ɵɵadvance();
      ɵɵproperty("popupSettings", ctx.popupSettings);
      ɵɵadvance();
      ɵɵproperty("rateLimit", ctx.resizeRateLimit);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.donutCenterStyle && ctx.donutCenterTemplate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showLicenseWatermark);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgStyle, ResizeSensorComponent, WatermarkOverlayComponent, TooltipPopupComponent, CrosshairTooltipsContainerComponent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendoChart",
      providers: [ConfigurationService, TooltipTemplateService, InstanceEventService$1, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.chart"
      }],
      selector: "kendo-chart",
      template: `
    <div #surface class="k-chart-surface"></div>
    <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
    </kendo-chart-crosshair-tooltips-container>
    <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
    </kendo-chart-tooltip-popup>
    <kendo-resize-sensor (resize)="onResize()" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
    <div class="k-chart-donut-center" [ngStyle]="donutCenterStyle" *ngIf="donutCenterStyle && donutCenterTemplate">
      <ng-template [ngTemplateOutlet]="donutCenterTemplate.templateRef"></ng-template>
    </div>

    <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
  `
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: ThemeService
    }, {
      type: ElementRef
    }, {
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: InstanceEventService$1
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    pannable: [{
      type: Input
    }],
    renderAs: [{
      type: Input
    }],
    seriesColors: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    transitions: [{
      type: Input
    }],
    zoomable: [{
      type: Input
    }],
    axisDefaults: [{
      type: Input
    }],
    categoryAxis: [{
      type: Input
    }],
    chartArea: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    panes: [{
      type: Input
    }],
    paneDefaults: [{
      type: Input
    }],
    plotArea: [{
      type: Input
    }],
    series: [{
      type: Input
    }],
    seriesDefaults: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    valueAxis: [{
      type: Input
    }],
    xAxis: [{
      type: Input
    }],
    yAxis: [{
      type: Input
    }],
    axisLabelClick: [{
      type: Output
    }],
    drag: [{
      type: Output
    }],
    dragEnd: [{
      type: Output
    }],
    dragStart: [{
      type: Output
    }],
    legendItemHover: [{
      type: Output
    }],
    legendItemLeave: [{
      type: Output
    }],
    noteClick: [{
      type: Output
    }],
    noteHover: [{
      type: Output
    }],
    noteLeave: [{
      type: Output
    }],
    paneRender: [{
      type: Output
    }],
    plotAreaClick: [{
      type: Output
    }],
    plotAreaHover: [{
      type: Output
    }],
    plotAreaLeave: [{
      type: Output
    }],
    render: [{
      type: Output
    }],
    select: [{
      type: Output
    }],
    selectEnd: [{
      type: Output
    }],
    selectStart: [{
      type: Output
    }],
    seriesClick: [{
      type: Output
    }],
    drilldown: [{
      type: Output
    }],
    seriesHover: [{
      type: Output
    }],
    seriesOver: [{
      type: Output
    }],
    seriesLeave: [{
      type: Output
    }],
    zoom: [{
      type: Output
    }],
    zoomEnd: [{
      type: Output
    }],
    zoomStart: [{
      type: Output
    }],
    legendItemClick: [{
      type: Output
    }],
    drilldownLevelChange: [{
      type: Output
    }],
    resizeRateLimit: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    drilldownLevel: [{
      type: Input
    }],
    seriesCollectionComponent: [{
      type: ContentChildren,
      args: [SeriesComponent]
    }],
    seriesComponents: [{
      type: ContentChildren,
      args: [SeriesItemComponent, {
        descendants: true
      }]
    }],
    donutCenterTemplate: [{
      type: ContentChild,
      args: [DonutCenterTemplateDirective, {
        static: false
      }]
    }],
    tooltipInstance: [{
      type: ViewChild,
      args: [TooltipPopupComponent, {
        static: true
      }]
    }],
    crossahirTooltips: [{
      type: ViewChild,
      args: [CrosshairTooltipsContainerComponent, {
        static: true
      }]
    }],
    surfaceElement: [{
      type: ViewChild,
      args: ["surface", {
        static: true
      }]
    }]
  });
})();
var AxisDefaultsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("axisDefaults", configurationService);
    this.configurationService = configurationService;
  }
};
AxisDefaultsComponent.ɵfac = function AxisDefaultsComponent_Factory(t) {
  return new (t || AxisDefaultsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
AxisDefaultsComponent.ɵcmp = ɵɵdefineComponent({
  type: AxisDefaultsComponent,
  selectors: [["kendo-chart-axis-defaults"]],
  inputs: {
    background: "background",
    color: "color",
    line: "line",
    majorGridLines: "majorGridLines",
    majorTicks: "majorTicks",
    minorGridLines: "minorGridLines",
    minorTicks: "minorTicks",
    narrowRange: "narrowRange",
    pane: "pane",
    plotBands: "plotBands",
    reverse: "reverse",
    startAngle: "startAngle",
    visible: "visible",
    crosshair: "crosshair",
    labels: "labels",
    title: "title"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AxisDefaultsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDefaultsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-axis-defaults",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    majorGridLines: [{
      type: Input
    }],
    majorTicks: [{
      type: Input
    }],
    minorGridLines: [{
      type: Input
    }],
    minorTicks: [{
      type: Input
    }],
    narrowRange: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    plotBands: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    crosshair: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var AxisDefaultsCrosshairComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("axisDefaults.crosshair", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
AxisDefaultsCrosshairComponent.ɵfac = function AxisDefaultsCrosshairComponent_Factory(t) {
  return new (t || AxisDefaultsCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
AxisDefaultsCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: AxisDefaultsCrosshairComponent,
  selectors: [["kendo-chart-axis-defaults-crosshair"]],
  inputs: {
    color: "color",
    dashType: "dashType",
    opacity: "opacity",
    visible: "visible",
    width: "width",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AxisDefaultsCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDefaultsCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-axis-defaults-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    dashType: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var AxisDefaultsCrosshairTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("axisDefaults.crosshair.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
AxisDefaultsCrosshairTooltipComponent.ɵfac = function AxisDefaultsCrosshairTooltipComponent_Factory(t) {
  return new (t || AxisDefaultsCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
AxisDefaultsCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: AxisDefaultsCrosshairTooltipComponent,
  selectors: [["kendo-chart-axis-defaults-crosshair-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AxisDefaultsCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDefaultsCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-axis-defaults-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var AxisDefaultsLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("axisDefaults.labels", configurationService);
    this.configurationService = configurationService;
  }
};
AxisDefaultsLabelsComponent.ɵfac = function AxisDefaultsLabelsComponent_Factory(t) {
  return new (t || AxisDefaultsLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
AxisDefaultsLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: AxisDefaultsLabelsComponent,
  selectors: [["kendo-chart-axis-defaults-labels"]],
  inputs: {
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    mirror: "mirror",
    padding: "padding",
    rotation: "rotation",
    skip: "skip",
    step: "step",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AxisDefaultsLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDefaultsLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-axis-defaults-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    mirror: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var AxisDefaultsTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("axisDefaults.title", configurationService);
    this.configurationService = configurationService;
  }
};
AxisDefaultsTitleComponent.ɵfac = function AxisDefaultsTitleComponent_Factory(t) {
  return new (t || AxisDefaultsTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
AxisDefaultsTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: AxisDefaultsTitleComponent,
  selectors: [["kendo-chart-axis-defaults-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function AxisDefaultsTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AxisDefaultsTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-axis-defaults-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var CategoryAxisItemComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService, intl, localeId) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.notifyChanges({
      weekStartDay: intl.firstDay(localeId)
    });
  }
};
CategoryAxisItemComponent.ɵfac = function CategoryAxisItemComponent_Factory(t) {
  return new (t || CategoryAxisItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LOCALE_ID));
};
CategoryAxisItemComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisItemComponent,
  selectors: [["kendo-chart-category-axis-item"]],
  inputs: {
    autoBaseUnitSteps: "autoBaseUnitSteps",
    axisCrossingValue: "axisCrossingValue",
    background: "background",
    baseUnit: "baseUnit",
    baseUnitStep: "baseUnitStep",
    categories: "categories",
    color: "color",
    justified: "justified",
    line: "line",
    majorGridLines: "majorGridLines",
    majorTicks: "majorTicks",
    max: "max",
    maxDateGroups: "maxDateGroups",
    maxDivisions: "maxDivisions",
    min: "min",
    minorGridLines: "minorGridLines",
    minorTicks: "minorTicks",
    name: "name",
    pane: "pane",
    plotBands: "plotBands",
    reverse: "reverse",
    roundToBaseUnit: "roundToBaseUnit",
    startAngle: "startAngle",
    type: "type",
    visible: "visible",
    weekStartDay: "weekStartDay",
    crosshair: "crosshair",
    labels: "labels",
    notes: "notes",
    select: "select",
    title: "title",
    rangeLabels: "rangeLabels"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-category-axis-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }, {
      type: IntlService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, {
    autoBaseUnitSteps: [{
      type: Input
    }],
    axisCrossingValue: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    baseUnit: [{
      type: Input
    }],
    baseUnitStep: [{
      type: Input
    }],
    categories: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    justified: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    majorGridLines: [{
      type: Input
    }],
    majorTicks: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    maxDateGroups: [{
      type: Input
    }],
    maxDivisions: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minorGridLines: [{
      type: Input
    }],
    minorTicks: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    plotBands: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    roundToBaseUnit: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    weekStartDay: [{
      type: Input
    }],
    crosshair: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    rangeLabels: [{
      type: Input
    }]
  });
})();
var CategoryAxisComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService) {
    super("categoryAxis", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
CategoryAxisComponent.ɵfac = function CategoryAxisComponent_Factory(t) {
  return new (t || CategoryAxisComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
CategoryAxisComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisComponent,
  selectors: [["kendo-chart-category-axis"]],
  contentQueries: function CategoryAxisComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CategoryAxisItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-category-axis",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [CategoryAxisItemComponent]
    }]
  });
})();
var CategoryAxisCrosshairComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
CategoryAxisCrosshairComponent.ɵfac = function CategoryAxisCrosshairComponent_Factory(t) {
  return new (t || CategoryAxisCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisCrosshairComponent,
  selectors: [["kendo-chart-category-axis-item-crosshair"]],
  inputs: {
    color: "color",
    dashType: "dashType",
    opacity: "opacity",
    visible: "visible",
    width: "width",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    dashType: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var CategoryAxisCrosshairTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
CategoryAxisCrosshairTooltipComponent.ɵfac = function CategoryAxisCrosshairTooltipComponent_Factory(t) {
  return new (t || CategoryAxisCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisCrosshairTooltipComponent,
  selectors: [["kendo-chart-category-axis-item-crosshair-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var CategoryAxisLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisLabelsComponent.ɵfac = function CategoryAxisLabelsComponent_Factory(t) {
  return new (t || CategoryAxisLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisLabelsComponent,
  selectors: [["kendo-chart-category-axis-item-labels"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    culture: "culture",
    dateFormats: "dateFormats",
    font: "font",
    format: "format",
    margin: "margin",
    mirror: "mirror",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    skip: "skip",
    step: "step",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    culture: [{
      type: Input
    }],
    dateFormats: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    mirror: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var CategoryAxisRangeLabelsComponent = class extends CategoryAxisLabelsComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
    this.configKey = "rangeLabels";
    this.markAsVisible();
  }
};
CategoryAxisRangeLabelsComponent.ɵfac = function CategoryAxisRangeLabelsComponent_Factory(t) {
  return new (t || CategoryAxisRangeLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisRangeLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisRangeLabelsComponent,
  selectors: [["kendo-chart-category-axis-item-range-labels"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisRangeLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisRangeLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-range-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var CategoryAxisNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisNotesComponent.ɵfac = function CategoryAxisNotesComponent_Factory(t) {
  return new (t || CategoryAxisNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisNotesComponent,
  selectors: [["kendo-chart-category-axis-item-notes"]],
  inputs: {
    data: "data",
    line: "line",
    position: "position",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    data: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var CategoryAxisNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisNotesIconComponent.ɵfac = function CategoryAxisNotesIconComponent_Factory(t) {
  return new (t || CategoryAxisNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisNotesIconComponent,
  selectors: [["kendo-chart-category-axis-item-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var CategoryAxisNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisNotesLabelComponent.ɵfac = function CategoryAxisNotesLabelComponent_Factory(t) {
  return new (t || CategoryAxisNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisNotesLabelComponent,
  selectors: [["kendo-chart-category-axis-item-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var CategoryAxisSelectComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("select", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisSelectComponent.ɵfac = function CategoryAxisSelectComponent_Factory(t) {
  return new (t || CategoryAxisSelectComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisSelectComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisSelectComponent,
  selectors: [["kendo-chart-category-axis-item-select"]],
  inputs: {
    from: "from",
    max: "max",
    min: "min",
    mousewheel: "mousewheel",
    to: "to"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisSelectComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisSelectComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-select",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    from: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    mousewheel: [{
      type: Input
    }],
    to: [{
      type: Input
    }]
  });
})();
var CategoryAxisTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
CategoryAxisTitleComponent.ɵfac = function CategoryAxisTitleComponent_Factory(t) {
  return new (t || CategoryAxisTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
CategoryAxisTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: CategoryAxisTitleComponent,
  selectors: [["kendo-chart-category-axis-item-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function CategoryAxisTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CategoryAxisTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-category-axis-item-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var ChartAreaComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("chartArea", configurationService);
    this.configurationService = configurationService;
  }
};
ChartAreaComponent.ɵfac = function ChartAreaComponent_Factory(t) {
  return new (t || ChartAreaComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ChartAreaComponent.ɵcmp = ɵɵdefineComponent({
  type: ChartAreaComponent,
  selectors: [["kendo-chart-area"]],
  inputs: {
    background: "background",
    border: "border",
    height: "height",
    margin: "margin",
    opacity: "opacity",
    width: "width"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ChartAreaComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartAreaComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-area",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    width: [{
      type: Input
    }]
  });
})();
var LegendComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("legend", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
LegendComponent.ɵfac = function LegendComponent_Factory(t) {
  return new (t || LegendComponent)(ɵɵdirectiveInject(ConfigurationService));
};
LegendComponent.ɵcmp = ɵɵdefineComponent({
  type: LegendComponent,
  selectors: [["kendo-chart-legend"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    height: "height",
    labels: "labels",
    margin: "margin",
    offsetX: "offsetX",
    offsetY: "offsetY",
    orientation: "orientation",
    padding: "padding",
    position: "position",
    reverse: "reverse",
    visible: "visible",
    width: "width",
    markers: "markers",
    spacing: "spacing",
    inactiveItems: "inactiveItems",
    item: "item",
    title: "title"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function LegendComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-legend",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    offsetX: [{
      type: Input
    }],
    offsetY: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    inactiveItems: [{
      type: Input
    }],
    item: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var LegendInactiveItemsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("legend.inactiveItems", configurationService);
    this.configurationService = configurationService;
  }
};
LegendInactiveItemsComponent.ɵfac = function LegendInactiveItemsComponent_Factory(t) {
  return new (t || LegendInactiveItemsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
LegendInactiveItemsComponent.ɵcmp = ɵɵdefineComponent({
  type: LegendInactiveItemsComponent,
  selectors: [["kendo-chart-legend-inactive-items"]],
  inputs: {
    labels: "labels"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function LegendInactiveItemsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendInactiveItemsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-legend-inactive-items",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    labels: [{
      type: Input
    }]
  });
})();
var LegendItemComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("legend.item", configurationService);
    this.configurationService = configurationService;
  }
};
LegendItemComponent.ɵfac = function LegendItemComponent_Factory(t) {
  return new (t || LegendItemComponent)(ɵɵdirectiveInject(ConfigurationService));
};
LegendItemComponent.ɵcmp = ɵɵdefineComponent({
  type: LegendItemComponent,
  selectors: [["kendo-chart-legend-item"]],
  inputs: {
    cursor: "cursor",
    type: "type",
    line: "line",
    area: "area",
    markers: "markers",
    highlight: "highlight",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function LegendItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LegendItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-legend-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    cursor: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    area: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    highlight: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var PaneComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
PaneComponent.ɵfac = function PaneComponent_Factory(t) {
  return new (t || PaneComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
PaneComponent.ɵcmp = ɵɵdefineComponent({
  type: PaneComponent,
  selectors: [["kendo-chart-pane"], ["kendo-chart-panes-item"]],
  inputs: {
    background: "background",
    border: "border",
    clip: "clip",
    height: "height",
    margin: "margin",
    name: "name",
    padding: "padding",
    title: "title"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PaneComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaneComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-pane, kendo-chart-panes-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    clip: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var PaneDefaultsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("paneDefaults", configurationService);
    this.configurationService = configurationService;
  }
};
PaneDefaultsComponent.ɵfac = function PaneDefaultsComponent_Factory(t) {
  return new (t || PaneDefaultsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
PaneDefaultsComponent.ɵcmp = ɵɵdefineComponent({
  type: PaneDefaultsComponent,
  selectors: [["kendo-chart-pane-defaults"]],
  inputs: {
    background: "background",
    border: "border",
    clip: "clip",
    height: "height",
    margin: "margin",
    padding: "padding",
    title: "title"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PaneDefaultsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaneDefaultsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-pane-defaults",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    clip: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var PaneDefaultsTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("paneDefaults.title", configurationService);
    this.configurationService = configurationService;
  }
};
PaneDefaultsTitleComponent.ɵfac = function PaneDefaultsTitleComponent_Factory(t) {
  return new (t || PaneDefaultsTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
PaneDefaultsTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: PaneDefaultsTitleComponent,
  selectors: [["kendo-chart-pane-defaults-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    position: "position",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PaneDefaultsTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PaneDefaultsTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-pane-defaults-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var PanesComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService) {
    super("panes", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
PanesComponent.ɵfac = function PanesComponent_Factory(t) {
  return new (t || PanesComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
PanesComponent.ɵcmp = ɵɵdefineComponent({
  type: PanesComponent,
  selectors: [["kendo-chart-panes"]],
  contentQueries: function PanesComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, PaneComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PanesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-panes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [PaneComponent]
    }]
  });
})();
var PanesTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
PanesTitleComponent.ɵfac = function PanesTitleComponent_Factory(t) {
  return new (t || PanesTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
PanesTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: PanesTitleComponent,
  selectors: [["kendo-chart-pane-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    position: "position",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PanesTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PanesTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-pane-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var PlotAreaComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("plotArea", configurationService);
    this.configurationService = configurationService;
  }
};
PlotAreaComponent.ɵfac = function PlotAreaComponent_Factory(t) {
  return new (t || PlotAreaComponent)(ɵɵdirectiveInject(ConfigurationService));
};
PlotAreaComponent.ɵcmp = ɵɵdefineComponent({
  type: PlotAreaComponent,
  selectors: [["kendo-chart-plot-area"]],
  inputs: {
    background: "background",
    border: "border",
    margin: "margin",
    opacity: "opacity",
    padding: "padding"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function PlotAreaComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlotAreaComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-plot-area",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    padding: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesDefaultsComponent.ɵfac = function SeriesDefaultsComponent_Factory(t) {
  return new (t || SeriesDefaultsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsComponent,
  selectors: [["kendo-chart-series-defaults"]],
  inputs: {
    border: "border",
    gap: "gap",
    highlight: "highlight",
    overlay: "overlay",
    spacing: "spacing",
    stack: "stack",
    type: "type",
    visual: "visual",
    labels: "labels",
    notes: "notes",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    border: [{
      type: Input
    }],
    gap: [{
      type: Input
    }],
    highlight: [{
      type: Input
    }],
    overlay: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    stack: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.labels", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesDefaultsLabelsComponent.ɵfac = function SeriesDefaultsLabelsComponent_Factory(t) {
  return new (t || SeriesDefaultsLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsLabelsComponent,
  selectors: [["kendo-chart-series-defaults-labels"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    visible: "visible",
    visual: "visual",
    from: "from",
    to: "to"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    from: [{
      type: Input
    }],
    to: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsLabelsFromComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.labels.from", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesDefaultsLabelsFromComponent.ɵfac = function SeriesDefaultsLabelsFromComponent_Factory(t) {
  return new (t || SeriesDefaultsLabelsFromComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsLabelsFromComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsLabelsFromComponent,
  selectors: [["kendo-chart-series-defaults-labels-from"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsLabelsFromComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsLabelsFromComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-labels-from",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsLabelsToComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.labels.to", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesDefaultsLabelsToComponent.ɵfac = function SeriesDefaultsLabelsToComponent_Factory(t) {
  return new (t || SeriesDefaultsLabelsToComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsLabelsToComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsLabelsToComponent,
  selectors: [["kendo-chart-series-defaults-labels-to"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsLabelsToComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsLabelsToComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-labels-to",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.notes", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesDefaultsNotesComponent.ɵfac = function SeriesDefaultsNotesComponent_Factory(t) {
  return new (t || SeriesDefaultsNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsNotesComponent,
  selectors: [["kendo-chart-series-defaults-notes"]],
  inputs: {
    line: "line",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    line: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesDefaultsNotesIconComponent.ɵfac = function SeriesDefaultsNotesIconComponent_Factory(t) {
  return new (t || SeriesDefaultsNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsNotesIconComponent,
  selectors: [["kendo-chart-series-defaults-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesDefaultsNotesLabelComponent.ɵfac = function SeriesDefaultsNotesLabelComponent_Factory(t) {
  return new (t || SeriesDefaultsNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsNotesLabelComponent,
  selectors: [["kendo-chart-series-defaults-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesDefaultsTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("seriesDefaults.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesDefaultsTooltipComponent.ɵfac = function SeriesDefaultsTooltipComponent_Factory(t) {
  return new (t || SeriesDefaultsTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesDefaultsTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesDefaultsTooltipComponent,
  selectors: [["kendo-chart-series-defaults-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesDefaultsTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesDefaultsTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-defaults-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesErrorBarsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("errorBars", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesErrorBarsComponent.ɵfac = function SeriesErrorBarsComponent_Factory(t) {
  return new (t || SeriesErrorBarsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesErrorBarsComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesErrorBarsComponent,
  selectors: [["kendo-chart-series-item-error-bars"]],
  inputs: {
    color: "color",
    endCaps: "endCaps",
    line: "line",
    value: "value",
    visual: "visual",
    xValue: "xValue",
    yValue: "yValue"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesErrorBarsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesErrorBarsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-error-bars",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    endCaps: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    xValue: [{
      type: Input
    }],
    yValue: [{
      type: Input
    }]
  });
})();
var SeriesExtremesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("extremes", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesExtremesComponent.ɵfac = function SeriesExtremesComponent_Factory(t) {
  return new (t || SeriesExtremesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesExtremesComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesExtremesComponent,
  selectors: [["kendo-chart-series-item-extremes"]],
  inputs: {
    background: "background",
    border: "border",
    rotation: "rotation",
    size: "size",
    type: "type"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesExtremesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesExtremesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-extremes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var SeriesHighlightComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("highlight", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesHighlightComponent.ɵfac = function SeriesHighlightComponent_Factory(t) {
  return new (t || SeriesHighlightComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesHighlightComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesHighlightComponent,
  selectors: [["kendo-chart-series-item-highlight"]],
  inputs: {
    border: "border",
    color: "color",
    line: "line",
    markers: "markers",
    opacity: "opacity",
    toggle: "toggle",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesHighlightComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesHighlightComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-highlight",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    toggle: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var SeriesLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesLabelsComponent.ɵfac = function SeriesLabelsComponent_Factory(t) {
  return new (t || SeriesLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesLabelsComponent,
  selectors: [["kendo-chart-series-item-labels"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    ariaContent: "ariaContent",
    distance: "distance",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    visible: "visible",
    visual: "visual",
    from: "from",
    to: "to"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    ariaContent: [{
      type: Input
    }],
    distance: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    from: [{
      type: Input
    }],
    to: [{
      type: Input
    }]
  });
})();
var SeriesLabelsFromComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels.from", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesLabelsFromComponent.ɵfac = function SeriesLabelsFromComponent_Factory(t) {
  return new (t || SeriesLabelsFromComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesLabelsFromComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesLabelsFromComponent,
  selectors: [["kendo-chart-series-item-labels-from"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    position: "position",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesLabelsFromComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesLabelsFromComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-labels-from",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesLabelsToComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels.to", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SeriesLabelsToComponent.ɵfac = function SeriesLabelsToComponent_Factory(t) {
  return new (t || SeriesLabelsToComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesLabelsToComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesLabelsToComponent,
  selectors: [["kendo-chart-series-item-labels-to"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    padding: "padding",
    position: "position",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesLabelsToComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesLabelsToComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-labels-to",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesMarkersComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("markers", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesMarkersComponent.ɵfac = function SeriesMarkersComponent_Factory(t) {
  return new (t || SeriesMarkersComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesMarkersComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesMarkersComponent,
  selectors: [["kendo-chart-series-item-markers"]],
  inputs: {
    background: "background",
    border: "border",
    rotation: "rotation",
    size: "size",
    type: "type",
    visible: "visible",
    visual: "visual",
    from: "from",
    to: "to"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesMarkersComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesMarkersComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-markers",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    from: [{
      type: Input
    }],
    to: [{
      type: Input
    }]
  });
})();
var SeriesNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesNotesComponent.ɵfac = function SeriesNotesComponent_Factory(t) {
  return new (t || SeriesNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesNotesComponent,
  selectors: [["kendo-chart-series-item-notes"]],
  inputs: {
    line: "line",
    position: "position",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    line: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var SeriesNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesNotesIconComponent.ɵfac = function SeriesNotesIconComponent_Factory(t) {
  return new (t || SeriesNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesNotesIconComponent,
  selectors: [["kendo-chart-series-item-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesNotesLabelComponent.ɵfac = function SeriesNotesLabelComponent_Factory(t) {
  return new (t || SeriesNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesNotesLabelComponent,
  selectors: [["kendo-chart-series-item-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SeriesOutliersComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("outliers", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesOutliersComponent.ɵfac = function SeriesOutliersComponent_Factory(t) {
  return new (t || SeriesOutliersComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesOutliersComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesOutliersComponent,
  selectors: [["kendo-chart-series-item-outliers"]],
  inputs: {
    background: "background",
    border: "border",
    rotation: "rotation",
    size: "size",
    type: "type"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesOutliersComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesOutliersComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-outliers",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var SeriesTrendlineComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("trendline", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesTrendlineComponent.ɵfac = function SeriesTrendlineComponent_Factory(t) {
  return new (t || SeriesTrendlineComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesTrendlineComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesTrendlineComponent,
  selectors: [["kendo-chart-series-item-trendline"]],
  inputs: {
    period: "period",
    order: "order",
    forecast: "forecast"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesTrendlineComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesTrendlineComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-trendline",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    period: [{
      type: Input
    }],
    order: [{
      type: Input
    }],
    forecast: [{
      type: Input
    }]
  });
})();
var SeriesTrendlineForecastComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("forecast", configurationService);
    this.configurationService = configurationService;
  }
};
SeriesTrendlineForecastComponent.ɵfac = function SeriesTrendlineForecastComponent_Factory(t) {
  return new (t || SeriesTrendlineForecastComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SeriesTrendlineForecastComponent.ɵcmp = ɵɵdefineComponent({
  type: SeriesTrendlineForecastComponent,
  selectors: [["kendo-chart-series-item-trendline-forecast"]],
  inputs: {
    before: "before",
    after: "after",
    forecast: "forecast"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SeriesTrendlineForecastComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SeriesTrendlineForecastComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-series-item-trendline-forecast",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    before: [{
      type: Input
    }],
    after: [{
      type: Input
    }],
    forecast: [{
      type: Input
    }]
  });
})();
var SubtitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("subtitle", configurationService);
    this.configurationService = configurationService;
  }
};
SubtitleComponent.ɵfac = function SubtitleComponent_Factory(t) {
  return new (t || SubtitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SubtitleComponent.ɵcmp = ɵɵdefineComponent({
  type: SubtitleComponent,
  selectors: [["kendo-chart-subtitle"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    text: "text",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SubtitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SubtitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-subtitle",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var TitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
TitleComponent.ɵfac = function TitleComponent_Factory(t) {
  return new (t || TitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
TitleComponent.ɵcmp = ɵɵdefineComponent({
  type: TitleComponent,
  selectors: [["kendo-chart-title"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    text: "text",
    description: "description",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function TitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var TooltipComponent = class extends SettingsComponent {
  constructor(configurationService, templateService) {
    super("tooltip", configurationService);
    this.configurationService = configurationService;
    this.templateService = templateService;
    this.markAsVisible();
  }
  ngAfterContentChecked() {
    this.templateService.setTemplate(this.seriesTooltipTemplate ? this.seriesTooltipTemplate.templateRef : null);
    this.templateService.setSharedTemplate(this.sharedTooltipTemplate ? this.sharedTooltipTemplate.templateRef : null);
  }
};
TooltipComponent.ɵfac = function TooltipComponent_Factory(t) {
  return new (t || TooltipComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(TooltipTemplateService));
};
TooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: TooltipComponent,
  selectors: [["kendo-chart-tooltip"]],
  contentQueries: function TooltipComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SeriesTooltipTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, SharedTooltipTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sharedTooltipTemplate = _t.first);
    }
  },
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    opacity: "opacity",
    padding: "padding",
    shared: "shared",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function TooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipComponent, [{
    type: Component,
    args: [{
      selector: "kendo-chart-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: TooltipTemplateService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    shared: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    seriesTooltipTemplate: [{
      type: ContentChild,
      args: [SeriesTooltipTemplateDirective, {
        static: false
      }]
    }],
    sharedTooltipTemplate: [{
      type: ContentChild,
      args: [SharedTooltipTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var ValueAxisItemComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
ValueAxisItemComponent.ɵfac = function ValueAxisItemComponent_Factory(t) {
  return new (t || ValueAxisItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
ValueAxisItemComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisItemComponent,
  selectors: [["kendo-chart-value-axis-item"]],
  inputs: {
    axisCrossingValue: "axisCrossingValue",
    background: "background",
    color: "color",
    line: "line",
    majorGridLines: "majorGridLines",
    majorTicks: "majorTicks",
    majorUnit: "majorUnit",
    max: "max",
    min: "min",
    minorGridLines: "minorGridLines",
    minorTicks: "minorTicks",
    minorUnit: "minorUnit",
    name: "name",
    narrowRange: "narrowRange",
    pane: "pane",
    plotBands: "plotBands",
    reverse: "reverse",
    type: "type",
    visible: "visible",
    crosshair: "crosshair",
    labels: "labels",
    notes: "notes",
    title: "title"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-value-axis-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    axisCrossingValue: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    majorGridLines: [{
      type: Input
    }],
    majorTicks: [{
      type: Input
    }],
    majorUnit: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minorGridLines: [{
      type: Input
    }],
    minorTicks: [{
      type: Input
    }],
    minorUnit: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    narrowRange: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    plotBands: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    crosshair: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var ValueAxisComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService) {
    super("valueAxis", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
ValueAxisComponent.ɵfac = function ValueAxisComponent_Factory(t) {
  return new (t || ValueAxisComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
ValueAxisComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisComponent,
  selectors: [["kendo-chart-value-axis"]],
  contentQueries: function ValueAxisComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ValueAxisItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-value-axis",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [ValueAxisItemComponent]
    }]
  });
})();
var ValueAxisCrosshairComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
ValueAxisCrosshairComponent.ɵfac = function ValueAxisCrosshairComponent_Factory(t) {
  return new (t || ValueAxisCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisCrosshairComponent,
  selectors: [["kendo-chart-value-axis-item-crosshair"]],
  inputs: {
    color: "color",
    opacity: "opacity",
    visible: "visible",
    width: "width",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var ValueAxisCrosshairTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
ValueAxisCrosshairTooltipComponent.ɵfac = function ValueAxisCrosshairTooltipComponent_Factory(t) {
  return new (t || ValueAxisCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisCrosshairTooltipComponent,
  selectors: [["kendo-chart-value-axis-item-crosshair-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var ValueAxisLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
  }
};
ValueAxisLabelsComponent.ɵfac = function ValueAxisLabelsComponent_Factory(t) {
  return new (t || ValueAxisLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisLabelsComponent,
  selectors: [["kendo-chart-value-axis-item-labels"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    margin: "margin",
    mirror: "mirror",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    skip: "skip",
    step: "step",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    mirror: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var ValueAxisNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes", configurationService);
    this.configurationService = configurationService;
  }
};
ValueAxisNotesComponent.ɵfac = function ValueAxisNotesComponent_Factory(t) {
  return new (t || ValueAxisNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisNotesComponent,
  selectors: [["kendo-chart-value-axis-item-notes"]],
  inputs: {
    data: "data",
    line: "line",
    position: "position",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    data: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var ValueAxisNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
ValueAxisNotesIconComponent.ɵfac = function ValueAxisNotesIconComponent_Factory(t) {
  return new (t || ValueAxisNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisNotesIconComponent,
  selectors: [["kendo-chart-value-axis-item-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var ValueAxisNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
ValueAxisNotesLabelComponent.ɵfac = function ValueAxisNotesLabelComponent_Factory(t) {
  return new (t || ValueAxisNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisNotesLabelComponent,
  selectors: [["kendo-chart-value-axis-item-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var ValueAxisTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
ValueAxisTitleComponent.ɵfac = function ValueAxisTitleComponent_Factory(t) {
  return new (t || ValueAxisTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ValueAxisTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: ValueAxisTitleComponent,
  selectors: [["kendo-chart-value-axis-item-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ValueAxisTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueAxisTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-value-axis-item-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var XAxisItemComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService, intl, localeId) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.intl = intl;
    this.notifyChanges({
      weekStartDay: intl.firstDay(localeId)
    });
  }
};
XAxisItemComponent.ɵfac = function XAxisItemComponent_Factory(t) {
  return new (t || XAxisItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LOCALE_ID));
};
XAxisItemComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisItemComponent,
  selectors: [["kendo-chart-x-axis-item"]],
  inputs: {
    axisCrossingValue: "axisCrossingValue",
    background: "background",
    baseUnit: "baseUnit",
    categories: "categories",
    color: "color",
    line: "line",
    majorGridLines: "majorGridLines",
    majorTicks: "majorTicks",
    majorUnit: "majorUnit",
    max: "max",
    min: "min",
    minorGridLines: "minorGridLines",
    minorTicks: "minorTicks",
    minorUnit: "minorUnit",
    name: "name",
    narrowRange: "narrowRange",
    pane: "pane",
    plotBands: "plotBands",
    reverse: "reverse",
    startAngle: "startAngle",
    type: "type",
    visible: "visible",
    weekStartDay: "weekStartDay",
    crosshair: "crosshair",
    labels: "labels",
    notes: "notes",
    title: "title"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-x-axis-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }, {
      type: IntlService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, {
    axisCrossingValue: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    baseUnit: [{
      type: Input
    }],
    categories: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    majorGridLines: [{
      type: Input
    }],
    majorTicks: [{
      type: Input
    }],
    majorUnit: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minorGridLines: [{
      type: Input
    }],
    minorTicks: [{
      type: Input
    }],
    minorUnit: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    narrowRange: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    plotBands: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    startAngle: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    weekStartDay: [{
      type: Input
    }],
    crosshair: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var XAxisComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService) {
    super("xAxis", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) {
  return new (t || XAxisComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
XAxisComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisComponent,
  selectors: [["kendo-chart-x-axis"]],
  contentQueries: function XAxisComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, XAxisItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-x-axis",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [XAxisItemComponent]
    }]
  });
})();
var XAxisCrosshairComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
XAxisCrosshairComponent.ɵfac = function XAxisCrosshairComponent_Factory(t) {
  return new (t || XAxisCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisCrosshairComponent,
  selectors: [["kendo-chart-x-axis-item-crosshair"]],
  inputs: {
    color: "color",
    opacity: "opacity",
    visible: "visible",
    width: "width",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var XAxisCrosshairTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
XAxisCrosshairTooltipComponent.ɵfac = function XAxisCrosshairTooltipComponent_Factory(t) {
  return new (t || XAxisCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisCrosshairTooltipComponent,
  selectors: [["kendo-chart-x-axis-item-crosshair-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var XAxisLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
  }
};
XAxisLabelsComponent.ɵfac = function XAxisLabelsComponent_Factory(t) {
  return new (t || XAxisLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisLabelsComponent,
  selectors: [["kendo-chart-x-axis-item-labels"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    culture: "culture",
    dateFormats: "dateFormats",
    font: "font",
    format: "format",
    margin: "margin",
    mirror: "mirror",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    skip: "skip",
    step: "step",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    culture: [{
      type: Input
    }],
    dateFormats: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    mirror: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var XAxisNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes", configurationService);
    this.configurationService = configurationService;
  }
};
XAxisNotesComponent.ɵfac = function XAxisNotesComponent_Factory(t) {
  return new (t || XAxisNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisNotesComponent,
  selectors: [["kendo-chart-x-axis-item-notes"]],
  inputs: {
    data: "data",
    line: "line",
    position: "position",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    data: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var XAxisNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
XAxisNotesIconComponent.ɵfac = function XAxisNotesIconComponent_Factory(t) {
  return new (t || XAxisNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisNotesIconComponent,
  selectors: [["kendo-chart-x-axis-item-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var XAxisNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
XAxisNotesLabelComponent.ɵfac = function XAxisNotesLabelComponent_Factory(t) {
  return new (t || XAxisNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisNotesLabelComponent,
  selectors: [["kendo-chart-x-axis-item-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var XAxisTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
XAxisTitleComponent.ɵfac = function XAxisTitleComponent_Factory(t) {
  return new (t || XAxisTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
XAxisTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: XAxisTitleComponent,
  selectors: [["kendo-chart-x-axis-item-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function XAxisTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(XAxisTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-x-axis-item-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var YAxisItemComponent = class extends CollectionItemComponent {
  constructor(configurationService, collectionService) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
YAxisItemComponent.ɵfac = function YAxisItemComponent_Factory(t) {
  return new (t || YAxisItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
YAxisItemComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisItemComponent,
  selectors: [["kendo-chart-y-axis-item"]],
  inputs: {
    axisCrossingValue: "axisCrossingValue",
    background: "background",
    baseUnit: "baseUnit",
    categories: "categories",
    color: "color",
    line: "line",
    majorGridLines: "majorGridLines",
    majorTicks: "majorTicks",
    majorUnit: "majorUnit",
    max: "max",
    min: "min",
    minorGridLines: "minorGridLines",
    minorTicks: "minorTicks",
    minorUnit: "minorUnit",
    name: "name",
    narrowRange: "narrowRange",
    pane: "pane",
    plotBands: "plotBands",
    reverse: "reverse",
    type: "type",
    visible: "visible",
    crosshair: "crosshair",
    labels: "labels",
    notes: "notes",
    title: "title"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-y-axis-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    axisCrossingValue: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    baseUnit: [{
      type: Input
    }],
    categories: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    majorGridLines: [{
      type: Input
    }],
    majorTicks: [{
      type: Input
    }],
    majorUnit: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minorGridLines: [{
      type: Input
    }],
    minorTicks: [{
      type: Input
    }],
    minorUnit: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    narrowRange: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    plotBands: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    crosshair: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    notes: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var YAxisComponent = class extends CollectionComponent {
  constructor(configurationService, collectionService) {
    super("yAxis", configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) {
  return new (t || YAxisComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
YAxisComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisComponent,
  selectors: [["kendo-chart-y-axis"]],
  contentQueries: function YAxisComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, YAxisItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-y-axis",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [YAxisItemComponent]
    }]
  });
})();
var YAxisCrosshairComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
YAxisCrosshairComponent.ɵfac = function YAxisCrosshairComponent_Factory(t) {
  return new (t || YAxisCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisCrosshairComponent,
  selectors: [["kendo-chart-y-axis-item-crosshair"]],
  inputs: {
    color: "color",
    opacity: "opacity",
    visible: "visible",
    width: "width",
    tooltip: "tooltip"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    color: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }]
  });
})();
var YAxisCrosshairTooltipComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("crosshair.tooltip", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
YAxisCrosshairTooltipComponent.ɵfac = function YAxisCrosshairTooltipComponent_Factory(t) {
  return new (t || YAxisCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisCrosshairTooltipComponent,
  selectors: [["kendo-chart-y-axis-item-crosshair-tooltip"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    format: "format",
    padding: "padding",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var YAxisLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
  }
};
YAxisLabelsComponent.ɵfac = function YAxisLabelsComponent_Factory(t) {
  return new (t || YAxisLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisLabelsComponent,
  selectors: [["kendo-chart-y-axis-item-labels"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    culture: "culture",
    dateFormats: "dateFormats",
    font: "font",
    format: "format",
    margin: "margin",
    mirror: "mirror",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    skip: "skip",
    step: "step",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    culture: [{
      type: Input
    }],
    dateFormats: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    mirror: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    skip: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var YAxisNotesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes", configurationService);
    this.configurationService = configurationService;
  }
};
YAxisNotesComponent.ɵfac = function YAxisNotesComponent_Factory(t) {
  return new (t || YAxisNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisNotesComponent,
  selectors: [["kendo-chart-y-axis-item-notes"]],
  inputs: {
    data: "data",
    line: "line",
    position: "position",
    visual: "visual",
    icon: "icon",
    label: "label"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    data: [{
      type: Input
    }],
    line: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    visual: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    label: [{
      type: Input
    }]
  });
})();
var YAxisNotesIconComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.icon", configurationService);
    this.configurationService = configurationService;
  }
};
YAxisNotesIconComponent.ɵfac = function YAxisNotesIconComponent_Factory(t) {
  return new (t || YAxisNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisNotesIconComponent,
  selectors: [["kendo-chart-y-axis-item-notes-icon"]],
  inputs: {
    background: "background",
    border: "border",
    size: "size",
    type: "type",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var YAxisNotesLabelComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("notes.label", configurationService);
    this.configurationService = configurationService;
  }
};
YAxisNotesLabelComponent.ɵfac = function YAxisNotesLabelComponent_Factory(t) {
  return new (t || YAxisNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisNotesLabelComponent,
  selectors: [["kendo-chart-y-axis-item-notes-label"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    content: "content",
    font: "font",
    format: "format",
    position: "position",
    rotation: "rotation",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    content: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var YAxisTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
YAxisTitleComponent.ɵfac = function YAxisTitleComponent_Factory(t) {
  return new (t || YAxisTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
YAxisTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: YAxisTitleComponent,
  selectors: [["kendo-chart-y-axis-item-title"]],
  inputs: {
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    rotation: "rotation",
    text: "text",
    visible: "visible",
    visual: "visual"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function YAxisTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YAxisTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-y-axis-item-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    rotation: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    visual: [{
      type: Input
    }]
  });
})();
var ZoomableComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("zoomable", configurationService);
    this.configurationService = configurationService;
  }
};
ZoomableComponent.ɵfac = function ZoomableComponent_Factory(t) {
  return new (t || ZoomableComponent)(ɵɵdirectiveInject(ConfigurationService));
};
ZoomableComponent.ɵcmp = ɵɵdefineComponent({
  type: ZoomableComponent,
  selectors: [["kendo-chart-zoomable"]],
  inputs: {
    mousewheel: "mousewheel",
    selection: "selection"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function ZoomableComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoomableComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-zoomable",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    mousewheel: [{
      type: Input
    }],
    selection: [{
      type: Input
    }]
  });
})();
var ChartBreadcrumbComponent = class {
  constructor() {
    this.rootItem = {
      icon: "home",
      svgIcon: homeIcon,
      title: "Home"
    };
    this.subscription = new import_rxjs.Subscription();
  }
  ngOnInit() {
    this.items = [this.rootItem];
    if (this.chart) {
      this.subscription.add(this.chart.drilldown.subscribe(this.onDrilldown.bind(this)));
      this.subscription.add(this.chart.drilldownLevelChange.subscribe(this.onDrilldownLevelChange.bind(this)));
    } else if (isDevMode()) {
      throw new Error('Chart Breadcrumb: No Chart instance supplied. Please add a reference using the "chart" attribute. For example: \n<kendo-chart-breadcrumb [chart]="instance" />\n<kendo-chart #instance>');
    }
  }
  ngOnChanges(changes) {
    const rootItemChange = changes["rootItem"];
    if (rootItemChange && this.items) {
      this.items[0] = rootItemChange.currentValue;
    }
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = null;
    }
  }
  /**
   * @hidden
   */
  onItemClick(target) {
    this.chart.drilldownLevel = this.items.findIndex((item) => item === target);
  }
  onDrilldown(e) {
    this.items = [...this.items, {
      text: e.point.category.toString()
    }];
  }
  onDrilldownLevelChange(level) {
    this.items = this.items.slice(0, level + 1);
  }
};
ChartBreadcrumbComponent.ɵfac = function ChartBreadcrumbComponent_Factory(t) {
  return new (t || ChartBreadcrumbComponent)();
};
ChartBreadcrumbComponent.ɵcmp = ɵɵdefineComponent({
  type: ChartBreadcrumbComponent,
  selectors: [["kendo-chart-breadcrumb"]],
  viewQuery: function ChartBreadcrumbComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c2, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.breadcrumb = _t.first);
    }
  },
  inputs: {
    chart: "chart",
    rootItem: "rootItem"
  },
  exportAs: ["kendoChartBreadcrumb"],
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [[3, "itemClick", "items"]],
  template: function ChartBreadcrumbComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "kendo-breadcrumb", 0);
      ɵɵlistener("itemClick", function ChartBreadcrumbComponent_Template_kendo_breadcrumb_itemClick_0_listener($event) {
        return ctx.onItemClick($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("items", ctx.items);
    }
  },
  dependencies: [BreadCrumbComponent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartBreadcrumbComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoChartBreadcrumb",
      selector: "kendo-chart-breadcrumb",
      template: `
        <kendo-breadcrumb [items]="items" (itemClick)="onItemClick($event)">
        </kendo-breadcrumb>
    `
    }]
  }], null, {
    chart: [{
      type: Input
    }],
    rootItem: [{
      type: Input
    }],
    breadcrumb: [{
      type: ViewChild,
      args: ["breadcrumb", {
        static: true
      }]
    }]
  });
})();
var CHART_DIRECTIVES = [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, ChartBreadcrumbComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesDrilldownTemplateDirective, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SeriesTrendlineComponent, SeriesTrendlineForecastComponent, SubtitleComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent];
var WeekStartDay;
(function(WeekStartDay2) {
  WeekStartDay2[WeekStartDay2["Sunday"] = 0] = "Sunday";
  WeekStartDay2[WeekStartDay2["Monday"] = 1] = "Monday";
  WeekStartDay2[WeekStartDay2["Tuesday"] = 2] = "Tuesday";
  WeekStartDay2[WeekStartDay2["Wednesday"] = 3] = "Wednesday";
  WeekStartDay2[WeekStartDay2["Thursday"] = 4] = "Thursday";
  WeekStartDay2[WeekStartDay2["Friday"] = 5] = "Friday";
  WeekStartDay2[WeekStartDay2["Saturday"] = 6] = "Saturday";
})(WeekStartDay || (WeekStartDay = {}));
var NavigatorFilterEvent = class extends BaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(sender);
    this.from = e.from;
    this.to = e.to;
  }
};
var RootConfigurationService = class extends ConfigurationService {
};
RootConfigurationService.ɵfac = /* @__PURE__ */ (() => {
  let ɵRootConfigurationService_BaseFactory;
  return function RootConfigurationService_Factory(t) {
    return (ɵRootConfigurationService_BaseFactory || (ɵRootConfigurationService_BaseFactory = ɵɵgetInheritedFactory(RootConfigurationService)))(t || RootConfigurationService);
  };
})();
RootConfigurationService.ɵprov = ɵɵdefineInjectable({
  token: RootConfigurationService,
  factory: RootConfigurationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RootConfigurationService, [{
    type: Injectable
  }], null, null);
})();
var EVENT_MAP$1 = {
  navigatorFilter: NavigatorFilterEvent
};
var StockInstanceEventService = class extends InstanceEventService$1 {
  create(name2, args, sender) {
    if (EVENT_MAP$1[name2]) {
      return new EVENT_MAP$1[name2](args, sender);
    }
    return super.create(name2, args, sender);
  }
};
var NAVIGATOR_DEFAULTS = {
  autoBindElements: true,
  liveDrag: false,
  partialRedraw: true
};
var StockChartComponent = class extends ChartComponent {
  constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
    super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
    this.configurationService = configurationService;
    this.themeService = themeService;
    this.element = element;
    this.intl = intl;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.instanceEventService = instanceEventService;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.drilldown = new EventEmitter();
    this.drilldownLevelChange = new EventEmitter();
    this.navigatorFilter = new EventEmitter();
    this.showLicenseWatermark = false;
    this.redrawSlaves = false;
    this.hostClasses = ["k-chart", "k-stockchart"];
    const isValid = validatePackage(packageMetadata);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
  }
  /**
   * @hidden
   */
  get drilldownLevel() {
    return this.drilldownState.length;
  }
  /**
   * If called, the navigator pane is not redrawn the next time the StockChart options are updated.
   * The method is useful if you need to update only the main series data for the selected period.
   */
  skipNavigatorRedraw() {
    this.redrawSlaves = true;
  }
  createInstance(element, observer) {
    this.applyNavigatorDefaults();
    if (this.isDevMode() && (this.options.zoomable || this.options.pannable)) {
      throw new Error("The pannable and zoomable options are not supported by the StockChart component.");
    }
    this.instance = new stock_chart_default(element, this.options, this.theme, {
      intlService: this.intl,
      observer,
      rtl: this.rtl,
      sender: this
    });
  }
  updateOptions() {
    this.applyNavigatorDefaults();
    if (this.redrawSlaves) {
      this.instance.applyOptions(this.options);
      this.instance.bindCategories();
      this.instance.navigator.redrawSlaves();
    } else {
      this.instance.setOptions(this.options);
    }
    this.redrawSlaves = false;
  }
  applyNavigatorDefaults() {
    this.options.navigator = Object.assign({}, this.options.navigator, NAVIGATOR_DEFAULTS);
  }
  isDevMode() {
    return isDevMode();
  }
};
StockChartComponent.ɵfac = function StockChartComponent_Factory(t) {
  return new (t || StockChartComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(ThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(StockInstanceEventService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
};
StockChartComponent.ɵcmp = ɵɵdefineComponent({
  type: StockChartComponent,
  selectors: [["kendo-stockchart"]],
  inputs: {
    navigator: "navigator",
    pannable: "pannable",
    zoomable: "zoomable",
    drilldownLevel: "drilldownLevel"
  },
  outputs: {
    drilldown: "drilldown",
    drilldownLevelChange: "drilldownLevelChange",
    navigatorFilter: "navigatorFilter"
  },
  exportAs: ["kendoStockChart"],
  features: [ɵɵProvidersFeature([ConfigurationService, TooltipTemplateService, {
    provide: RootConfigurationService,
    useExisting: ConfigurationService
  }, StockInstanceEventService, LocalizationService, {
    provide: L10N_PREFIX,
    useValue: "kendo.chart"
  }]), ɵɵInheritDefinitionFeature],
  decls: 6,
  vars: 3,
  consts: [["surface", ""], [1, "k-chart-surface"], [3, "popupSettings"], [3, "leave", "popupSettings"], [3, "resize"], ["kendoWatermarkOverlay", "", 4, "ngIf"], ["kendoWatermarkOverlay", ""]],
  template: function StockChartComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelement(0, "div", 1, 0)(2, "kendo-chart-crosshair-tooltips-container", 2);
      ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
      ɵɵlistener("leave", function StockChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.tooltipMouseleave($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(4, "kendo-resize-sensor", 4);
      ɵɵlistener("resize", function StockChartComponent_Template_kendo_resize_sensor_resize_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onResize());
      });
      ɵɵelementEnd();
      ɵɵtemplate(5, StockChartComponent_div_5_Template, 1, 0, "div", 5);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("popupSettings", ctx.popupSettings);
      ɵɵadvance();
      ɵɵproperty("popupSettings", ctx.popupSettings);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showLicenseWatermark);
    }
  },
  dependencies: [TooltipPopupComponent, CrosshairTooltipsContainerComponent, NgIf, ResizeSensorComponent, WatermarkOverlayComponent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendoStockChart",
      providers: [ConfigurationService, TooltipTemplateService, {
        provide: RootConfigurationService,
        useExisting: ConfigurationService
      }, StockInstanceEventService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.chart"
      }],
      selector: "kendo-stockchart",
      template: `
        <div #surface class="k-chart-surface"></div>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: ThemeService
    }, {
      type: ElementRef
    }, {
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: StockInstanceEventService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    navigator: [{
      type: Input
    }],
    pannable: [{
      type: Input
    }],
    zoomable: [{
      type: Input
    }],
    drilldown: [{
      type: Output
    }],
    drilldownLevelChange: [{
      type: Output
    }],
    drilldownLevel: [{
      type: Input
    }],
    navigatorFilter: [{
      type: Output
    }]
  });
})();
var PREFIX = new InjectionToken("configuration prefix");
var PrefixConfigurationService = class extends ConfigurationService {
  constructor(rootService, prefix, ngZone) {
    super(ngZone);
    this.rootService = rootService;
    this.prefix = prefix;
  }
  push(store) {
    this.rootService.notify(new Change(this.prefix, store));
  }
  notify(change) {
    change.key = this.prefix + (change.key ? `.${change.key}` : "");
    this.rootService.notify(change);
  }
};
PrefixConfigurationService.ɵfac = function PrefixConfigurationService_Factory(t) {
  return new (t || PrefixConfigurationService)(ɵɵinject(RootConfigurationService), ɵɵinject(PREFIX), ɵɵinject(NgZone));
};
PrefixConfigurationService.ɵprov = ɵɵdefineInjectable({
  token: PrefixConfigurationService,
  factory: PrefixConfigurationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PrefixConfigurationService, [{
    type: Injectable
  }], function() {
    return [{
      type: RootConfigurationService,
      decorators: [{
        type: Inject,
        args: [RootConfigurationService]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PREFIX]
      }]
    }, {
      type: NgZone
    }];
  }, null);
})();
var NavigatorComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("", configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorComponent.ɵfac = function NavigatorComponent_Factory(t) {
  return new (t || NavigatorComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorComponent,
  selectors: [["kendo-chart-navigator"]],
  inputs: {
    position: "position",
    visible: "visible",
    categoryAxis: "categoryAxis",
    hint: "hint",
    pane: "pane",
    select: "select",
    series: "series"
  },
  features: [ɵɵProvidersFeature([{
    provide: PREFIX,
    useValue: "navigator"
  }, {
    provide: ConfigurationService,
    useClass: PrefixConfigurationService
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: PREFIX,
        useValue: "navigator"
      }, {
        provide: ConfigurationService,
        useClass: PrefixConfigurationService
      }],
      selector: "kendo-chart-navigator",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    position: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    categoryAxis: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    pane: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    series: [{
      type: Input
    }]
  });
})();
var NavigatorCategoryAxisComponent = class extends CategoryAxisItemComponent {
  constructor(configurationService, intl, localeId) {
    super(configurationService, null, intl, localeId);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisComponent.ɵfac = function NavigatorCategoryAxisComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LOCALE_ID));
};
NavigatorCategoryAxisComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisComponent,
  selectors: [["kendo-chart-navigator-category-axis"]],
  features: [ɵɵProvidersFeature([{
    provide: PREFIX,
    useValue: "navigator.categoryAxis"
  }, {
    provide: ConfigurationService,
    useClass: PrefixConfigurationService
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: PREFIX,
        useValue: "navigator.categoryAxis"
      }, {
        provide: ConfigurationService,
        useClass: PrefixConfigurationService
      }],
      selector: "kendo-chart-navigator-category-axis",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: IntlService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var NavigatorCategoryAxisCrosshairComponent = class extends CategoryAxisCrosshairComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisCrosshairComponent.ɵfac = function NavigatorCategoryAxisCrosshairComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisCrosshairComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisCrosshairComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisCrosshairComponent,
  selectors: [["kendo-chart-navigator-category-axis-crosshair"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisCrosshairComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisCrosshairComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-crosshair",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisCrosshairTooltipComponent = class extends CategoryAxisCrosshairTooltipComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisCrosshairTooltipComponent.ɵfac = function NavigatorCategoryAxisCrosshairTooltipComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisCrosshairTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisCrosshairTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisCrosshairTooltipComponent,
  selectors: [["kendo-chart-navigator-category-axis-crosshair-tooltip"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisCrosshairTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisCrosshairTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-crosshair-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisLabelsComponent = class extends CategoryAxisLabelsComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisLabelsComponent.ɵfac = function NavigatorCategoryAxisLabelsComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisLabelsComponent,
  selectors: [["kendo-chart-navigator-category-axis-labels"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisNotesComponent = class extends CategoryAxisNotesComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisNotesComponent.ɵfac = function NavigatorCategoryAxisNotesComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisNotesComponent,
  selectors: [["kendo-chart-navigator-category-axis-notes"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisNotesIconComponent = class extends CategoryAxisNotesIconComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisNotesIconComponent.ɵfac = function NavigatorCategoryAxisNotesIconComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisNotesIconComponent,
  selectors: [["kendo-chart-navigator-category-axis-notes-icon"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisNotesLabelComponent = class extends CategoryAxisNotesLabelComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisNotesLabelComponent.ɵfac = function NavigatorCategoryAxisNotesLabelComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisNotesLabelComponent,
  selectors: [["kendo-chart-navigator-category-axis-notes-label"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisSelectComponent = class extends CategoryAxisSelectComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisSelectComponent.ɵfac = function NavigatorCategoryAxisSelectComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisSelectComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisSelectComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisSelectComponent,
  selectors: [["kendo-chart-navigator-category-axis-select"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisSelectComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisSelectComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-select",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorCategoryAxisTitleComponent = class extends CategoryAxisTitleComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorCategoryAxisTitleComponent.ɵfac = function NavigatorCategoryAxisTitleComponent_Factory(t) {
  return new (t || NavigatorCategoryAxisTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorCategoryAxisTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorCategoryAxisTitleComponent,
  selectors: [["kendo-chart-navigator-category-axis-title"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorCategoryAxisTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorCategoryAxisTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-category-axis-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorHintComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("hint", configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorHintComponent.ɵfac = function NavigatorHintComponent_Factory(t) {
  return new (t || NavigatorHintComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorHintComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorHintComponent,
  selectors: [["kendo-chart-navigator-hint"]],
  inputs: {
    content: "content",
    format: "format",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorHintComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorHintComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-hint",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    content: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var NavigatorPaneComponent = class extends PaneComponent {
  constructor(configurationService) {
    super(configurationService, null);
    this.configurationService = configurationService;
  }
};
NavigatorPaneComponent.ɵfac = function NavigatorPaneComponent_Factory(t) {
  return new (t || NavigatorPaneComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorPaneComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorPaneComponent,
  selectors: [["kendo-chart-navigator-pane"]],
  features: [ɵɵProvidersFeature([{
    provide: PREFIX,
    useValue: "navigator.pane"
  }, {
    provide: ConfigurationService,
    useClass: PrefixConfigurationService
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorPaneComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorPaneComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: PREFIX,
        useValue: "navigator.pane"
      }, {
        provide: ConfigurationService,
        useClass: PrefixConfigurationService
      }],
      selector: "kendo-chart-navigator-pane",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorPaneTitleComponent = class extends PanesTitleComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorPaneTitleComponent.ɵfac = function NavigatorPaneTitleComponent_Factory(t) {
  return new (t || NavigatorPaneTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorPaneTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorPaneTitleComponent,
  selectors: [["kendo-chart-navigator-pane-title"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorPaneTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorPaneTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-pane-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSelectComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("select", configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSelectComponent.ɵfac = function NavigatorSelectComponent_Factory(t) {
  return new (t || NavigatorSelectComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSelectComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSelectComponent,
  selectors: [["kendo-chart-navigator-select"]],
  inputs: {
    from: "from",
    to: "to",
    mousewheel: "mousewheel"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSelectComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSelectComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-select",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    from: [{
      type: Input
    }],
    to: [{
      type: Input
    }],
    mousewheel: [{
      type: Input
    }]
  });
})();
var NavigatorSeriesItemComponent = class extends SeriesItemComponent {
  constructor(configurationService, collectionService) {
    super(configurationService, collectionService);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
  }
};
NavigatorSeriesItemComponent.ɵfac = function NavigatorSeriesItemComponent_Factory(t) {
  return new (t || NavigatorSeriesItemComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService));
};
NavigatorSeriesItemComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesItemComponent,
  selectors: [["kendo-chart-navigator-series-item"]],
  inputs: {
    drilldownField: "drilldownField"
  },
  features: [ɵɵProvidersFeature([ConfigurationService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesItemComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesItemComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [ConfigurationService],
      selector: "kendo-chart-navigator-series-item",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }];
  }, {
    drilldownField: [{
      type: Input
    }]
  });
})();
var NavigatorSeriesComponent = class extends SeriesComponent {
  constructor(configurationService, collectionService, tooltipTemplateService, viewContainer) {
    super(configurationService, collectionService, tooltipTemplateService, viewContainer);
    this.configurationService = configurationService;
    this.collectionService = collectionService;
    this.tooltipTemplateService = tooltipTemplateService;
    this.viewContainer = viewContainer;
  }
  readTooltipTemplates() {
  }
};
NavigatorSeriesComponent.ɵfac = function NavigatorSeriesComponent_Factory(t) {
  return new (t || NavigatorSeriesComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(CollectionService), ɵɵdirectiveInject(TooltipTemplateService), ɵɵdirectiveInject(ViewContainerRef));
};
NavigatorSeriesComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesComponent,
  selectors: [["kendo-chart-navigator-series"]],
  contentQueries: function NavigatorSeriesComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NavigatorSeriesItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.children = _t);
    }
  },
  features: [ɵɵProvidersFeature([CollectionService]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [CollectionService],
      selector: "kendo-chart-navigator-series",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: CollectionService
    }, {
      type: TooltipTemplateService
    }, {
      type: ViewContainerRef
    }];
  }, {
    children: [{
      type: ContentChildren,
      args: [NavigatorSeriesItemComponent]
    }]
  });
})();
var NavigatorSeriesErrorBarsComponent = class extends SeriesErrorBarsComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesErrorBarsComponent.ɵfac = function NavigatorSeriesErrorBarsComponent_Factory(t) {
  return new (t || NavigatorSeriesErrorBarsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesErrorBarsComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesErrorBarsComponent,
  selectors: [["kendo-chart-navigator-series-item-error-bars"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesErrorBarsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesErrorBarsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-error-bars",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesExtremesComponent = class extends SeriesExtremesComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesExtremesComponent.ɵfac = function NavigatorSeriesExtremesComponent_Factory(t) {
  return new (t || NavigatorSeriesExtremesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesExtremesComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesExtremesComponent,
  selectors: [["kendo-chart-navigator-series-item-extremes"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesExtremesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesExtremesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-extremes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesHighlightComponent = class extends SeriesHighlightComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesHighlightComponent.ɵfac = function NavigatorSeriesHighlightComponent_Factory(t) {
  return new (t || NavigatorSeriesHighlightComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesHighlightComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesHighlightComponent,
  selectors: [["kendo-chart-navigator-series-item-highlight"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesHighlightComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesHighlightComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-highlight",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesLabelsComponent = class extends SeriesLabelsComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
NavigatorSeriesLabelsComponent.ɵfac = function NavigatorSeriesLabelsComponent_Factory(t) {
  return new (t || NavigatorSeriesLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesLabelsComponent,
  selectors: [["kendo-chart-navigator-series-item-labels"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesLabelsFromComponent = class extends SeriesLabelsFromComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
NavigatorSeriesLabelsFromComponent.ɵfac = function NavigatorSeriesLabelsFromComponent_Factory(t) {
  return new (t || NavigatorSeriesLabelsFromComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesLabelsFromComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesLabelsFromComponent,
  selectors: [["kendo-chart-navigator-series-item-labels-from"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesLabelsFromComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesLabelsFromComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-labels-from",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesLabelsToComponent = class extends SeriesLabelsToComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
NavigatorSeriesLabelsToComponent.ɵfac = function NavigatorSeriesLabelsToComponent_Factory(t) {
  return new (t || NavigatorSeriesLabelsToComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesLabelsToComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesLabelsToComponent,
  selectors: [["kendo-chart-navigator-series-item-labels-to"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesLabelsToComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesLabelsToComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-labels-to",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesMarkersComponent = class extends SeriesMarkersComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesMarkersComponent.ɵfac = function NavigatorSeriesMarkersComponent_Factory(t) {
  return new (t || NavigatorSeriesMarkersComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesMarkersComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesMarkersComponent,
  selectors: [["kendo-chart-navigator-series-item-markers"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesMarkersComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesMarkersComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-markers",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesNotesComponent = class extends SeriesNotesComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesNotesComponent.ɵfac = function NavigatorSeriesNotesComponent_Factory(t) {
  return new (t || NavigatorSeriesNotesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesNotesComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesNotesComponent,
  selectors: [["kendo-chart-navigator-series-item-notes"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesNotesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesNotesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-notes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesNotesIconComponent = class extends SeriesNotesIconComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesNotesIconComponent.ɵfac = function NavigatorSeriesNotesIconComponent_Factory(t) {
  return new (t || NavigatorSeriesNotesIconComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesNotesIconComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesNotesIconComponent,
  selectors: [["kendo-chart-navigator-series-item-notes-icon"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesNotesIconComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesNotesIconComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-notes-icon",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesNotesLabelComponent = class extends SeriesNotesLabelComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesNotesLabelComponent.ɵfac = function NavigatorSeriesNotesLabelComponent_Factory(t) {
  return new (t || NavigatorSeriesNotesLabelComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesNotesLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesNotesLabelComponent,
  selectors: [["kendo-chart-navigator-series-item-notes-label"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesNotesLabelComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesNotesLabelComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-notes-label",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesOutliersComponent = class extends SeriesOutliersComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesOutliersComponent.ɵfac = function NavigatorSeriesOutliersComponent_Factory(t) {
  return new (t || NavigatorSeriesOutliersComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesOutliersComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesOutliersComponent,
  selectors: [["kendo-chart-navigator-series-item-outliers"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesOutliersComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesOutliersComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-outliers",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var NavigatorSeriesTooltipComponent = class extends SeriesTooltipComponent {
  constructor(configurationService) {
    super(configurationService);
    this.configurationService = configurationService;
  }
};
NavigatorSeriesTooltipComponent.ɵfac = function NavigatorSeriesTooltipComponent_Factory(t) {
  return new (t || NavigatorSeriesTooltipComponent)(ɵɵdirectiveInject(ConfigurationService));
};
NavigatorSeriesTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: NavigatorSeriesTooltipComponent,
  selectors: [["kendo-chart-navigator-series-item-tooltip"]],
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NavigatorSeriesTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigatorSeriesTooltipComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-chart-navigator-series-item-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, null);
})();
var STOCK_CHART_DIRECTIVES = [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent];
var SparklineComponent = class extends ChartComponent {
  constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
    super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
    this.configurationService = configurationService;
    this.themeService = themeService;
    this.element = element;
    this.intl = intl;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.instanceEventService = instanceEventService;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.drilldown = new EventEmitter();
    this.drilldownLevelChange = new EventEmitter();
    this.tooltipWrapperClass = "k-sparkline-tooltip-wrapper";
    this.tooltipContentClasses = {
      "k-sparkline-tooltip": true
    };
    this.showLicenseWatermark = false;
    this.hostClasses = ["k-sparkline", "k-widget"];
    const isValid = validatePackage(packageMetadata);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
  }
  /**
   * @hidden
   */
  get drilldownLevel() {
    return this.drilldownState.length;
  }
  createInstance(element, observer) {
    this.instance = new sparkline_default(element, sparkline_default.normalizeOptions(this.options), this.theme, {
      intlService: this.intl,
      observer,
      rtl: this.rtl,
      sender: this
    });
  }
  updateOptions() {
    this.instance.setOptions(sparkline_default.normalizeOptions(this.options));
  }
};
SparklineComponent.ɵfac = function SparklineComponent_Factory(t) {
  return new (t || SparklineComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(ThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(InstanceEventService$1), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
};
SparklineComponent.ɵcmp = ɵɵdefineComponent({
  type: SparklineComponent,
  selectors: [["kendo-sparkline"]],
  inputs: {
    type: "type",
    data: "data",
    drilldownLevel: "drilldownLevel"
  },
  outputs: {
    drilldown: "drilldown",
    drilldownLevelChange: "drilldownLevelChange"
  },
  exportAs: ["kendoSparkline"],
  features: [ɵɵProvidersFeature([ConfigurationService, TooltipTemplateService, InstanceEventService$1, LocalizationService, {
    provide: L10N_PREFIX,
    useValue: "kendo.chart"
  }]), ɵɵInheritDefinitionFeature],
  decls: 6,
  vars: 6,
  consts: [["surface", ""], [1, "k-chart-surface"], [3, "popupSettings"], [3, "leave", "animate", "wrapperClass", "classNames", "popupSettings"], [3, "resize"], ["kendoWatermarkOverlay", "", 4, "ngIf"], ["kendoWatermarkOverlay", ""]],
  template: function SparklineComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelement(0, "span", 1, 0)(2, "kendo-chart-crosshair-tooltips-container", 2);
      ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
      ɵɵlistener("leave", function SparklineComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.tooltipMouseleave($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(4, "kendo-resize-sensor", 4);
      ɵɵlistener("resize", function SparklineComponent_Template_kendo_resize_sensor_resize_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onResize());
      });
      ɵɵelementEnd();
      ɵɵtemplate(5, SparklineComponent_div_5_Template, 1, 0, "div", 5);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("popupSettings", ctx.popupSettings);
      ɵɵadvance();
      ɵɵproperty("animate", false)("wrapperClass", ctx.tooltipWrapperClass)("classNames", ctx.tooltipContentClasses)("popupSettings", ctx.popupSettings);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showLicenseWatermark);
    }
  },
  dependencies: [TooltipPopupComponent, CrosshairTooltipsContainerComponent, NgIf, ResizeSensorComponent, WatermarkOverlayComponent],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SparklineComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendoSparkline",
      providers: [ConfigurationService, TooltipTemplateService, InstanceEventService$1, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.chart"
      }],
      selector: "kendo-sparkline",
      template: `
        <span #surface class="k-chart-surface"></span>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup [animate]="false" [wrapperClass]="tooltipWrapperClass"
            [classNames]="tooltipContentClasses" (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: ThemeService
    }, {
      type: ElementRef
    }, {
      type: IntlService
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: InstanceEventService$1
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    type: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    drilldown: [{
      type: Output
    }],
    drilldownLevelChange: [{
      type: Output
    }],
    drilldownLevel: [{
      type: Input
    }]
  });
})();
var SPARKLINE_DIRECTIVES = [SparklineComponent];
var ChartModule = class {
};
ChartModule.ɵfac = function ChartModule_Factory(t) {
  return new (t || ChartModule)();
};
ChartModule.ɵmod = ɵɵdefineNgModule({
  type: ChartModule,
  declarations: [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, ChartBreadcrumbComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesDrilldownTemplateDirective, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SeriesTrendlineComponent, SeriesTrendlineForecastComponent, SubtitleComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent],
  imports: [CommonModule, BreadCrumbModule, PopupModule, ResizeSensorModule, WatermarkModule],
  exports: [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, ChartBreadcrumbComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesDrilldownTemplateDirective, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, SeriesTrendlineComponent, SeriesTrendlineForecastComponent, SubtitleComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent]
});
ChartModule.ɵinj = ɵɵdefineInjector({
  providers: [ThemeService],
  imports: [CommonModule, BreadCrumbModule, PopupModule, ResizeSensorModule, WatermarkModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartModule, [{
    type: NgModule,
    args: [{
      declarations: [CHART_DIRECTIVES],
      exports: [CHART_DIRECTIVES],
      imports: [CommonModule, BreadCrumbModule, PopupModule, ResizeSensorModule, WatermarkModule],
      providers: [ThemeService]
    }]
  }], null, null);
})();
var StockChartModule = class {
};
StockChartModule.ɵfac = function StockChartModule_Factory(t) {
  return new (t || StockChartModule)();
};
StockChartModule.ɵmod = ɵɵdefineNgModule({
  type: StockChartModule,
  declarations: [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent],
  imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule],
  exports: [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, ChartModule]
});
StockChartModule.ɵinj = ɵɵdefineInjector({
  imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule, ChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StockChartModule, [{
    type: NgModule,
    args: [{
      declarations: [STOCK_CHART_DIRECTIVES],
      exports: [STOCK_CHART_DIRECTIVES, ChartModule],
      imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule]
    }]
  }], null, null);
})();
var SparklineModule = class {
};
SparklineModule.ɵfac = function SparklineModule_Factory(t) {
  return new (t || SparklineModule)();
};
SparklineModule.ɵmod = ɵɵdefineNgModule({
  type: SparklineModule,
  declarations: [SparklineComponent],
  imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule],
  exports: [SparklineComponent, ChartModule]
});
SparklineModule.ɵinj = ɵɵdefineInjector({
  imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule, ChartModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SparklineModule, [{
    type: NgModule,
    args: [{
      declarations: [SPARKLINE_DIRECTIVES],
      exports: [SPARKLINE_DIRECTIVES, ChartModule],
      imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule, WatermarkModule]
    }]
  }], null, null);
})();
var SankeyBaseEvent = class extends PreventableEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super();
    this.sender = sender;
    this.originalEvent = e.originalEvent;
  }
};
var SankeyNodeEvent = class extends SankeyBaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(e, sender);
    this.dataItem = e.dataItem;
  }
};
var SankeyLinkEvent = class extends SankeyBaseEvent {
  /**
   * @hidden
   */
  constructor(e, sender) {
    super(e, sender);
    this.dataItem = e.dataItem;
  }
};
var EVENT_MAP = {
  nodeEnter: SankeyNodeEvent,
  nodeLeave: SankeyNodeEvent,
  linkEnter: SankeyLinkEvent,
  linkLeave: SankeyLinkEvent,
  nodeClick: SankeyNodeEvent,
  linkClick: SankeyLinkEvent
};
var InstanceEventService2 = class {
  create(name2, args, sender) {
    return new EVENT_MAP[name2](args, sender);
  }
};
var SankeyLinkTooltipTemplateContext = class {
  /**
   * @hidden
   */
  constructor(e) {
    const dataItem = e.dataItem;
    this.source = dataItem.source;
    this.target = dataItem.target;
    this.value = dataItem.value;
  }
};
var SankeyLinkTooltipTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
SankeyLinkTooltipTemplateDirective.ɵfac = function SankeyLinkTooltipTemplateDirective_Factory(t) {
  return new (t || SankeyLinkTooltipTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
SankeyLinkTooltipTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: SankeyLinkTooltipTemplateDirective,
  selectors: [["", "kendoSankeyLinkTooltipTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyLinkTooltipTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSankeyLinkTooltipTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var SankeyNodeTooltipTemplateContext = class {
  /**
   * @hidden
   */
  constructor(e) {
    const dataItem = e.dataItem;
    this.label = dataItem.label;
    this.color = dataItem.color;
    this.value = e.nodeValue;
  }
};
var SankeyNodeTooltipTemplateDirective = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
SankeyNodeTooltipTemplateDirective.ɵfac = function SankeyNodeTooltipTemplateDirective_Factory(t) {
  return new (t || SankeyNodeTooltipTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
};
SankeyNodeTooltipTemplateDirective.ɵdir = ɵɵdefineDirective({
  type: SankeyNodeTooltipTemplateDirective,
  selectors: [["", "kendoSankeyNodeTooltipTemplate", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyNodeTooltipTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSankeyNodeTooltipTemplate]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var SankeyTooltipTemplateService = class {
};
SankeyTooltipTemplateService.ɵfac = function SankeyTooltipTemplateService_Factory(t) {
  return new (t || SankeyTooltipTemplateService)();
};
SankeyTooltipTemplateService.ɵprov = ɵɵdefineInjectable({
  token: SankeyTooltipTemplateService,
  factory: SankeyTooltipTemplateService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyTooltipTemplateService, [{
    type: Injectable
  }], null, null);
})();
var SquareSymbol = class {
  constructor() {
    this.size = 15;
    this.display = "inline-flex";
    this.marginLeft = 3;
  }
};
SquareSymbol.ɵfac = function SquareSymbol_Factory(t) {
  return new (t || SquareSymbol)();
};
SquareSymbol.ɵdir = ɵɵdefineDirective({
  type: SquareSymbol,
  selectors: [["", "squareSymbol", ""]],
  hostVars: 10,
  hostBindings: function SquareSymbol_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("background-color", ctx.color)("width", ctx.size, "px")("height", ctx.size, "px")("display", ctx.display)("margin-left", ctx.marginLeft, "px");
    }
  },
  inputs: {
    color: "color",
    size: "size"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SquareSymbol, [{
    type: Directive,
    args: [{
      selector: "[squareSymbol]"
    }]
  }], null, {
    color: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.backgroundColor"]
    }],
    size: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.width.px"]
    }, {
      type: HostBinding,
      args: ["style.height.px"]
    }],
    display: [{
      type: HostBinding,
      args: ["style.display"]
    }],
    marginLeft: [{
      type: HostBinding,
      args: ["style.marginLeft.px"]
    }]
  });
})();
var DEFAULT_OFFSET = 12;
var SankeyTooltipPopupComponent = class extends BaseTooltip2 {
  constructor(element, popupService, templateService, localizationService, intlService, ngZone) {
    super(popupService, localizationService);
    this.element = element;
    this.popupService = popupService;
    this.templateService = templateService;
    this.localizationService = localizationService;
    this.intlService = intlService;
    this.ngZone = ngZone;
    this.animate = false;
    this.wrapperClass = "k-chart-tooltip-wrapper";
    this.arrowRightIcon = arrowRightIcon;
    this.textStyle = {
      margin: "0 3px"
    };
    this.tooltipStyle = {
      display: "flex",
      alignItems: "center"
    };
  }
  onInit() {
    this.popupRef.popupElement.className += ` ${this.wrapperClass}`;
  }
  show(e) {
    this.isNode = e.targetType === "node";
    this.isLink = e.targetType === "link";
    this.nodeTooltipTemplateRef = this.templateService.nodeTemplate || this.defaultNodeTooltipTemplate.templateRef;
    this.nodeTooltipContext = new SankeyNodeTooltipTemplateContext(e);
    this.linkTooltipTemplateRef = this.templateService.linkTemplate || this.defaultLinkTooltipTemplate.templateRef;
    this.linkTooltipContext = new SankeyLinkTooltipTemplateContext(e);
    super.show({
      style: {
        position: "static"
        // Override k-tooltip positioning
      },
      anchor: {
        align: e.tooltipData.popupAlign,
        point: this.tooltipAnchor(e)
      }
    });
  }
  tooltipAnchor(e) {
    const element = this.element.nativeElement;
    const size = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const anchor = Object.assign({}, e.tooltipData.popupOffset);
    const popupAlign = e.tooltipData.popupAlign;
    const offset = this.offset || DEFAULT_OFFSET;
    anchor.left += popupAlign.horizontal === "left" ? offset : -1 * offset;
    if (popupAlign.horizontal === "right") {
      anchor.left -= size.width;
    }
    if (popupAlign.vertical === "bottom") {
      anchor.top -= size.height + offset;
    } else {
      anchor.top += offset;
    }
    return anchor;
  }
  formatUnits(value2) {
    return this.intlService.format(this.tooltipUnitFormat, value2 !== null && value2 !== void 0 ? value2 : 0);
  }
};
SankeyTooltipPopupComponent.ɵfac = function SankeyTooltipPopupComponent_Factory(t) {
  return new (t || SankeyTooltipPopupComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SankeyTooltipTemplateService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(NgZone));
};
SankeyTooltipPopupComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyTooltipPopupComponent,
  selectors: [["kendo-sankey-tooltip-popup"]],
  viewQuery: function SankeyTooltipPopupComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(SankeyNodeTooltipTemplateDirective, 5);
      ɵɵviewQuery(SankeyLinkTooltipTemplateDirective, 5);
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultNodeTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.defaultLinkTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    animate: "animate",
    popupSettings: "popupSettings",
    wrapperClass: "wrapperClass",
    tooltipUnitFormat: "tooltipUnitFormat",
    offset: "offset"
  },
  features: [ɵɵProvidersFeature([PopupService, {
    provide: POPUP_CONTAINER,
    useFactory: bodyFactory
  }]), ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 0,
  consts: [["content", ""], ["kendoSankeyNodeTooltipTemplate", ""], ["kendoSankeyLinkTooltipTemplate", ""], [1, "k-tooltip", "k-sankey-tooltip", "k-chart-tooltip", "k-chart-shared-tooltip", 3, "ngStyle"], [1, "k-tooltip-content"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngStyle"], ["squareSymbol", "", 3, "color"], ["name", "arrow-right", 3, "svgIcon"]],
  template: function SankeyTooltipPopupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, SankeyTooltipPopupComponent_ng_template_0_Template, 4, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, SankeyTooltipPopupComponent_ng_template_2_Template, 6, 6, "ng-template", 1)(3, SankeyTooltipPopupComponent_ng_template_3_Template, 9, 9, "ng-template", 2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgStyle, IconWrapperComponent, SankeyLinkTooltipTemplateDirective, SankeyNodeTooltipTemplateDirective, SquareSymbol],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyTooltipPopupComponent, [{
    type: Component,
    args: [{
      providers: [PopupService, {
        provide: POPUP_CONTAINER,
        useFactory: bodyFactory
      }],
      selector: "kendo-sankey-tooltip-popup",
      template: `
        <ng-template #content>
            <div class="k-tooltip k-sankey-tooltip k-chart-tooltip k-chart-shared-tooltip" [ngStyle]="style">
                <div class="k-tooltip-content">
                    <ng-template
                        [ngTemplateOutlet]="nodeTooltipTemplateRef"
                        *ngIf="isNode"
                        [ngTemplateOutletContext]="nodeTooltipContext"
                    >
                    </ng-template>
                    <ng-template
                        [ngTemplateOutlet]="linkTooltipTemplateRef"
                        *ngIf="isLink"
                        [ngTemplateOutletContext]="linkTooltipContext"
                    >
                    </ng-template>
                </div>
            </div>
        </ng-template>

        <ng-template kendoSankeyNodeTooltipTemplate let-color="color" let-label="label" let-value="value">
            <div [ngStyle]="tooltipStyle">
                <div squareSymbol [color]="color"></div>
                <span [ngStyle]="textStyle">{{ label.text }}</span>
                <span [ngStyle]="textStyle">{{ formatUnits(value) }}</span>
            </div>
        </ng-template>

        <ng-template kendoSankeyLinkTooltipTemplate let-source="source" let-target="target" let-value="value">
            <div [ngStyle]="tooltipStyle">
                <div squareSymbol [color]="source.color"></div>
                <span [ngStyle]="textStyle">{{ source.label?.text }}</span>
                <kendo-icon-wrapper name="arrow-right" [svgIcon]="arrowRightIcon"></kendo-icon-wrapper>
                <span [ngStyle]="textStyle">{{ target.label?.text }}</span>
                <span [ngStyle]="textStyle">{{ formatUnits(value) }}</span>
            </div>
        </ng-template>
    `
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: SankeyTooltipTemplateService
    }, {
      type: LocalizationService
    }, {
      type: IntlService
    }, {
      type: NgZone
    }];
  }, {
    defaultNodeTooltipTemplate: [{
      type: ViewChild,
      args: [SankeyNodeTooltipTemplateDirective, {
        static: false
      }]
    }],
    defaultLinkTooltipTemplate: [{
      type: ViewChild,
      args: [SankeyLinkTooltipTemplateDirective, {
        static: false
      }]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    animate: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    wrapperClass: [{
      type: Input
    }],
    tooltipUnitFormat: [{
      type: Input
    }],
    offset: [{
      type: Input
    }]
  });
})();
var Messages = class extends ComponentMessages {
};
Messages.ɵfac = /* @__PURE__ */ (() => {
  let ɵMessages_BaseFactory;
  return function Messages_Factory(t) {
    return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(Messages)))(t || Messages);
  };
})();
Messages.ɵdir = ɵɵdefineDirective({
  type: Messages,
  selectors: [["", "kendoSankeyMessages", ""]],
  inputs: {
    tooltipUnitFormat: "tooltipUnitFormat"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      selector: "[kendoSankeyMessages]"
    }]
  }], null, {
    tooltipUnitFormat: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class extends Messages {
  constructor(service) {
    super();
    this.service = service;
  }
};
LocalizedMessagesDirective.ɵfac = function LocalizedMessagesDirective_Factory(t) {
  return new (t || LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
};
LocalizedMessagesDirective.ɵdir = ɵɵdefineDirective({
  type: LocalizedMessagesDirective,
  selectors: [["", "kendoSankeyLocalizedMessages", ""]],
  features: [ɵɵProvidersFeature([{
    provide: Messages,
    useExisting: forwardRef(() => LocalizedMessagesDirective)
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoSankeyLocalizedMessages]"
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SankeyComponent = class {
  constructor(element, configurationService, themeService, localizationService, instanceEventService, ngZone, changeDetector, renderer) {
    this.element = element;
    this.configurationService = configurationService;
    this.themeService = themeService;
    this.localizationService = localizationService;
    this.instanceEventService = instanceEventService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.nodeEnter = new EventEmitter();
    this.nodeLeave = new EventEmitter();
    this.nodeClick = new EventEmitter();
    this.linkEnter = new EventEmitter();
    this.linkLeave = new EventEmitter();
    this.linkClick = new EventEmitter();
    this.showLicenseWatermark = false;
    this.rtl = false;
    const isValid = validatePackage(packageMetadata);
    this.showLicenseWatermark = shouldShowValidationUI(isValid);
    this.themeService.loadTheme();
    this.refreshWait();
  }
  ngOnChanges(changes) {
    const store = this.configurationService.store;
    copyChanges(changes, store);
    store.popupSettings = null;
    this.configurationService.push(store);
  }
  /**
   * Updates the component fields with the specified values and refreshes the widget.
   *
   * Use this method when the configuration values cannot be set through the template.
   *
   * @example
   * ```ts-no-run
   * sankey.notifyChanges({ title: { text: 'New Title' } });
   * ```
   *
   * @param changes An object containing the updated input fields.
   */
  notifyChanges(changes) {
    this.ngOnChanges(toSimpleChanges(changes));
  }
  ngOnDestroy() {
    this.destroyed = true;
    if (this.optionsChange) {
      this.optionsChange.unsubscribe();
    }
    if (this.instance) {
      this.instance.destroy();
      this.instance = null;
    }
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    clearTimeout(this.redrawTimeout);
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localizationService.get(key);
  }
  createInstance(element) {
    this.instance = new Sankey3(element, this.options, this.theme);
    ["nodeEnter", "nodeLeave", "nodeClick", "linkEnter", "linkLeave", "linkClick"].forEach((eventName) => this.instance.bind(eventName, (e) => this.trigger(eventName, e)));
    this.instance.bind("tooltipShow", (e) => this.onShowTooltip(e));
    this.instance.bind("tooltipHide", () => this.onHideTooltip());
  }
  /**
   * Exports the Sankey diagram as an image. The export operation is asynchronous and returns a promise.
   *
   * @param {ImageExportOptions} options - The parameters for the exported image.
   * @returns {Promise<string>} - A promise that will be resolved with a PNG image encoded as a Data URI.
   */
  exportImage(options = {}) {
    return exportImage(this.exportVisual(options), options);
  }
  /**
   * Exports the Sankey diagram as an SVG document. The export operation is asynchronous and returns a promise.
   *
   * @param options - The parameters for the exported file.
   * @returns - A promise that will be resolved with an SVG document that is encoded as a Data URI.
   */
  exportSVG(options = {}) {
    return exportSVG(this.exportVisual(options), options);
  }
  /**
   * Exports the visual of the Sankey component to a drawing group.
   *
   * @param options - The parameters for the export operation.
   * @returns - The root Group of the scene.
   */
  exportVisual(options = {}) {
    return this.instance.exportVisual(options);
  }
  init() {
    if (!this.canRender) {
      return;
    }
    const element = this.instanceElement.nativeElement;
    this.createInstance(element);
  }
  /**
   * Reloads the Sankey appearance settings from the current [Kendo UI Theme]({% slug themesandstyles %}).
   *
   * Call this method after loading a different theme stylesheet.
   */
  reloadTheme() {
    if (!this.instance) {
      return;
    }
    this.themeService.reset();
    this.instance.destroy();
    this.instance = null;
  }
  onShowTooltip(e) {
    this.run(() => {
      this.tooltipInstance.show(e);
    }, true, true);
  }
  onHideTooltip() {
    if (this.tooltipInstance.active) {
      this.tooltipInstance.hide();
      this.detectChanges();
    }
  }
  trigger(name2, e) {
    const emitter = this.activeEmitter(name2);
    if (emitter) {
      const args = this.instanceEventService.create(name2, e, this);
      this.run(() => {
        emitter.emit(args);
      });
      return args.isDefaultPrevented && args.isDefaultPrevented();
    }
  }
  requiresHandlers(names) {
    for (let idx = 0; idx < names.length; idx++) {
      if (this.activeEmitter(names[idx])) {
        return true;
      }
    }
    return false;
  }
  refresh() {
    clearTimeout(this.redrawTimeout);
    if (!this.instance) {
      this.init();
      return;
    }
    this.updateOptions();
  }
  updateOptions() {
    this.instance.setOptions(this.options);
  }
  get canRender() {
    return isDocumentAvailable() && Boolean(this.instanceElement);
  }
  activeEmitter(name2) {
    const emitter = this[name2];
    if (emitter && emitter.emit && hasObservers(emitter)) {
      return emitter;
    }
  }
  refreshWait() {
    this.ngZone.runOutsideAngular(() => {
      this.optionsChange = (0, import_rxjs.combineLatest)([this.configurationService.onChange$, this.themeService.onChange$]).pipe((0, import_operators.tap)((result) => {
        this.options = result[0];
        this.theme = this.loadTheme(result[1]);
      }), (0, import_operators.auditTime)(THROTTLE_MS)).subscribe(() => {
        this.refresh();
      });
    });
  }
  loadTheme(chartTheme) {
    return Object.assign(Object.assign({}, chartTheme), {
      nodeColors: chartTheme.seriesColors
    });
  }
  run(callback, inZone = true, detectChanges) {
    if (inZone) {
      if (detectChanges) {
        this.changeDetector.markForCheck();
      }
      this.ngZone.run(callback);
    } else {
      callback();
      if (detectChanges) {
        this.detectChanges();
      }
    }
  }
  detectChanges() {
    if (!this.destroyed) {
      this.changeDetector.detectChanges();
    }
  }
};
SankeyComponent.ɵfac = function SankeyComponent_Factory(t) {
  return new (t || SankeyComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(ThemeService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(InstanceEventService2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
};
SankeyComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyComponent,
  selectors: [["kendo-sankey"]],
  viewQuery: function SankeyComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(SankeyTooltipPopupComponent, 7);
      ɵɵviewQuery(_c3, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tooltipInstance = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.instanceElement = _t.first);
    }
  },
  inputs: {
    data: "data",
    links: "links",
    nodes: "nodes",
    labels: "labels",
    title: "title",
    legend: "legend",
    tooltip: "tooltip",
    disableAutoLayout: "disableAutoLayout",
    popupSettings: "popupSettings"
  },
  outputs: {
    nodeEnter: "nodeEnter",
    nodeLeave: "nodeLeave",
    nodeClick: "nodeClick",
    linkEnter: "linkEnter",
    linkLeave: "linkLeave",
    linkClick: "linkClick"
  },
  exportAs: ["kendoSankey"],
  features: [ɵɵProvidersFeature([ConfigurationService, LocalizationService, InstanceEventService2, SankeyTooltipTemplateService, {
    provide: L10N_PREFIX,
    useValue: "kendo.sankey"
  }]), ɵɵNgOnChangesFeature],
  decls: 5,
  vars: 3,
  consts: () => {
    let i18n_0;
    if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
      const MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CHARTS_FESM2015_PROGRESS_KENDO_ANGULAR_CHARTS_MJS_0 = goog.getMsg("({0} units)");
      i18n_0 = MSG_C__ANGULAR_ARM_NODE_MODULES__PROGRESS_KENDO_ANGULAR_CHARTS_FESM2015_PROGRESS_KENDO_ANGULAR_CHARTS_MJS_0;
    } else {
      i18n_0 = $localize`:kendo.sankey.tooltipUnitFormat|The format string to use when displaying node and link values in the tooltip:({0} units)`;
    }
    return [["instance", ""], ["kendoSankeyLocalizedMessages", "", "tooltipUnitFormat", i18n_0], [3, "popupSettings", "tooltipUnitFormat"], ["kendoWatermarkOverlay", "", 4, "ngIf"], ["kendoWatermarkOverlay", ""]];
  },
  template: function SankeyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 1);
      ɵɵelement(1, "div", null, 0)(3, "kendo-sankey-tooltip-popup", 2);
      ɵɵtemplate(4, SankeyComponent_div_4_Template, 1, 0, "div", 3);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("popupSettings", ctx.popupSettings)("tooltipUnitFormat", ctx.messageFor("tooltipUnitFormat"));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showLicenseWatermark);
    }
  },
  dependencies: [NgIf, WatermarkOverlayComponent, SankeyTooltipPopupComponent, LocalizedMessagesDirective],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      exportAs: "kendoSankey",
      providers: [ConfigurationService, LocalizationService, InstanceEventService2, SankeyTooltipTemplateService, {
        provide: L10N_PREFIX,
        useValue: "kendo.sankey"
      }],
      selector: "kendo-sankey",
      template: `
        <ng-container
            kendoSankeyLocalizedMessages
            i18n-tooltipUnitFormat="kendo.sankey.tooltipUnitFormat|The format string to use when displaying node and link values in the tooltip"
            tooltipUnitFormat="({0} units)"
        ></ng-container>
        <div #instance></div>
        <kendo-sankey-tooltip-popup
            [popupSettings]="popupSettings"
            [tooltipUnitFormat]="messageFor('tooltipUnitFormat')"
        >
        </kendo-sankey-tooltip-popup>
        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ConfigurationService
    }, {
      type: ThemeService
    }, {
      type: LocalizationService
    }, {
      type: InstanceEventService2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    data: [{
      type: Input
    }],
    links: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    legend: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    disableAutoLayout: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    nodeEnter: [{
      type: Output
    }],
    nodeLeave: [{
      type: Output
    }],
    nodeClick: [{
      type: Output
    }],
    linkEnter: [{
      type: Output
    }],
    linkLeave: [{
      type: Output
    }],
    linkClick: [{
      type: Output
    }],
    tooltipInstance: [{
      type: ViewChild,
      args: [SankeyTooltipPopupComponent, {
        static: true
      }]
    }],
    instanceElement: [{
      type: ViewChild,
      args: ["instance", {
        static: true
      }]
    }]
  });
})();
var SankeyFlatBindingDataBoundEvent = class {
  /**
   * @hidden
   */
  constructor(data) {
    this.data = data;
  }
};
var SankeyFlatBindingDirective = class {
  constructor(sankey) {
    this.sankey = sankey;
    this.dimensionFields = [];
    this.dataBound = new EventEmitter();
  }
  ngOnChanges(changes) {
    var _a;
    if (!isChanged("data", changes, false)) {
      return;
    }
    if (((_a = this.dimensionFields) === null || _a === void 0 ? void 0 : _a.length) === 0) {
      throw new Error("kendoSankeyFlatBinding: dimensionFields is required");
    }
    if (!this.valueField) {
      throw new Error("kendoSankeyFlatBinding: valueField is required");
    }
    const dimensions = this.dimensionFields.map((field) => ({
      value: getter(field)
    }));
    const measure = {
      value: getter(this.valueField)
    };
    const data = createSankeyData(this.data, dimensions, measure);
    this.dataBound.emit(new SankeyFlatBindingDataBoundEvent(data));
    this.sankey.notifyChanges({
      data
    });
  }
};
SankeyFlatBindingDirective.ɵfac = function SankeyFlatBindingDirective_Factory(t) {
  return new (t || SankeyFlatBindingDirective)(ɵɵdirectiveInject(SankeyComponent));
};
SankeyFlatBindingDirective.ɵdir = ɵɵdefineDirective({
  type: SankeyFlatBindingDirective,
  selectors: [["", "kendoSankeyFlatBinding", ""]],
  inputs: {
    data: [0, "kendoSankeyFlatBinding", "data"],
    dimensionFields: "dimensionFields",
    valueField: "valueField"
  },
  outputs: {
    dataBound: "dataBound"
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyFlatBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSankeyFlatBinding]"
    }]
  }], function() {
    return [{
      type: SankeyComponent
    }];
  }, {
    data: [{
      type: Input,
      args: ["kendoSankeyFlatBinding"]
    }],
    dimensionFields: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    dataBound: [{
      type: Output
    }]
  });
})();
var SankeyLabelsComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("labels", configurationService);
    this.configurationService = configurationService;
  }
};
SankeyLabelsComponent.ɵfac = function SankeyLabelsComponent_Factory(t) {
  return new (t || SankeyLabelsComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SankeyLabelsComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyLabelsComponent,
  selectors: [["kendo-sankey-labels"]],
  inputs: {
    visible: "visible",
    font: "font",
    color: "color",
    align: "align",
    position: "position",
    padding: "padding",
    margin: "margin",
    border: "border",
    offset: "offset",
    stroke: "stroke"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyLabelsComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyLabelsComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-sankey-labels",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    visible: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    align: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    stroke: [{
      type: Input
    }]
  });
})();
var SankeyLegendComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("legend", configurationService);
    this.configurationService = configurationService;
    this.markAsVisible();
  }
};
SankeyLegendComponent.ɵfac = function SankeyLegendComponent_Factory(t) {
  return new (t || SankeyLegendComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SankeyLegendComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyLegendComponent,
  selectors: [["kendo-sankey-legend"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    height: "height",
    labels: "labels",
    margin: "margin",
    offsetX: "offsetX",
    offsetY: "offsetY",
    orientation: "orientation",
    padding: "padding",
    position: "position",
    reverse: "reverse",
    visible: "visible",
    width: "width",
    markers: "markers",
    spacing: "spacing",
    title: "title"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyLegendComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyLegendComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-sankey-legend",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    offsetX: [{
      type: Input
    }],
    offsetY: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    reverse: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    markers: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var SankeyLinksComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("links", configurationService);
    this.configurationService = configurationService;
  }
};
SankeyLinksComponent.ɵfac = function SankeyLinksComponent_Factory(t) {
  return new (t || SankeyLinksComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SankeyLinksComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyLinksComponent,
  selectors: [["kendo-sankey-links"]],
  inputs: {
    colorType: "colorType",
    color: "color",
    opacity: "opacity",
    highlight: "highlight"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyLinksComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyLinksComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-sankey-links",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    colorType: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    highlight: [{
      type: Input
    }]
  });
})();
var SankeyCustomMessagesComponent = class extends Messages {
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
};
SankeyCustomMessagesComponent.ɵfac = function SankeyCustomMessagesComponent_Factory(t) {
  return new (t || SankeyCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
};
SankeyCustomMessagesComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyCustomMessagesComponent,
  selectors: [["kendo-sankey-messages"]],
  features: [ɵɵProvidersFeature([{
    provide: Messages,
    useExisting: forwardRef(() => SankeyCustomMessagesComponent)
  }]), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyCustomMessagesComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => SankeyCustomMessagesComponent)
      }],
      selector: "kendo-sankey-messages",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SankeyNodesComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("nodes", configurationService);
    this.configurationService = configurationService;
  }
};
SankeyNodesComponent.ɵfac = function SankeyNodesComponent_Factory(t) {
  return new (t || SankeyNodesComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SankeyNodesComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyNodesComponent,
  selectors: [["kendo-sankey-nodes"]],
  inputs: {
    colorType: "colorType",
    color: "color",
    opacity: "opacity",
    offset: "offset",
    padding: "padding",
    width: "width",
    align: "align"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyNodesComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyNodesComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-sankey-nodes",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    colorType: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    align: [{
      type: Input
    }]
  });
})();
var SankeyTitleComponent = class extends SettingsComponent {
  constructor(configurationService) {
    super("title", configurationService);
    this.configurationService = configurationService;
  }
};
SankeyTitleComponent.ɵfac = function SankeyTitleComponent_Factory(t) {
  return new (t || SankeyTitleComponent)(ɵɵdirectiveInject(ConfigurationService));
};
SankeyTitleComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyTitleComponent,
  selectors: [["kendo-sankey-title"]],
  inputs: {
    align: "align",
    background: "background",
    border: "border",
    color: "color",
    font: "font",
    margin: "margin",
    padding: "padding",
    position: "position",
    text: "text",
    description: "description",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyTitleComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyTitleComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-sankey-title",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }];
  }, {
    align: [{
      type: Input
    }],
    background: [{
      type: Input
    }],
    border: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    font: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    padding: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    visible: [{
      type: Input
    }]
  });
})();
var SankeyTooltipComponent = class extends SettingsComponent {
  constructor(configurationService, templateService) {
    super("tooltip", configurationService);
    this.configurationService = configurationService;
    this.templateService = templateService;
    this.markAsVisible();
  }
  ngAfterContentChecked() {
    var _a, _b;
    this.templateService.linkTemplate = (_a = this.linkTooltipTemplate) === null || _a === void 0 ? void 0 : _a.templateRef;
    this.templateService.nodeTemplate = (_b = this.nodeTooltipTemplate) === null || _b === void 0 ? void 0 : _b.templateRef;
  }
};
SankeyTooltipComponent.ɵfac = function SankeyTooltipComponent_Factory(t) {
  return new (t || SankeyTooltipComponent)(ɵɵdirectiveInject(ConfigurationService), ɵɵdirectiveInject(SankeyTooltipTemplateService));
};
SankeyTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: SankeyTooltipComponent,
  selectors: [["kendo-sankey-tooltip"]],
  contentQueries: function SankeyTooltipComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SankeyLinkTooltipTemplateDirective, 5);
      ɵɵcontentQuery(dirIndex, SankeyNodeTooltipTemplateDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.linkTooltipTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTooltipTemplate = _t.first);
    }
  },
  inputs: {
    followPointer: "followPointer",
    delay: "delay",
    offset: "offset",
    visible: "visible"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function SankeyTooltipComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyTooltipComponent, [{
    type: Component,
    args: [{
      selector: "kendo-sankey-tooltip",
      template: ""
    }]
  }], function() {
    return [{
      type: ConfigurationService
    }, {
      type: SankeyTooltipTemplateService
    }];
  }, {
    followPointer: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    visible: [{
      type: Input
    }],
    linkTooltipTemplate: [{
      type: ContentChild,
      args: [SankeyLinkTooltipTemplateDirective, {
        static: false
      }]
    }],
    nodeTooltipTemplate: [{
      type: ContentChild,
      args: [SankeyNodeTooltipTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var SANKEY_EXPORTS = [SankeyComponent, SankeyTooltipPopupComponent, SankeyLinkTooltipTemplateDirective, SankeyNodeTooltipTemplateDirective, SankeyCustomMessagesComponent, LocalizedMessagesDirective, SankeyTitleComponent, SankeyLegendComponent, SankeyTooltipComponent, SankeyLinksComponent, SankeyNodesComponent, SankeyLabelsComponent, SankeyFlatBindingDirective];
var SANKEY_DIRECTIVES = [...SANKEY_EXPORTS, SquareSymbol];
var SankeyModule = class {
};
SankeyModule.ɵfac = function SankeyModule_Factory(t) {
  return new (t || SankeyModule)();
};
SankeyModule.ɵmod = ɵɵdefineNgModule({
  type: SankeyModule,
  declarations: [SankeyComponent, SankeyTooltipPopupComponent, SankeyLinkTooltipTemplateDirective, SankeyNodeTooltipTemplateDirective, SankeyCustomMessagesComponent, LocalizedMessagesDirective, SankeyTitleComponent, SankeyLegendComponent, SankeyTooltipComponent, SankeyLinksComponent, SankeyNodesComponent, SankeyLabelsComponent, SankeyFlatBindingDirective, SquareSymbol],
  imports: [CommonModule, IconsModule, PopupModule, ResizeSensorModule, WatermarkModule],
  exports: [SankeyComponent, SankeyTooltipPopupComponent, SankeyLinkTooltipTemplateDirective, SankeyNodeTooltipTemplateDirective, SankeyCustomMessagesComponent, LocalizedMessagesDirective, SankeyTitleComponent, SankeyLegendComponent, SankeyTooltipComponent, SankeyLinksComponent, SankeyNodesComponent, SankeyLabelsComponent, SankeyFlatBindingDirective]
});
SankeyModule.ɵinj = ɵɵdefineInjector({
  providers: [ThemeService],
  imports: [CommonModule, IconsModule, PopupModule, ResizeSensorModule, WatermarkModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SankeyModule, [{
    type: NgModule,
    args: [{
      declarations: [SANKEY_DIRECTIVES],
      exports: [SANKEY_EXPORTS],
      imports: [CommonModule, IconsModule, PopupModule, ResizeSensorModule, WatermarkModule],
      providers: [ThemeService]
    }]
  }], null, null);
})();
var ChartsModule = class {
};
ChartsModule.ɵfac = function ChartsModule_Factory(t) {
  return new (t || ChartsModule)();
};
ChartsModule.ɵmod = ɵɵdefineNgModule({
  type: ChartsModule,
  exports: [ChartModule, SparklineModule, StockChartModule, SankeyModule]
});
ChartsModule.ɵinj = ɵɵdefineInjector({
  imports: [ChartModule, SparklineModule, StockChartModule, SankeyModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChartsModule, [{
    type: NgModule,
    args: [{
      exports: [ChartModule, SparklineModule, StockChartModule, SankeyModule]
    }]
  }], null, null);
})();
export {
  AxisDefaultsComponent,
  AxisDefaultsCrosshairComponent,
  AxisDefaultsCrosshairTooltipComponent,
  AxisDefaultsLabelsComponent,
  AxisDefaultsTitleComponent,
  AxisLabelClickEvent,
  CHART_DIRECTIVES,
  CategoryAxisComponent,
  CategoryAxisCrosshairComponent,
  CategoryAxisCrosshairTooltipComponent,
  CategoryAxisItemComponent,
  CategoryAxisLabelsComponent,
  CategoryAxisNotesComponent,
  CategoryAxisNotesIconComponent,
  CategoryAxisNotesLabelComponent,
  CategoryAxisRangeLabelsComponent,
  CategoryAxisSelectComponent,
  CategoryAxisTitleComponent,
  ChartAreaComponent,
  ChartBreadcrumbComponent,
  ChartComponent,
  ChartModule,
  ChartsModule,
  CollectionService,
  ConfigurationService,
  CrosshairTooltipComponent,
  CrosshairTooltipsContainerComponent,
  DonutCenterTemplateDirective,
  DragEndEvent,
  DragEvent,
  DragStartEvent,
  DrilldownEvent,
  InstanceEventService2 as InstanceEventService,
  LegendComponent,
  LegendInactiveItemsComponent,
  LegendItemClickEvent,
  LegendItemComponent,
  LegendItemHoverEvent,
  LegendItemLeaveEvent,
  LocalizedMessagesDirective,
  NavigatorCategoryAxisComponent,
  NavigatorCategoryAxisCrosshairComponent,
  NavigatorCategoryAxisCrosshairTooltipComponent,
  NavigatorCategoryAxisLabelsComponent,
  NavigatorCategoryAxisNotesComponent,
  NavigatorCategoryAxisNotesIconComponent,
  NavigatorCategoryAxisNotesLabelComponent,
  NavigatorCategoryAxisSelectComponent,
  NavigatorCategoryAxisTitleComponent,
  NavigatorComponent,
  NavigatorFilterEvent,
  NavigatorHintComponent,
  NavigatorPaneComponent,
  NavigatorPaneTitleComponent,
  NavigatorSelectComponent,
  NavigatorSeriesComponent,
  NavigatorSeriesErrorBarsComponent,
  NavigatorSeriesExtremesComponent,
  NavigatorSeriesHighlightComponent,
  NavigatorSeriesItemComponent,
  NavigatorSeriesLabelsComponent,
  NavigatorSeriesLabelsFromComponent,
  NavigatorSeriesLabelsToComponent,
  NavigatorSeriesMarkersComponent,
  NavigatorSeriesNotesComponent,
  NavigatorSeriesNotesIconComponent,
  NavigatorSeriesNotesLabelComponent,
  NavigatorSeriesOutliersComponent,
  NavigatorSeriesTooltipComponent,
  NoteClickEvent,
  NoteHoverEvent,
  PaneComponent,
  PaneDefaultsComponent,
  PaneDefaultsTitleComponent,
  PaneRenderEvent,
  PanesComponent,
  PanesTitleComponent,
  PlotAreaClickEvent,
  PlotAreaComponent,
  PlotAreaHoverEvent,
  RenderEvent,
  SANKEY_DIRECTIVES,
  SANKEY_EXPORTS,
  SPARKLINE_DIRECTIVES,
  STOCK_CHART_DIRECTIVES,
  SankeyBaseEvent,
  SankeyComponent,
  SankeyCustomMessagesComponent,
  SankeyFlatBindingDataBoundEvent,
  SankeyFlatBindingDirective,
  SankeyLabelsComponent,
  SankeyLegendComponent,
  SankeyLinkEvent,
  SankeyLinkTooltipTemplateDirective,
  SankeyLinksComponent,
  SankeyModule,
  SankeyNodeEvent,
  SankeyNodeTooltipTemplateDirective,
  SankeyNodesComponent,
  SankeyTitleComponent,
  SankeyTooltipComponent,
  SankeyTooltipPopupComponent,
  SelectEndEvent,
  SelectEvent,
  SelectStartEvent,
  SeriesClickEvent,
  SeriesComponent,
  SeriesDefaultsComponent,
  SeriesDefaultsLabelsComponent,
  SeriesDefaultsLabelsFromComponent,
  SeriesDefaultsLabelsToComponent,
  SeriesDefaultsNotesComponent,
  SeriesDefaultsNotesIconComponent,
  SeriesDefaultsNotesLabelComponent,
  SeriesDefaultsTooltipComponent,
  SeriesDrilldownTemplateDirective,
  SeriesErrorBarsComponent,
  SeriesExtremesComponent,
  SeriesHighlightComponent,
  SeriesHoverEvent,
  SeriesItemComponent,
  SeriesLabelsComponent,
  SeriesLabelsFromComponent,
  SeriesLabelsToComponent,
  SeriesMarkersComponent,
  SeriesNotesComponent,
  SeriesNotesIconComponent,
  SeriesNotesLabelComponent,
  SeriesOutliersComponent,
  SeriesTooltipComponent,
  SeriesTooltipTemplateDirective,
  SeriesTrendlineComponent,
  SeriesTrendlineForecastComponent,
  SharedTooltipTemplateDirective,
  SparklineComponent,
  SparklineModule,
  StockChartComponent,
  StockChartModule,
  SubtitleComponent,
  TitleComponent,
  TooltipComponent,
  TooltipPopupComponent,
  TooltipTemplateService,
  ValueAxisComponent,
  ValueAxisCrosshairComponent,
  ValueAxisCrosshairTooltipComponent,
  ValueAxisItemComponent,
  ValueAxisLabelsComponent,
  ValueAxisNotesComponent,
  ValueAxisNotesIconComponent,
  ValueAxisNotesLabelComponent,
  ValueAxisTitleComponent,
  WeekStartDay,
  XAxisComponent,
  XAxisCrosshairComponent,
  XAxisCrosshairTooltipComponent,
  XAxisItemComponent,
  XAxisLabelsComponent,
  XAxisNotesComponent,
  XAxisNotesIconComponent,
  XAxisNotesLabelComponent,
  XAxisTitleComponent,
  YAxisComponent,
  YAxisCrosshairComponent,
  YAxisCrosshairTooltipComponent,
  YAxisItemComponent,
  YAxisLabelsComponent,
  YAxisNotesComponent,
  YAxisNotesIconComponent,
  YAxisNotesLabelComponent,
  YAxisTitleComponent,
  ZoomEndEvent,
  ZoomEvent,
  ZoomStartEvent,
  ZoomableComponent
};
//# sourceMappingURL=@progress_kendo-angular-charts.js.map
